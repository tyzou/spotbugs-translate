<?xml version="1.0" encoding="UTF-8"?>
<MessageCollection xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="messagecollection.xsd">
  <!--
  **********************************************************************
  Plugin information
  **********************************************************************
  https://www.jianshu.com/p/b62af1189deb
  -->
  <Plugin>
    <ShortDescription>Core SpotBugs plugin</ShortDescription>
    <Details>
<![CDATA[
<p>
This plugin contains all of the standard SpotBugs detectors.
</p>
]]>
    </Details>
    <BugsUrl>https://spotbugs.readthedocs.io/en/latest/bugDescriptions.html</BugsUrl>
    <AllBugsUrl>https://spotbugs.readthedocs.io/en/latest/bugDescriptions.html</AllBugsUrl>
  </Plugin>
  <FindBugsMain cmd="addMessages" class="edu.umd.cs.findbugs.AddMessages">
    <Description>在分析结果中添加消息（例如，错误的文本描述）  Add msgs (e.g., textual descriptions of bugs) to analysis results</Description>
  </FindBugsMain>
  <FindBugsMain cmd="analyze" class="edu.umd.cs.findbugs.FindBugs2">
    <Description>执行SpotBugs分析  Perform SpotBugs Analysis</Description>
  </FindBugsMain>
  <FindBugsMain cmd="gui" class="edu.umd.cs.findbugs.gui2.Driver">
    <Description>启动SpotBugs GUI  Launch SpotBugs GUI</Description>
  </FindBugsMain>
  <FindBugsMain cmd="list" class="edu.umd.cs.findbugs.PrintingBugReporter">
    <Description>将分析结果转换为文本形式  Convert analysis results to textual form</Description>
  </FindBugsMain>
  <FindBugsMain cmd="help" class="edu.umd.cs.findbugs.ShowHelp">
    <Description>为命令提供帮助  Provide help for commands</Description>
  </FindBugsMain>
  <FindBugsMain cmd="version" class="edu.umd.cs.findbugs.Version">
    <Description>列出SpotBugs版本  List SpotBugs version</Description>
  </FindBugsMain>
  <FindBugsMain cmd="filter" class="edu.umd.cs.findbugs.workflow.Filter">
    <Description>过滤器分析结果  Filter analysis results</Description>
  </FindBugsMain>
  <FindBugsMain cmd="set" class="edu.umd.cs.findbugs.workflow.SetBugDatabaseInfo">
    <Description>设置项目配置/选项  Set project configuration/options</Description>
  </FindBugsMain>
  <FindBugsMain cmd="history" class="edu.umd.cs.findbugs.workflow.MineBugHistory">
    <Description>列出多版本分析结果的详细信息  List details from multi-version analysis results</Description>
  </FindBugsMain>
  <FindBugsMain cmd="union" class="edu.umd.cs.findbugs.workflow.UnionResults">
    <Description>合并不相交零部件的分析结果  Merge analysis results from disjoint components</Description>
  </FindBugsMain>
  <FindBugsMain cmd="merge" class="edu.umd.cs.findbugs.workflow.Update">
    <Description>合并不同版本软件的分析结果，以生成多版本分析结果  Combine analysis results from different versions of software to produce multi-version analysis results</Description>
  </FindBugsMain>

  <FindBugsMain cmd="dis" class="edu.umd.cs.findbugs.workflow.PrintClass">
    <Description>反汇编类文件  Disassemble a class file</Description>
  </FindBugsMain>
  <FindBugsMain cmd="errors" class="edu.umd.cs.findbugs.workflowListErrors">
    <Description>列出存储在结果文件中的分析错误  List analysis errors stored in results file</Description>
  </FindBugsMain>

  <!-- On changing this, please also update default cloud id in FindbugsPlugin -->
  <Cloud id="edu.umd.cs.findbugs.cloud.doNothingCloud">
    <Description>(cloud disabled)</Description>
    <Details>Bug reviews are disabled when using this plugin.</Details>
  </Cloud>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.SuppressMultithreaded">
    <Description>抑制多线程正确性问题  Suppress multithreaded correctness issues</Description>
    <Details>抑制所有多线程正确性问题  Suppress all multithreaded correctness issues</Details>
  </PluginComponent>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.SuppressI18N">
    <Description>抑制国际化问题  Suppress internationalization issues</Description>
    <Details>抑制所有国际化问题  Suppress all internationalization issues</Details>
  </PluginComponent>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.SelectivelySuppressI18N">
    <Description>抑制除选定包之外的所有包中的国际化问题  Suppress internationalization issues in all but selected packages</Description>
    <Details>禁止所有国际化问题，i18n中指定的问题除外。属性资源  Suppress all internationalization issues except those specified in the i18n.properties resource</Details>
  </PluginComponent>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.MaxRank14">
    <Description>抑制等级高于14的所有问题  Suppress all issues with rank higher than 14</Description>
    <Details>抑制等级高于14的所有问题  Suppress all issues with rank higher than 14</Details>
  </PluginComponent>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.SuppressMalicious">
    <Description>抑制有关恶意代码漏洞的警告  Suppress warnings about vulnerabilities to malicious code</Description>
    <Details>抑制有关恶意代码漏洞的警告  Suppress warnings about vulnerabilities to malicious code</Details>
  </PluginComponent>
  <!--
  **********************************************************************
  Categories (replacing the BugCategoryDescriptions.properties file)
  **********************************************************************
   -->
  <BugCategory category="CORRECTNESS">
    <Description>正确性  Correctness</Description>
    <Abbreviation>C</Abbreviation>
    <Details>可能的错误-一个明显的编码错误，导致代码可能不是开发人员想要的。我们努力降低假阳性率。  Probable bug - an apparent coding mistake resulting in code that was probably not what the developer intended. We strive for a low false positive rate.</Details>
  </BugCategory>
  <BugCategory category="NOISE">
    <Description>伪随机噪声  Bogus random noise</Description>
    <Abbreviation>N</Abbreviation>
    <Details>伪随机噪声：用于数据挖掘实验中的控制，而不是用于发现软件中的实际错误  Bogus random noise: intended to be useful     as a control in data mining experiments, not in finding actual bugs in software</Details>
  </BugCategory>
  <BugCategory category="SECURITY">
    <Description>安全  Security</Description>
    <Abbreviation>S</Abbreviation>
    <Details>使用不受信任的输入可能会造成可远程利用的安全漏洞。  A use of untrusted input in a way that could create a remotely exploitable security vulnerability.</Details>
  </BugCategory>
  <BugCategory category="BAD_PRACTICE">
    <Description>糟糕的代码实现(违反推荐和基本编码规范) Bad practice</Description>
    <Abbreviation>B</Abbreviation>
    <Details>违反推荐和基本编码规范。示例包括哈希代码和等式问题、可克隆习惯用法、删除的异常、可序列化问题和误用finalize。我们努力使这一分析准确无误，尽管有些团体可能并不关心某些不良做法。  Violations of recommended and essential coding practice. Examples include hash code and equals problems, cloneable idiom, dropped exceptions, Serializable problems, and misuse of finalize. We strive to make this analysis accurate, although some groups may not care about some of the bad practices.</Details>
  </BugCategory>
  <BugCategory category="STYLE">
    <Description>糟糕的代码（风格）  Dodgy code</Description>
    <Abbreviation>D</Abbreviation>
    <Details>混乱、异常或编写方式导致错误的代码。示例包括死本地存储、交换机失效、未确认的强制转换以及已知为null的值的冗余null检查。接受更多误报。在SpotBugs的早期版本中，这个类别被称为Style。  code that is confusing, anomalous, or written in a way that leads itself to errors. Examples include dead local stores, switch fall through, unconfirmed casts, and redundant null check of value known to be null. More false positives accepted. In previous versions of SpotBugs, this category was known as Style.</Details>
  </BugCategory>
  <BugCategory category="PERFORMANCE">
    <Description>性能  Performance</Description>
    <Abbreviation>P</Abbreviation>
    <Details>不一定不正确但可能效率低下的代码  code that is not necessarily incorrect but may be inefficient</Details>
  </BugCategory>
  <BugCategory category="MALICIOUS_CODE">
    <Description>恶意代码漏洞  Malicious code vulnerability</Description>
    <Abbreviation>V</Abbreviation>
    <Details>易受不可信代码攻击的代码  code that is vulnerable to attacks from untrusted code</Details>
  </BugCategory>
  <BugCategory category="MT_CORRECTNESS">
    <Description>多线程正确性  Multithreaded correctness</Description>
    <Abbreviation>M</Abbreviation>
    <Details>与线程、锁和volatile相关的代码缺陷  code flaws having to do with threads, locks, and volatiles</Details>
  </BugCategory>
  <BugCategory category="I18N">
    <Description>国际化  Internationalization</Description>
    <Abbreviation>I</Abbreviation>
    <Details>与国际化和语言环境有关的代码缺陷  code flaws having to do with internationalization and locale</Details>
    <!-- DM_CONVERT_CASE is the only core bug pattern in this category -->
  </BugCategory>
  <BugCategory category="EXPERIMENTAL">
    <Description>实验的  Experimental</Description>
    <Abbreviation>X</Abbreviation>
    <Details>实验性且未经充分审查的错误模式  Experimental and not fully vetted bug patterns</Details>
    <!-- DM_CONVERT_CASE is the only core bug pattern in this category -->
  </BugCategory>

  <!--
  **********************************************************************
  Detectors
  **********************************************************************
   -->
  <Detector class="edu.umd.cs.findbugs.detect.OverridingMethodsMustInvokeSuperDetector">
    <Details>
<![CDATA[<p>查找必须调用super的重写方法</p>  <p> Finds overriding methods that must call super. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindRoughConstants">
    <Details>
<![CDATA[<p>查找大致（但不精确）等于已知值（如Math.PI）的常数</p>  <p> Finds constants which roughly (but not precisely) equal to known values like Math.PI. </p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InitializeNonnullFieldsInConstructor">
    <Details>
<![CDATA[<p>查找构造函数中未写入的非空字段</p>  <p> Finds non-null fields that are not written to in constructors. </p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.IntCast2LongAsInstant">
    <Details>
<![CDATA[<p>查找使用32位值描述自epoch以来的毫秒数</p>  <p> Finds uses of 32-bit values to describe milliseconds since the epoch. </p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainLongInstantfParams">
    <Details>
<![CDATA[<p>构建参数数据库，该参数采用64位值描述自epoch以来的毫秒数</p>  <p> Builds database of parameters that take a 64 bit value describing milliseconds since the epoch.</p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InconsistentAnnotations">
    <Details>
<![CDATA[<p>该检测器发现直接应用于方法参数的类型限定符和这些方法参数的使用之间的不一致</p>  <p> This detector finds inconsistencies between type qualifiers directly applied to method parameters and uses of those method parameters. </p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.AtomicityProblem">
    <Details>
<![CDATA[<p>查找不会自动执行的并发抽象上的操作序列（例如，get/put）</p>  <p> Finds sequences of operations (e.g., get/put) on a concurrent abstraction     that will not be executed atomically.     </p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SynchronizationOnSharedBuiltinConstant">
    <Details>
<![CDATA[<p>此检测器查找共享内置常量（如String）上的同步</p>  <p> This detector looks for synchronization on a shared built-in constant (such as a String).</p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SynchronizeAndNullCheckField">
    <Details>
<![CDATA[<p>此检测器查找同步的字段，然后检查为空</p>  <p> This detector looks for a field that is synchronized on and then null checked.</p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckImmutableAnnotation">
    <Details>
<![CDATA[<p>查找注释为net.jcip.annotations的类是否违反规则。Immutable或javax.annotation.concurrent.Immable</p>  <p> Looks for violations of the rules for classes annotated as net.jcip.annotations.Immutable or javax.annotation.concurrent.Immutable.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.VarArgsProblems">
    <Details>
<![CDATA[<p>查找Java 1.5 varargs引起的问题</p>  <p> Looks for problems with arising from Java 1.5 varargs.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteJCIPAnnotation">
    <Details>
<![CDATA[<p>从net.jcip记录注释。注释包</p>  <p> Record annotations from the net.jcip.annotations package.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteDirectlyRelevantTypeQualifiers">
    <Details>
<![CDATA[<p>请注意与分析方法相关的类型限定符</p>  <p> Note the type qualifiers relevant to analyzing a method.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BuildInterproceduralCallGraph">
    <Details>
      <![CDATA[<p>构建过程间调用图</p>  <p>Builds the interprocedural call graph.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BuildObligationPolicyDatabase">
    <Details>
          <![CDATA[<p>构建FindUnsatisfiedObligation检测器使用的义务类型和方法的数据库。  <p>Builds the database of obligation types and methods used by the FindUnsatisfiedObligation detector.]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteSuppressedWarnings">
    <Details>
<![CDATA[<p>基于使用edu.umd.cs.findbugs.annotations禁止显示警告。注释取消警告注释</p>  <p> Suppresses warnings based on use of the edu.umd.cs.findbugs.annotations.NoteSuppressWarnings annotation.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteAnnotationRetention">
    <Details>
<![CDATA[<p>记录注释保留</p>  <p> Records annotation retention.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteSyntheticElements">
    <Details>
      <![CDATA[<p>记录合成类、方法、字段等</p>  <p>Records synthetic classes, methods, fields, etc.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.Methods">
    <Details>
<![CDATA[<p>构建分析类中定义的所有方法的数据库，供其他检测器使用</p>  <p> Builds a database of all methods defined in analyzed classes, for use by other detectors.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ReflectiveClasses">
    <Details>
<![CDATA[<p>尝试确定哪些类对其.class对象具有常量引用</p>  <p> Try to determine which classes have constant references to their .class objects.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CalledMethods">
    <Details>
<![CDATA[<p>构建分析类中调用的所有方法的数据库，供其他检测器使用</p>  <p> Builds a database of all methods invoked in analyzed classes, for use by other detectors.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNoSideEffectMethods">
    <Details>
<![CDATA[<p>查找没有副作用的方法，只返回一些值</p>  <p> Looks for the methods which have no side effect, just return some value.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BuildStringPassthruGraph">
    <Details>
<![CDATA[<p>构建从方法传递到方法的字符串参数的数据库，保持不变</p>  <p> Builds the database of string parameters passed from method to method unchanged.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FunctionsThatMightBeMistakenForProcedures">
    <Details>
<![CDATA[<p>寻找具有返回该类新实例的方法的不可变类，人们可能会意外地认为这些方法改变了调用它们的实例</p>  <p> Looks for immutable classes with methods that return new instances of that class, where people might accidentally think those methods mutate the instance they are invoked on. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ConfusionBetweenInheritedAndOuterMethod">
    <Details>
<![CDATA[<p>查找继承方法和外部方法之间的潜在混淆</p>  <p> Looks for potential confusion between inherited and outer methods.</p>]]>
    </Details>
  </Detector>
    <Detector class="edu.umd.cs.findbugs.detect.NoteCheckReturnValueAnnotations">
    <Details>
<![CDATA[<p>查找注释以检查方法的返回值</p>  <p> Looks for annotations to check return values of a method. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SynchronizeOnClassLiteralNotGetClass">
    <Details>
      <![CDATA[<p>查找根据getClass的结果而不是根据类文本进行同步的代码</p>  <p> Looks for code that synchronizes on the results of getClass rather than on class literals. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FieldItemSummary">
    <Details>
      <![CDATA[<p>此检测器生成存储到字段中的内容的摘要信息</p>  <p>     This detector produces summary information for what is stored     into fields. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteNonNullAnnotations">
    <Details>
      <![CDATA[<p>在方法、字段和参数上查找@Nonnull注释。当在只应使用非空值的上下文中使用可能为空的值时，FindNullDeref检测器可以使用这些值来生成警告</p>  <p> Looks for @Nonnull annotations on methods, fields, and parameters. These can be used by the FindNullDeref detector to generate warnings when a possibly-null value is used in a context where only non-null values should be used. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteUnconditionalParamDerefs">
    <Details>
      <![CDATA[<p>分析应用程序中的所有方法，以无条件地确定哪些解引用参数。此信息将在稍后的分析传递中使用，以查找可能将空值传递给这些方法的调用位置</p> <p>这是一个慢探测器</p>  <p> Analyze all methods in the application to determine which dereference parameters unconditionally.  This information is used in a later analysis pass to find call sites where null values may be passed to those methods. </p> <p> This is a slow detector. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteNonnullReturnValues">
    <Details>
      <![CDATA[<p>分析应用程序中的所有方法，以确定哪些方法总是返回非空值</p>  <p> Analyze all methods in the application to determine which     methods always return non-null values. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BooleanReturnNull">
    <Details>
<![CDATA[<p>查找返回显式空值的布尔返回类型的方法</p>  <p> Looks for methods with Boolean return type that return explicit null values.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.OptionalReturnNull">
    <Details>
<![CDATA[<p>查找返回显式空值的可选返回类型的方法</p>  <p> Looks for methods with Optional return type that return explicit null values.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUselessObjects">
    <Details>
<![CDATA[<p>查找无用的对象</p>  <p> Looks for useless objects.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MutableEnum">
    <Details>
          <![CDATA[<p>查找可变枚举字段并发出警告</p>  <p> Looks and warns about mutable enum fields.</p>]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BadUseOfReturnValue">
    <Details>
<![CDATA[<p>查找函数的返回值在被检查为非null后被丢弃的情况</p>  <p> Looks for cases where the return value of a function is discarded after being checked for non-null.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InheritanceUnsafeGetResource">
    <Details>
<![CDATA[<p>查找this.getClass（）.getResource（…）的用法，如果该类由另一个包中的类扩展，则可能会产生意外结果</p>  <p> Looks for uses of this.getClass().getResource(...), which can give unexpected results if the class is extended by a class in another package. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InfiniteRecursiveLoop">
    <Details>
<![CDATA[<p>查找无限递归循环</p>  <p> Looks for an infinite recursive loop. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InfiniteLoop">
    <Details>
<![CDATA[<p>查找无限循环</p>  <p> Looks for an infinite loop. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.VolatileUsage">
    <Details>
<![CDATA[<p>查找volatile字段使用中的错误模式</p>  <p> Looks for bug patterns in the usage of volatile fields. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.EmptyZipFileEntry">
    <Details>
<![CDATA[<p>这将查找空zip文件条目的创建。它是一个中等速度的探测器</p>  <p> This looks for creation of empty zip file entries. It is a moderately fast detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.UncallableMethodOfAnonymousClass">
    <Details>
<![CDATA[<p>此检测器查找定义方法的匿名内部类，这些方法可能用于但不重写超类中的方法</p>  <p> This detector looks for anonymous inner classes that define methods that are probably intended to but do not override methods in a superclass. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DontUseEnum">
    <Details>
<![CDATA[<p>检查字段和方法是否不使用名称断言或枚举，因为它们是Java5中的关键字</p>  <p>Checks that fields and methods don't use the name assert or enum as they are keywords in Java 5.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.URLProblems">
    <Details>
<![CDATA[<p><code>java.net上的equals和hashCode方法。URL</code>解析域名。因此，这些操作可能非常昂贵，并且此检测器会查找可能调用这些方法的位置</p>  <p> The equals and hashCode method on <code>java.net.URL</code> resolve the domain name. As a result, these operations can be very expensive, and this detector looks for places where those methods might be invoked. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FinalizerNullsFields">
    <Details>
<![CDATA[<p>此检测器查找使类的字段为空的终结器。这对垃圾收集器没有任何帮助，字段的清零没有任何作用</p>  <p> This detector looks for finalizers that null out fields of a class. This does not help the garbage collector in any way, the nulling out of fields has no effect. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CrossSiteScripting">
    <Details>
<![CDATA[<p>此检测器查找明显/明显的跨站点脚本漏洞</p>  <p> This detector looks for obvious/blatant cases of cross site scripting vulnerabilities.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.RepeatedConditionals">
    <Details>
<![CDATA[<p>此检测器查找包含重复条件测试的代码，例如（x==5||x==5）。  <p> This detector looks for code containing repeated conditional tests, such as (x == 5 || x == 5).]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.RedundantConditions">
    <Details>
<![CDATA[<p>此检测器查找包含无用条件的代码，如表达式中的第二个条件：（x>=10&&x>=5）。  <p> This detector looks for code containing useless conditions like the second condition in this expression: (x >= 10 && x >= 5).]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CallToUnsupportedMethod">
    <Details>
<![CDATA[<p>此检测器查找对不受支持的方法的调用。  <p> This detector looks for calls to methods that are unsupported.]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FormatStringChecker">
    <Details>
<![CDATA[<p>检查格式字符串是否不正确</p>  <p> Checks for incorrect format strings. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.EqualsOperandShouldHaveClassCompatibleWithThis">
    <Details>
<![CDATA[<p>检查等于方法，检查其操作数是否是与定义等于方法的类不兼容的类的实例</p>  <p> Checks for equals methods that check for their operand being an instance of a class that is not compatible with the class defining the equals method. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestingGround">
    <Details>
<![CDATA[<p>这个探测器只是测试新探测器的挂钩。通常，这个探测器什么也不做</p>  <p> This detector is just a hook for testing new detectors. Normally, this detector does nothing.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestingGround2">
    <Details>
<![CDATA[<p>这个探测器只是测试新探测器的挂钩。通常，这个探测器什么也不做</p>  <p> This detector is just a hook for testing new detectors. Normally, this detector does nothing.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.LostLoggerDueToWeakReference">
    <Details>
<![CDATA[<p>该检测器在OpenJDK1.6下查找行为不同的代码，其中弱引用用于保存Logger</p>  <p> This detector finds code that behaves differently under OpenJDK 1.6, where weak references are used to hold onto Loggers. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestingGround2">
    <Details>
<![CDATA[<p>这个探测器只是测试新探测器的挂钩。通常，这个探测器什么也不做</p>  <p> This detector is just a hook for testing new detectors. Normally, this detector does nothing.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.Noise">
    <Details>
<![CDATA[<p>此检测器生成一个随机信号：仅基于方法所执行操作的哈希值的警告。这些警告是虚假的随机噪声，目的是在数据挖掘实验中用作控制，而不是在软件中查找实际的错误。这个探测器只是测试新探测器的挂钩。通常，这个探测器什么也不做</p>  <p> This detector generates a random signal: warnings that are just based on hash values of the operations performed by methods. These warnings are bogus random noise, intended to be useful   as a control in data mining experiments, not in finding actual bugs in software.   This detector is just a hook for testing new detectors. Normally, this detector does nothing.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoiseNullDeref">
    <Details>
<![CDATA[<p>零解引用的噪声检测器。目的是在关于警告的有效性或预测能力的实验中用作控制，而不是用来发现代码中的问题</p>  <p> Noisy detector for null dereferences. Intended to be used as a control in experiments about the validity or predictive ability of warnings, not as a way to find problems in code. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.HugeSharedStringConstants">
    <Details>
<![CDATA[<p>此检测器查找在多个类文件中重复的字符串常量</p>  <p> This detector looks for string constants that are duplicated across multiple classfiles. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DoInsideDoPrivileged">
    <Details>
<![CDATA[<p>查找应该在doPrivileged块内执行的代码</p>  <p> Looks for code that should be executed inside doPrivileged blocks.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ResolveAllReferences">
    <Details>
<![CDATA[<p>检查是否已解析所有引用调用</p>  <p> Checks that all references call be resolved.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SwitchFallthrough">
    <Details>
<![CDATA[<p>此检测器查找包含fall-through的switch语句</p>  <p> This detector looks for switch statements containing fall through. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindFieldSelfAssignment">
    <Details>
<![CDATA[<p>此检测器通过读取同一字段的值来查找字段赋值的位置</p>  <p> This detector looks for places where a field is assigned by reading the value of the same field.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSelfComparison">
    <Details>
<![CDATA[<p>此检测器查找值与自身进行比较的位置</p>  <p> This detector looks for places where a value is compared with itself.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSelfComparison2">
    <Details>
<![CDATA[<p>此检测器查找值与自身进行比较的位置</p>  <p> This detector looks for places where a value is compared with itself.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNonShortCircuit">
    <Details>
<![CDATA[<p>此检测器查找非短路布尔运算符的可疑用法（<code>|</code>和<code>&</code>，而不是<code>||</code>和<code>&&</code>）</p>  <p> This detector looks for suspicious uses of non-short-circuiting boolean operators (<code>|</code> and <code>&amp;</code> instead of <code>||</code> and <code>&amp;&amp;</code>).</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DontCatchIllegalMonitorStateException">
    <Details>
<![CDATA[<p>此检测器查找捕获IllegalMonitorStateException的try-catch块</p>  <p> This detector looks for try-catch blocks that catch an IllegalMonitorStateException.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindFloatMath">
    <Details>
<![CDATA[<p>这个检测器寻找浮点数学的用法。它是一个中等速度的探测器</p>  <p> This detector looks for uses of floating point math. It is a moderately fast detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CloneIdiom">
    <Details>
<![CDATA[<p>此检测器查找编写可克隆类的习惯用法的违反情况</p>  <p> This detector looks for violations of the idioms for writing cloneable classes. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ComparatorIdiom">
    <Details>
<![CDATA[<p>此检测器查找实现<code>Comparator</code>的类的编写习惯用法的违反情况</p>  <p> This detector looks for violations of the idioms for writing classes that implement <code>Comparator</code>. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DroppedException">
    <Details>
<![CDATA[<p>此检测器查找捕获到异常的代码，但没有执行任何操作来处理异常</p>  <p> This detector looks for code where an exception is caught, but nothing is done to handle the exception.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.LoadOfKnownNullValue">
    <Details>
<![CDATA[<p>查找已知为null的值的加载</p>  <p> Looks for loads of values known to be null. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DumbMethodInvocations">
    <Details>
<![CDATA[<p>此检测器查找传递给方法的错误参数（例如，子字符串（0））</p>  <p> This detector looks for bad arguments being passed to methods (e.g., substring(0)). </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DumbMethods">
    <Details>
<![CDATA[<p>此检测器查找对无意义方法的调用，例如无参数String构造函数</p>  <p> This detector looks for calls to pointless methods, such as the no-argument String constructor. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CovariantArrayAssignment">
    <Details>
<![CDATA[<p>此检测器查找协变数组赋值，如Object[]array=new String[10]，这可能会在运行时导致ArrayStoreException</p>  <p> This detector looks for covariant array assignments like Object[] array = new String[10] which may cause ArrayStoreException at runtime. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NumberConstructor">
    <Details>
<![CDATA[<p>查找对具有基元参数的Number构造函数的调用</p>  <p> Looks for calls to Number constructors with primitive arguments. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindDoubleCheck">
    <Details>
<![CDATA[<p>此检测器查找双重检查锁定的实例</p>  <p> This detector looks for instances of double checked locking. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindFinalizeInvocations">
    <Details>
<![CDATA[<p>此检测器查找finalize（）调用和其他与finalizer相关的问题</p>  <p> This detector looks for calls to finalize() and other finalizer-related issues.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindHEmismatch">
    <Details>
<![CDATA[<p>此检测器查找hashCode（）和equals（）方法定义中的问题</p>  <p> This detector looks for problems in the definition of the hashCode() and equals() methods.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.OverridingEqualsNotSymmetrical">
    <Details>
<![CDATA[<p>在等价关系可能不对称的超类中查找重写等于方法的等于方法</p>  <p> Looks for equals methods that override equals methods in a superclass where the equivalence relationship might not be symmetrical. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNakedNotify">
    <Details>
<![CDATA[<p>此检测器查找似乎不会修改可变对象状态的notify（）调用</p>  <p> This detector looks for calls to notify() that don't seem to modify mutable object state.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindReturnRef">
    <Details>
<![CDATA[<p>此检测器查找返回可变静态数据的方法</p>  <p> This detector looks for methods that return mutable static data. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindRunInvocations">
    <Details>
<![CDATA[<p>此检测器查找对Thread.run（）的调用。这是一个快速探测器</p>  <p> This detector looks for calls to Thread.run().  It is a fast detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSpinLoop">
    <Details>
<![CDATA[<p>这个探测器寻找旋转场读数的循环</p>  <p> This detector looks for loops that spin reading from a field. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindTwoLockWait">
    <Details>
<![CDATA[<p>此检测器查找持有两个（或更多）锁的wait（）调用。这是一个慢探测器</p>  <p> This detector looks for calls to wait() with two (or more) locks held. It is a slow detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnconditionalWait">
    <Details>
<![CDATA[<p>此检测器查找对wait（）的调用，而不是在条件或循环中</p>  <p> This detector looks for calls to wait() not in a conditional or loop. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUninitializedGet">
    <Details>
<![CDATA[<p>此检测器查找构造函数中未初始化字段的读取</p>  <p> This detector looks for reads of uninitialized fields in constructors. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnsyncGet">
    <Details>
<![CDATA[<p>此检测器查找get和set方法，其中get在同步时未同步</p>  <p> This detector looks for get and set methods where the get is unsynchronized while the set is synchronized.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InitializationChain">
    <Details>
<![CDATA[<p>此检测器查找潜在的循环类初始化依赖项</p>  <p> This detector looks for potentially circular class initialization dependencies.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.IteratorIdioms">
    <Details>
<![CDATA[<p>此检测器查找如何定义迭代器类的问题</p>  <p> This detector looks for problems in how Iterator classes are defined. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.LockedFields">
    <Details>
<![CDATA[<p>此检测器查找以与锁定不一致的方式访问的字段</p>  <p> This detector looks for fields that are accessed in an inconsistent manner with respect to locking.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.EqStringTest">
    <Details>
<![CDATA[<p>此检测器使用==或！=查找字符串对象的比较操作员</p>  <p> This detector looks for comparisons of String objects using the == or != operators.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MutableLock">
    <Details>
<![CDATA[<p>此检测器查找从修改字段读取的对象的同步</p>  <p> This detector looks for synchronization on objects read from modified fields.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SynchronizingOnContentsOfFieldToProtectField">
    <Details>
<![CDATA[<p>此检测器查找字段上似乎正在同步的代码，以保护该字段的更新</p>  <p> This detector looks for code that seems to be synchronizing on a field in order to guard updates of that field. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MutableStaticFields">
    <Details>
<![CDATA[<p>此检测器查找可能被恶意代码修改的静态字段</p>  <p> This detector looks for static fields that may be modified by malicious code.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.Naming">
    <Details>
<![CDATA[<p>此检测器查找命名可疑的方法</p>  <p> This detector looks for suspiciously-named methods.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ReadReturnShouldBeChecked">
    <Details>
<![CDATA[<p>此检测器查找对InputStream的调用。read（）或InputStream。skip（），其中忽略返回值</p>  <p> This detector looks for calls to InputStream.read() or InputStream.skip() where the return value is ignored.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SerializableIdiom">
    <Details>
<![CDATA[<p>此检测器查找Serializable类实现中的潜在问题</p>  <p> This detector looks for potential problems in the implementation of Serializable classes.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.StartInConstructor">
    <Details>
<![CDATA[<p>此检测器查找启动线程的构造函数</p>  <p> This detector looks for constructors that start threads.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindBadForLoop">
    <Details>
<![CDATA[<p>此检测器查找不正确的环路</p>  <p> This detector looks for incorrect for loops. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ExplicitSerialization">
    <Details>
<![CDATA[<p>通过readObject和writeObject寻找显式序列化，作为此类确实已序列化的证据</p>  <p> Looks for explicit serialization via readObject and     writeObject as evidence that this class is, indeed, serialized. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.UnreadFields">
    <Details>
<![CDATA[<p>此检测器查找从未读取其值的字段</p>  <p> This detector looks for fields whose value is never read.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.WaitInLoop">
    <Details>
<![CDATA[<p>此检测器查找不在循环中的wait（）调用</p>  <p> This detector looks for calls to wait() that are not in a loop. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BCPMethodReturnCheck">
    <Details>
<![CDATA[<p>此检测器查找对返回值被可疑忽略的方法的调用。这是一个慢探测器</p>  <p> This detector looks for calls to methods where the return value is suspiciously ignored.  It is a slow detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindComparatorProblems">
    <Details>
<![CDATA[<p>此检测器查找比较器中的问题。比较或可比较。与实现进行比较</p>  <p> This detector looks for problems in Comparator.compare or Comparable.compareTo implementation.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNullDeref">
    <Details>
<![CDATA[<p>此检测器查找可能发生空指针异常的位置。它还寻找参考值与null的冗余比较。这是一个慢探测器</p>  <p> This detector looks for places where a null pointer exception might occur.  It also looks for redundant comparisons of reference values against null.  It is a slow detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNullDerefsInvolvingNonShortCircuitEvaluation">
    <Details>
<![CDATA[<p>此检测器查找可能发生空指针异常的位置，使用非短路评估会导致常规技术失败</p>  <p> This detector looks for places where a null pointer exception might occur, and the use of non-short-circuit evaluation causes the usual techniques to fail. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindOpenStream">
    <Details>
<![CDATA[<p>此检测器查找未逃逸该方法并且在该方法之外的所有路径上似乎未关闭的IO流对象。这是一个慢探测器</p>  <p> This detector looks for IO stream objects which do not escape the method and do not appear to be closed on all paths out of the method. It is a slow detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.PreferZeroLengthArrays">
    <Details>
<![CDATA[<p>此检测器查找返回数组或显式空引用的方法。在这种情况下，返回零长度数组通常比返回空引用更好</p>  <p> This detector looks for methods that return either arrays or an explicit null reference. Returning a zero length array is generally preferred in this context to returning a null reference. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUselessControlFlow">
    <Details>
<![CDATA[<p>此检测器查找没有影响的控制流语句</p>  <p> This detector looks for control flow statements which have no effect. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnreleasedLock">
    <Details>
<![CDATA[<p>这个检测器查找JSR-166（<code>java.util.concurrent</code>）锁，这些锁是获取的，但不是在方法之外的所有路径上释放的&nbsp；它是一个中等速度的探测器&nbsp；注意，为了使用这个检测器，您需要<code>java.util。辅助类路径中的concurrent</code>包（或者正在分析包本身）</p>  <p> This detector looks for JSR-166 (<code>java.util.concurrent</code>) locks which are acquired, but not released on all paths out of the method.&nbsp; It is a moderately fast detector.&nbsp; Note that in order to use this detector, you need to have the <code>java.util.concurrent</code> package in the auxiliary classpath (or be analyzing the package itself).</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindRefComparison">
    <Details>
<![CDATA[<p>此检测器查找将两个参考值与==或！=进行比较的位置运算符，该类的类型（如<code>java.lang.String</code>），其中比较引用值通常是一个错误。这是一个慢探测器</p>  <p> This detector looks for places where two reference values are compared with the == or != operator, and the class is of a type (such as <code>java.lang.String</code>) where comparing reference values is generally an error.  It is a slow detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindMismatchedWaitOrNotify">
    <Details>
<![CDATA[<p>此检测器查找对wait（）、notify（）或notifyAll（）的调用，这些调用似乎没有对当前锁定的对象进行&nbsp；它是一个中等速度的探测器&nbsp<b> 此检测器被禁用，因为它仍在开发中，并且会产生太多误报</b></p>  <p> This detector looks for calls to wait(), notify(), or notifyAll() which do not appear to be made on an object which is currently locked.&nbsp; It is a moderately fast detector.&nbsp; <b>This detector is disabled because it is still under development, and produces too many false positives.</b></p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindEmptySynchronizedBlock">
    <Details>
<![CDATA[<p>此检测器查找空的同步块</p>  <p> This detector looks for empty synchronized blocks.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindInconsistentSync2">
    <Details>
<![CDATA[<p>此检测器查找以与锁定不一致的方式访问的字段。这是一个慢探测器</p>  <p> This detector looks for fields that are accessed in an inconsistent manner with respect to locking.  It is a slow detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindLocalSelfAssignment2">
    <Details>
<![CDATA[<p>此检测器查找局部变量的自赋值</p>  <p> This detector looks for self assignments of local variables. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.IncompatMask">
    <Details>
<![CDATA[<p>此检测器查找可疑的按位逻辑表达式</p>  <p> This detector looks for suspicious bitwise logical expressions. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.LazyInit">
    <Details>
<![CDATA[<p>此检测器查找字段不易失的惰性字段初始化。它是一个中等速度的探测器</p>  <p> This detector looks for lazy field initialization where the field is not volatile.  It is a moderately fast detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindJSR166LockMonitorenter">
    <Details>
<![CDATA[<p>此检测器查找在JSR166锁上执行的普通同步。它是一个中等速度的探测器</p>  <p> This detector looks for ordinary synchronization performed on JSR166 locks.  It is a moderately fast detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUncalledPrivateMethods">
    <Details>
<![CDATA[<p>此检测器查找从未调用的私有方法</p>  <p> This detector looks for private methods that are never called. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.StringConcatenation">
    <Details>
<![CDATA[<p>此检测器使用+查找循环中的字符串串联</p>  <p> This detector looks for String concatenation in loops using +. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InefficientInitializationInsideLoop">
    <Details>
<![CDATA[<p>此检测器查找循环内初始化的对象，这些对象可以移动到外部以获得更好的性能</p>  <p> This detector looks for objects initialized within loop which can be moved outside for better performance. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InefficientIndexOf">
    <Details>
<![CDATA[<p>此检测器查找使用String的代码。indexOf（String）或String。lastIndexOf（String），传递长度为1的常量字符串。建议使用更高效的整数实现。快速探测器</p>  <p> This detector looks for code that uses String.indexOf(String) or String.lastIndexOf(String), passing a constant string of length 1. It is recommended to use the more efficient integer implementations. A fast detector. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InefficientToArray">
    <Details>
<![CDATA[<p>此检测器使用toArray（）方法查找将Collections转换为数组的代码，该方法接受原型数组，并传递长度为零的数组参数</p>  <p> This detector looks for code that converts Collections to arrays using the toArray() method that takes a prototype array, passing an array argument which is zero-length. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InvalidJUnitTest">
    <Details>
<![CDATA[<p>此检测器查找格式错误的JUnit测试</p>  <p> This detector looks for JUnit tests that are malformed. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BadlyOverriddenAdapter">
    <Details>
<![CDATA[<p>此检测器查找扩展Adapter类并用错误签名覆盖Listener方法的代码</p>  <p> This detector looks for code that extends an Adapter class and overrides a Listener method with the wrong signature. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BadResultSetAccess">
    <Details>
<![CDATA[<p>此检测器查找对字段索引为0的结果集的getXXX或setXXX方法的调用。由于ResultSet字段从索引1开始，这总是一个错误</p>  <p> This detector looks for calls to getXXX or setXXX methods of a result set where the field index is 0. As ResultSet fields start at index 1, this is always a mistake. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SuperfluousInstanceOf">
    <Details>
<![CDATA[<p>此检测器使用instanceof运算符查找类型检查，其中可以静态完成确定</p>  <p> This detector looks for type checks using the instanceof operator where the determination can be done statically. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BadAppletConstructor">
    <Details>
<![CDATA[<p>此检测器查找调用父小程序中依赖小程序存根的方法的小程序构造函数。因为这个存根直到init（）方法之前才初始化，所以这些方法在构造函数中会失败</p>  <p> This detector looks for Applet constructors that call methods in the parent Applet that rely on the Applet stub. Since this stub isn't initialized until just before the init() method, these methods will fail in the constructor. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SuspiciousThreadInterrupted">
    <Details>
<![CDATA[<p>此检测器查找对Thread的调用。来自非静态上下文的interrupted（）。如果从Thread.currentThread（）调用。interrupted（），那么这只是一个无用的练习，只需使用Thread.interrupted（）即可。但是，如果在任意线程对象上调用它，则很可能是一个错误，因为interrupted（）总是在当前线程上调用</p>  <p> This detector looks for calls to Thread.interrupted() from a non-static context. If it is called from Thread.currentThread().interrupted(), then it is just a useless exercise, just use Thread.interrupted(). However if it is called on an arbitrary thread object, it is most probably an error, as interrupted() is always called on the current thread. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSqlInjection">
    <Details>
<![CDATA[<p>此检测器使用数据流分析来查找SQL语句上执行方法的调用，在这些SQL语句中，除常量字符串之外的其他内容作为参数传递</p>  <p> This detector uses data flow analysis to look for invocations of execute methods on SQL statements in which something other than a constant string is passed as an argument. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindDeadLocalStores">
    <Details>
<![CDATA[<p>此检测器查找从未随后读取的局部变量的赋值。它是一个中等速度的探测器</p>  <p> This detector looks for assignments to local variables that are never subsequently read. It is a moderately fast detector. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindMaskedFields">
    <Details>
<![CDATA[<p>此检测器查找由方法中定义的局部字段屏蔽的类级字段</p>  <p> This detector looks for class level fields that are masked by local fields defined in methods. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.WrongMapIterator">
    <Details>
<![CDATA[<p>此检测器使用从keySet迭代器检索到的键来查找Map条目的值</p>  <p> This detector looks for accessing the value of a Map entry, using a key that was retrieved from a keySet iterator. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InstantiateStaticClass">
    <Details>
<![CDATA[<p>此检测器查找基于仅定义静态方法的类创建对象的代码</p>  <p> This detector looks for code that creates objects based on classes that only define static methods. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.RuntimeExceptionCapture">
    <Details>
<![CDATA[<p>当块中没有代码抛出Exception时，此检测器查找捕获Exception的catch子句</p>  <p> This detector looks for catch clauses that catch Exception, when no code in the block throws Exception. </p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindFloatEquality">
    <Details>
<![CDATA[<p>查找浮点相等表达式。快速探测器</p>  <p> Looks for floating point equality expressions. A fast detector. </p>]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnsatisfiedObligation">
    <Details>
<![CDATA[<p>此检测器在方法的所有路径上查找未清理的I/O流和数据库资源。这是一个慢探测器</p>  <p>This detector looks for I/O streams and database resources that are not cleaned up on all paths out of a method.  This is a slow detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.UnnecessaryMath">
    <Details>
<![CDATA[<p>此检测器查找对常量值调用java.lang.Math静态方法的代码，其中生成的值是一个静态已知常量。改用常数更快，有时更准确</p>  <p>This detector looks for code that calls java.lang.Math static methods on constant values, where the resultant value is a statically known constant. It is faster, and sometimes more accurate, to use the constant instead.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindCircularDependencies">
    <Details>
<![CDATA[<p>此检测器查找类之间的循环依赖关系</p>  <p>This detector looks for circular dependencies among classes. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.RedundantInterfaces">
    <Details>
<![CDATA[<p>此检测器查找声明它们实现与超级类相同接口的类。如果超类实现了接口，那么子类也是多余的</p>  <p>This detector looks for classes that declare they implement the same interface as a super class. This is redundant, if a superclass implements an interface, so does the subclass.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MultithreadedInstanceAccess">
    <Details>
<![CDATA[<p>这个检测器寻找实现Struts框架中的潜在问题</p>  <p>This detector looks for potential problems in implementing the Struts framework. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.PublicSemaphores">
    <Details>
<![CDATA[<p>此检测器查找同步的公共类，并在This</b>上使用wait（）、notify（）或notifyAll（）。这将同步实现公开为类的公共工件。该类的客户端可能会将该类的实例用作自己的同步对象，并对基本实现造成破坏</p>  <p>This detector looks for public classes that synchronize and use wait(), notify() or notifyAll() on <b>this</b>. This exposes a synchronization implementation as a public artifact of the class. Clients of the class may use an instance of the class as its own synchronizing object, and cause havoc to the base implementation. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MethodReturnCheck">
    <Details>
<![CDATA[<p>此检测器查找对返回值被可疑忽略的方法的调用</p>  <p> This detector looks for calls to methods where the return value is suspiciously ignored.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.IDivResultCastToDouble">
    <Details>
<![CDATA[<p>此检测器查找整数除法结果转换为双精度的位置。通常，意思是将整数操作数强制转换为双精度，然后执行除法</p>  <p> This detector looks for places where the result of integer division is cast to double. Often, what was meant was to cast the integer operands to double and then perform the division. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindBadCast2">
    <Details>
<![CDATA[<p>此检测器使用数据流分析查找对象引用的错误类型转换</p>  <p> This detector looks for bad casts of object references using data flow analysis. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNonSerializableStoreIntoSession">
    <Details>
<![CDATA[<p>此检测器在HTTP会话中查找非序列化对象的存储</p>  <p> This detector looks for stores of non Serializable objects into HTTP sessions. </p>]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindUseOfNonSerializableValue">
    <Details>
<![CDATA[<p>此检测器在需要序列化的上下文中查找非序列化对象的使用</p>  <p> This detector looks for uses of non Serializable objects in contexts that require them to be serializable. </p>]]>
    </Details>
  </Detector>


  <Detector class="edu.umd.cs.findbugs.detect.FindNonSerializableValuePassedToWriteObject">
    <Details>
<![CDATA[<p>此检测器查找传递给ObjectOutput的writeObject方法的非序列化对象</p>  <p> This detector looks for non Serializable objects passed to the writeObject method of an ObjectOutput. </p>]]>
    </Details>
  </Detector>



  <Detector class="edu.umd.cs.findbugs.detect.BadSyntaxForRegularExpression">
    <Details>
<![CDATA[<p>此检测器查找语法无效的正则表达式</p>  <p> This detector looks for regular expressions that have invalid syntax.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindPuzzlers">
    <Details>
<![CDATA[<p>这个检测器寻找Joshua Bloch和Neal Gafter在他们的编程难题工作中提到的各种小错误</p>  <p> This detector looks for miscellaneous small errors mentioned by Joshua Bloch and Neal Gafter in their work on Programming Puzzlers.   </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSleepWithLockHeld">
    <Details>
      <![CDATA[<p>此检测器查找对Thread的调用。sleep（）在保持锁的情况下创建。这是一个慢探测器</p>  <p>    This detector looks for calls to Thread.sleep() made with    a lock held.  It is a slow detector. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DuplicateBranches">
    <Details>
<![CDATA[<p>此检测器查找两个分支具有相同代码的if/else或switch语句，从而使测试无效。这通常是由于复制和粘贴两个分支，导致一个分支的逻辑不正确。</p><p></p>  <p> This detector looks for if/else or switch statements that have the same code for two branches, thus rendering the test useless. This often is caused by copying and pasting the two branches, causing incorrect logic for the one branch.</p><p></p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InefficientMemberAccess">
    <Details>
<![CDATA[<p>当所属类的成员变量为私有时，此检测器查找写入所属类成员变量的内部类。在这种情况下，需要使用编译器生成的特殊访问器方法来写入此变量。将可见性放宽到受保护状态将允许直接写入字段</p> <p></p>  <p> This detector looks for internal classes that write to member variables of the owning class, when that member variable is private. In this case, a special compiler generated accessor method needs to be used to write to this variable. Relaxing the visibility to protected will allow the field to be directly written.</p> <p></p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.XMLFactoryBypass">
    <Details>
<![CDATA[<p>这个检测器寻找XML接口实现的直接分配。这将代码绑定到特定的实现，而不是使用提供的工厂模式来创建这些对象</p> <p></p>  <p> This detector looks for direct allocations of implementations of XML interfaces. This ties the code to a specific implementation, rather than using the supplied factory pattern to create these objects.</p> <p></p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.UselessSubclassMethod">
    <Details>
      <![CDATA[<p>此检测器查找实现超类中定义的方法的子类，这些方法只将未经修改的参数传递给父类方法。这些方法可以删除</p> <p></p>  <p> This detector looks for subclasses that implement methods defined in the super class, that only pass the parameters untouched to the parent class method. These methods can just be removed. </p> <p></p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ConfusedInheritance">
    <Details>
      <![CDATA[<p>此检测器查找声明受保护成员的最终类。由于无法从派生此类，因此对成员使用受保护的访问权限是不正确的。应将访问权限更改为公共或私人，以代表该领域的正确意图。这可能是由于该类的使用发生了变化，而没有将所有类完全更改为新的范例</p> <p></p>  <p> This detector looks for final classes that declare protected members. As this class can not be derived from, the use of protected access for members is incorrect. The access should be changed to public or private to represent the correct intention of the field. This was probably caused by a change in use for this class, without completely changing all of the class to the new paradigm. </p> <p></p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.QuestionableBooleanAssignment">
    <Details>
      <![CDATA[<p>此检测器查找条件表达式中变量的文字布尔值的简单赋值</p> <p></p>  <p> This detector looks for simple assignments of literal boolean values to variables in conditional expressions. </p> <p></p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainNullReturnValues">
    <Details>
      <![CDATA[<p>TrainNullReturnValues确定哪些方法可以返回null并将其保存到文件中。生成的文件可以在后续过程中使用，以提高零解引用检测器的精度。由于这只是一个培训通行证，因此没有任何警告报告</p> <p>这是一个慢探测器</p>  <p> TrainNullReturnValues determines which methods may return null and saves them to a file.  The resulting file may be used in a subsequent pass to improve the precision of the null-dereference detector. Since this is just a training pass, no warnings are reported. </p> <p> This is a slow detector. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainUnconditionalDerefParams">
    <Details>
      <![CDATA[<p>TrainUnconditionalParamDerefs确定哪些方法可以无条件取消引用参数并将其保存到文件中。生成的文件可以在后续过程中使用，以提高零解引用检测器的精度。由于这只是一个培训通行证，因此没有任何警告报告</p> <p>这是一个慢探测器</p>  <p> TrainUnconditionalParamDerefs determines which methods may unconditionally dereference parameters and saves them to a file. The resulting file may be used in a subsequent pass to improve the precision of the null-dereference detector. Since this is just a training pass, no warnings are reported. </p> <p> This is a slow detector. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainFieldStoreTypes">
    <Details>
      <![CDATA[<p>TrainFieldStoreType分析存储在字段中的类型，并将其存储到数据库中。数据库可以在以后的过程中使用，以使类型分析更加精确</p> <p>这是一个慢探测器</p>  <p> TrainFieldStoreTypes analyzes the types stored into fields and stores them to a database.  The database may be used in a later pass to make type analysis more precise. </p> <p> This is a slow detector. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainNonNullAnnotations">
    <Details>
      <![CDATA[<p>TrainNonNullAnnotations收集@Nonnull和@PossiblyNull注释，并将它们存储到数据库文件中。这是一个快速探测器</p>  <p> TrainNonNullAnnotations collects @Nonnull and @PossiblyNull annotations and stores them to database files.  This is a fast detector. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckCalls">
    <Details>
      <![CDATA[<p>此检测器仅用于调试SpotBugs中的方法调用解析。不要启用它</p>  <p>This detector is just for debugging method call resolution in SpotBugs. Don't enable it.</p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindBugsSummaryStats">
    <Details>
<![CDATA[<p>此检测器仅收集有关分析过程的汇总统计信息</p>  <p> This detector just collects summary statistics information about the analysis process. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestASM">
    <Details>
    <![CDATA[<p>这个检测器是一个代码示例，展示了如何使用ASM字节码分析框架编写SpotBugs检测器</p>  <p>     This detector is a code example showing how to write a SpotBugs     detector using the ASM bytecode analysis framework.     </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnrelatedTypesInGenericContainer">
    <Details>
    <![CDATA[<p>此检测器查看接收<code>java.lang.Object</code>的泛型集合方法调用的参数，以查看参数的类型是否与集合的参数相关。具有不相关类类型的参数永远不会在集合中。例如，如果<code>foo</code>是一个<code>列表&lt；字符串&gt</code>和<code>bar</code>是一个<code>StringBuffer</code>foo调用。contains（bar）</code>将始终返回false。这是一个快速探测器</p>  <p> This detector looks at the arguments of calls to generic     collection methods that receive a <code>java.lang.Object</code>     to see if the argument's type is related to the collection's     parameter. Arguments with unrelated class types are never going     to be in the collection. For example, if <code>foo</code> is a     <code>List&lt;String&gt;</code> and <code>bar</code> is a     <code>StringBuffer</code>, the call <code>foo.contains(bar)</code>     will always return false. This is a fast detector.     </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.StaticCalendarDetector">
    <Details>
<![CDATA[<p>此检测器对java.util类型的静态字段发出警告。日历或java.text。DateFormat（和子类），因为日历对于多线程使用来说本质上是不安全的</p>  <p>This detector warns about static fields of type java.util.Calendar or java.text.DateFormat (and subclasses) because  Calendars are inherently unsafe for multithreaded use. </p>]]>
</Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestDataflowAnalysis">
    <Details>
      <![CDATA[<p>这是一个内部检测器，仅用于测试数据流分析。默认情况下不启用</p>  <p>This is an internal detector used only for testing dataflow analyses.     It is not enabled by default.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckTypeQualifiers">
    <Details>
      <![CDATA[<p>检查是否违反了JSR-305类型限定符注释指定的属性</p>  <p>Check for violations of properties specified by JSR-305   type qualifier annotations.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.AppendingToAnObjectOutputStream">
    <Details>
      <![CDATA[<p>查找试图附加到对象输出流的情况</p>  <p>Looks for an attempt to append to an object output stream.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckExpectedWarnings">
    <Details>
          <![CDATA[<p>检查@ExpectedWarning和@NoWarning注释。此检测器仅用于测试SpotBugs</p>  <p>Checks @ExpectedWarning and @NoWarning annotations.     This detector is used only for testing SpotBugs.</p>]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DontIgnoreResultOfPutIfAbsent">
    <Details>
          <![CDATA[<p>检查如果忽略putIfAbsent的结果，则不会重用作为第二个参数传递的值</p>  <p>Checks that if the result of putIfAbsent is ignored, the value passed as the second argument is not reused. </p>]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ReadOfInstanceFieldInMethodInvokedByConstructorInSuperclass">
    <Details>
          <![CDATA[<p>检查从超类的构造函数调用的方法</p>  <p>Checks for methods invoked from constructors for superclasses.  </p>]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DefaultEncodingDetector">
    <Details>
<![CDATA[<p>检查对使用用户默认平台编码执行字节到字符串（或字符串到字节）转换的方法的调用。这可能导致应用程序行为因平台而异</p>  <p> Checks for calls to methods which perform a byte to String (or String to byte) conversion using the user's default  platform encoding. This can cause the application behaviour to vary between platforms.  </p>]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckRelaxingNullnessAnnotation">
    <Details>
      <![CDATA[<p>检查重写方法在返回值上不松弛@Nonnull（maked@CheckForNull），在参数上不松弛@CheckForNull（maked@Nonnnull）</p>  <p>Checks that overriding methods do not relax @Nonnull (made @CheckForNull) on return values   or @CheckForNull (made @Nonnull) on parameters.</p>]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DontAssertInstanceofInTests">
    <Details>
      <![CDATA[<p>JUnit测试中的模式检测器，其中通过断言instanceof运算符检查对象的类型</p> <p>应避免这种情况，因为与断言instanceof运算符的结果所产生的“false is not true”消息相比，由不正确的强制转换导致的ClassCastException可能提供更多有关错误原因的信息</p> <p>它是一种快速探测器</p>  <p>Detector for patterns in JUnit tests where the type of an object    is checked by asserting the instanceof operator.</p> <p>    This should be avoided as the ClassCastException that would result    from an improper cast may provide more information regarding the    cause of the error than a "false is not true" message which would    result from asserting the result of the instanceof operator. </p>    <p>It is a fast detector</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindBadEndOfStreamCheck">
    <Details>
      <![CDATA[<p>模式检测器，其中java.io.FileInputStream的返回值为。read（）或java.io.FileReader。read（）在检查-1之前被转换。</p><p>两个方法都返回一个int。如果这个int被转换为字节（在FileInputStream.read（）的情况下），那么-1和字节0xFF将无法区分。如果它被转换为char（在FileReader.read（）的情况下），那么-1将变成0xFFFF，即Character。MAX_VALUE，因为Java中的字符是无符号的</p>  <p>Detector for patterns where the return value of java.io.FileInputStream.read() or    java.io.FileReader.read() is converted before checking against -1.</p> <p>    Both methods return an int. If this int is converted to byte (in the case of    FileInputStream.read()) then -1 and the byte 0xFF become indistinguishable.    If it is converted to char (in the case of FileReader.read()) then -1 becomes    0xFFFF which is Character.MAX_VALUE since characters are unsigned in Java. </p>]]>
    </Details>
  </Detector>
  <!--
  **********************************************************************
  BugPatterns
  **********************************************************************
   -->

  <BugPattern type="JUA_DONT_ASSERT_INSTANCEOF_IN_TESTS">
    <ShortDescription>不建议在测试中断言instanceof的值。  Asserting value of instanceof in tests is not recommended.</ShortDescription>
    <LongDescription>{3}的{2}中的{0}类型断言可能会隐藏有关强制转换失败原因的有用信息。</LongDescription>
    <Details>
      <![CDATA[<p>不建议在测试中进行断言类型检查，因为类强制转换异常消息比断言实例更好地指示使用错误类的实例的原因</p> <p>当调试由于错误强制转换而失败的测试时，观察产生的ClassCastException的输出可能更有用，它可以提供有关实际遇到的类型的信息。在强制转换之前断言类型反而会导致信息量较小的<code>“false is not true”</code>消息</p> <p>如果JUnit与hamcrest一起使用，<a href=“https://junit.org/junit4/javadoc/latest/index.html?org/hamcrest/core/IsInstanceOf.html“><code>IsInstanceOf</code></a>可以改用hamcrest中的类</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="OVERRIDING_METHODS_MUST_INVOKE_SUPER">
    <ShortDescription>超级方法用@OverridingMethodsMustInvokeSuper注释，但重写方法没有调用超级方法。  Super method is annotated with @OverridingMethodsMustInvokeSuper, but the overriding method isn't calling the super method.</ShortDescription>
    <LongDescription>超级方法用@OverridingMethodsMustInvokeSuper注释，但{1}没有调用超级方法。</LongDescription>
    <Details>
      <![CDATA[<p>超级方法用@OverridingMethodsMustInvokeSuper注释，但重写方法没有调用超级方法</p>]]>
    </Details>  </BugPattern>
  <BugPattern type="CNT_ROUGH_CONSTANT_VALUE">
    <ShortDescription>找到已知常数的粗略值  Rough value of known constant found</ShortDescription>
    <LongDescription>找到{3}的大致值：{2}</LongDescription>
    <Details>
      <![CDATA[<p>建议使用预定义的库常量，以提高代码的清晰度和精度</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SKIPPED_CLASS_TOO_BIG">
    <ShortDescription>类太大，无法分析  Class too big for analysis</ShortDescription>
    <LongDescription>{0}太大，无法分析</LongDescription>
    <Details>
      <![CDATA[<p>这个类比可以有效处理的要大，并且没有对错误进行全面分析</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NOISE_NULL_DEREFERENCE">
    <ShortDescription>关于空指针引用的虚假警告  Bogus warning about a null pointer dereference</ShortDescription>
    <LongDescription>{1}中关于空指针引用的虚假警告</LongDescription>
    <Details>
      <![CDATA[<p>虚假警告</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NOISE_METHOD_CALL">
    <ShortDescription>关于方法调用的虚假警告  Bogus warning about a method call</ShortDescription>
    <LongDescription>关于{1}中的方法调用{2}的虚假警告</LongDescription>
    <Details>
      <![CDATA[<p>虚假警告</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NOISE_FIELD_REFERENCE">
    <ShortDescription>关于字段引用的虚假警告  Bogus warning about a field reference</ShortDescription>
    <LongDescription>关于{1}中对{2}的引用的虚假警告</LongDescription>
    <Details>
      <![CDATA[<p>虚假警告</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NOISE_OPERATION">
    <ShortDescription>关于操作的虚假警告  Bogus warning about an operation</ShortDescription>
    <LongDescription>关于操作的虚假警告{1}</LongDescription>
    <Details>
      <![CDATA[<p>虚假警告</p>]]>
    </Details>
  </BugPattern>
    <BugPattern type="DMI_BIGDECIMAL_CONSTRUCTED_FROM_DOUBLE">
        <ShortDescription>由未精确表示的双精度值构造的BigDecimal  BigDecimal constructed from double that isn't represented precisely</ShortDescription>
        <LongDescription>从{1}中的{4}构造的BigDecimal</LongDescription>
        <Details>
      <![CDATA[<p>这段代码从无法很好地转换为十进制数的双精度值创建BigDecimal。例如，可以假设在Java中编写新的BigDecimal（0.1）会创建一个BigDechimal，它正好等于0.1（未缩放的值为1，小数位数为1），但实际上等于0.100000000000005551115125782702117181583404541015625。您可能想使用BigDeximal。valueOf（double d）方法，它使用double的String表示形式来创建BigDecimal（例如，BigDechimal.valueOf</p>]]>
    </Details>
    </BugPattern>

    <BugPattern type="DMI_DOH">
        <ShortDescription>哦！无意义的方法调用  D'oh! A nonsensical method invocation</ShortDescription>
        <LongDescription>哦！{1}中对{2.nameAndSignature}的无意义调用</LongDescription>
        <Details>
      <![CDATA[<p>这种局部方法调用没有意义，原因从检查中可以明显看出</p>]]>
    </Details>
    </BugPattern>

  <BugPattern type="DMI_VACUOUS_CALL_TO_EASYMOCK_METHOD">
    <ShortDescription>对EasyMock方法的无用/无效调用  Useless/vacuous call to EasyMock method</ShortDescription>
    <LongDescription>对{1}中{2}的无用/空调用</LongDescription>
    <Details>
      <![CDATA[<p>此调用不会将任何对象传递给EasyMock方法，因此该调用不会执行任何操作</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_SCHEDULED_THREAD_POOL_EXECUTOR_WITH_ZERO_CORE_THREADS">
    <ShortDescription>使用零核心线程创建ScheduledThreadPoolExecutor  Creation of ScheduledThreadPoolExecutor with zero core threads</ShortDescription>
    <LongDescription>在{1}中使用零核心线程创建ScheduledThreadPoolExecutor</LongDescription>
    <Details>
      <![CDATA[<p>（<a href=“http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html#ScheduledThreadPoolExecutor%28int%29“>Javadoc</a>）具有零核心线程的ScheduledThreadPoolExecutor将永远不会执行任何操作；对最大池大小的更改将被忽略</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_FUTILE_ATTEMPT_TO_CHANGE_MAXPOOL_SIZE_OF_SCHEDULED_THREAD_POOL_EXECUTOR">
    <ShortDescription>无法更改ScheduledThreadPoolExecutor的最大池大小  Futile attempt to change max pool size of ScheduledThreadPoolExecutor</ShortDescription>
    <LongDescription>无法更改{1}中ScheduledThreadPoolExecutor的最大池大小</LongDescription>
    <Details>
      <![CDATA[<p>（<a href=“http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html“>Javadoc</a>）虽然ScheduledThreadPoolExecutor继承自ThreadPool Executors，但一些继承的优化方法对它没有用处。特别是，由于它使用corePoolSize线程和无限队列充当固定大小的池，因此对maximumPoolSizes的调整没有任何用处</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_UNSUPPORTED_METHOD">
    <ShortDescription>调用不支持的方法  Call to unsupported method</ShortDescription>
    <LongDescription>调用{1}中不受支持的方法{2}</LongDescription>
    <Details>
      <![CDATA[<p>此方法调用的所有目标都会引发UnsupportedOperationException</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_EMPTY_DB_PASSWORD">
    <ShortDescription>空数据库密码  Empty database password</ShortDescription>
    <LongDescription>{1}中的数据库密码为空</LongDescription>
    <Details>
      <![CDATA[<p>此代码使用空白或空密码创建数据库连接。这表明数据库不受密码保护</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_CONSTANT_DB_PASSWORD">
    <ShortDescription>硬编码常量数据库密码  Hardcoded constant database password</ShortDescription>
    <LongDescription>{1}中的硬编码常量数据库密码</LongDescription>
    <Details>
      <![CDATA[<p>此代码使用硬编码的固定密码创建数据库连接。任何能够访问源代码或编译代码的人都可以轻松地学习密码</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="HRS_REQUEST_PARAMETER_TO_COOKIE">
    <ShortDescription>由不受信任的输入形成的HTTP cookie  HTTP cookie formed from untrusted input</ShortDescription>
    <LongDescription>{1}中不受信任的输入形成的HTTP cookie</LongDescription>
    <Details>
      <![CDATA[<p>此代码使用不受信任的HTTP参数构造HTTP Cookie。如果将此cookie添加到HTTP响应，它将允许HTTP响应拆分漏洞。请参见<a href=“http://en.wikipedia.org/wiki/HTTP_response_splitting">http://en.wikipedia.org/wiki/HTTP_response_splitting</a>了解更多信息</p> <p>SpotBugs只查找最明显的HTTP响应拆分案例。如果SpotBugs发现<em>任何</em>，您几乎可以肯定<em>有SpotBug没有报告的更多漏洞。如果您担心HTTP响应拆分，应该认真考虑使用商业静态分析或笔测试工具</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="HRS_REQUEST_PARAMETER_TO_HTTP_HEADER">
    <ShortDescription>HTTP响应拆分漏洞  HTTP Response splitting vulnerability</ShortDescription>
    <LongDescription>HTTP参数直接写入{1}中的HTTP头输出</LongDescription>
    <Details>
            <![CDATA[<p>此代码直接将HTTP参数写入HTTP头，从而允许HTTP响应拆分漏洞。请参见<a href=“http://en.wikipedia.org/wiki/HTTP_response_splitting">http://en.wikipedia.org/wiki/HTTP_response_splitting</a>了解更多信息</p> <p>SpotBugs只查找最明显的HTTP响应拆分案例。如果SpotBugs发现<em>任何</em>，您几乎可以肯定<em>有SpotBug没有报告的更多漏洞。如果您担心HTTP响应拆分，应该认真考虑使用商业静态分析或笔测试工具</p>]]>
        </Details>
  </BugPattern>



  <BugPattern type="PT_RELATIVE_PATH_TRAVERSAL">
    <ShortDescription>servlet中的相对路径遍历  Relative path traversal in servlet</ShortDescription>
    <LongDescription>{1}中的相对路径遍历</LongDescription>
    <Details>
<![CDATA[<p>该软件使用HTTP请求参数构造一个路径名，该路径名应位于受限目录内，但它不能正确中和“..”等序列，这些序列可以解析到该目录外的某个位置。请参见<a href=“http://cwe.mitre.org/data/definitions/23.html">http://cwe.mitre.org/data/definitions/23.html</a>了解更多信息</p> <p>SpotBugs只查找最明显的相对路径遍历情况。如果SpotBugs发现<em>任何</em>，您几乎可以肯定<em>有SpotBug没有报告的更多漏洞。如果您关心相对路径遍历，您应该认真考虑使用商业静态分析或笔测试工具</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="PT_ABSOLUTE_PATH_TRAVERSAL">
    <ShortDescription>servlet中的绝对路径遍历  Absolute path traversal in servlet</ShortDescription>
    <LongDescription>{1}中的绝对路径遍历</LongDescription>
    <Details>
<![CDATA[<p>该软件使用HTTP请求参数构造一个应位于受限目录中的路径名，但它不能正确中和绝对路径序列，例如“/abs/path”，该路径序列可以解析到该目录之外的位置。请参见<a href=“http://cwe.mitre.org/data/definitions/36.html">http://cwe.mitre.org/data/definitions/36.html</a>了解更多信息</p> <p>SpotBugs只查找最明显的绝对路径遍历案例。如果SpotBugs发现<em>任何</em>，您几乎可以肯定<em>有SpotBug没有报告的更多漏洞。如果您关心绝对路径遍历，您应该认真考虑使用商业静态分析或笔测试工具</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER">
    <ShortDescription>Servlet反映了跨站点脚本漏洞  Servlet reflected cross site scripting vulnerability</ShortDescription>
    <LongDescription>写入{1}中Servlet输出的HTTP参数</LongDescription>
    <Details>
<![CDATA[<p>这段代码直接将HTTP参数写入Servlet输出，从而允许反射跨站点脚本漏洞。请参见<a href=“http://en.wikipedia.org/wiki/Cross-site_scripting">http://en.wikipedia.org/wiki/Cross-site_scripting</a>了解更多信息</p> <p>SpotBugs只查找最明显的跨站点脚本案例。如果SpotBugs发现<em>任何</em>，您几乎可以肯定<em>有更多SpotBug没有报告的跨站点脚本漏洞。如果您关心跨站点脚本，您应该认真考虑使用商业静态分析或笔测试工具</p>]]>
    </Details>
  </BugPattern>


  <BugPattern type="XSS_REQUEST_PARAMETER_TO_SEND_ERROR">
    <ShortDescription>Servlet在错误页中反映了跨站点脚本漏洞  Servlet reflected cross site scripting vulnerability in error page</ShortDescription>
    <LongDescription>HTTP参数写入{1}中的Servlet错误页</LongDescription>
    <Details>
<![CDATA[<p>这段代码直接将HTTP参数写入服务器错误页（使用HttpServletResponse.sendError）。回显此不受信任的输入会导致反射的跨站点脚本漏洞。请参见<a href=“http://en.wikipedia.org/wiki/Cross-site_scripting">http://en.wikipedia.org/wiki/Cross-site_scripting</a>了解更多信息</p> <p>SpotBugs只查找最明显的跨站点脚本案例。如果SpotBugs发现<em>任何</em>，您几乎可以肯定<em>有更多SpotBug没有报告的跨站点脚本漏洞。如果您关心跨站点脚本，您应该认真考虑使用商业静态分析或笔测试工具</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="XSS_REQUEST_PARAMETER_TO_JSP_WRITER">
    <ShortDescription>JSP反映了跨站点脚本漏洞  JSP reflected cross site scripting vulnerability</ShortDescription>
    <LongDescription>HTTP参数直接写入JSP输出，在{1.class}中给出反映的XSS漏洞</LongDescription>
    <Details>
<![CDATA[<p>这段代码直接将HTTP参数写入JSP输出，从而允许跨站点脚本漏洞。请参见<a href=“http://en.wikipedia.org/wiki/Cross-site_scripting">http://en.wikipedia.org/wiki/Cross-site_scripting</a>了解更多信息</p> <p>SpotBugs只查找最明显的跨站点脚本案例。如果SpotBugs发现<em>任何</em>，您几乎可以肯定<em>有更多SpotBug没有报告的跨站点脚本漏洞。如果您关心跨站点脚本，您应该认真考虑使用商业静态分析或笔测试工具</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SW_SWING_METHODS_INVOKED_IN_SWING_THREAD">
    <ShortDescription>某些swing方法需要在swing线程中调用  Certain swing methods need to be invoked in Swing thread</ShortDescription>
    <LongDescription>{1}中对swing方法的调用需要在swing事件线程中执行</LongDescription>
    <Details>
<![CDATA[<p>（<a href=“http://web.archive.org/web/20090526170426/http://java.sun.com/developer/JDCTechTips/2003/tt1208.html“>来自JDC技术提示</a>）：Swing方法show（）、setVisible（）和pack（）将为帧创建关联的对等方。通过创建对等点，系统将创建事件分派线程。这会造成问题，因为事件分派线程可能会在打包和验证仍在处理时通知侦听器。这种情况可能导致两个线程通过基于Swing组件的GUI——这是一个严重的缺陷，可能导致死锁或其他相关的线程问题。包调用会导致实现组件。当它们被实现时（也就是说，不一定是可见的），它们可以在事件分派线程上触发侦听器通知</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IL_INFINITE_LOOP">
    <ShortDescription>明显的无限循环  An apparent infinite loop</ShortDescription>
    <LongDescription>{1}中有一个明显的无限循环</LongDescription>
    <Details>
<![CDATA[<p>这个循环似乎没有终止的方法（除了抛出异常之外）</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IL_INFINITE_RECURSIVE_LOOP">
    <ShortDescription>一个明显的无限递归循环  An apparent infinite recursive loop</ShortDescription>
    <LongDescription>{1}中有一个明显的无限递归循环</LongDescription>
    <Details>
<![CDATA[<p>此方法无条件地调用自身。这似乎表明无限递归循环将导致堆栈溢出</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IL_CONTAINER_ADDED_TO_ITSELF">
    <ShortDescription>集合已添加到自身  A collection is added to itself</ShortDescription>
    <LongDescription>集合被添加到{1}中的自身</LongDescription>
    <Details>
<![CDATA[<p>集合被添加到自身。因此，计算此集合的hashCode将引发StackOverflowException</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="VO_VOLATILE_REFERENCE_TO_ARRAY">
    <ShortDescription>对数组的volatile引用不会将数组元素视为volatile  A volatile reference to an array doesn't treat the array elements as volatile</ShortDescription>
    <LongDescription>{1} 是对数组的可变引用；数组元素是非易失性的</LongDescription>
    <Details>
<![CDATA[<p>这声明了对数组的可变引用，这可能不是您想要的。对于数组的volatile引用，对数组引用的读取和写入被视为volatile，但数组元素是非volatile的。要获取volatile数组元素，需要使用java.util中的原子数组类之一。并发（Java 5.0中提供）</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="VO_VOLATILE_INCREMENT">
    <ShortDescription>易失性字段的增量不是原子的  An increment to a volatile field isn't atomic</ShortDescription>
    <LongDescription>{1}中易失性字段{2}的增量</LongDescription>
    <Details>
<![CDATA[<p>此代码增加/减少易失性字段。易失性字段的增量/减量不是原子的。如果多个线程同时递增/递减字段，递增/递减可能会丢失</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UI_INHERITANCE_UNSAFE_GETRESOURCE">
    <ShortDescription>如果类被扩展，则使用GetResource可能不安全  Usage of GetResource may be unsafe if class is extended</ShortDescription>
    <LongDescription>如果类被扩展，在{1}中使用GetResource可能不安全</LongDescription>
    <Details>
<![CDATA[<p>如果该类由另一个包中的类扩展，则调用<code>this.getClass（）.getResource（…）</code>可能会产生意外的结果</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_BOOLEAN_RETURN_NULL">
    <ShortDescription>具有布尔返回类型的方法返回显式null  Method with Boolean return type returns explicit null</ShortDescription>
    <LongDescription>{1} 具有布尔返回类型并返回显式null</LongDescription>
    <Details>
       <![CDATA[<p>返回布尔值的方法。TRUE，布尔值。FALSE或null是等待发生的事故。可以像返回布尔值类型一样调用此方法，编译器将插入布尔值的自动取消装箱。如果返回空值，这将导致NullPointerException</p>]]>
       </Details>
  </BugPattern>
  <BugPattern type="NP_OPTIONAL_RETURN_NULL">
    <ShortDescription>具有可选返回类型的方法返回显式null  Method with Optional return type returns explicit null</ShortDescription>
    <LongDescription>{1} 具有可选返回类型并返回显式null</LongDescription>
    <Details>
       <![CDATA[<p>使用Optional返回类型（java.util.Optional或com.google.common.base.Optional）总是意味着设计不需要显式的空返回。在这种情况下返回空值是违反合同的，很可能会破坏客户端代码</p>]]>
       </Details>
  </BugPattern>
  <BugPattern type="NP_NONNULL_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR">
    <ShortDescription>非空字段未初始化  Non-null field is not initialized</ShortDescription>
    <LongDescription>非空字段{2.name}未由{1}初始化</LongDescription>
    <Details>
       <![CDATA[<p>该字段标记为非空，但构造函数不会写入。该字段可能在构造函数期间在别处初始化，也可能总是在使用前初始化</p>]]>
       </Details>
  </BugPattern>
  <BugPattern type="NP_SYNC_AND_NULL_CHECK_FIELD">
    <ShortDescription>对同一字段进行同步和空值检查。  Synchronize and null check on the same field.</ShortDescription>
    <LongDescription>在{1}中，字段{2.givenClass}同步，然后检查是否为空。</LongDescription>
    <Details>
<![CDATA[<p>由于字段已同步，因此它似乎不太可能为空。如果它为null，然后在NullPointerException上同步，则会引发异常，检查将毫无意义。最好在另一个字段上同步</p>]]>
     </Details>
  </BugPattern>
  <BugPattern type="RpC_REPEATED_CONDITIONAL_TEST">
    <ShortDescription>重复条件测试  Repeated conditional tests</ShortDescription>
    <LongDescription>{1}中重复的条件测试</LongDescription>
    <Details>
<![CDATA[<p>代码包含两次条件测试，一次接着一次（例如，<code>x==0||x==0</code>）。也许第二次出现是为了其他原因（例如，<code>x==0||y==0</code>）</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="TESTING">
    <ShortDescription>测试  Testing</ShortDescription>
    <LongDescription>{1}中生成的测试警告</LongDescription>
    <Details>
<![CDATA[<p>此错误模式仅由新的、未完全实现的错误检测器生成</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="TESTING1">
    <ShortDescription>测试1  Testing 1</ShortDescription>
    <LongDescription>{1}中生成的测试警告1</LongDescription>
    <Details>
<![CDATA[<p>此错误模式仅由新的、未完全实现的错误检测器生成</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="TESTING2">
    <ShortDescription>测试2  Testing 2</ShortDescription>
    <LongDescription>{1}中生成的测试警告2</LongDescription>
    <Details>
<![CDATA[<p>此错误模式仅由新的、未完全实现的错误检测器生成</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="TESTING3">
    <ShortDescription>测试3  Testing 3</ShortDescription>
    <LongDescription>{1}中生成的测试警告3</LongDescription>
    <Details>
<![CDATA[<p>此错误模式仅由新的、未完全实现的错误检测器生成</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UNKNOWN">
    <ShortDescription>未知错误模式  Unknown bug pattern</ShortDescription>
    <LongDescription>{1}中存在未知错误模式bug_pattern</LongDescription>
    <Details>
<![CDATA[<p>记录了一条警告，但SpotBugs找不到此错误模式的描述，因此无法对其进行描述。这应该只发生在SpotBugs或其配置中的bug的情况下，或者如果分析是使用插件生成的，但该插件当前未加载</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="AM_CREATES_EMPTY_ZIP_FILE_ENTRY">
    <ShortDescription>创建空zip文件条目  Creates an empty zip file entry</ShortDescription>
    <LongDescription>{1}中创建的空zip文件条目</LongDescription>
    <Details>
<![CDATA[<p>代码调用<code>putNextEntry（）</code>，紧接着调用<code_>closeEntry（。这将导致空的ZipFile条目。在调用<code>putNextEntry（）</code>和<code>closeEntry（</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="AM_CREATES_EMPTY_JAR_FILE_ENTRY">
    <ShortDescription>创建空jar文件条目  Creates an empty jar file entry</ShortDescription>
    <LongDescription>{1}中创建的空jar文件条目</LongDescription>
    <Details>
<![CDATA[<p>代码调用<code>putNextEntry（）</code>，紧接着调用<code_>closeEntry（。这将导致一个空的JarFile条目。条目的内容应该在调用<code>putNextEntry（）</code>和<code>closeEntry（</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IMSE_DONT_CATCH_IMSE">
    <ShortDescription>IllegalMonitorStateException的可疑捕获  Dubious catching of IllegalMonitorStateException</ShortDescription>
    <LongDescription>{1}中IllegalMonitorStateException的可疑捕获</LongDescription>
    <Details>
<![CDATA[<p>IllegalMonitorStateException通常仅在代码中出现设计缺陷时抛出（对未锁定的对象调用wait或notify）</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FL_MATH_USING_FLOAT_PRECISION">
    <ShortDescription>方法使用浮点精度执行数学运算  Method performs math using floating point precision</ShortDescription>
    <LongDescription>{1} 使用浮点精度执行数学运算</LongDescription>
    <Details>
<![CDATA[<p>该方法使用浮点精度执行数学运算。浮点精度非常不精确。例如，16777216.0f+1.0f=16777216.0f。考虑改用双重数学</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CAA_COVARIANT_ARRAY_FIELD">
    <ShortDescription>字段的协变数组赋值  Covariant array assignment to a field</ShortDescription>
    <LongDescription>类型{2}的数组被分配给类型{3}的字段</LongDescription>
    <Details>
<![CDATA[<p>协变类型的数组被分配给字段。如果其他类型的引用稍后将存储在此数组中，如以下代码所示，这会造成混淆，并可能导致运行时出现ArrayStoreException：</p><pre><code>Number[]arr=new Integer[10]；arr[0]=1.0</code></pre><p>考虑更改创建的数组类型或字段类型</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CAA_COVARIANT_ARRAY_LOCAL">
    <ShortDescription>局部变量的协变数组赋值  Covariant array assignment to a local variable</ShortDescription>
    <LongDescription>{2}类型的数组被分配给{3}类型变量</LongDescription>
    <Details>
<![CDATA[<p>协变类型的数组被分配给局部变量。如果其他类型的引用稍后将存储在此数组中，如以下代码所示，这会造成混淆，并可能导致运行时出现ArrayStoreException：</p><pre><code>Number[]arr=new Integer[10]；arr[0]=1.0</code></pre><p>考虑更改创建的数组的类型或局部变量类型</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CAA_COVARIANT_ARRAY_RETURN">
    <ShortDescription>从方法返回协变数组  Covariant array is returned from the method</ShortDescription>
    <LongDescription>从返回类型为{3}的方法返回{2}类型的数组</LongDescription>
    <Details>
<![CDATA[<p>从方法返回协变类型的数组。如果调用代码将尝试在返回的数组中存储其他类型的引用，这会造成混淆，并可能导致运行时出现ArrayStoreException</p> <p>考虑更改已创建数组的类型或方法返回类型</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CAA_COVARIANT_ARRAY_ELEMENT_STORE">
    <ShortDescription>可能不兼容的元素存储在协变数组中  Possibly incompatible element is stored in covariant array</ShortDescription>
    <LongDescription>{2}类型的值存储到元素类型为{3}的数组中</LongDescription>
    <Details>
<![CDATA[<p>值存储到数组中，且值类型与数组类型不匹配。从分析中可以看出，实际数组类型比其变量或字段的声明类型窄，并且此赋值不满足原始数组类型。此分配可能会在运行时导致ArrayStoreException</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CN_IDIOM">
    <ShortDescription>类实现了Cloneable，但未定义或使用clone方法  Class implements Cloneable but does not define or use clone method</ShortDescription>
    <LongDescription>类{0}实现了Cloneable，但没有定义或使用clone方法</LongDescription>
    <Details>
<![CDATA[<p>类实现了Cloneable，但未定义或使用clone方法</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE">
    <ShortDescription>类定义了clone（），但未实现Cloneable  Class defines clone() but doesn't implement Cloneable</ShortDescription>
    <LongDescription>{0}定义了clone（），但未实现Cloneable</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个clone（）方法，但该类不实现Cloneable。在某些情况下这是可以的（例如，你想控制子类如何克隆自己），但要确保这是你想要的</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CN_IDIOM_NO_SUPER_CALL">
    <ShortDescription>克隆方法不调用super.clone（）  clone method does not call super.clone()</ShortDescription>
    <LongDescription>{1} 不调用super.clone（）</LongDescription>
    <Details>
<![CDATA[<p>这个非final类定义了一个不调用super.clone（）的clone（）方法。如果这个类（“<i>A</i>”）由一个子类（“<i>B</i>“）扩展，并且子类<i>B</i>调用super。则<i>B</i>的clone（）方法很可能会返回一个<i>A</i>类型的对象，这违反了克隆（）的标准约定</p> <p>如果所有clone（）方法都调用super。clone（），则可以保证它们使用Object。clone（），它总是返回正确类型的对象</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_FUTURE_KEYWORD_USED_AS_IDENTIFIER">
    <ShortDescription>在较新版本的Java中使用作为关键字的标识符  Use of identifier that is a keyword in later versions of Java</ShortDescription>
    <LongDescription>{1} 使用{2}作为变量名，这在Java的更高版本中是一个关键字</LongDescription>
    <Details>
<![CDATA[<p>标识符是一个在较新版本的Java中保留为关键字的单词，您的代码需要更改才能在较新的Java版本中编译它</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_FUTURE_KEYWORD_USED_AS_MEMBER_IDENTIFIER">
    <ShortDescription>在较新版本的Java中使用作为关键字的标识符  Use of identifier that is a keyword in later versions of Java</ShortDescription>
    <LongDescription>{1} 与较新版本的Java中的关键字冲突</LongDescription>
    <Details>
<![CDATA[<p>此标识符在较新版本的Java中用作关键字。此代码以及引用此API的任何代码都需要更改，以便在Java的更高版本中编译它</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DE_MIGHT_DROP">
    <ShortDescription>方法可能会丢弃异常  Method might drop exception</ShortDescription>
    <LongDescription>{1} 可能会丢弃{2}</LongDescription>
    <Details>
<![CDATA[<p>此方法可能会丢弃异常&nbsp；通常，应该以某种方式处理或报告异常，或者应该将异常从方法中抛出</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DE_MIGHT_IGNORE">
    <ShortDescription>方法可能会忽略异常  Method might ignore exception</ShortDescription>
    <LongDescription>{1} 可能忽略{2}</LongDescription>
    <Details>
<![CDATA[<p>此方法可能会忽略异常&nbsp；通常，应该以某种方式处理或报告异常，或者应该将异常从方法中抛出</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DP_DO_INSIDE_DO_PRIVILEGED">
    <ShortDescription>只应在doPrivileged块内调用的已调用方法  Method invoked that should be only be invoked inside a doPrivileged block</ShortDescription>
    <LongDescription>{2}的调用，应该从{1}中的doPrivileged块中调用</LongDescription>
    <Details>
<![CDATA[<p>此代码调用需要安全权限检查的方法。如果此代码将被授予安全权限，但可能被没有安全权限的代码调用，则调用需要在doPrivileged块内进行</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DP_DO_INSIDE_DO_PRIVILEDGED"> <!-- misspelled for backward compatibility -->
    <ShortDescription>只应在doPrivileged块内调用的已调用方法  Method invoked that should be only be invoked inside a doPrivileged block</ShortDescription>
    <LongDescription>{2}的调用，应该从{1}中的doPrivileged块中调用</LongDescription>
    <Details>
<![CDATA[<p>此代码调用需要安全权限检查的方法。如果此代码将被授予安全权限，但可能被没有安全权限的代码调用，则调用需要在doPrivileged块内进行</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED">
    <ShortDescription>Classloader只能在doPrivileged块内创建  Classloaders should only be created inside doPrivileged block</ShortDescription>
    <LongDescription>{1} 创建{2}类加载器，它应该在doPrivileged块中执行</LongDescription>
    <Details>
<![CDATA[<p>这段代码创建了一个类加载器，如果安装了安全管理，它需要权限。如果此代码可能被没有安全权限的代码调用，那么类加载器的创建需要在doPrivileged块中进行</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="JCIP_FIELD_ISNT_FINAL_IN_IMMUTABLE_CLASS">
    <ShortDescription>不可变类的字段应为final  Fields of immutable classes should be final</ShortDescription>
    <LongDescription>{1.givenClass}应该是final，因为{0}被标记为Immutable。</LongDescription>
    <Details>
<![CDATA[<p>该类用net.jcip.annotations注释。Immutable或javax.annotation.concurrent。不可变，这些注释的规则要求所有字段都是final</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_THREAD_PASSED_WHERE_RUNNABLE_EXPECTED">
    <ShortDescription>线程已传递到需要Runnable的位置  Thread passed where Runnable expected</ShortDescription>
    <LongDescription>线程传递到{1}中需要Runnable的位置</LongDescription>
    <Details>
<![CDATA[<p>Thread对象作为参数传递给需要Runnable的方法。这很不寻常，可能表示逻辑错误或导致意外行为</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_COLLECTION_OF_URLS">
    <ShortDescription>映射和URL集可能成为性能猪  Maps and sets of URLs can be performance hogs</ShortDescription>
    <LongDescription>{1} 是或使用一个映射或一组URL，这可能会影响性能</LongDescription>
    <Details>
<![CDATA[<p>此方法或字段是或使用映射或URL集。由于URL的equals和hashCode方法都执行域名解析，这可能会导致性能大幅下降。请参见<a href=“http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html">http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html</a>了解更多信息。考虑使用<code>java.net。而是URI</code></p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_BLOCKING_METHODS_ON_URL">
    <ShortDescription>URL的equals和hashCode方法正在阻塞  The equals and hashCode methods of URL are blocking</ShortDescription>
    <LongDescription>在{1}中调用{2}，它阻止进行域名解析</LongDescription>
    <Details>
<![CDATA[<p>URL的equals和hashCode方法执行域名解析，这可能会导致很大的性能损失。请参见<a href=“http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html">http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html</a>了解更多信息。考虑使用<code>java.net。而是URI</code></p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION">
    <ShortDescription>在没有运行时保留的情况下，无法使用反射检查是否存在批注  Can't use reflection to check for presence of annotation without runtime retention</ShortDescription>
    <LongDescription>使用反射检查{1}中没有运行时保留的注释{3}是否存在</LongDescription>
    <Details>
<![CDATA[<p>除非注释本身已经用@Retention（RetentionPolicy.RUNTIME）注释，否则无法使用反射观察注释（例如，使用isAnnotationPresent方法）</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_EXIT">
    <ShortDescription>方法调用System.exit（…）  Method invokes System.exit(...)</ShortDescription>
    <LongDescription>{1} 调用System.exit（…），从而关闭整个虚拟机</LongDescription>
    <Details>
<![CDATA[<p>正在调用系统。exit关闭整个Java虚拟机。只有在适当的时候才能这样做。这样的调用使得您的代码很难或不可能被其他代码调用。考虑改为抛出RuntimeException</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_RUN_FINALIZERS_ON_EXIT">
    <ShortDescription>方法调用危险的方法runFinalizersOnExit  Method invokes dangerous method runFinalizersOnExit</ShortDescription>
    <LongDescription>{1} 调用危险的方法runFinalizersOnExit</LongDescription>
    <Details>
<![CDATA[<p><em>切勿呼叫系统。runFinalizersOnExit或Runtime。不管什么原因，runFinalizersOnExit都是Java库中最危险的方法之一</em>--乔舒亚·布洛赫</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_STRING_CTOR">
    <ShortDescription>方法调用效率低下的新String（String）构造函数  Method invokes inefficient new String(String) constructor</ShortDescription>
    <LongDescription>{1} 调用效率低下的新String（String）构造函数</LongDescription>
    <Details>
<![CDATA[<p>使用<code>java.lang.String（String）</code>构造函数会浪费内存，因为这样构造的对象在功能上与作为参数传递的<code>String</code>无法区分&nbsp；只需直接使用参数<code>String</code></p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_STRING_VOID_CTOR">
    <ShortDescription>方法调用效率低下的新String（）构造函数  Method invokes inefficient new String() constructor</ShortDescription>
    <LongDescription>{1} 调用效率低下的新String（）构造函数</LongDescription>
    <Details>
<![CDATA[<p>使用无参数构造函数创建新的<code>java.lang.String</code>对象会浪费内存，因为这样创建的对象在功能上与空字符串常量无法区分&nbsp；Java保证相同的字符串常量将由相同的<code>string</code>对象表示&nbsp；因此，您应该直接使用空字符串常量</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_STRING_TOSTRING">
    <ShortDescription>方法对String调用toString（）方法  Method invokes toString() method on a String</ShortDescription>
    <LongDescription>{1} 对String调用toString（）方法</LongDescription>
    <Details>
<![CDATA[<p>调用字符串。toString（）</code>只是一个冗余操作。只需使用字符串</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_GC">
    <ShortDescription>显式垃圾收集；极为可疑，基准代码除外  Explicit garbage collection; extremely dubious except in benchmarking code</ShortDescription>
    <LongDescription>{1} 强制垃圾收集；极为可疑，基准代码除外</LongDescription>
    <Details>
<![CDATA[<p>代码显式调用垃圾收集。除了在基准测试中的具体用途外，这是非常可疑的</p> <p>在过去，人们在诸如close或finalize方法之类的例程中显式调用垃圾收集器的情况导致了巨大的性能黑洞。垃圾收集可能很昂贵。任何迫使数百或数千次垃圾收集的情况都会使机器陷入瘫痪</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_BOOLEAN_CTOR">
    <ShortDescription>方法调用低效的布尔构造函数；改用Boolean.valueOf（…）  Method invokes inefficient Boolean constructor; use Boolean.valueOf(...) instead</ShortDescription>
    <LongDescription>{1} 调用低效的布尔构造函数；改用Boolean.valueOf（…）</LongDescription>
    <Details>
<![CDATA[<p>创建<code>java.lang.Boolean</code>的新实例会浪费内存，因为<code>Boolean</code>对象是不可变的，并且这种类型只有两个有用的值&nbsp；使用<code>布尔值。valueOf（）</code>方法（或Java 1.5自动装箱）来创建布尔对象</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_NUMBER_CTOR">
    <ShortDescription>方法调用效率低下的Number构造函数；改用static valueOf  Method invokes inefficient Number constructor; use static valueOf instead</ShortDescription>
    <LongDescription>{1} 调用效率低下的{2}构造函数；改用{3}</LongDescription>
    <Details>
      <![CDATA[<p>使用<code>new Integer（int）</code>可以保证始终生成新对象，而<code>Integer。valueOf（int）</code>允许编译器、类库或JVM缓存值。使用缓存的值可以避免对象分配，并且代码会更快</p> <p>-128到127之间的值保证有相应的缓存实例，使用<code>valueOf</code>的速度大约是使用构造函数的3.5倍。对于常量范围之外的值，两种样式的性能相同</p> <p>除非该类必须与Java 1.5之前的JVM兼容，否则在创建<code>Long</code>、<code>Integer</code]、<code>Short</code>、<code>Character</code>和<code>Byte</code></p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_FP_NUMBER_CTOR">
    <ShortDescription>方法调用低效的浮点数字构造函数；改用static valueOf  Method invokes inefficient floating-point Number constructor; use static valueOf instead</ShortDescription>
    <LongDescription>{1} 调用效率低下的{2}构造函数；改用{3}</LongDescription>
    <Details>
      <![CDATA[<p>使用<code>new Double（Double）</code>可以保证始终生成一个新对象，而使用<code_>Double。valueOf（double）</code>允许编译器、类库或JVM缓存值。使用缓存的值可以避免对象分配，并且代码会更快</p> <p>除非该类必须与Java 1.5之前的JVM兼容，否则在创建<code>Double</code>和<code>Float</code]实例时，请使用autobox或<code]valueOf（）</code>method</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_CONVERT_CASE">
    <ShortDescription>考虑使用被调用方法的Locale参数化版本  Consider using Locale parameterized version of invoked method</ShortDescription>
    <LongDescription>使用非本地化字符串。到UpperCase（）或字符串。{1}中的toLowerCase（）</LongDescription>
    <Details>
<![CDATA[<p>正在使用平台的默认编码将String转换为大写或小写。当与国际字符一起使用时，这可能会导致不正确的转换。使用</p><ul><li>String。toUpperCase（区域设置l）</li><li>String。改为较低用例（语言环境l）</li></ul><p>版本</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR">
    <ShortDescription>三元运算符的原语值未装箱并强制  Primitive value is unboxed and coerced for ternary operator</ShortDescription>
    <LongDescription>{1}中的三元运算符的原语值未装箱并强制</LongDescription>
    <Details>
<![CDATA[<p>作为条件三元运算符（<code>b？e1:e2</code>运算符）求值的一部分，包装的原语值被取消装箱并转换为另一种原语类型。Java的语义规定，如果<code>e1</code>和<code>e2</code>是包装好的数值，则这些值将被取消装箱，并转换/强制为它们的通用类型（例如，如果<code>e1</code>是<code]Integer</code>e2</code>是<code>Float</code]类型，则<code1>e1>/code>将取消装箱，转换为浮点值，并装箱。参见JLS第15.25节</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BX_BOXING_IMMEDIATELY_UNBOXED">
    <ShortDescription>原语值被装箱，然后立即取消装箱  Primitive value is boxed and then immediately unboxed</ShortDescription>
    <LongDescription>原语值被装箱，然后立即在{1}中取消装箱</LongDescription>
    <Details>
<![CDATA[<p>原语被装箱，然后立即取消装箱。这可能是因为在需要未装箱值的地方进行了手动装箱，从而迫使编译器立即撤消装箱工作</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BX_UNBOXING_IMMEDIATELY_REBOXED">
    <ShortDescription>装箱的值被取消装箱，然后立即重新装箱  Boxed value is unboxed and then immediately reboxed</ShortDescription>
    <LongDescription>装箱的值被取消装箱，然后立即在{1}中重新装箱</LongDescription>
    <Details>
<![CDATA[<p>装箱的值将取消装箱，然后立即重新装箱</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION">
    <ShortDescription>将原语值装箱，然后取消装箱，以执行原语强制  Primitive value is boxed then unboxed to perform primitive coercion</ShortDescription>
    <LongDescription>将原语值装箱，然后取消装箱，以在{1}中执行原语强制</LongDescription>
    <Details>
<![CDATA[<p>构造的原始装箱值，然后立即转换为不同的原始类型（例如，<code>new Double（d）.intValue（）</code>）。只需执行直接基元强制（例如，<code>（int）d</code>）</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_BOXED_PRIMITIVE_TOSTRING">
    <ShortDescription>方法分配一个装箱原语，只调用toString  Method allocates a boxed primitive just to call toString</ShortDescription>
    <LongDescription>原语被装箱只是为了调用{1}中的toString</LongDescription>
    <Details>
<![CDATA[<p>只为调用toString（）而分配了一个装箱原语。只使用静态形式的toString更有效，它接受原语值。因此，</p><table><tr><th>替换…</th><th>With this…</th></tr><tr><td>new Integer（1）.toString（）</td><td>Integer。toString（1）</td></tr><tr><td>新长（1）.toString（）</td><td>Long。toString（1）</td></tr><tr><td>新浮点（1.0）.toString（）。toString（1）</td></tr><tr><td>新短（1）.toString（）</td_<td>短。toString（1）</td></tr><tr><td>新布尔值（true）.toString（）</td_<td>布尔值。toString（true）</td></tr></table>]]>
    </Details>
  </BugPattern>
    <BugPattern type="DM_BOXED_PRIMITIVE_FOR_PARSING">
    <ShortDescription>装箱/取消装箱以分析原语  Boxing/unboxing to parse a primitive</ShortDescription>
    <LongDescription>装箱/取消装箱以解析原语{1}</LongDescription>
    <Details>
<![CDATA[<p>从String创建装箱原语，只是为了提取未装箱的原语值。只调用静态parseXXX方法更有效</p>]]>
    </Details>
  </BugPattern>
    <BugPattern type="DM_BOXED_PRIMITIVE_FOR_COMPARE">
    <ShortDescription>装箱要比较的原语  Boxing a primitive to compare</ShortDescription>
    <LongDescription>基元被装箱以调用{2}：改用{3}</LongDescription>
    <Details>
<![CDATA[<p>创建装箱原语只是为了调用compareTo方法。使用直接作用于原语的静态比较方法更有效（自Java1.4以来用于double和float，自Java1.7以来用于其他原语类型）</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_NEW_FOR_GETCLASS">
    <ShortDescription>方法分配一个对象，仅用于获取类对象  Method allocates an object, only to get the class object</ShortDescription>
    <LongDescription>{1} 分配一个对象，只是为了获取类对象</LongDescription>
    <Details>
<![CDATA[<p>这个方法分配一个对象，只是为了调用它的getClass（），以便检索它的Class对象。只访问类的.class属性更简单</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_MONITOR_WAIT_ON_CONDITION">
    <ShortDescription>根据条件调用监视器wait（）  Monitor wait() called on Condition</ShortDescription>
    <LongDescription>对{1}中的条件调用了监视器wait（）</LongDescription>
    <Details>
      <![CDATA[<p>此方法在<code>java.util.concurrent.locks上调用<code>wait（）</code>。条件</code>对象&nbsp；等待<code>条件</code>应该使用<code>Condition</code>interface定义的<code]await（）</code]方法之一来完成</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="RV_01_TO_INT">
    <ShortDescription>从0到1的随机值强制为整数0  Random value from 0 to 1 is coerced to the integer 0</ShortDescription>
    <LongDescription>{1} uses生成一个从0到1的随机值，然后将该值强制为整数0</LongDescription>
    <Details>
<![CDATA[<p>从0到1的随机值被强制为整数值0。您可能希望在将随机值强制为整数之前将其乘以其他值，或者使用<code>random。nextInt（n）</code>方法</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_INVALID_MIN_MAX">
    <ShortDescription>数学组合不正确。max和Math.min  Incorrect combination of Math.max and Math.min</ShortDescription>
    <LongDescription>数学组合不正确。max和数学。min：此代码始终返回{2}</LongDescription>
    <Details>
<![CDATA[<p>这段代码尝试使用类似Math的构造来限制值边界。最小值（0，数学最大值（100，value））。然而，常量的顺序不正确：它应该是Math。最小值（100，数学最大值（0，value））。因此，此代码始终生成相同的结果（如果值为NaN，则为NaN）</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_NEXTINT_VIA_NEXTDOUBLE">
    <ShortDescription>使用Random的nextInt方法而不是nextDouble生成随机整数  Use the nextInt method of Random rather than nextDouble to generate a random integer</ShortDescription>
    <LongDescription>{1} 使用Random的nextDouble方法生成一个随机整数；使用nextInt更有效</LongDescription>
    <Details>
<![CDATA[<p>如果<code>r</code>是java.util。随机</code>，您可以使用<code>r生成从<code>0</code>n-1</code>的随机数。nextInt（n）</code>，而不是使用<code>（int）（r.nextDouble（）*n）</code></p> <p>nextInt的参数必须为正数。例如，如果要生成从-99到0的随机值，请使用<code>-r.nextInt（100）</code></p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE">
    <ShortDescription>传递给SQL语句上的execute或addBatch方法的非恒定字符串  Nonconstant string passed to execute or addBatch method on an SQL statement</ShortDescription>
    <LongDescription>{1} 在SQL语句中将非恒定String传递给execute或addBatch方法</LongDescription>
    <Details>
<![CDATA[<p>该方法在SQL语句上调用execute或addBatch方法，该语句带有一个似乎是动态生成的String。考虑改用准备好的语句。它更高效，不易受到SQL注入攻击</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING">
    <ShortDescription>从非恒定字符串生成准备好的语句  A prepared statement is generated from a nonconstant String</ShortDescription>
    <LongDescription>从{1}中的非恒定字符串生成准备好的语句</LongDescription>
    <Details>
<![CDATA[<p>该代码从非恒定字符串创建SQL准备语句。如果在构建此字符串时使用了来自用户的未经检查的受污染数据，则可以使用SQL注入使准备好的语句执行一些意外和不需要的操作</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_USELESS_THREAD">
    <ShortDescription>使用默认空运行方法创建了线程  A thread was created using the default empty run method</ShortDescription>
    <LongDescription>{1} 使用默认的空运行方法创建线程</LongDescription>
    <Details>
<![CDATA[<p>此方法通过从thread类派生或传递Runnable对象来创建线程，而不指定run方法。那么，这个线程只会浪费时间</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DC_DOUBLECHECK">
    <ShortDescription>可能的现场双重检查  Possible double check of field</ShortDescription>
    <LongDescription>可能对{1}中的{2}进行双重检查</LongDescription>
    <Details>
<![CDATA[<p>此方法可能包含双重检查锁定的实例&nbsp；根据Java内存模型的语义，这个习惯用法是不正确的&nbsp；有关详细信息，请参阅网页<a href=“http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking。html“>http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html</a></p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DC_PARTIALLY_CONSTRUCTED">
    <ShortDescription>部分初始化对象可能暴露  Possible exposure of partially initialized object</ShortDescription>
    <LongDescription>{1}中部分初始化的对象可能暴露</LongDescription>
    <Details>
<![CDATA[<p>看起来这个方法使用了带有双重检查锁定的惰性字段初始化。虽然字段被正确地声明为volatile，但在字段赋值之后，对象的内部结构可能会发生变化，因此另一个线程可能会看到部分初始化的对象</p> <p>要解决此问题，请考虑先将对象存储到局部变量中，只有在完全构造后才将其保存到volatile字段中</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_FINALIZER_NULLS_FIELDS">
    <ShortDescription>终结器空字段  Finalizer nulls fields</ShortDescription>
    <LongDescription>{3} 在{1.class}中的finalize方法内设置为null</LongDescription>
    <Details>
<![CDATA[<p>此终结器将清空字段。这通常是一个错误，因为它不帮助垃圾收集，而且无论如何对象都将被垃圾收集</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_FINALIZER_ONLY_NULLS_FIELDS">
    <ShortDescription>仅限终结器为空字段  Finalizer only nulls fields</ShortDescription>
    <LongDescription>{1} 仅空字段</LongDescription>
    <Details>
<![CDATA[<p>此终结器只执行空字段操作。这完全没有意义，需要对对象进行垃圾收集、最终确定，然后再次进行垃圾收集。您应该只删除finalize方法</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_PUBLIC_SHOULD_BE_PROTECTED">
    <ShortDescription>终结者应该受到保护，而不是公开  Finalizer should be protected, not public</ShortDescription>
    <LongDescription>{1} 是公开的；应该受到保护</LongDescription>
    <Details>
<![CDATA[<p>类的<code>finalize（）</code>方法应该具有受保护的访问权限，而不是公共访问权限</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_EMPTY">
    <ShortDescription>应删除空终结器  Empty finalizer should be deleted</ShortDescription>
    <LongDescription>{1} 为空，应删除</LongDescription>
    <Details>
<![CDATA[<p>空的<code>finalize（）</code>方法是无用的，因此应该删除它们</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_NULLIFY_SUPER">
    <ShortDescription>终结器使超类终结器无效  Finalizer nullifies superclass finalizer</ShortDescription>
    <LongDescription>{1} 正在使{2}无效。finalize（）；这是有意的吗？</LongDescription>
    <Details>
<![CDATA[<p>这个空的<code>finalize（）</code>方法显式否定由其超类定义的任何终结器的效果&nbsp；不会执行为超类定义的任何终结器操作&nbsp；除非有意这样做，否则请删除此方法</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_USELESS">
    <ShortDescription>终结器只调用超类终结器  Finalizer does nothing but call superclass finalizer</ShortDescription>
    <LongDescription>{1} 除了打电话给super。finalize（）；删除它</LongDescription>
    <Details>
<![CDATA[<p>这个<code>finalize（）</code>方法所做的唯一事情是调用超类的<code>finalize&nbsp；删除它</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_MISSING_SUPER_CALL">
    <ShortDescription>终结器不调用超类终结器  Finalizer does not call superclass finalizer</ShortDescription>
    <LongDescription>{1} 缺少对超级用户的呼叫。finalize（），所以{2}。finalize（）未被调用</LongDescription>
    <Details>
<![CDATA[<p>这个方法不调用其超类的方法&nbsp；因此，不会执行为超类定义的任何终结器操作&nbsp；添加对<code>super.finalize（）</code>的调用</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_EXPLICIT_INVOCATION">
    <ShortDescription>显式调用终结器  Explicit invocation of finalizer</ShortDescription>
    <LongDescription>在{1}中显式调用{2}</LongDescription>
    <Details>
<![CDATA[<p>此方法包含对对象的<code>finalize（）</code>方法的显式调用&nbsp；因为终结器方法应该执行一次，并且只由VM执行，所以这是一个坏主意</p> <p>如果一组连接的对象是可终结的，那么VM将在所有可终结对象上调用finalize方法，可能同时在不同的线程中调用finalization方法。因此，在类X的finalize方法中，对X引用的对象调用finalize是一个特别糟糕的主意，因为它们可能已经在单独的线程中完成了</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS">
    <ShortDescription>等于检查不兼容的操作数  Equals checks for incompatible operand</ShortDescription>
    <LongDescription>{1} 检查操作数是否为{2.givenClass}</LongDescription>
    <Details>
<![CDATA[<p>这个equals方法正在检查参数是否是某个不兼容的类型（即，既不是定义equals法的类的父类型，也不是子类型的类）。例如，Foo类可能有一个equals方法，类似于：</p><pre><code>public boolean equals（Object o）{if（o instanceof Foo）return name.equals（（（Foo）o）.name）；else if</code></pre><p>这被认为是一种糟糕的做法，因为它使实现对称和可传递的equals方法变得非常困难。如果没有这些属性，可能会出现非常意外的行为</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_DONT_DEFINE_EQUALS_FOR_ENUM">
    <ShortDescription>为枚举定义的协变equals（）方法  Covariant equals() method defined for enum</ShortDescription>
    <LongDescription>枚举{0}定义等于（{0.givenClass}）</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个枚举，并且使用对象标识定义了枚举的相等性。为枚举值定义协变等于方法是非常糟糕的做法，因为这可能会导致两个不同的枚举值使用协变枚举方法进行相等比较，而在正常比较时则不相等。不要这样做</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_SELF_USE_OBJECT">
    <ShortDescription>Covariant equals（）方法已定义，Object。等于（对象）继承  Covariant equals() method defined, Object.equals(Object) inherited</ShortDescription>
    <LongDescription>{0}定义equals（{0.givenClass}）方法并使用Object.equals（Object）</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个协变版本的<code>equals（）</code>方法，但继承了在基<code>java.lang.Object</code>class中定义的普通<code]equals&nbsp；该类可能应该定义一个<code>boolean equals（Object）</code>方法</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_OTHER_USE_OBJECT">
    <ShortDescription>定义了不重写Object.equals（Object）的equals（）方法  equals() method defined that doesn't override Object.equals(Object)</ShortDescription>
    <LongDescription>{0}定义{1.givenClass}方法并使用Object.equals（Object）</LongDescription>
    <Details>
<![CDATA[<p>这个类定义了一个<code>equals（）</code>方法，它不会覆盖在java.lang.Object</code>baseclass中定义的普通<code>equals&nbsp；该类可能应该定义一个<code>boolean equals（Object）</code>方法</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_OTHER_NO_OBJECT">
    <ShortDescription>定义了不重写equals（Object）的equals  equals() method defined that doesn't override equals(Object)</ShortDescription>
    <LongDescription>{0}定义不重写equals（Object）的{1.givenClass}方法</LongDescription>
    <Details>
<![CDATA[<p>这个类定义了一个<code>equals（）</code>方法，它不会覆盖在java.lang.Object</code>baseclass中定义的普通<code>equals&nbsp；相反，它从超类继承<code>equals（Object）</code>方法。该类可能应该定义一个<code>boolean equals（Object）</code>方法</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_DOESNT_OVERRIDE_EQUALS">
    <ShortDescription>类不重写超类中的等于  Class doesn't override equals in superclass</ShortDescription>
    <LongDescription>{0}不重写{2.givenClass}</LongDescription>
    <Details>
<![CDATA[<p>此类扩展了一个定义equals方法并添加字段的类，但不定义equales方法本身。因此，此类实例上的相等将忽略子类和添加字段的标识。确保这是预期的，并且不需要重写equals方法。即使您不需要重写equals方法，也可以考虑重写它，以记录子类的equals法只返回调用super.equals（o）的结果这一事实</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_SELF_NO_OBJECT">
    <ShortDescription>协变equals（）方法已定义  Covariant equals() method defined</ShortDescription>
    <LongDescription>{0}定义equals（{0.givenClass}）方法，但不定义equal（Object）</LongDescription>
    <Details>
<![CDATA[<p>此类定义了<code>equals（）</code>的协变版本&nbsp；要正确覆盖<code>java.lang.Object</code>中的<code>等于（）</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_OVERRIDING_EQUALS_NOT_SYMMETRIC">
    <ShortDescription>equals方法重写超类中的equals，并且可能不是对称的  equals method overrides equals in superclass and may not be symmetric</ShortDescription>
    <LongDescription>{1.class}重写{2.class.givenClass}中的equals，并且可能不是对称的</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个equals方法，该方法覆盖超类中的equals法。两种equals方法都使用<code>实例</code>来确定两个对象是否相等。这充满了风险，因为equals方法必须对称（换句话说，<code>a.equals（b）==b.equals（a）</code>）。如果B是a的子类型，并且a的equals方法检查参数是否是a的实例，而B的equales方法检查参数是B的实例，那么这些方法定义的等价关系很可能不是对称的</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_GETCLASS_AND_CLASS_CONSTANT">
    <ShortDescription>对于子类型，equals方法失败  equals method fails for subtypes</ShortDescription>
    <LongDescription>{1} 子类型失败</LongDescription>
    <Details>
<![CDATA[<p>这个类有一个equals方法，如果它被子类继承，它将被破坏。它将类文字与参数的类进行比较（例如，在类<code>Foo中，它可能会检查<code>Foo.class==o.getClass（）</code>）。最好检查<code>this。getClass（）==o.获取类（）</code></p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_UNUSUAL">
    <ShortDescription>异常等式法  Unusual equals method</ShortDescription>
    <LongDescription>{1} 是不寻常的</LongDescription>
    <Details>
<![CDATA[<p>此类不执行我们识别的任何模式，以检查参数类型是否与<code>此</code>对象的类型兼容。这段代码可能没有任何错误，但值得检查</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_COMPARING_CLASS_NAMES">
    <ShortDescription>equals方法比较类名而不是类对象  equals method compares class names rather than class objects</ShortDescription>
    <LongDescription>{1} 比较类名而不是类对象</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个equals方法，该方法通过检查两个对象的类名称是否相等来检查这两个对象是否是同一个类。如果由不同的类装入器装入，则可以有同名的不同类。只需检查类对象是否相同</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_ALWAYS_TRUE">
    <ShortDescription>equals方法始终返回true  equals method always returns true</ShortDescription>
    <LongDescription>{1} 始终返回true</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个始终返回true的equals方法。这很有想象力，但不太聪明。另外，这意味着equals方法不是对称的</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_ALWAYS_FALSE">
    <ShortDescription>equals方法总是返回false  equals method always returns false</ShortDescription>
    <LongDescription>{1} 总是返回false</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个始终返回false的equals方法。这意味着一个对象不等于它自己，并且不可能创建此类的有用“贴图”或“集”。更重要的是，这意味着equals不是自反的，这是equals方法的要求之一</p> <p>可能的预期语义是对象标识：对象等于其自身。这是从类<code>Object</code>继承的行为。如果需要覆盖从不同超类继承的equals，可以使用：</p><pre><code>public boolean equals（Object o）{return this==o；}</代码></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="HSC_HUGE_SHARED_STRING_CONSTANT">
    <ShortDescription>巨大的字符串常量在多个类文件中重复  Huge string constants is duplicated across multiple class files</ShortDescription>
    <LongDescription>{1} 初始化为长度为{2}个字符的字符串常量，该字符串常量在{3}其他类文件中重复</LongDescription>
    <Details>
      <![CDATA[<p>大型String常量在多个类文件中重复。这可能是因为final字段被初始化为String常量，而Java语言要求其他类对final字段的所有引用都内联到该类文件中。请参见<a href=“http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6447475“>JDK bug 6447475</a>，了解JDK中出现此bug的描述，以及解决它如何将JDK的大小减少1 MB</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_ARGUMENT_MIGHT_BE_NULL">
    <ShortDescription>方法不检查null参数  Method does not check for null argument</ShortDescription>
    <LongDescription>{1} 不检查null参数</LongDescription>
    <Details>
      <![CDATA[<p>此方法的一个参数已被标识为一个值，应始终检查该值是否为空，但在取消引用时没有进行前面的空检查</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT">
    <ShortDescription>equals（）方法不检查null参数  equals() method does not check for null argument</ShortDescription>
    <LongDescription>{1} 不检查null参数</LongDescription>
    <Details>
      <![CDATA[<p>equals（Object）的实现违反了java.lang.Object定义的约定。equals（），因为它不检查作为参数传递的null。如果传递了空值，则所有equals（）方法都应返回false</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="RV_NEGATING_RESULT_OF_COMPARETO">
    <ShortDescription>否定compareTo（）/compare（）的结果  Negating the result of compareTo()/compare()</ShortDescription>
    <LongDescription>{1} 对{2}的返回值求反</LongDescription>
    <Details>
<![CDATA[<p>此代码否定compareTo或compare方法的返回值。这是一个有问题或错误的编程实践，因为如果返回值是Integer。MIN_VALUE，否定返回值不会否定结果的符号。通过颠倒操作数的顺序而不是否定结果，可以获得相同的预期结果</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CO_COMPARETO_RESULTS_MIN_VALUE">
    <ShortDescription>compareTo（）/compare（）返回Integer.MIN_VALUE  compareTo()/compare() returns Integer.MIN_VALUE</ShortDescription>
    <LongDescription>{1} 返回整数。MIN_VALUE，不能取反</LongDescription>
    <Details>
<![CDATA[<p>在某些情况下，此compareTo或compare方法返回常量Integer。MIN_VALUE，这是一种非常糟糕的做法。关于compareTo的返回值，唯一重要的是结果的符号。但人们有时会否定compareTo的返回值，期望这会否定结果的符号。它会，除非返回的值是Integer.MIN_value。所以只返回-1而不是Integer.MIN_VALUE。]]>
    </Details>
  </BugPattern>
  <BugPattern type="CO_COMPARETO_INCORRECT_FLOATING">
    <ShortDescription>compareTo（）/compare（）错误地处理浮点或双精度值  compareTo()/compare() incorrectly handles float or double value</ShortDescription>
    <LongDescription>{1} 错误地处理{2}值</LongDescription>
    <Details>
<![CDATA[<p>此方法使用如下模式比较双精度值或浮点值：val1&gt；值2？1:val1&lt；值2-1:0。此模式对于-0.0和NaN值不正确，这可能导致错误的排序结果或损坏的集合（如果比较的值用作键）。考虑使用Double。比较或浮动。比较正确处理所有特殊情况的静态方法</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CO_SELF_NO_OBJECT">
    <ShortDescription>定义了协变compareTo（）方法  Covariant compareTo() method defined</ShortDescription>
    <LongDescription>{0}定义compareTo（{0.givenClass}）方法，但不定义compareTo（Object）</LongDescription>
    <Details>
<![CDATA[<p>此类定义了<code>compareTo（）</code>的协变版本&nbsp；要正确覆盖<code>Comparable</code>接口中的<code>compareTo</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_SIGNATURE_DECLARES_HASHING_OF_UNHASHABLE_CLASS">
    <ShortDescription>签名声明在哈希构造中使用不可破坏的类  Signature declares use of unhashable class in hashed construct</ShortDescription>
    <LongDescription>{2} 未定义hashCode（）方法，但在{1}的散列上下文中使用</LongDescription>
    <Details>
<![CDATA[<p>方法、字段或类声明通用签名，其中在需要哈希类的上下文中使用非哈希类。声明equals方法但从Object继承hashCode（）方法的类是不可损坏的，因为它不满足equal对象具有相等hashCodes的要求</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_USE_OF_UNHASHABLE_CLASS">
    <ShortDescription>在哈希数据结构中使用不带hashCode（）方法的类  Use of class without a hashCode() method in a hashed data structure</ShortDescription>
    <LongDescription>{2} 未定义hashCode（）方法，但在{1}的哈希数据结构中使用</LongDescription>
    <Details>
<![CDATA[<p>类定义了一个equals（Object）方法，但没有定义hashCode（）方法，因此不能满足相等对象具有相等hashCodes的要求。此类的实例用于哈希数据结构中，因此修复此问题的需要最为重要。]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_HASHCODE_USE_OBJECT_EQUALS">
    <ShortDescription>类定义hashCode（）并使用Object.equals（）  Class defines hashCode() and uses Object.equals()</ShortDescription>
    <LongDescription>{0}定义hashCode并使用Object.equals（）</LongDescription>
    <Details>
<![CDATA[<p>这个类定义了一个<code>hashCode（）</code>方法，但从<code>java.lang.Object</code>（通过比较对象引用来定义相等性）继承了它的<code]equals（）</code>方法&nbsp；虽然这可能会满足相等对象必须具有相等哈希码的约定，但覆盖<code>hashCode（）</code>方法可能并不是有意的&nbsp；（覆盖<code>hashCode（）</code>意味着对象的标识基于比简单引用相等更复杂的条件。）</p> <p>如果您认为该类的实例永远不会插入到HashMap/HashTable中，建议使用的<code>hashCode</code>实现是：</p><pre><code>public int hashCode（）{assert false:“hashCode-not designed”；return 42；//任何任意常量都可以}</code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_COMPARETO_USE_OBJECT_EQUALS">
    <ShortDescription>类定义compareTo（…）并使用Object.equals（）  Class defines compareTo(...) and uses Object.equals()</ShortDescription>
    <LongDescription>{0}定义{1.givenClass}并使用Object.equals（）</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个<code>compareTo（…）</code>方法，但从<code>java.lang.Object</code>中继承了它的<code]equals（）</code>方法。通常，当且仅当equals返回true时，compareTo的值应返回零。如果违反了这一点，就会在PriorityQueue之类的类中发生奇怪且不可预测的故障。在Java 5中，PriorityQueue。remove方法使用compareTo方法，而在Java6中，它使用equals方法</p> <p>从Comparable接口中compareTo方法的JavaDoc中：强烈建议，但并不严格要求<code>（x.compareTo（y）==0）==（x.equals（y））</code>。一般来说，任何实现Comparable接口并违反此条件的类都应该清楚地表明这一事实。推荐的语言是“注意：这个类的自然顺序与equals不一致。”</blockquote></p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_HASHCODE_NO_EQUALS">
    <ShortDescription>类定义了hashCode（）而不是equals（）  Class defines hashCode() but not equals()</ShortDescription>
    <LongDescription>{0}定义了hashCode，但不等于</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个<code>hashCode（）</code>方法，但不定义<code>等于（）</code>方法&nbsp；因此，类可能会违反相等对象必须具有相等哈希码的不变量</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_EQUALS_USE_HASHCODE">
    <ShortDescription>类定义equals（）并使用Object.hashCode（）  Class defines equals() and uses Object.hashCode()</ShortDescription>
    <LongDescription>{0}定义equals并使用Object.hashCode（）</LongDescription>
    <Details>
<![CDATA[<p>此类重写<code>equals（Object）</code>，但不重写<code_>hashCode（）</code>，并从<code>java.lang.Object</code>继承<code]hashCode（）</code>的实现（它返回标识哈希码，这是VM分配给对象的任意值）&nbsp；因此，该类很可能违反相等对象必须具有相等哈希码的不变量</p> <p>如果您认为该类的实例永远不会插入到HashMap/HashTable中，建议使用的<code>hashCode</code>实现是：</p><pre><code>public int hashCode（）{assert false:“hashCode-not designed”；return 42；//任何任意常量都可以}</code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_INHERITS_EQUALS_USE_HASHCODE">
    <ShortDescription>类继承equals（）并使用Object.hashCode（）  Class inherits equals() and uses Object.hashCode()</ShortDescription>
    <LongDescription>{0}继承equals并使用Object.hashCode（）</LongDescription>
    <Details>
<![CDATA[<p>这个类从抽象超类继承<code>equals（Object）</code>，从<code>java.lang.Object</code>hashCode（）</code>（它返回标识哈希码，这是VM分配给对象的任意值）&nbsp；因此，该类很可能违反相等对象必须具有相等哈希码的不变量</p> <p>如果您不想定义hashCode方法，并且/或者不相信该对象会被放入HashMap/Hashtable中，请定义要抛出<code>UnsupportedOperationException</code>的<code>hashCode（）</code>method</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_EQUALS_NO_HASHCODE">
    <ShortDescription>类定义了equals（）而不是hashCode（）  Class defines equals() but not hashCode()</ShortDescription>
    <LongDescription>{0}定义equals，但不定义hashCode</LongDescription>
    <Details>
<![CDATA[<p>此类重写<code>equals（Object）</code>，但不重写<code_>hashCode（）</code>&nbsp；因此，类可能会违反相等对象必须具有相等哈希码的不变量</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_ABSTRACT_SELF">
    <ShortDescription>抽象类定义协变equals（）方法  Abstract class defines covariant equals() method</ShortDescription>
    <LongDescription>抽象{0}定义了equals（{0.givenClass}）方法</LongDescription>
    <Details>
<![CDATA[<p>此类定义了<code>equals（）</code>的协变版本&nbsp；要正确覆盖<code>java.lang.Object</code>中的<code>等于（）</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ES_COMPARING_STRINGS_WITH_EQ">
    <ShortDescription>使用==或！比较String对象=  Comparison of String objects using == or !=</ShortDescription>
    <LongDescription>使用==或！=比较String对象在{1}中</LongDescription>
    <Details>
<![CDATA[<p>此代码使用==或！=比较<code>java.lang.String</code>对象的引用相等性操作员。除非这两个字符串都是源文件中的常量，或者已经使用<code>String进行了实例化。intern（）</code>方法，相同的字符串值可以由两个不同的string对象表示。考虑改用<code>equals（Object）</code>方法</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ES_COMPARING_PARAMETER_STRING_WITH_EQ">
    <ShortDescription>使用==或！比较字符串参数=  Comparison of String parameter using == or !=</ShortDescription>
    <LongDescription>使用==或！=比较字符串参数在{1}中</LongDescription>
    <Details>
<![CDATA[<p>此代码使用==或！=比较<code>java.lang.String</code>参数的引用相等性操作员。要求调用者只向方法传递String常量或实例化字符串是不必要的，并且很少会带来可测量的性能提升。考虑改用<code>equals（Object）</code>方法</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CO_ABSTRACT_SELF">
    <ShortDescription>抽象类定义协变compareTo（）方法  Abstract class defines covariant compareTo() method</ShortDescription>
    <LongDescription>抽象{0}定义compareTo（{0.givenClass}）方法</LongDescription>
    <Details>
<![CDATA[<p>此类定义了<code>compareTo（）</code>的协变版本&nbsp；要正确覆盖<code>Comparable</code>接口中的<code>compareTo</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IS_FIELD_NOT_GUARDED">
    <ShortDescription>字段未防止并发访问  Field not guarded against concurrent access</ShortDescription>
    <LongDescription>{1.givenClass}未防止并发访问；锁定{2}%的时间</LongDescription>
    <Details>
<![CDATA[<p>此字段用net.jcip.annotations注释。GuardedBy或javax.annotation.concurrent。GuardedBy，但可以以似乎违反这些注释的方式访问</p>]]>
</Details>
  </BugPattern>
  <BugPattern type="MSF_MUTABLE_SERVLET_FIELD">
    <ShortDescription>可变servlet字段  Mutable servlet field</ShortDescription>
    <LongDescription>{1} 是一个可变的servlet字段</LongDescription>
    <Details>
<![CDATA[<p>web服务器通常只创建servlet或JSP类的一个实例（即，将该类视为Singleton），并将有多个线程在该实例上调用方法来服务多个同时请求。因此，具有可变实例字段通常会产生竞争条件。]]>
    </Details>
  </BugPattern>
  <BugPattern type="IS2_INCONSISTENT_SYNC">
    <ShortDescription>同步不一致  Inconsistent synchronization</ShortDescription>
    <LongDescription>{1}的同步不一致；锁定{2}%的时间</LongDescription>
    <Details>
<![CDATA[<p>就同步而言，此类字段的访问似乎不一致&nbsp；此错误报告表明，错误模式检测器判断</p><ul><li>该类包含锁定和解锁访问的混合，</li><li>该类注释为javax.annotation.concurrent。NotThreadSafe，</li><li>至少有一个锁定的访问是由类自己的方法之一执行的，并且</li><li>非同步字段访问（读写）的数量不超过所有访问的三分之一，写操作的权重是读操作的两倍</li></ul><p>与此错误模式匹配的典型错误是忘记同步线程安全类中的一个方法</p> <p>您可以选择标记为“Unsynchronized access”（未同步访问）的节点，以显示检测器认为未同步访问字段的代码位置</p> <p>注意，该检测器存在各种不准确的来源；例如，检测器无法静态检测持有锁的所有情况&nbsp；此外，即使检测器能够准确区分锁定和未锁定的访问，所讨论的代码也可能是正确的</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NN_NAKED_NOTIFY">
    <ShortDescription>裸体通知  Naked notify</ShortDescription>
    <LongDescription>{1}中的裸体通知</LongDescription>
    <Details>
<![CDATA[<p>调用<code>notify（）</code>或<code>notifyAll（）</code>时，没有对可变对象状态进行任何（明显的）附带修改&nbsp；通常，在监视器上调用notify方法是因为另一个线程正在等待的某些条件变为真&nbsp；然而，为了使条件有意义，它必须涉及一个对两个线程都可见的堆对象</p> <p>此bug不一定表示错误，因为可变对象状态的更改可能发生在调用包含通知的方法的方法中</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_EXPOSE_REP">
    <ShortDescription>公共静态方法可能通过返回数组公开内部表示  Public static method may expose internal representation by returning array</ShortDescription>
    <LongDescription>公共静态{1}可以通过返回{2.givenClass}来公开内部表示</LongDescription>
    <Details>
<![CDATA[<p>公共静态方法返回对作为类静态状态一部分的数组的引用。任何调用此方法的代码都可以自由修改底层数组。一个修复方法是返回阵列的副本</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_REP">
    <ShortDescription>可能通过返回对可变对象的引用来公开内部表示  May expose internal representation by returning reference to mutable object</ShortDescription>
    <LongDescription>{1} 可能通过返回{2.givenClass}公开内部表示</LongDescription>
    <Details>
<![CDATA[<p>返回对存储在对象的某个字段中的可变对象值的引用将公开对象的内部表示&nbsp；如果实例是由不受信任的代码访问的，并且对可变对象的未经检查的更改会危及安全性或其他重要属性，那么您需要做一些不同的事情。在许多情况下，返回对象的新副本是更好的方法</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_REP2">
    <ShortDescription>可以通过合并对可变对象的引用来公开内部表示  May expose internal representation by incorporating reference to mutable object</ShortDescription>
    <LongDescription>{1} 可以通过将外部可变对象存储到{2.givenClass}中来公开内部表示</LongDescription>
    <Details>
<![CDATA[<p>这段代码将对外部可变对象的引用存储到对象的内部表示中&nbsp；如果实例是由不受信任的代码访问的，并且对可变对象的未经检查的更改会危及安全性或其他重要属性，那么您需要做一些不同的事情。在许多情况下，存储对象的副本是更好的方法</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_STATIC_REP2">
    <ShortDescription>可以通过将可变对象存储到静态字段中来公开内部静态状态  May expose internal static state by storing a mutable object into a static field</ShortDescription>
    <LongDescription>{1} 可以通过将可变对象存储到静态字段{2}中来公开内部静态状态</LongDescription>
    <Details>
<![CDATA[<p>此代码将对外部可变对象的引用存储到静态字段中。如果对可变对象的未经检查的更改会危及安全性或其他重要属性，则需要采取不同的措施。在许多情况下，存储对象的副本是更好的方法</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_EXPOSE_BUF">
    <ShortDescription>可能通过返回共享非公共数据的缓冲区来公开内部表示  May expose internal representation by returning a buffer sharing non-public data</ShortDescription>
    <LongDescription>{1} 可能通过返回{2.givenClass}公开内部表示</LongDescription>
    <Details>
<![CDATA[<p>公共静态方法要么返回一个缓冲区（java.nio.*buffer），该缓冲区通过仅保留对同一数组的引用来包装属于类静态状态的数组，要么返回缓冲区的浅表副本，该副本是与原始缓冲区共享其引用的类静态stat的一部分。任何调用此方法的代码都可以自由修改底层数组。一种修复方法是返回只读缓冲区或带有数组副本的新缓冲区</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_BUF">
    <ShortDescription>可能通过返回共享非公共数据的缓冲区来公开内部表示  May expose internal representation by returning a buffer sharing non-public data</ShortDescription>
    <LongDescription>{1} 可能通过返回{2.givenClass}公开内部表示</LongDescription>
    <Details>
<![CDATA[<p>返回对缓冲区（java.nio.*buffer）的引用，该缓冲区包装存储在对象的某个字段中的数组，从而公开数组元素的内部表示，因为缓冲区只存储对数组的引用，而不复制其内容。类似地，返回存储在对象某个字段中的此类缓冲区的浅表副本（使用其duplicate（）方法）也会公开缓冲区的内部表示&nbsp；如果实例是由不受信任的代码访问的，并且对数组的未检查更改会危及安全性或其他重要属性，则需要采取不同的措施。在许多情况下，返回只读缓冲区（使用其asReadOnly（）方法）或将数组复制到新缓冲区（用其put（）方法</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_BUF2">
    <ShortDescription>可以通过创建包含对数组引用的缓冲区来公开内部表示  May expose internal representation by creating a buffer which incorporates reference to array</ShortDescription>
    <LongDescription>{1} 可以通过在{2.givenClass}中创建包含外部数组的缓冲区来公开内部表示</LongDescription>
    <Details>
<![CDATA[<p>这段代码创建了一个缓冲区，它将对外部数组或外部缓冲区数组的引用存储到对象的内部表示中&nbsp；如果实例是由不受信任的代码访问的，并且对数组的未检查更改会危及安全性或其他重要属性，则需要采取不同的措施。在许多情况下，存储阵列的副本是一种更好的方法</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_STATIC_BUF2">
    <ShortDescription>可以通过创建缓冲区将外部数组存储到静态字段中来公开内部静态状态  May expose internal static state by creating a buffer which stores an external array into a static field</ShortDescription>
    <LongDescription>{1} 可以通过创建将外部数组存储到静态字段{2}中的缓冲区来公开内部静态状态</LongDescription>
    <Details>
<![CDATA[<p>这段代码创建了一个缓冲区，将对外部数组或外部缓冲区数组的引用存储到一个静态字段中。如果对阵列的未检查更改会危及安全性或其他重要属性，则需要采取不同的措施。在许多情况下，存储阵列的副本是一种更好的方法</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RU_INVOKE_RUN">
    <ShortDescription>调用在线程上运行（您是想启动它吗？）  Invokes run on a thread (did you mean to start it instead?)</ShortDescription>
    <LongDescription>{1} 显式调用在线程上运行（您是不是打算启动它？）</LongDescription>
    <Details>
<![CDATA[<p>此方法在对象上显式调用<code>run（）</code>&nbsp；通常，类实现<code>Runnable</code>接口，因为它们将在新线程中调用它们的<code>run（）</code>thread方法，在这种情况下，<code]thread。start（）</code>是要调用的正确方法</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SP_SPIN_ON_FIELD">
    <ShortDescription>方法在字段上旋转  Method spins on field</ShortDescription>
    <LongDescription>在{1}中的{2.givenClass}上旋转</LongDescription>
    <Details>
<![CDATA[<p>此方法在读取字段的循环中旋转&nbsp；编译器可以合法地将读取的内容从循环中取出，将代码转换为无限循环&nbsp；应该更改该类，以便它使用正确的同步（包括等待和通知调用）</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NS_DANGEROUS_NON_SHORT_CIRCUIT">
    <ShortDescription>非短路逻辑的潜在危险使用  Potentially dangerous use of non-short-circuit logic</ShortDescription>
    <LongDescription>{1}中使用非短路逻辑的潜在危险</LongDescription>
    <Details>
<![CDATA[<p>此代码似乎使用了非短路逻辑（例如，&amp；或|），而不是短路逻辑（&amp！&amp？或||）。此外，根据左侧的值，你可能不想评估右手边（因为它会有副作用，可能会导致异常或代价高昂。</p><p>非短路逻辑会导致表达式的两边都要求值，即使可以通过了解左手边推断出结果。如果计算右手边时左手边的保护壳可能会产生错误，则效率可能会降低，并可能导致错误。</p><p>请参阅<a href=“https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.22.2“>Java语言规范</a>了解详细信息</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NS_NON_SHORT_CIRCUIT">
    <ShortDescription>非短路逻辑使用不当  Questionable use of non-short-circuit logic</ShortDescription>
    <LongDescription>{1}中非短路逻辑的可疑使用</LongDescription>
    <Details>
<![CDATA[<p>此代码似乎使用了非短路逻辑（例如，&amp；或|），而不是短路逻辑（&amp！&amp？或||）。非短路逻辑会导致对表达式的两边进行求值，即使可以从左侧推断出结果。如果评估右侧时左侧防护罩案例可能会产生错误，则这可能效率较低，并可能导致错误<p> 请参见<a href=“https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.22.2“>Java语言规范</a>了解详细信息</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="TLW_TWO_LOCK_WAIT">
    <ShortDescription>按住两个锁等待  Wait with two locks held</ShortDescription>
    <LongDescription>带有{1}中的两个锁的wait（）</LongDescription>
    <Details>
<![CDATA[<p>在保持两个锁的同时等待监视器可能会导致死锁&nbsp；执行等待只会释放被等待对象的锁，而不会释放任何其他锁&nbsp；这不一定是一个bug，但值得仔细检查</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="TLW_TWO_LOCK_NOTIFY" deprecated="true"> <!-- never generated -->
    <ShortDescription>持有两个锁时通知  Notify with two locks held</ShortDescription>
    <LongDescription>notify（）或notifyAll*（），在{1}中持有两个锁</LongDescription>
    <Details>
<![CDATA[<p>代码在持有两个锁的情况下调用notify（）或notifyAll（）。如果此通知旨在唤醒持有相同锁的wait（），它可能会死锁，因为wait只会放弃一个锁，而notify将无法获得两个锁，因此notify不会成功&nbsp；如果还存在关于两个锁等待的警告，则错误的可能性很高</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UW_UNCOND_WAIT">
    <ShortDescription>无条件等待  Unconditional wait</ShortDescription>
    <LongDescription>{1}中的无条件等待</LongDescription>
    <Details>
<![CDATA[<p>此方法包含对<code>java.lang.Object的调用。wait（）</code>，它不受条件控制流的保护&nbsp；在调用wait之前，代码应该验证它打算等待的条件是否已经满足；以前的任何通知都将被忽略</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UR_UNINIT_READ">
    <ShortDescription>构造函数中字段的未初始化读取  Uninitialized read of field in constructor</ShortDescription>
    <LongDescription>{1}中{2.name}的未初始化读取</LongDescription>
    <Details>
<![CDATA[<p>此构造函数读取尚未赋值的字段&nbsp；这通常是由于程序员错误地使用了字段而不是构造函数的一个参数引起的</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UR_UNINIT_READ_CALLED_FROM_SUPER_CONSTRUCTOR">
    <ShortDescription>从超类的构造函数调用的字段方法的未初始化读取  Uninitialized read of field method called from constructor of superclass</ShortDescription>
    <LongDescription>从超类的构造函数调用时，{2.name}未在{1}中初始化</LongDescription>
    <Details>
<![CDATA[<p>此方法在超类的构造函数中调用。此时，类的字段尚未初始化</p> <p>要使其更具体，请考虑以下类：</p><pre><code>抽象类A{int hashCode；abstract Object getValue（）；A（）{hashCode=getValue）.hashCode（）；}}类B扩展了A{对象值；B（对象v）{this.value=v；}对象getValue（）{return value；}}</code></pre><p>当构造<code>B</code>时，<code>a</code>>类的构造函数在<code]B</code>的构造函数设置<code＞值之前被调用。因此，当<code>A</code>的构造函数调用<code>getValue</code>时，将为<code>value</code>读取未初始化的值</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UG_SYNC_SET_UNSYNC_GET">
    <ShortDescription>非同步获取方法、同步设置方法  Unsynchronized get method, synchronized set method</ShortDescription>
    <LongDescription>{1} 未同步，{2}已同步</LongDescription>
    <Details>
<![CDATA[<p>此类包含名称类似的get和set方法，其中set方法是同步的，而get方法是不同步的&nbsp；这可能导致运行时的错误行为，因为get方法的调用方不一定会看到对象的一致状态&nbsp；get方法应同步</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IC_INIT_CIRCULARITY">
    <ShortDescription>初始化循环  Initialization circularity</ShortDescription>
    <LongDescription>{0}和{1}之间的初始化循环</LongDescription>
    <Details>
<![CDATA[<p>在bug实例引用的两个类的静态初始值设定项中检测到循环&nbsp；这种循环可能会导致多种意外行为</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION">
    <ShortDescription>超类在初始化期间使用子类  Superclass uses subclass during initialization</ShortDescription>
    <LongDescription>{0}的初始化访问尚未初始化的类{2}</LongDescription>
    <Details>
<![CDATA[<p>在类的初始化过程中，该类主动使用子类。该子类在使用时尚未初始化。例如，在下面的代码中，<code>foo</code>将为空</p> 公共类CircularClassInitialization{static class InnerClassSingleton extends Circular类初始化{static InnerClassSingleton singleton=new InnerClass singleton（）；}static CircularClassInitialization foo=InnerClassSingleton。单例；}</代码></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IT_NO_SUCH_ELEMENT">
    <ShortDescription>迭代器next（）方法无法引发NoSuchElementException  Iterator next() method can't throw NoSuchElementException</ShortDescription>
    <LongDescription>{1} 无法引发NoSuchElementException</LongDescription>
    <Details>
<![CDATA[<p>此类实现<code>java.util。迭代器</code>接口&nbsp；但是，它的<code>next（）</code>方法不能抛出<code>java.util.NoSuchElementException</code>&nbsp；应该更改<code>next（）</code>方法，以便在没有更多要返回的元素时调用它会抛出<code>NoSuchElementException</code>if</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DL_SYNCHRONIZATION_ON_SHARED_CONSTANT">
    <ShortDescription>实习生字符串上的同步  Synchronization on interned String</ShortDescription>
    <LongDescription>{1}中实习生字符串的同步</LongDescription>
    <Details>
<![CDATA[<p>代码在内部字符串上同步</p> <pre><code>private static String LOCK=“LOCK”。。。synchronized（LOCK）{…}…</code></pre><p>常量字符串被截留，并在JVM加载的所有其他类之间共享。因此，此代码锁定了其他代码也可能锁定的内容。这可能导致非常奇怪且难以诊断的阻塞和死锁行为。请参见<a href=“http://www.javalobby.org/java/forums/t96352.html">http://www.javalobby.org/java/forums/t96352.html</a>和<a href=“http://jira.codehaus.org/browse/JETTY-352">http://jira.codehaus.org/browse/JETTY-352</a></p> <p>参见CERThttps://www.securecoding.cert.org/confluence/display/java/CON08-J.+不要+不+同步+在+对象上+可以+重复使用的+“>CON08-J。不要同步可能重复使用的对象</a>了解更多信息</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DL_SYNCHRONIZATION_ON_BOOLEAN">
    <ShortDescription>布尔值上的同步  Synchronization on Boolean</ShortDescription>
    <LongDescription>{1}中布尔值的同步</LongDescription>
    <Details>
      <![CDATA[<p>代码在装箱的基元常量（如布尔值）上同步</p> <pre><code>private static Boolean inited=Boolean。错误的同步（初始化）{if（！inited）{init（）；inited=Boolean.TRUE；}}</code></pre><p>由于通常只有两个布尔对象，因此此代码可能与其他无关代码在同一对象上同步，从而导致无响应和可能的死锁</p> <p>参见CERThttps://www.securecoding.cert.org/confluence/display/java/CON08-J.+不要+不+同步+在+对象上+可以+重复使用的+“>CON08-J。不要同步可能重复使用的对象</a>了解更多信息</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DL_SYNCHRONIZATION_ON_UNSHARED_BOXED_PRIMITIVE">
    <ShortDescription>装箱原语值的同步  Synchronization on boxed primitive values</ShortDescription>
    <LongDescription>在{1}中的{2}上同步</LongDescription>
    <Details>
      <![CDATA[<p>代码在明显非共享的盒装原语上同步，例如Integer</p> <pre><code>私有静态最终整数文件锁定=新整数（1）。。。synchronized（fileLock）{..做一些事情..}…</code></pre><p>在这段代码中，最好将fileLock重新声明为</p><pre><code>private static final Object fileLock=new Object（）</code></pre><p>现有的代码可能还可以，但它很混乱，未来的重构，例如IntelliJ中的“Remove Boxing”重构，可能会使用在整个JVM中共享的内部Integer对象来代替它，从而导致非常混乱的行为和潜在的死锁</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DL_SYNCHRONIZATION_ON_BOXED_PRIMITIVE">
    <ShortDescription>装箱原语的同步  Synchronization on boxed primitive</ShortDescription>
    <LongDescription>在{1}中的{2}上同步</LongDescription>
    <Details>
      <![CDATA[<p>代码在装箱的基本常量上同步，例如Integer</p> <pre><code>私有静态整数计数=0。。。已同步（计数）{count++；}</code></pre><p>由于Integer对象可以缓存和共享，因此此代码可能与其他无关代码在同一对象上同步，从而导致无响应和可能的死锁</p> <p>参见CERThttps://www.securecoding.cert.org/confluence/display/java/CON08-J.+不要+不+同步+在+对象上+可以+重复使用的+“>CON08-J。不要同步可能重复使用的对象</a>了解更多信息</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ESync_EMPTY_SYNC">
    <ShortDescription>空同步块  Empty synchronized block</ShortDescription>
    <LongDescription>{1}中的同步块为空</LongDescription>
    <Details>
<![CDATA[<p>代码中包含一个空的同步块：</p><pre><code>synchronized（）{}</code></pre><p>空同步块比大多数人认识到的要微妙得多，而且很难正确使用，而且空同步块几乎从来都不是比不那么做作的解决方案更好的解决方案</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IS_INCONSISTENT_SYNC">
    <ShortDescription>同步不一致  Inconsistent synchronization</ShortDescription>
    <LongDescription>{1}的同步不一致；锁定{2}%的时间</LongDescription>
    <Details>
<![CDATA[<p>就同步而言，此类字段的访问似乎不一致&nbsp；此错误报告表明，错误模式检测器判断</p><ul><li>该类包含锁定和解锁访问的混合，</li><li>至少有一个锁定访问是由该类自己的方法之一执行的，并且</li><li>非同步字段访问（读写）的数量不超过所有访问的三分之一，写操作的权重是读操作的两倍</li></ul><p>与此错误模式匹配的典型错误是忘记同步线程安全类中的一个方法</p> <p>注意，该检测器存在各种不准确的来源；例如，检测器无法静态检测持有锁的所有情况&nbsp；此外，即使检测器能够准确区分锁定和未锁定的访问，所讨论的代码也可能是正确的</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ML_SYNC_ON_FIELD_TO_GUARD_CHANGING_THAT_FIELD">
    <ShortDescription>场同步，徒劳地试图守卫该场  Synchronization on field in futile attempt to guard that field</ShortDescription>
    <LongDescription>{2.givenClass}上的同步无法保护它</LongDescription>
    <Details>
<![CDATA[<p>此方法在字段上同步，似乎是为了防止对该字段的同时更新。但保护字段会锁定引用的对象，而不是字段。这可能无法提供所需的互斥，其他线程可能正在获取引用对象的锁（用于其他目的）。此模式的一个示例是：</p><pre><code>private Long myNtfSeqNbrCounter=new Long（0）；private Long getNotificationSequenceNumber（）{Long result=null；synchronized（myNtfSeqNbrCounter）{result=new Long返回结果；}</代码></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ML_SYNC_ON_UPDATED_FIELD">
    <ShortDescription>方法在更新的字段上同步  Method synchronizes on an updated field</ShortDescription>
    <LongDescription>{1} 在更新的字段{2.givenClass}上同步</LongDescription>
    <Details>
<![CDATA[<p>此方法对从可变字段引用的对象进行同步。这不太可能有有用的语义，因为不同的线程可能在不同的对象上同步</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_OOI_PKGPROTECT">
    <ShortDescription>字段应移出接口并使包受到保护  Field should be moved out of an interface and made package protected</ShortDescription>
    <LongDescription>{1} 应移出接口并使包受到保护</LongDescription>
    <Details>
<![CDATA[<p>接口中定义的最终静态字段引用可变对象，如数组或哈希表。恶意代码或意外从其他包更改此可变对象。为了解决这个问题，需要将字段移到一个类中，并使包受到保护，以避免此漏洞</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_FINAL_PKGPROTECT">
    <ShortDescription>字段应为最终字段和包保护字段  Field should be both final and package protected</ShortDescription>
    <LongDescription>{1} 应为最终和包装保护</LongDescription>
    <Details>
<![CDATA[<p>一个可变的静态字段可能会被恶意代码更改，或者意外地从另一个包中更改。该字段可以设置为包保护和/或最终字段，以避免此漏洞</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_SHOULD_BE_REFACTORED_TO_BE_FINAL">
    <ShortDescription>字段不是最终字段，但应重构为最终字段  Field isn't final but should be refactored to be so</ShortDescription>
    <LongDescription>{1} 不是最终版本，但应该重构为最终版本</LongDescription>
    <Details>
<![CDATA[<p>这个静态字段是公开的，但不是最终的，可能会被恶意代码或其他包中的意外更改。该字段可以设置为最终字段，以避免此漏洞。然而，静态初始值设定项包含多个对字段的写入，因此这样做需要进行一些重构</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_SHOULD_BE_FINAL">
    <ShortDescription>字段不是最终字段，但应该是  Field isn't final but should be</ShortDescription>
    <LongDescription>{1} 不是最终结果，但应该是</LongDescription>
    <Details>
<![CDATA[<p>这个静态字段是公开的，但不是最终的，可能会被恶意代码或其他包中的意外更改。该字段可以设置为最终字段，以避免此漏洞</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_PKGPROTECT">
    <ShortDescription>字段应进行打包保护  Field should be package protected</ShortDescription>
    <LongDescription>{1} 应进行包装保护</LongDescription>
    <Details>
<![CDATA[<p>可变静态字段可能会因恶意代码或意外而更改。可以对字段进行打包保护，以避免此漏洞</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_MUTABLE_HASHTABLE">
    <ShortDescription>字段是可变哈希表  Field is a mutable Hashtable</ShortDescription>
    <LongDescription>{1} 是可变哈希表</LongDescription>
    <Details>
<![CDATA[<p>最后一个静态字段引用哈希表，可以被恶意代码访问，也可以意外地从另一个包访问。此代码可以自由修改哈希表的内容</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_MUTABLE_COLLECTION">
    <ShortDescription>字段是可变集合  Field is a mutable collection</ShortDescription>
    <LongDescription>{1} 是可变集合</LongDescription>
    <Details>
<![CDATA[<p>可变集合实例被分配给最终静态字段，因此可能会被恶意代码更改或意外地从另一个包更改。考虑将此字段包装到Collections.unmodifiableSet/List/Map/etc中。以避免此漏洞</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_MUTABLE_COLLECTION_PKGPROTECT">
    <ShortDescription>字段是一个可变集合，应进行包保护  Field is a mutable collection which should be package protected</ShortDescription>
    <LongDescription>{1} 是一个应受包保护的可变集合</LongDescription>
    <Details>
<![CDATA[<p>可变集合实例被分配给最终静态字段，因此可能会被恶意代码更改或意外地从另一个包更改。可以对字段进行打包保护，以避免此漏洞。或者，您可以将此字段包装到Collections.unmodifiableSet/List/Map/etc中。以避免此漏洞</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_MUTABLE_ARRAY">
    <ShortDescription>字段是可变数组  Field is a mutable array</ShortDescription>
    <LongDescription>{1} 是可变数组</LongDescription>
    <Details>
<![CDATA[<p>最后一个静态字段引用一个数组，可以被恶意代码访问，也可以意外地从另一个包访问。此代码可以自由修改数组的内容</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_CANNOT_BE_FINAL">
    <ShortDescription>字段不是最终字段，无法防止恶意代码  Field isn't final and can't be protected from malicious code</ShortDescription>
    <LongDescription>{1} 不是最终版本，无法防止恶意代码</LongDescription>
    <Details>
<![CDATA[<p>一个可变的静态字段可能会被恶意代码更改，或者意外地从另一个包中更改。不幸的是，字段的使用方式不允许轻松解决此问题</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ME_MUTABLE_ENUM_FIELD">
    <ShortDescription>枚举字段是公共的且是可变的  Enum field is public and mutable</ShortDescription>
    <LongDescription>{1} 字段是公共的且是可变的</LongDescription>
    <Details>
<![CDATA[<p>可变公共字段是在公共枚举内定义的，因此可以通过恶意代码或其他包中的意外更改。虽然可变枚举字段可能用于惰性初始化，但将它们暴露给外部世界是一种不好的做法。考虑将此字段声明为final和/或package private</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ME_ENUM_FIELD_SETTER">
    <ShortDescription>公共枚举方法无条件地设置其字段  Public enum method unconditionally sets its field</ShortDescription>
    <LongDescription>{1} 无条件设置字段{2.name}</LongDescription>
    <Details>
<![CDATA[<p>在公共枚举中声明的此公共方法无条件地设置枚举字段，因此该字段可以被恶意代码更改，也可以被其他包意外更改。虽然可变枚举字段可能用于惰性初始化，但将它们暴露给外部世界是一种不好的做法。考虑删除此方法或将其声明为包私有</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IA_AMBIGUOUS_INVOCATION_OF_INHERITED_OR_OUTER_METHOD">
    <ShortDescription>对继承或外部方法的潜在不明确调用  Potentially ambiguous invocation of either an inherited or outer method</ShortDescription>
    <LongDescription>{1}中外部或继承方法{2}的调用可能不明确</LongDescription>
    <Details>
<![CDATA[<p>内部类正在调用一个可以解析为继承方法或外部类中定义的方法的方法。例如，您调用<code>foo（17）</code>，它在超类和外部方法中定义。根据Java语义，它将被解析为调用继承的方法，但这可能不是您想要的</p> <p>如果您真的想调用继承的方法，请通过调用super上的方法来调用它（例如，invoke super.foo（17）），这样代码的其他读者和SpotBugs就可以清楚地看到，您想调用继承方法，而不是外部类中的方法</p> <p>如果您调用此。foo（17）</code>，则将调用继承的方法。然而，由于SpotBugs只查看类文件，因此它无法区分调用<code>this之间的区别。foo（17）</code>和<code>foo（17</code>foo），它仍然会抱怨潜在的不明确调用</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_SAME_SIMPLE_NAME_AS_SUPERCLASS">
    <ShortDescription>类名不应隐藏超类的简单名称  Class names shouldn't shadow simple name of superclass</ShortDescription>
    <LongDescription>类名{0}隐藏了超类{1}的简单名称</LongDescription>
    <Details>
<![CDATA[<p>这个类有一个与其超类相同的简单名称，只是它的超类位于不同的包中（例如，<code>alpha.Foo</code>extends<code>beta.Foo</code>）。这可能会非常令人困惑，造成许多情况，在这些情况下，您必须查看导入语句来解析引用，并有许多机会意外定义不重写超类中方法的方法</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_SAME_SIMPLE_NAME_AS_INTERFACE">
    <ShortDescription>类名不应隐藏实现接口的简单名称  Class names shouldn't shadow simple name of implemented interface</ShortDescription>
    <LongDescription>类名{0}隐藏了实现接口{1}的简单名称</LongDescription>
    <Details>
<![CDATA[<p>这个类/接口的简单名称与实现/扩展接口的名称相同，只是接口位于不同的包中（例如，<code>alpha.Foo</code>extends<code>beta.Foo>/code>）。这可能会非常令人困惑，造成许多情况，在这些情况下，您必须查看导入语句来解析引用，并有许多机会意外定义不重写超类中方法的方法</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_CLASS_NAMING_CONVENTION">
    <ShortDescription>类名应以大写字母开头  Class names should start with an upper case letter</ShortDescription>
    <LongDescription>类名{0}不以大写字母开头</LongDescription>
    <Details>
<![CDATA[<p>类名应该是名词，大小写混合，每个内部单词的第一个字母大写。尽量使你的类名简单明了。使用整词避免首字母缩写和缩写（除非缩写比长形式使用得更广泛，如URL或HTML）</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_METHOD_NAMING_CONVENTION">
    <ShortDescription>方法名称应以小写字母开头  Method names should start with a lower case letter</ShortDescription>
    <LongDescription>方法名{1}不以小写字母开头</LongDescription>
    <Details>
<![CDATA[<p>方法应该是动词，大小写混合，首字母小写，每个内部单词的首字母大写</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_FIELD_NAMING_CONVENTION">
    <ShortDescription>字段名称应以小写字母开头  Field names should start with a lower case letter</ShortDescription>
    <LongDescription>字段名{1}不是以小写字母开头</LongDescription>
    <Details>
<![CDATA[<p>非最终字段的名称应为混合大小写，首字母小写，后续单词的首字母大写</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_VERY_CONFUSING">
    <ShortDescription>非常混乱的方法名称  Very confusing method names</ShortDescription>
    <LongDescription>方法{1}和{3}非常令人困惑</LongDescription>
    <Details>
<![CDATA[<p>引用的方法的名称仅因大小写而不同。这非常令人困惑，因为如果大小写相同，那么其中一个方法将覆盖另一个方法</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_VERY_CONFUSING_INTENTIONAL">
    <ShortDescription>非常混乱的方法名（但可能是故意的）  Very confusing method names (but perhaps intentional)</ShortDescription>
    <LongDescription>使用方法{1}和{3}非常令人困惑（但可能是故意的）</LongDescription>
    <Details>
<![CDATA[<p>引用的方法的名称仅因大小写而不同。这非常令人困惑，因为如果大小写相同，那么其中一个方法将覆盖另一个方法。从其他方法的存在来看，这两种方法的存在似乎都是有意的，但肯定令人困惑。您应该努力消除其中一个，除非由于API冻结而被迫同时使用这两个</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_WRONG_PACKAGE">
    <ShortDescription>由于参数的包错误，方法未重写超类中的方法  Method doesn't override method in superclass due to wrong package for parameter</ShortDescription>
    <LongDescription>{1} 不重写超类中的方法，因为参数类型{4}与超类参数类型{5}不匹配</LongDescription>
    <Details>
<![CDATA[<p>子类中的方法不会覆盖超类中的类似方法，因为参数的类型与超类中相应参数的类型不完全匹配。例如，如果您有：</p><pre><code>import alpha。富；公共类A{public int f（Foo x）{return 17；}}----导入测试版。富；公共类B扩展了A{public int f（Foo x）{return 42；}}</code></pre><p>在类<code>B中定义的<code>f（Foo）</code>方法不会覆盖在类<code>A中定义的方法，因为参数类型是来自不同包的</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_WRONG_PACKAGE_INTENTIONAL">
    <ShortDescription>由于参数的包错误，方法未重写超类中的方法  Method doesn't override method in superclass due to wrong package for parameter</ShortDescription>
    <LongDescription>{1} 不重写超类中的方法，因为参数类型{4}与超类参数类型{5}不匹配</LongDescription>
    <Details>
<![CDATA[<p>子类中的方法不会覆盖超类中的类似方法，因为参数的类型与超类中相应参数的类型不完全匹配。例如，如果您有：</p><pre><code>import alpha。富；公共类A{public int f（Foo x）{return 17；}}----导入测试版。富；公共类B扩展了A{public int f（Foo x）{return 42；}公共int f（alpha.Foo x）{return 27；}}</code></pre><p>在类<code>B中定义的<code>f（Foo）</code>方法不会覆盖在类<code>A中定义的方法，因为参数类型是来自不同包的</p> <p>在这种情况下，子类确实定义了一个具有与超类中的方法相同签名的方法，因此这一点大概可以理解。然而，这种方法非常令人困惑。您应该强烈考虑删除或弃用具有类似但不相同签名的方法</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_CONFUSING">
    <ShortDescription>混淆方法名称  Confusing method names</ShortDescription>
    <LongDescription>混淆方法{1}和{3}</LongDescription>
    <Details>
<![CDATA[<p>引用的方法的名称仅因大小写而不同</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_METHOD_CONSTRUCTOR_CONFUSION">
    <ShortDescription>明显的方法/构造函数混淆  Apparent method/constructor confusion</ShortDescription>
    <LongDescription>{1} 可能是想成为一名构造师</LongDescription>
    <Details>
<![CDATA[<p>此常规方法与定义它的类同名。这很可能是为了成为一个构造函数。如果打算将其作为构造函数，请删除void返回值的声明。如果你意外地定义了这个方法，意识到了错误，定义了一个合适的构造函数，但由于向后兼容而无法摆脱这个方法，那么就不要推荐这个方法</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_LCASE_HASHCODE">
    <ShortDescription>类定义哈希码（）；它应该是hashCode（）吗？  Class defines hashcode(); should it be hashCode()?</ShortDescription>
    <LongDescription>类{0}定义哈希码（）；它应该是hashCode（）吗？</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个名为<code>hashcode（）</code>的方法&nbsp；此方法不会覆盖<code>java.lang.Object</code>中的<code>hashCode（）</code>方法，这可能是有意的</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_LCASE_TOSTRING">
    <ShortDescription>类定义tostring（）；应该是toString（）吗？  Class defines tostring(); should it be toString()?</ShortDescription>
    <LongDescription>类{0}定义tostring（）；应该是toString（）吗？</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个名为<code>tostring（）</code>的方法&nbsp；此方法不会覆盖<code>java.lang.Object</code>中的<code>toString（）</code>方法，这可能是有意的</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_BAD_EQUAL">
    <ShortDescription>类定义相等（对象）；它应该等于（Object）吗？  Class defines equal(Object); should it be equals(Object)?</ShortDescription>
    <LongDescription>类{0}定义了equal（Object）；它应该等于（Object）吗？</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个方法<code>equal（Object）</code>&nbsp；此方法不会覆盖<code>java.lang.Object</code>中的<code>等于（Object）</code>method，这可能是有意的</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_CLASS_NOT_EXCEPTION">
    <ShortDescription>类不是从Exception派生的，即使它是这样命名的  Class is not derived from an Exception, even though it is named as such</ShortDescription>
    <LongDescription>类{0}不是从Exception派生的，即使它是这样命名的</LongDescription>
    <Details>
<![CDATA[<p>此类不是从另一个异常派生的，而是以“exception”结尾。这会让此类用户感到困惑</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RR_NOT_CHECKED">
    <ShortDescription>方法忽略InputStream.read（）的结果  Method ignores results of InputStream.read()</ShortDescription>
    <LongDescription>{1} 忽略{2}的结果</LongDescription>
    <Details>
<![CDATA[<p>此方法忽略<code>java.io.InputStream的一个变体的返回值。read（）</code>，它可以返回多个字节&nbsp；如果不检查返回值，调用方将无法正确处理读取的字节数少于调用方请求的字节数的情况&nbsp；这是一种特别隐蔽的错误，因为在许多程序中，从输入流读取通常会读取请求的全部数据，导致程序偶尔失败</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SR_NOT_CHECKED">
    <ShortDescription>方法忽略InputStream.skip（）的结果  Method ignores results of InputStream.skip()</ShortDescription>
    <LongDescription>{1} 忽略{2}的结果</LongDescription>
    <Details>
<![CDATA[<p>此方法忽略<code>java.io.InputStream的返回值。skip（）</code>，它可以跳过多个字节&nbsp；如果不检查返回值，调用方将无法正确处理跳过的字节数少于调用方请求的字节数的情况&nbsp；这是一种特别隐蔽的错误，因为在许多程序中，从输入流跳过通常会跳过所请求的全部数据，导致程序偶尔失败。但是，对于缓冲流，skip（）将只跳过缓冲区中的数据，并且通常无法跳过请求的字节数</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_READ_RESOLVE_IS_STATIC">
    <ShortDescription>readResolve方法不能声明为静态方法。  The readResolve method must not be declared as a static method.</ShortDescription>
    <LongDescription>{1} 应声明为实例方法而不是静态方法</LongDescription>
    <Details>
<![CDATA[<p>为了使readResolve方法被序列化机制识别，不能将其声明为静态方法</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_PRIVATE_READ_RESOLVE_NOT_INHERITED">
    <ShortDescription>私有readResolve方法未被子类继承  Private readResolve method not inherited by subclasses</ShortDescription>
    <LongDescription>{0}中的私有readResolve方法未被子类继承。</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个私有的readResolve方法。因为它是私有的，所以它不会被子类继承。这可能是有意的，也可以，但应该进行审查，以确保它是有意的</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_READ_RESOLVE_MUST_RETURN_OBJECT">
    <ShortDescription>readResolve方法必须声明为返回类型Object。  The readResolve method must be declared with a return type of Object.</ShortDescription>
    <LongDescription>方法{1}必须声明为返回类型Object，而不是{1.returnType}</LongDescription>
    <Details>
<![CDATA[<p>为了使readResolve方法被序列化机制识别，必须将其声明为具有Object的返回类型</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_TRANSIENT_FIELD_OF_NONSERIALIZABLE_CLASS">
    <ShortDescription>不可序列化的类的瞬态字段。  Transient field of class that isn't Serializable.</ShortDescription>
    <LongDescription>{1.givenClass}是暂时的，但{0}不可序列化</LongDescription>
    <Details>
<![CDATA[<p>该字段被标记为transient，但该类不可序列化，因此将其标记为transtient绝对没有效果。这可能是该类可序列化的前一版本代码的剩余标记，也可能表示对序列化工作方式的误解</p> <p><em>仅当设置了特殊选项<tt>reportTransientFieldOfNonSerializableClass</tt>时，才会报告此错误。</em></p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_TRANSIENT_FIELD_NOT_RESTORED">
    <ShortDescription>非反序列化设置的瞬态字段。  Transient field that isn't set by deserialization.</ShortDescription>
    <LongDescription>字段{1}是暂时的，但不是通过反序列化设置的</LongDescription>
    <Details>
<![CDATA[<p>此类包含一个在类中多个位置更新的字段，因此它似乎是类状态的一部分。但是，由于该字段被标记为transient，并且没有在readObject或readResolve中设置，因此它将在类的任何反序列化实例中包含默认值</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_METHOD_MUST_BE_PRIVATE">
    <ShortDescription>方法必须是私有的才能使序列化工作  Method must be private in order for serialization to work</ShortDescription>
    <LongDescription>方法{1.givenClass}必须是私有的，才能在{0}的序列化/反序列化中调用</LongDescription>
    <Details>
<![CDATA[<p>此类实现<code>Serializable</code>接口，并定义自定义序列化/反序列化的方法。但是，由于该方法未声明为私有，因此序列化/反序列化API将自动忽略它</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION">
    <ShortDescription>类是可外部化的，但未定义void构造函数  Class is Externalizable but doesn't define a void constructor</ShortDescription>
    <LongDescription>{0}可外部化，但未定义void构造函数</LongDescription>
    <Details>
<![CDATA[<p>此类实现了<code>Externalizable</code>接口，但未定义公共void构造函数。反序列化Externalizable对象时，首先需要通过调用公共void构造函数来构造它们。由于此类没有，序列化和反序列化将在运行时失败</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NO_SUITABLE_CONSTRUCTOR">
    <ShortDescription>类是可序列化的，但其超类未定义void构造函数  Class is Serializable but its superclass doesn't define a void constructor</ShortDescription>
    <LongDescription>{0}可序列化，但其超类未定义可访问的void构造函数</LongDescription>
    <Details>
<![CDATA[<p>此类实现了<code>Serializable</code>接口，而其超类没有实现。当这样的对象被反序列化时，需要通过调用超类的void构造函数来初始化超类的字段。由于超类没有超类，因此序列化和反序列化将在运行时失败</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NO_SERIALVERSIONID">
    <ShortDescription>类是Serializable，但未定义serialVersionUID  Class is Serializable, but doesn't define serialVersionUID</ShortDescription>
    <LongDescription>{0}可序列化；考虑声明serialVersionUID</LongDescription>
    <Details>
<![CDATA[<p>此类实现<code>Serializable</code>接口，但不定义<code>serialVersionUID</code>field&nbsp；像添加对.class对象的引用这样简单的更改将向类中添加合成字段，这将不幸地更改隐式serialVersionUID（例如，添加对<code>String.class</code>的引用将生成一个静态字段<code>class$java$lang$String</code>>）。此外，字节码编译器的不同源代码可能会对为引用类对象或内部类而生成的合成变量使用不同的命名约定。为了确保Serializable跨版本的互操作性，请考虑添加显式serialVersionUID</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_COMPARATOR_SHOULD_BE_SERIALIZABLE">
    <ShortDescription>比较器未实现Serializable  Comparator doesn't implement Serializable</ShortDescription>
    <LongDescription>{0}实现Comparator但不可序列化</LongDescription>
    <Details>
<![CDATA[<p>此类实现了Comparator接口。您应该考虑它是否还应该实现<code>Serializable</code>接口。如果比较器用于构造有序集合，例如<code>TreeMap</code>，那么只有当比较器也可序列化时，<code>TreeMap</code>才可序列化。由于大多数比较器只有很少或没有状态，因此使其可序列化通常是一种简单且良好的防御编程</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SF_SWITCH_FALLTHROUGH">
    <ShortDescription>Switch语句发现一个案例进入下一个案例  Switch statement found where one case falls through to the next case</ShortDescription>
    <LongDescription>在{1}中找到的Switch语句，其中一个事例转换为另一个事例</LongDescription>
    <Details>
<![CDATA[<p>此方法包含一个switch语句，其中一个case分支将延伸到下一个cases。通常情况下，您需要以休息或返回结束此案例</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SF_SWITCH_NO_DEFAULT">
    <ShortDescription>找到缺少默认大小写的Switch语句  Switch statement found where default case is missing</ShortDescription>
    <LongDescription>在缺少默认大小写的{1}中找到Switch语句</LongDescription>
    <Details>
<![CDATA[<p>此方法包含缺少默认大小写的switch语句。通常您需要提供默认案例</p> <p>由于分析只查看生成的字节码，因此如果默认大小写位于switch语句的末尾，并且switch声明不包含其他情况下的break语句，则可能会错误触发此警告。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH">
    <ShortDescription>由于switch语句失败而导致的死存储  Dead store due to switch statement fall through</ShortDescription>
    <LongDescription>由于switch语句失败，前面案例中{2.givenClass}的值在此被覆盖</LongDescription>
    <Details>
<![CDATA[<p>由于交换机掉线，先前交换机案例中存储的值在此被覆盖。很可能是你忘了在前一个案例的末尾加上休息或返回</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH_TO_THROW">
    <ShortDescription>由于switch语句掉入抛出而导致的死存储  Dead store due to switch statement fall through to throw</ShortDescription>
    <LongDescription>前面案例中的{2.givenClass}的值在此丢失，因为switch语句无法抛出</LongDescription>
    <Details>
<![CDATA[<p>由于开关掉落到抛出异常的地方，因此在这里会忽略前一个开关案例中存储的值。很可能是你忘了在前一个案例的末尾加上休息或返回</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="WS_WRITEOBJECT_SYNC">
    <ShortDescription>类的writeObject（）方法已同步，但其他方法均未同步  Class's writeObject() method is synchronized but nothing else is</ShortDescription>
    <LongDescription>{0}的writeObject方法已同步，但没有其他方法</LongDescription>
    <Details>
<![CDATA[<p>这个类有一个同步的<code>writeObject（）</code>方法；但是，类的其他方法都没有同步</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RS_READOBJECT_SYNC">
    <ShortDescription>类的readObject（）方法已同步  Class's readObject() method is synchronized</ShortDescription>
    <LongDescription>{0}的readObject方法已同步</LongDescription>
    <Details>
<![CDATA[<p>这个可序列化类定义了一个同步的<code>readObject（）</code>&nbsp；根据定义，通过反序列化创建的对象只能由一个线程访问，因此不需要同步<code>readObject（）</code>&nbsp；如果<code>readObject（）</code>方法本身导致对象对另一个线程可见，这就是一个非常可疑的编码风格的例子</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NONSTATIC_SERIALVERSIONID">
    <ShortDescription>serialVersionUID不是静态的  serialVersionUID isn't static</ShortDescription>
    <LongDescription>{1} 不是静态的</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个非静态的<code>serialVersionUID</code>字段&nbsp；如果该字段用于指定版本UID以进行序列化，则应将其设置为静态</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NONFINAL_SERIALVERSIONID">
    <ShortDescription>serialVersionUID不是最终版本  serialVersionUID isn't final</ShortDescription>
    <LongDescription>{1} 不是最终的</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个非最终的<code>serialVersionUID</code>字段&nbsp；如果为了序列化目的而指定版本UID，则该字段应为最终字段</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NONLONG_SERIALVERSIONID">
    <ShortDescription>serialVersionUID不长  serialVersionUID isn't long</ShortDescription>
    <LongDescription>{1} 不是很长</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个不长的<code>serialVersionUID</code>字段&nbsp；如果该字段用于指定版本UID以进行序列化，则应将其设置为long</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_BAD_FIELD">
    <ShortDescription>可序列化类中的非瞬态非序列化实例字段  Non-transient non-serializable instance field in serializable class</ShortDescription>
    <LongDescription>类{0}定义非暂时的非序列化实例字段{1.name}</LongDescription>
    <Details>
<![CDATA[<p>这个Serializable类定义了一个非基元实例字段，该字段既不是瞬态的、Serializaable的，也不是<code>java.lang.Object</code>的，并且似乎没有实现<code>Externalizable</code>interface或<code]readObject（）</code>和<code>writeObject（&nbsp；如果此字段中存储了非序列化对象，则此类对象将无法正确反序列化</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_BAD_FIELD_INNER_CLASS">
    <ShortDescription>非序列化类具有可序列化的内部类  Non-serializable class has a serializable inner class</ShortDescription>
    <LongDescription>{0}是可序列化的，但也是非序列化类的内部类</LongDescription>
    <Details>
<![CDATA[<p>此Serializable类是非序列化类的内部类。因此，尝试序列化它也会尝试关联它所关联的外部类的实例，从而导致运行时错误</p> <p>如果可能，将内部类设置为静态内部类应该可以解决问题。使外部类可序列化也可能有效，但这意味着序列化内部类的实例也总是序列化外部类的实例，这通常不是您真正想要的。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_INNER_CLASS">
    <ShortDescription>可序列化内部类  Serializable inner class</ShortDescription>
    <LongDescription>{0}是可序列化的内部类</LongDescription>
    <Details>
<![CDATA[<p>这个Serializable类是一个内部类。任何序列化它的尝试都将序列化关联的外部实例。外部实例是可序列化的，因此不会失败，但它可能序列化的数据比预期的多得多。如果可能，将内部类设置为静态内部类（也称为嵌套类）应该可以解决这个问题。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_BAD_FIELD_STORE">
    <ShortDescription>存储在可序列化类的实例字段中的非序列化值  Non-serializable value stored into instance field of a serializable class</ShortDescription>
    <LongDescription>{2} 存储到非瞬态字段{1.givenClass}</LongDescription>
    <Details>
<![CDATA[<p>非序列化值存储在可序列化类的非瞬态字段中</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SC_START_IN_CTOR">
    <ShortDescription>构造函数调用Thread.start（）  Constructor invokes Thread.start()</ShortDescription>
    <LongDescription>{1} 调用{2}</LongDescription>
    <Details>
<![CDATA[<p>构造函数启动线程。如果类被扩展/子类化，这可能是错误的，因为线程将在子类构造函数启动之前启动</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SS_SHOULD_BE_STATIC">
    <ShortDescription>未读字段：该字段是否应为静态？  Unread field: should this field be static?</ShortDescription>
    <LongDescription>未读字段：{1}；这个字段应该是静态的吗？</LongDescription>
    <Details>
<![CDATA[<p>此类包含一个初始化为编译时静态值的实例final字段。考虑将字段设置为静态</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UUF_UNUSED_FIELD">
    <ShortDescription>未使用的字段  Unused field</ShortDescription>
    <LongDescription>未使用的字段：{1}</LongDescription>
    <Details>
<![CDATA[<p>此字段从未使用过&nbsp；考虑将其从类中删除</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="URF_UNREAD_FIELD">
    <ShortDescription>未读字段  Unread field</ShortDescription>
    <LongDescription>未读字段：{1}</LongDescription>
    <Details>
<![CDATA[<p>此字段永远不会被读取&nbsp；考虑将其从类中删除</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD">
    <ShortDescription>未使用的公共或受保护字段  Unused public or protected field</ShortDescription>
    <LongDescription>未使用的公共或受保护字段：{1}</LongDescription>
    <Details>
<![CDATA[<p>此字段从未使用过&nbsp；该字段是公共的或受保护的，因此它可能用于未被视为分析一部分的类。如果没有，请考虑将其从类中删除</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD">
    <ShortDescription>未读公共/受保护字段  Unread public/protected field</ShortDescription>
    <LongDescription>未读公共/保护字段：{1}</LongDescription>
    <Details>
<![CDATA[<p>此字段永远不会被读取&nbsp；该字段是公共的或受保护的，因此它可能用于未被视为分析一部分的类。如果没有，请考虑将其从类中删除</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="QF_QUESTIONABLE_FOR_LOOP">
    <ShortDescription>for循环中的复杂、细微或错误增量  Complicated, subtle or wrong increment in for-loop</ShortDescription>
    <LongDescription>for循环{1}中的复杂、细微或错误增量</LongDescription>
    <Details>
<![CDATA[<p>您确定此for循环正在递增/递减正确的变量吗？for循环似乎正在初始化和检查另一个变量</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UWF_NULL_FIELD">
    <ShortDescription>字段仅设置为空  Field only ever set to null</ShortDescription>
    <LongDescription>字段仅设置为空：{1}</LongDescription>
    <Details>
<![CDATA[<p>对该字段的所有写入都是常量值null，因此对该字段进行的所有读取都将返回null。检查错误，如果没有用就删除它</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD">
    <ShortDescription>未写入的公共或受保护字段  Unwritten public or protected field</ShortDescription>
    <LongDescription>未写入的公共或受保护字段：{1}</LongDescription>
    <Details>
<![CDATA[<p>未看到对此公共/受保护字段的写入&nbsp；所有读取都将返回默认值。检查错误（是否已初始化？），如果没有用，请将其移除</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UWF_UNWRITTEN_FIELD">
    <ShortDescription>未写入字段  Unwritten field</ShortDescription>
    <LongDescription>未写入字段：{1}</LongDescription>
    <Details>
<![CDATA[<p>此字段从未写入&nbsp；所有读取都将返回默认值。检查错误（是否已初始化？），如果没有用，请将其移除</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD">
    <ShortDescription>从实例方法写入静态字段  Write to static field from instance method</ShortDescription>
    <LongDescription>从实例方法{1}写入静态字段{2}</LongDescription>
    <Details>
<![CDATA[<p>此实例方法写入静态字段。如果正在操纵多个实例，并且通常是不好的做法，那么要纠正这一点很困难</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_LOAD_OF_KNOWN_NULL_VALUE">
    <ShortDescription>已知空值的加载  Load of known null value</ShortDescription>
    <LongDescription>{1}中已知空值的加载</LongDescription>
    <Details>
<![CDATA[<p>由于之前对null的检查，此时引用的变量已知为null。虽然这是有效的，但可能是错误的（可能您打算引用其他变量，或者可能之前检查变量是否为null的检查应该是检查它是否为非null的）</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_DEREFERENCE_OF_READLINE_VALUE">
    <ShortDescription>在不进行nullcheck的情况下取消对readLine（）结果的引用  Dereference of the result of readLine() without nullcheck</ShortDescription>
    <LongDescription>取消引用{1}中不带nullcheck的readLine（）结果</LongDescription>
    <Details>
<![CDATA[<p>调用readLine（）的结果被取消引用，而不检查结果是否为空。如果没有更多要读取的文本行，readLine（）将返回null和取消引用，这将生成null指针异常</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_IMMEDIATE_DEREFERENCE_OF_READLINE">
    <ShortDescription>立即取消对readLine（）结果的引用  Immediate dereference of the result of readLine()</ShortDescription>
    <LongDescription>立即取消对{1}中readLine（）结果的引用</LongDescription>
    <Details>
<![CDATA[<p>调用readLine（）的结果将立即取消引用。如果没有更多要读取的文本行，readLine（）将返回null和取消引用，这将生成null指针异常</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_UNWRITTEN_FIELD">
    <ShortDescription>读取未写入字段  Read of unwritten field</ShortDescription>
    <LongDescription>读取{1}中的未写入字段{2.name}</LongDescription>
    <Details>
<![CDATA[<p>程序正在取消引用一个似乎从未写入非空值的字段。除非该字段是通过分析未发现的某种机制初始化的，否则取消引用该值将生成空指针异常</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD">
    <ShortDescription>读取未写入的公共或受保护字段  Read of unwritten public or protected field</ShortDescription>
    <LongDescription>读取{1}中未写入的公共或受保护字段{2.name}</LongDescription>
    <Details>
<![CDATA[<p>程序正在取消引用一个似乎从未写入非空值的公共或受保护字段。除非该字段是通过分析未发现的某种机制初始化的，否则取消引用该值将生成空指针异常</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIC_THREADLOCAL_DEADLY_EMBRACE">
    <ShortDescription>非静态内部类和线程局部的致命拥抱  Deadly embrace of non-static inner class and thread local</ShortDescription>
    <LongDescription>{0}需要是static才能避免与{1}发生致命拥抱</LongDescription>
    <Details>
<![CDATA[<p>这个类是一个内部类，但可能应该是一个静态内部类。实际上，内部类和外部类中的线程局部之间存在致命拥抱的严重危险。因为内部类不是静态的，所以它保留了对外部类的引用。如果线程局部包含对内部类实例的引用，则内部和外部实例都是可访问的，不符合垃圾收集的条件</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIC_INNER_SHOULD_BE_STATIC">
    <ShortDescription>应为静态内部类  Should be a static inner class</ShortDescription>
    <LongDescription>{0}应该是_static_内部类吗？</LongDescription>
    <Details>
<![CDATA[<p>此类是一个内部类，但不使用其对创建它的对象的嵌入引用&nbsp；此引用会使类的实例更大，并且可能会使对创建者对象的引用保持更长的生存时间&nbsp；如果可能，应将类设置为静态</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR">
    <ShortDescription>字段未在构造函数中初始化，但在未进行空检查的情况下取消引用  Field not initialized in constructor but dereferenced without null check</ShortDescription>
    <LongDescription>{1.givenClass}未在构造函数中初始化，在{2}中取消引用</LongDescription>
    <Details>
<![CDATA[<p>此字段从未在任何构造函数中初始化，因此在构造对象后可能为空。在其他地方，它被加载和取消引用，而没有进行空检查。这可能是一个错误或有问题的设计，因为这意味着如果该字段在初始化之前被取消引用，将生成空指针异常</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIC_INNER_SHOULD_BE_STATIC_ANON">
    <ShortDescription>可以重构为命名的静态内部类  Could be refactored into a named static inner class</ShortDescription>
    <LongDescription>类{0}可以重构为命名的_static_内部类</LongDescription>
    <Details>
<![CDATA[<p>此类是一个内部类，但不使用其对创建它的对象的嵌入引用&nbsp；此引用会使类的实例更大，并且可能会使对创建者对象的引用保持更长的生存时间&nbsp；如果可能，该类应成为<em>静态</em>内部类。由于匿名内部类不能标记为静态，因此需要重构内部类，使其成为命名的内部类</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS">
    <ShortDescription>可以重构为静态内部类  Could be refactored into a static inner class</ShortDescription>
    <LongDescription>类{0}可以重构为_static_内部类</LongDescription>
    <Details>
<![CDATA[<p>这个类是一个内部类，但不使用它对创建它的对象的嵌入引用，除非是在内部对象的构造过程中&nbsp；此引用会使类的实例更大，并且可能会使对创建者对象的引用保持更长的生存时间&nbsp；如果可能，该类应成为<em>静态</em>内部类。由于在构造内部实例时需要引用外部对象，因此需要重构内部类，以便将对外部实例的引用传递给内部类的构造函数</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="WA_NOT_IN_LOOP">
    <ShortDescription>等待不在循环中  Wait not in loop</ShortDescription>
    <LongDescription>在{1}中等待不在循环中</LongDescription>
    <Details>
<![CDATA[<p>此方法包含对<code>java.lang.Object的调用。wait（）</code>，它不在循环中&nbsp；如果监视器用于多个条件，则调用者打算等待的条件可能不是实际发生的条件</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="WA_AWAIT_NOT_IN_LOOP">
    <ShortDescription>条件await（）不在循环中  Condition.await() not in loop</ShortDescription>
    <LongDescription>条件{1}中的await（）不在循环中</LongDescription>
    <Details>
<![CDATA[<p>此方法包含对<code>java.util.concurrent的调用。await（）</code>（或变体）不在循环中&nbsp；如果对象用于多个条件，则调用者打算等待的条件可能不是实际发生的条件</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NO_NOTIFY_NOT_NOTIFYALL">
    <ShortDescription>使用notify（）而不是notifyAll（）  Using notify() rather than notifyAll()</ShortDescription>
    <LongDescription>在{1}中使用notify而不是notifyAll</LongDescription>
    <Details>
<![CDATA[<p>此方法调用<code>notify（）</code>，而不是<code>notifyAll（）</code>&nbsp；Java监视器通常用于多种情况&nbsp；调用<code>notify（）</code>只会唤醒一个线程，这意味着唤醒的线程可能不是等待调用者刚刚满足的条件的线程</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UC_USELESS_VOID_METHOD">
    <ShortDescription>无用的非空空方法  Useless non-empty void method</ShortDescription>
    <LongDescription>方法{1}似乎没有用处</LongDescription>
    <Details>
<![CDATA[<p>我们的分析表明，这种非空void方法实际上没有执行任何有用的工作。请检查一下：可能代码中有错误，或者其主体可以完全删除</p> <p>我们正在尝试尽可能减少误报，但在某些情况下，此警告可能是错误的。常见的假阳性情况包括：</p><ul><li>该方法旨在触发加载某些可能有副作用的类</该方法旨在隐式抛出一些模糊的异常</li></ul>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UC_USELESS_CONDITION">
    <ShortDescription>条件没有影响  Condition has no effect</ShortDescription>
    <LongDescription>无用条件：此时{2}已知</LongDescription>
    <Details>
<![CDATA[<p>此条件始终产生与之前缩小的相关变量值相同的结果。可能是别的意思，或者这种情况可以消除</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UC_USELESS_CONDITION_TYPE">
    <ShortDescription>由于变量类型，条件不起作用  Condition has no effect due to the variable type</ShortDescription>
    <LongDescription>无用条件：总是{2}，因为变量类型是{3}</LongDescription>
    <Details>
<![CDATA[<p>由于所涉及变量的类型范围，此条件始终会产生相同的结果。可能是别的意思，或者这种情况可以消除</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UC_USELESS_OBJECT">
    <ShortDescription>创建了无用对象  Useless object created</ShortDescription>
    <LongDescription>存储在方法{1}的变量{2}中的无用对象</LongDescription>
    <Details>
<![CDATA[<p>我们的分析表明这个物体是无用的。它是被创建和修改的，但它的值永远不会超出方法的范围，也不会产生任何副作用。要么有错误，对象是要使用的，要么可以删除</p> <p>这种分析很少产生假阳性。常见的假阳性情况包括：</p><p>-此对象用于隐式抛出一些模糊的异常</p> <p>-此对象用作存根来泛化代码</p> <p>-此对象用于保存对弱/软引用对象的强引用</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UC_USELESS_OBJECT_STACK">
    <ShortDescription>堆栈上创建的无用对象  Useless object created on stack</ShortDescription>
    <LongDescription>在方法{1}中创建的无用对象</LongDescription>
    <Details>
<![CDATA[<p>创建此对象只是为了执行一些没有任何副作用的修改。可能是别的意思，或者这个物体可以被移除</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RANGE_ARRAY_INDEX">
    <ShortDescription>数组索引超出界限  Array index is out of bounds</ShortDescription>
    <LongDescription>数组索引超出范围：{3}</LongDescription>
    <Details>
<![CDATA[<p>已执行数组操作，但数组索引超出范围，这将在运行时导致ArrayIndexOutOfBoundsException</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RANGE_ARRAY_OFFSET">
    <ShortDescription>数组偏移量超出界限  Array offset is out of bounds</ShortDescription>
    <LongDescription>数组偏移量超出界限：{3}</LongDescription>
    <Details>
<![CDATA[<p>方法使用数组参数和偏移量参数调用，但偏移量超出范围。这将在运行时导致IndexOutOfBoundsException</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RANGE_ARRAY_LENGTH">
    <ShortDescription>数组长度超出界限  Array length is out of bounds</ShortDescription>
    <LongDescription>数组长度超出界限：{3}</LongDescription>
    <Details>
<![CDATA[<p>方法使用数组参数和长度参数调用，但长度超出了界限。这将在运行时导致IndexOutOfBoundsException</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RANGE_STRING_INDEX">
    <ShortDescription>字符串索引超出界限  String index is out of bounds</ShortDescription>
    <LongDescription>调用{5}:{3}时字符串索引超出范围</LongDescription>
    <Details>
<![CDATA[<p>字符串方法被调用，而指定的字符串索引越界。这将在运行时导致StringIndexOutOfBoundsException</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_CHECK_FOR_POSITIVE_INDEXOF">
    <ShortDescription>方法检查String的结果是否正确。indexOf为正  Method checks to see if result of String.indexOf is positive</ShortDescription>
    <LongDescription>{1} 检查String的结果是否正确。indexOf为正</LongDescription>
    <Details>
<![CDATA[<p>该方法调用String。indexOf并检查结果是正值还是非正值。更典型的做法是检查结果是阴性还是非阴性。只有当检查的子字符串出现在String开头以外的某个位置时，它才为正</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_DONT_JUST_NULL_CHECK_READLINE">
    <ShortDescription>方法在检查readLine的结果是否为非空后丢弃该结果  Method discards result of readLine after checking if it is non-null</ShortDescription>
    <LongDescription>{1} 检查readLine的结果是否为非空后将其丢弃</LongDescription>
    <Details>
<![CDATA[<p>检查返回值是否为非空值后，readLine返回的值将被丢弃。在几乎所有情况下，如果结果为非null，您将希望使用该非null值。再次调用readLine将得到不同的行</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="RV_RETURN_VALUE_IGNORED_INFERRED">
    <ShortDescription>方法忽略返回值，这样可以吗？  Method ignores return value, is this OK?</ShortDescription>
    <LongDescription>{2.givenClass}的返回值被忽略，在{1}中是否可以</LongDescription>
    <Details>
<![CDATA[<p>这段代码调用一个方法并忽略返回值。返回值与调用该方法的类型相同，从我们的分析来看，返回值可能很重要（例如，忽略<code>String.toLowerCase（）</code>的返回值）</p> <p>仅从方法主体的简单分析来看，我们猜测忽略返回值可能是个坏主意。您可以使用@CheckReturnValue注释来指示SpotBugs忽略此方法的返回值是重要的还是可以接受的</p> <p>请仔细调查，以决定是否可以忽略返回值</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT">
    <ShortDescription>忽略无副作用的方法的返回值  Return value of method without side effect is ignored</ShortDescription>
    <LongDescription>{2.givenClass}的返回值被忽略，但方法没有副作用</LongDescription>
    <Details>
<![CDATA[<p>这段代码调用一个方法并忽略返回值。然而，我们的分析表明，该方法（包括其在子类中的实现，如果有的话）除了返回值之外，不会产生任何影响。因此，可以删除此调用</p> <p>我们正在尝试尽可能减少误报，但在某些情况下，此警告可能是错误的。常见的假阳性案例包括：</p><p>-该方法被设计为被覆盖，并在分析范围之外的其他项目中产生副作用</p> <p>-调用该方法以触发可能产生副作用的类加载</p> <p>-调用该方法只是为了获得一些异常</p> <p>如果您觉得我们的假设不正确，可以使用@CheckReturnValue注释来指示SpotBugs忽略此方法的返回值是可以接受的</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="RV_RETURN_VALUE_IGNORED">
    <ShortDescription>方法忽略返回值  Method ignores return value</ShortDescription>
    <LongDescription>{1}中忽略{2.givenClass}的返回值</LongDescription>
    <Details>
<![CDATA[<p>应检查此方法的返回值。此警告的一个常见原因是对不可变对象调用方法，认为它更新了对象。例如，在下面的代码片段中，</p><pre><code>String dateString=getHeaderField（name）；dateString。修剪（）</code></pre><p>程序员似乎认为trim（）方法将更新dateString引用的String。但由于String是不可变的，因此trim（）函数返回一个新的String值，此处将忽略该值。代码应更正为：</p><pre><code>String dateString=getHeaderField（name）；dateString=dateString。修剪（）</代码></pre>]]>
    </Details>
  </BugPattern>


  <BugPattern type="RV_RETURN_VALUE_IGNORED_BAD_PRACTICE">
    <ShortDescription>方法忽略异常返回值  Method ignores exceptional return value</ShortDescription>
    <LongDescription>{1}中忽略了{2}的异常返回值</LongDescription>
    <Details>
<![CDATA[<p>此方法返回未选中的值。应检查返回值，因为它可能指示异常或意外的函数执行。例如，<code>File。如果无法成功删除文件（而不是引发异常），则delete（）</code>方法将返回false。如果不检查结果，就不会注意到方法调用是否通过返回非典型返回值来指示意外行为</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_CHECK_COMPARETO_FOR_SPECIFIC_RETURN_VALUE">
    <ShortDescription>代码检查compareTo返回的特定值  Code checks for specific values returned by compareTo</ShortDescription>
    <LongDescription>检查{2.givenClass}的返回值是否等于{3}</LongDescription>
    <Details>
<![CDATA[<p>此代码调用了compareTo或compare方法，并检查返回值是否是特定值，例如1或-1。调用这些方法时，只应检查结果的符号，而不应检查任何特定的非零值。虽然许多或大多数compareTo和compare方法只返回-1、0或1，但其中一些方法将返回其他值。]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_EXCEPTION_NOT_THROWN">
    <ShortDescription>创建并丢弃异常，而不是引发异常  Exception created and dropped rather than thrown</ShortDescription>
    <LongDescription>{2.givenClass}未在{1}中抛出</LongDescription>
    <Details>
<![CDATA[<p>这段代码创建了一个异常（或错误）对象，但没有对其进行任何处理。例如，类似</p><pre><code>if（x&lt；0）{new IllegalArgumentException（“x必须是非负的”）；}</code></pre><p>程序员可能想抛出创建的异常：</p><pre><code>if（x&lt；0）{throw new IllegalArgumentException（“x必须为非负”）；}</代码></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_ALWAYS_NULL">
    <ShortDescription>空指针引用  Null pointer dereference</ShortDescription>
    <LongDescription>{1}中{2.givenClass}的空指针引用</LongDescription>
    <Details>
<![CDATA[<p>此处取消引用空指针&nbsp；执行代码时，这将导致<code>NullPointerException</code></p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_CLOSING_NULL">
    <ShortDescription>对始终为空的值调用close（）  close() invoked on a value that is always null</ShortDescription>
    <LongDescription>无法关闭{2.givenClass}，因为它在{1}中始终为空</LongDescription>
    <Details>
<![CDATA[<p>正在对始终为空的值调用close（）。如果执行此语句，将发生空指针异常。但最大的风险是，你永远不会关闭应该关闭的东西。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_STORE_INTO_NONNULL_FIELD">
    <ShortDescription>将空值存储到带注释的@Nonnull字段中  Store of null value into field annotated @Nonnull</ShortDescription>
    <LongDescription>将空值存储到{1}中带注释的@Nonnull字段{2.givenClass}中</LongDescription>
    <Details>
      <![CDATA[<p>可以为null的值存储到一个已注释为@Nonnull的字段中</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_ALWAYS_NULL_EXCEPTION">
    <ShortDescription>异常路径上方法中的空指针引用  Null pointer dereference in method on exception path</ShortDescription>
    <LongDescription>异常路径上{1}中{2.givenClass}的空指针引用</LongDescription>
    <Details>
<![CDATA[<p>异常路径上为空的指针在此处取消引用&nbsp；执行代码时，这将导致<code>NullPointerException</code>&nbsp；请注意，因为SpotBugs当前不修剪不可行的异常路径，所以这可能是一个错误警告</p> <p>还要注意，SpotBugs将switch语句的默认情况视为异常路径，因为默认情况通常不可行</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE">
    <ShortDescription>参数必须为非null，但标记为可为null  Parameter must be non-null but is marked as nullable</ShortDescription>
    <LongDescription>{2} 必须为非null，但标记为可为null</LongDescription>
    <Details>
<![CDATA[<p>此参数的使用方式始终要求它为非null，但该参数被显式注释为可为null。参数或注释的使用错误</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_ON_SOME_PATH">
    <ShortDescription>可能的空指针引用  Possible null pointer dereference</ShortDescription>
    <LongDescription>{1}中{2.givenClass}的可能空指针引用</LongDescription>
    <Details>
<![CDATA[<p>语句有一个分支，<em>如果执行，</em>保证将取消对空值的引用，这将在执行代码时生成一个<code>NullPointerException</code>。当然，问题可能是分支或语句不可行，并且无法执行空指针异常；这超出了SpotBugs的能力</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_ON_SOME_PATH_MIGHT_BE_INFEASIBLE">
    <ShortDescription>分支上可能不可行的空指针引用  Possible null pointer dereference on branch that might be infeasible</ShortDescription>
    <LongDescription>分支上{2.givenClass}的空指针引用可能在{1}中不可行</LongDescription>
    <Details>
<![CDATA[<p>语句有一个分支，<em>如果执行，</em>保证将取消对空值的引用，这将在执行代码时生成一个<code>NullPointerException</code>。当然，问题可能是分支或语句不可行，并且无法执行空指针异常；这超出了SpotBugs的能力。由于该值之前已测试为空，这是一种肯定的可能性</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_ON_SOME_PATH_EXCEPTION">
    <ShortDescription>异常路径上的方法中可能存在空指针引用  Possible null pointer dereference in method on exception path</ShortDescription>
    <LongDescription>异常路径上{1}中{2.givenClass}的可能空指针引用</LongDescription>
    <Details>
<![CDATA[<p>此处取消引用某些异常控制路径上为空的引用值&nbsp；执行代码时，这可能会导致<code>NullPointerException</code>&nbsp；请注意，因为SpotBugs当前不修剪不可行的异常路径，所以这可能是一个错误警告</p> <p>还要注意，SpotBugs将switch语句的默认情况视为异常路径，因为默认情况通常不可行</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE">
    <ShortDescription>由于被调用方法的返回值，可能存在空指针引用  Possible null pointer dereference due to return value of called method</ShortDescription>
    <LongDescription>由于被调用方法的返回值，{1}中可能存在空指针引用</LongDescription>
    <Details>
      <![CDATA[<p>方法的返回值在不进行null检查的情况下被取消引用，并且该方法的返回数值通常应检查为null。执行代码时，这可能会导致<code>NullPointerException</code></p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_PARAM_DEREF_NONVIRTUAL">
    <ShortDescription>非虚拟方法调用为非null参数传递null  Non-virtual method call passes null for non-null parameter</ShortDescription>
    <LongDescription>{1}中的非虚拟方法调用为{2.givenClass}的非null参数传递null</LongDescription>
    <Details>
      <![CDATA[<p>将可能为null的值传递给非null方法参数。要么将参数注释为应始终为非空的参数，要么分析表明它将始终被取消引用</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS">
    <ShortDescription>方法调用为非null参数传递null  Method call passes null for non-null parameter</ShortDescription>
    <LongDescription>为{1}中{2.givenClass}的非Null参数传递了Null</LongDescription>
    <Details>
      <![CDATA[<p>在所有已知目标方法都要求参数为非null的调用位置传递可能为null的值。要么将参数注释为应始终为非空的参数，要么分析表明它将始终被取消引用</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_PARAM_DEREF">
    <ShortDescription>方法调用为非null参数传递null  Method call passes null for non-null parameter</ShortDescription>
    <LongDescription>为{1}中{2.givenClass}的非Null参数传递了Null</LongDescription>
    <Details>
      <![CDATA[<p>此方法调用为非null方法参数传递null值。要么将参数注释为应始终为非空的参数，要么分析表明它将始终被取消引用</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_NONNULL_PARAM_VIOLATION">
    <ShortDescription>方法调用将null传递给非null参数  Method call passes null to a non-null parameter</ShortDescription>
    <LongDescription>为{1}中{2.givenClass}的非Null参数传递了Null</LongDescription>
    <Details>
      <![CDATA[<p>此方法传递一个null值作为方法的参数，该参数必须为非null。该参数已明确标记为@Nonnull，或者分析已确定该参数始终被取消引用</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_NONNULL_RETURN_VIOLATION">
    <ShortDescription>方法可能返回null，但声明为@Nonnull  Method may return null, but is declared @Nonnull</ShortDescription>
    <LongDescription>{1} 可能返回null，但声明为@Nonnull</LongDescription>
    <Details>
      <![CDATA[<p>此方法可能返回null值，但该方法（或它重写的超类方法）被声明为返回@Nonnull</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_CLONE_COULD_RETURN_NULL">
    <ShortDescription>Clone方法可能返回null  Clone method may return null</ShortDescription>
    <LongDescription>{1} 可能返回null</LongDescription>
    <Details>
      <![CDATA[<p>此克隆方法在某些情况下似乎返回null，但克隆永远不允许返回null值。如果您确信此路径无法访问，请改为抛出AssertionError</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_TOSTRING_COULD_RETURN_NULL">
    <ShortDescription>toString方法可能返回null  toString method may return null</ShortDescription>
    <LongDescription>{1} 可能返回null</LongDescription>
    <Details>
      <![CDATA[<p>在某些情况下，此toString方法似乎返回null。对规范的自由解读可能会被解释为允许这样做，但这可能是个坏主意，可能会导致其他代码崩溃。返回空字符串或其他适当的字符串，而不是null</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_GUARANTEED_DEREF">
    <ShortDescription>保证取消引用空值  Null value is guaranteed to be dereferenced</ShortDescription>
    <LongDescription>{2.givenClass}可以为空，并保证在{1}中取消引用</LongDescription>
    <Details>
          <![CDATA[<p>有一个语句或分支，如果执行该语句或分支将确保某个值在此时为空，并且该值将被取消引用（涉及运行时异常的转发路径除外）</p> <p>注意，如<code>if（x==null）这样的检查会抛出新的NullPointerException（）</code>被视为对<code>x的取消引用</p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH">
    <ShortDescription>值为空，并保证在异常路径上取消引用  Value is null and guaranteed to be dereferenced on exception path</ShortDescription>
    <LongDescription>{2.name}为空，保证在异常路径上的{1}中取消引用</LongDescription>
    <Details>
          <![CDATA[<p>异常路径上有一条语句或分支，如果执行该语句或分支将确保某个值此时为空，并且该值将被取消引用（涉及运行时异常的正向路径除外）</p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="SI_INSTANCE_BEFORE_FINALS_ASSIGNED">
    <ShortDescription>静态初始值设定项在分配所有静态最终字段之前创建实例  Static initializer creates instance before all static final fields assigned</ShortDescription>
    <LongDescription>{0}的静态初始值设定项在分配所有静态最终字段之前创建实例</LongDescription>
    <Details>
<![CDATA[<p>类的静态初始值设定项在分配所有静态final字段之前创建类的实例</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="OS_OPEN_STREAM">
    <ShortDescription>方法可能无法关闭流  Method may fail to close stream</ShortDescription>
    <LongDescription>{1} 可能无法关闭流</LongDescription>
    <Details>
<![CDATA[<p>该方法创建IO流对象，不会将其分配给任何字段，也不会将其传递给可能会关闭它的其他方法，或将其返回，并且似乎不会在方法之外的所有路径上关闭该流&nbsp；这可能导致文件描述符泄漏&nbsp；通常，最好使用<code>finally</code>块来确保流是关闭的</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="OS_OPEN_STREAM_EXCEPTION_PATH">
    <ShortDescription>方法可能无法在异常时关闭流  Method may fail to close stream on exception</ShortDescription>
    <LongDescription>{1} 可能无法在异常时关闭流</LongDescription>
    <Details>
<![CDATA[<p>该方法创建IO流对象，不将其分配给任何字段，不将它传递给其他方法，也不返回它，并且在方法之外的所有可能的异常路径上似乎都不会关闭它&nbsp；这可能导致文件描述符泄漏&nbsp；通常，最好使用<code>finally</code>块来确保流是关闭的</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="PZLA_PREFER_ZERO_LENGTH_ARRAYS">
    <ShortDescription>考虑返回零长度数组而不是null  Consider returning a zero length array rather than null</ShortDescription>
    <LongDescription>{1}应该返回零长度数组而不是null吗？</LongDescription>
    <Details>
<![CDATA[<p>返回一个长度为零的数组而不是一个空引用来表示没有结果（即结果的空列表）通常是更好的设计。这样，方法的客户端就不需要显式检查null</p> <p>另一方面，使用null表示“这个问题没有答案”可能是合适的。例如，<code>File。如果给定的目录不包含文件，listFiles（）</code>将返回空列表；如果文件不是目录，则返回null</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UCF_USELESS_CONTROL_FLOW">
    <ShortDescription>无用的控制流  Useless control flow</ShortDescription>
    <LongDescription>{1}中无用的控制流</LongDescription>
    <Details>
<![CDATA[<p>此方法包含一个无用的控制流语句，其中控制流继续到同一位置，而不管是否执行分支。例如，这是由于<code>if</code>语句的语句块为空：</p><pre><code>if（argv.length==0）{//TODO:handle this case}</code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UCF_USELESS_CONTROL_FLOW_NEXT_LINE">
    <ShortDescription>无用的控制流到下一行  Useless control flow to next line</ShortDescription>
    <LongDescription>到{1}中下一行的无用控制流</LongDescription>
    <Details>
<![CDATA[<p>此方法包含一个无用的控制流语句，在该语句中，无论是否执行分支，控制流都遵循同一行或下一行。通常，这是由于不小心将空语句用作<code>if语句的主体，例如：</p><pre><code>if（argv.length==1）；系统输出。println（“你好”+argv[0]）</代码></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE">
    <ShortDescription>对先前取消引用的值进行空检查  Nullcheck of value previously dereferenced</ShortDescription>
    <LongDescription>以前在{1}中取消引用的值的{4.lineNumber}处的{2.givenClass}的空检查</LongDescription>
    <Details>
<![CDATA[<p>这里检查一个值以查看它是否为空，但该值不能为空，因为它以前被取消引用，如果为空，则在之前的取消引用时会发生空指针异常。本质上，这段代码和前面的取消引用对于是否允许此值为空不一致。检查是多余的，或者之前的取消引用是错误的</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE">
    <ShortDescription>已知为null的值的冗余nullcheck  Redundant nullcheck of value known to be null</ShortDescription>
    <LongDescription>{2}的冗余nullcheck在{1}中为null</LongDescription>
    <Details>
<![CDATA[<p>此方法包含对已知空值和常量空值的冗余检查</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE">
    <ShortDescription>已知非null值的冗余null检查  Redundant nullcheck of value known to be non-null</ShortDescription>
    <LongDescription>{2}的冗余nullcheck，已知其在{1}中为非null</LongDescription>
    <Details>
<![CDATA[<p>此方法包含对已知非null值与常量null的冗余检查</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES">
    <ShortDescription>两个空值的冗余比较  Redundant comparison of two null values</ShortDescription>
    <LongDescription>{1}中两个空值的冗余比较</LongDescription>
    <Details>
<![CDATA[<p>此方法包含两个已知绝对为空的引用的冗余比较</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE">
    <ShortDescription>非空值与空值的冗余比较  Redundant comparison of non-null value to null</ShortDescription>
    <LongDescription>{1}中非空值与空值的冗余比较</LongDescription>
    <Details>
<![CDATA[<p>此方法包含已知为非null的引用和已知为null的另一个引用</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_CHECKED_NULL_COMPARISON" deprecated="true"> <!-- deprecated in favor of two separate RCN_ patterns -->
    <ShortDescription>与先前检查值的null进行冗余比较  Redundant comparison to null of previously checked value</ShortDescription>
    <LongDescription>{1}中先前检查的{2}的null的冗余比较</LongDescription>
    <Details>
<![CDATA[<p>此方法包含引用值与null的冗余比较。报告了两种类型的冗余比较：</p><ul><li>两个比较的值都绝对为空</li><li>一个值绝对为空，另一个绝对不为空。虽然检查是不必要的，但它可能只是一种防御性编程</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UL_UNRELEASED_LOCK">
    <ShortDescription>方法不会释放所有路径上的锁  Method does not release lock on all paths</ShortDescription>
    <LongDescription>{1} 不会释放所有路径上的锁</LongDescription>
    <Details>
<![CDATA[<p>此方法获取JSR-166（<code>java.util.concurrent</code>）锁，但不会在方法之外的所有路径上释放它。通常，使用JSR-166锁的正确习惯用法是：</p><pre><code>lock l=。。。；l、 锁定（）；尝试{//do something}finally{l.unlock（）；}</代码></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UL_UNRELEASED_LOCK_EXCEPTION_PATH">
    <ShortDescription>方法不会释放所有异常路径上的锁  Method does not release lock on all exception paths</ShortDescription>
    <LongDescription>{1} 不会释放所有异常路径上的锁</LongDescription>
    <Details>
<![CDATA[<p>此方法获取JSR-166（<code>java.util.concurrent</code>）锁，但不会在方法之外的所有异常路径上释放它。通常，使用JSR-166锁的正确习惯用法是：</p><pre><code>lock l=。。。；l、 锁定（）；尝试{//do something}finally{l.unlock（）；}</代码></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RC_REF_COMPARISON">
    <ShortDescription>可疑参考比较  Suspicious reference comparison</ShortDescription>
    <LongDescription>{1}中{2}引用的可疑比较</LongDescription>
    <Details>
<![CDATA[<p>此方法使用==或！=比较两个参考值运算符，其中比较此类型实例的正确方法通常是使用equals（）方法。可以创建相等但不作为==进行比较的不同实例，因为它们是不同的对象。通常不应通过引用进行比较的类的示例有java.lang.Integer、java.lang.Float等</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RC_REF_COMPARISON_BAD_PRACTICE">
    <ShortDescription>与常量的可疑引用比较  Suspicious reference comparison to constant</ShortDescription>
    <LongDescription>{2}引用与{1}中常量的可疑比较</LongDescription>
    <Details>
<![CDATA[<p>此方法使用==或！=将参考值与常量进行比较运算符，其中比较此类型实例的正确方法通常是使用equals（）方法。可以创建相等但不作为==进行比较的不同实例，因为它们是不同的对象。通常不应通过引用进行比较的类的示例有java.lang.Integer、java.lang.Float等</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN">
    <ShortDescription>布尔值的可疑参考比较  Suspicious reference comparison of Boolean values</ShortDescription>
    <LongDescription>{1}中布尔引用的可疑比较</LongDescription>
    <Details>
<![CDATA[<p>此方法使用==或！=比较两个布尔值操作人员通常，只有两个布尔值（Boolean.TRUE和Boolean.FALSE），但可以使用新的布尔（b）</code>构造函数创建其他布尔对象。最好避免这样的对象，但如果它们确实存在，则使用==或！=检查布尔对象是否相等与使用<code>.equals（…）</code>得到的结果不同</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_UNRELATED_TYPES_USING_POINTER_EQUALITY">
    <ShortDescription>使用指针相等比较不同类型  Using pointer equality to compare different types</ShortDescription>
    <LongDescription>使用指针相等比较{2.givenClass}和{1}中的{3.givenClass{</LongDescription>
    <Details>
<![CDATA[<p>此方法使用指针相等性来比较两个似乎属于不同类型的引用。此比较的结果在运行时始终为假</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_UNRELATED_TYPES">
    <ShortDescription>调用equals（）比较不同类型  Call to equals() comparing different types</ShortDescription>
    <LongDescription>调用{1}中的{3.simpleClass}.equals（{2.simpleClass}）</LongDescription>
    <Details>
<![CDATA[<p>此方法对不同类类型的两个引用调用equals（Object），分析表明它们将在运行时指向不同类的对象。此外，对将被调用的equals方法的检查表明，要么此调用总是返回false，要么equals的方法不是对称的（这是类Object中equals协议所要求的属性）</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_UNRELATED_INTERFACES">
    <ShortDescription>调用equals（）比较不同的接口类型  Call to equals() comparing different interface types</ShortDescription>
    <LongDescription>调用{1}中的{3.simpleClass}.equals（{2.simpleClass}）</LongDescription>
    <Details>
<![CDATA[<p>此方法对两个无关接口类型的引用调用equals（Object），其中两个引用都不是另一个的子类型，并且没有已知的非抽象类实现这两个接口。因此，所比较的对象在运行时不太可能是同一类的成员（除非未分析某些应用程序类，或者在运行时可能发生动态类加载）。根据equals（）的约定，不同类的对象应该总是以不相等的方式进行比较；因此，根据java.lang.Object定义的契约。equals（Object），则此比较的结果在运行时始终为false</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_UNRELATED_CLASS_AND_INTERFACE">
    <ShortDescription>调用equals（）比较无关的类和接口  Call to equals() comparing unrelated class and interface</ShortDescription>
    <LongDescription>调用{1}中的{3.simpleClass}.equals（{2.simpleClass}）</LongDescription>
    <Details>
      <![CDATA[<p>此方法在两个引用上调用equals（Object），其中一个是类，另一个是接口，其中类及其任何非抽象子类都没有实现接口。因此，所比较的对象在运行时不太可能是同一类的成员（除非未分析某些应用程序类，或者在运行时可能发生动态类加载）。根据equals（）的约定，不同类的对象应该总是以不相等的方式进行比较；因此，根据java.lang.Object定义的契约。equals（Object），则此比较的结果在运行时始终为false</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="EC_NULL_ARG">
    <ShortDescription>调用等于（null）  Call to equals(null)</ShortDescription>
    <LongDescription>调用{1}中的equals（null）</LongDescription>
    <Details>
<![CDATA[<p>此方法调用equals（Object），传递一个空值作为参数。根据equals（）方法的约定，此调用应始终返回<code>false</code></p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MWN_MISMATCHED_WAIT">
    <ShortDescription>不匹配的等待（）  Mismatched wait()</ShortDescription>
    <LongDescription>{1}中的wait（）不匹配</LongDescription>
    <Details>
<![CDATA[<p>此方法调用Object。wait（），但显然没有持有对象的锁&nbsp；在没有锁的情况下调用wait（）将导致抛出<code>IllegalMonitorStateException</code></p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MWN_MISMATCHED_NOTIFY">
    <ShortDescription>不匹配的notify（）  Mismatched notify()</ShortDescription>
    <LongDescription>{1}中的notify（）不匹配</LongDescription>
    <Details>
<![CDATA[<p>此方法调用Object。notify（）或Object。notifyAll（），但显然没有持有对象的锁&nbsp；在没有锁的情况下调用notify（）或notifyAll（）将导致抛出<code>IllegalMonitorStateException</code></p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_LOCAL_SELF_ASSIGNMENT_INSTEAD_OF_FIELD">
    <ShortDescription>本地自分配，而非字段分配  Self assignment of local rather than assignment to field</ShortDescription>
    <LongDescription>{2}的自分配，而不是分配给{1}中的字段</LongDescription>
    <Details>
<![CDATA[<p>此方法包含局部变量的自赋值，并且有一个同名的字段。任务似乎已经完成；e、 g.</p><pre><code>int foo；公共void setFoo（int foo）{foo=foo；}</code></pre><p>赋值无效。你是不是打算改为分配到字段</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_LOCAL_SELF_ASSIGNMENT">
    <ShortDescription>局部变量的自赋值  Self assignment of local variable</ShortDescription>
    <LongDescription>{1}中{2}的自分配</LongDescription>
    <Details>
<![CDATA[<p>此方法包含局部变量的自赋值；e、 g.</p><pre><code>public void foo（）{int x=3；x=x；}</code></pre><p>这样的赋值是无用的，可能表示逻辑错误或输入错误</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_FIELD_SELF_ASSIGNMENT">
    <ShortDescription>字段的自分配  Self assignment of field</ShortDescription>
    <LongDescription>{1}中字段{2.givenClass}的自分配</LongDescription>
    <Details>
<![CDATA[<p>此方法包含字段的自赋值；e、 g.</p><pre><code>int x；公共void foo（）{x=x；}</code></pre><p>这样的赋值是无用的，可能表示逻辑错误或输入错误</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_FIELD_DOUBLE_ASSIGNMENT">
    <ShortDescription>字段的双重赋值  Double assignment of field</ShortDescription>
    <LongDescription>{1}中字段{2.givenClass}的双重赋值</LongDescription>
    <Details>
<![CDATA[<p>此方法包含字段的双重赋值；e、 g.</p><pre><code>int x，y；公共void foo（）{x=x=17；}</code></pre><p>对一个字段进行两次赋值是无用的，可能表示逻辑错误或输入错误</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_LOCAL_DOUBLE_ASSIGNMENT">
    <ShortDescription>局部变量的双重赋值  Double assignment of local variable</ShortDescription>
    <LongDescription>{1}中{2}的双重赋值</LongDescription>
    <Details>
<![CDATA[<p>此方法包含局部变量的双重赋值；e、 g.</p><pre><code>public void foo（）{int x，y；x=x=17；}</code></pre><p>将同一值两次赋值给一个变量是没有用的，可能表示逻辑错误或输入错误</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_FIELD_SELF_COMPUTATION">
    <ShortDescription>涉及领域的非理性自我计算（例如，x和x）  Nonsensical self computation involving a field (e.g., x &amp; x)</ShortDescription>
    <LongDescription>{2.givenClass}本身在{1}中的非理性自计算</LongDescription>
    <Details>
<![CDATA[<p>此方法使用对同一字段（例如，x&x或x-x）的另一个引用来执行字段的无意义计算。由于计算的性质，此操作似乎没有意义，可能表示输入错误或逻辑错误。仔细检查计算</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_LOCAL_SELF_COMPUTATION">
    <ShortDescription>涉及变量（如x和x）的非理性自我计算  Nonsensical self computation involving a variable (e.g., x &amp; x)</ShortDescription>
    <LongDescription>{2}自身在{1}中的无感自计算</LongDescription>
    <Details>
<![CDATA[<p>此方法使用对同一变量（例如，x&x或x-x）的另一个引用来执行局部变量的无意义计算。由于计算的性质，此操作似乎没有意义，可能表示输入错误或逻辑错误。仔细检查计算</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_FIELD_SELF_COMPARISON">
    <ShortDescription>字段与自身的自我比较  Self comparison of field with itself</ShortDescription>
    <LongDescription>{2.givenClass}与{1}中自身的自比较</LongDescription>
    <Details>
<![CDATA[<p>此方法将字段与其自身进行比较，可能表示输入错误或逻辑错误。确保你在比较正确的东西</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_LOCAL_SELF_COMPARISON">
    <ShortDescription>价值与自身的自我比较  Self comparison of value with itself</ShortDescription>
    <LongDescription>{2}与自身{1}的自我比较</LongDescription>
    <Details>
<![CDATA[<p>此方法将局部变量与自身进行比较，可能表示输入错误或逻辑错误。确保你在比较正确的东西</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT">
    <ShortDescription>双重的对int调用了longBitsToDouble  Double.longBitsToDouble invoked on an int</ShortDescription>
    <LongDescription>双重的对{1}中的int调用了longBitsToDouble</LongDescription>
    <Details>
<![CDATA[<p>双重身份。调用了longBitsToDouble方法，但传递了32位int值作为参数。这几乎肯定不是有意的，也不太可能产生预期的结果</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_ARGUMENTS_WRONG_ORDER">
    <ShortDescription>反转的方法参数  Reversed method arguments</ShortDescription>
    <LongDescription>{1}中调用{2.name}的参数顺序错误</LongDescription>
    <Details>
<![CDATA[<p>此方法调用的参数似乎顺序错误。例如，调用<code>Preconditions。checkNotNull（“message”，message）</code>有保留参数：要检查的值是第一个参数</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_RANDOM_USED_ONLY_ONCE">
    <ShortDescription>仅创建和使用一次的随机对象  Random object created and used only once</ShortDescription>
    <LongDescription>在{1}中只创建和使用一次随机对象</LongDescription>
    <Details>
<![CDATA[<p>这段代码创建了一个java.util。Random对象，使用它生成一个随机数，然后丢弃Random物体。这会产生质量一般的随机数，并且效率低下。如果可能，请重写代码，以便创建一次Random对象并保存，每次需要新的随机数时，都会调用现有Random目标上的方法来获取它</p> <p>如果生成的随机数不可猜测很重要，则您<em>不得</em>为每个随机数创建新的随机数；这些值很容易猜测。您应该强烈考虑使用java.security。取而代之的是SecureRandom（并避免为每个所需的随机数分配新的SecureRandom）</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_ABSOLUTE_VALUE_OF_RANDOM_INT">
    <ShortDescription>错误尝试计算有符号随机整数的绝对值  Bad attempt to compute absolute value of signed random integer</ShortDescription>
    <LongDescription>尝试计算{1}中有符号随机整数的绝对值时出错</LongDescription>
    <Details>
<![CDATA[<p>此代码生成一个随机有符号整数，然后计算该随机整数的绝对值。如果随机数生成器返回的数字是整数。MIN_VALUE</code>，则结果也将为负数（因为<code>Math.abs（Integer.MIN_VALUE）==Integer.MIN_VALUE</code>）。（长值也会出现同样的问题）</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_ABSOLUTE_VALUE_OF_HASHCODE">
    <ShortDescription>错误尝试计算带符号的32位哈希码的绝对值  Bad attempt to compute absolute value of signed 32-bit hashcode</ShortDescription>
    <LongDescription>尝试计算{1}中有符号32位哈希码的绝对值时出错</LongDescription>
    <Details>
<![CDATA[<p>这段代码生成一个哈希码，然后计算该哈希码的绝对值。如果哈希码为<code>Integer。MIN_VALUE</code>，则结果也将为负数（因为<code>Math.abs（Integer.MIN_VALUE）==Integer.MIN_VALUE</code>）</p> <p>2^32个字符串中有一个的hashCode为Integer。MIN_VALUE，包括“聚乙烯润滑剂”、“GydZG_”和“设计工作室”</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_REM_OF_RANDOM_INT">
    <ShortDescription>32位有符号随机整数的余数  Remainder of 32-bit signed random integer</ShortDescription>
    <LongDescription>{1}中计算的32位有符号随机整数的余数</LongDescription>
    <Details>
<![CDATA[<p>这段代码生成一个随机有符号整数，然后将该值的余数乘以另一个值。由于随机数可以是负数，余数运算的结果也可以是负值。确保这是有意的，并强烈考虑使用Random。改为nextInt（int）方法</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_REM_OF_HASHCODE">
    <ShortDescription>hashCode的余数可能为负数  Remainder of hashCode could be negative</ShortDescription>
    <LongDescription>{1}中hashCode的余数可能为负数</LongDescription>
    <Details>
<![CDATA[<p>这段代码计算一个hashCode，然后将该值的余数乘以另一个值。因为hashCode可以是负数，所以余数运算的结果也可以是负值</p> <p>假设您想确保计算结果为非负，则可能需要更改代码。如果知道除数是2的幂，则可以改用按位的and运算符（即，不要使用<code>x.hashCode（）%n</code>，而是使用<code_>x.hash code（；（n-1）</code>）。这可能比计算余数还要快。如果您不知道除数是2的幂，那么取余数运算结果的绝对值（即，使用<code>Math.abs（x.hashCode（）%n）</code>）</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE">
    <ShortDescription>非负值与负常量或零的错误比较  Bad comparison of nonnegative value with negative constant or zero</ShortDescription>
    <LongDescription>非负值与{1}中的{2}的错误比较</LongDescription>
    <Details>
<![CDATA[<p>此代码将保证为非负的值与负常量或零进行比较</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="INT_BAD_COMPARISON_WITH_SIGNED_BYTE">
    <ShortDescription>有符号字节的错误比较  Bad comparison of signed byte</ShortDescription>
    <LongDescription>{1}中有符号字节与{2}的错误比较</LongDescription>
    <Details>
<![CDATA[<p>有符号字节的值只能在-128到127之间。将有符号字节与超出该范围的值进行比较是空的，可能不正确。要将有符号字节<code>b</code>转换为范围为0..255的无符号值，请使用<code>0xff&amp；b</code></p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="INT_BAD_COMPARISON_WITH_INT_VALUE">
    <ShortDescription>int值与长常量的错误比较  Bad comparison of int value with long constant</ShortDescription>
    <LongDescription>int与{1}中的{2}的错误比较</LongDescription>
    <Details>
<![CDATA[<p>这段代码将int值与超出可表示为int值的值范围的长常量进行比较。这种比较是空洞的，可能不正确</p>]]>
    </Details>
  </BugPattern>


  <BugPattern type="INT_VACUOUS_BIT_OPERATION">
    <ShortDescription>整数值上的虚位掩码操作  Vacuous bit mask operation on integer value</ShortDescription>
    <LongDescription>{1}中{3}上的空{2}操作</LongDescription>
    <Details>
<![CDATA[<p>这是一个整数位操作（and、or、exclusive或），它不做任何有用的工作（例如<code>v&0xffffffff</code>）</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="INT_VACUOUS_COMPARISON">
    <ShortDescription>整数值的空白比较  Vacuous comparison of integer value</ShortDescription>
    <LongDescription>整数值{1}的空白比较</LongDescription>
    <Details>
<![CDATA[<p>整数比较总是返回相同的值（例如，x&lt；=integer.MAX_value）</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="INT_BAD_REM_BY_1">
    <ShortDescription>模1的整数余数  Integer remainder modulo 1</ShortDescription>
    <LongDescription>{1}中计算的模1整数余数</LongDescription>
    <Details>
<![CDATA[<p>任何表达式（exp%1）都保证始终返回零。您是指（exp&amp；1）还是（exp%2）</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_IOR_OF_SIGNED_BYTE">
    <ShortDescription>有符号字节值的位OR  Bitwise OR of signed byte value</ShortDescription>
    <LongDescription>{1}中计算的有符号字节值的位“或”</LongDescription>
    <Details>
<![CDATA[<p>加载一个字节值（例如，从字节数组加载的值或由返回类型为byte的方法返回的值），并对该值执行逐位or。在对字节值执行任何按位操作之前，将字节值符号扩展到32位。因此，如果<code>b[0]</code>包含值<code>0xff</code]，并且<code]x</code>0最初为0，则代码<code]（（x&lt；&lt；8）|b[0]）</code>将对extend进行签名，以获得值<code>0xffffff</code>，从而得到值<code_>0xffffff</p> <p>特别是，以下用于将字节数组打包为int的代码严重错误：</p><pre><code>int result=0；对于（int i=0；i&lt；4；i++）{result=（（result&lt；&lt；8）|b[i]）；}</code></pre><p>下面的习惯用法将起作用：</p><pre><code>int result=0；对于（int i=0；i&lt；4；i++）{result=（（result&lt；&lt；8）|（b[i]&0xff））；}</代码></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_ADD_OF_SIGNED_BYTE">
    <ShortDescription>有符号字节值的逐位相加  Bitwise add of signed byte value</ShortDescription>
    <LongDescription>{1}中计算的有符号字节值的逐位相加</LongDescription>
    <Details>
<![CDATA[<p>添加一个字节值和一个已知清除8个低位的值。在对值执行任何按位操作之前，从字节数组加载的值将符号扩展到32位。因此，如果<code>b[0]</code>包含值<code>0xff</code]，并且<code]x</code>0初始值为0，则代码<code]（（x&lt；&lt；8）+b[0]）</code>将对extend进行签名，以获得值<code>0xffffffff</code>，从而得到值<code_>0xffff</p> <p>特别是，以下用于将字节数组打包为int的代码严重错误：</p><pre><code>int result=0；对于（int i=0；i&lt；4；i++）结果=（（result&lt；&lt；8）+b[i]）</code></pre><p>下面的习惯用法将起作用：</p><pre><code>int result=0；对于（int i=0；i&lt；4；i++）结果=（（result&lt；&lt；8）+（b[i]&0xff））</代码></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_AND">
    <ShortDescription>不兼容的位掩码  Incompatible bit masks</ShortDescription>
    <LongDescription>（e&amp;{2}=={3}）中不兼容的位掩码在{1}中产生一个常量结果</LongDescription>
    <Details>
<![CDATA[<p>此方法将（e&C）形式的表达式与D进行比较，由于常数C和D的特定值，D总是不相等。这可能表示逻辑错误或输入错误</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_SIGNED_CHECK">
    <ShortDescription>检查按位操作的符号  Check for sign of bitwise operation</ShortDescription>
    <LongDescription>检查{1}中的位操作符号</LongDescription>
    <Details>
<![CDATA[<p>此方法比较表达式，例如<code>（（event.detail&SWT.SELECTED）&gt；0）</code>。使用位算法，然后与大于运算符进行比较，可能会导致意外结果（当然，这取决于SWT.SELECTED的值）。如果是SWT。SELECTED是负数，这是bug的候选项。即使是SWT。SELECTED不是负数，使用“！=“0”而不是“&gt；”；0'. </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_SIGNED_CHECK_HIGH_BIT">
    <ShortDescription>检查涉及负数的位运算的符号  Check for sign of bitwise operation involving negative number</ShortDescription>
    <LongDescription>检查{1}中涉及{2}的位操作的符号</LongDescription>
    <Details>
<![CDATA[<p>此方法比较按位表达式，例如<code>（（val&CONSTANT）&gt；0）</code>其中CONSTANT是负数。使用位算法，然后与大于运算符进行比较，可能会导致意外结果。这种比较不太可能像预期的那样起作用。好的做法是使用'！=“0”而不是“&gt；”；0'. </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_AND_ZZ">
    <ShortDescription>检查（（…）&amp;0）==0  Check to see if ((...) &amp; 0) == 0</ShortDescription>
    <LongDescription>检查{1}中的（…）&amp;0）==0</LongDescription>
    <Details>
<![CDATA[<p>此方法将<code>（e&0）</code>形式的表达式与0进行比较，后者始终相等。这可能表示逻辑错误或输入错误</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_IOR">
    <ShortDescription>不兼容的位掩码  Incompatible bit masks</ShortDescription>
    <LongDescription>（e|{2}=={3}）中的不兼容位掩码在{1}中产生常量结果</LongDescription>
    <Details>
<![CDATA[<p>此方法将<code>（e|C）</code>形式的表达式与D进行比较。由于常数C和D的特定值，D总是不相等。这可能表示逻辑错误或输入错误</p> <p>通常，出现此错误的原因是代码希望在位集中执行成员身份测试，但使用按位OR运算符（“|”）而不是按位AND（“&amp；”）</p> <p>此类错误也可能出现在表达式中，如<code>（e&amp；A|B）==C</code>，其解析方式类似于<code]（（e&A）|B）==C</code>，而<code>（e&安培；（A|B</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="LI_LAZY_INIT_INSTANCE" deprecated="true"> <!-- never generated? -->
    <ShortDescription>实例字段的惰性初始化不正确  Incorrect lazy initialization of instance field</ShortDescription>
    <LongDescription>{1}中实例字段{2}的延迟初始化不正确</LongDescription>
    <Details>
<![CDATA[<p>此方法包含非易失性字段的非同步惰性初始化。因为编译器或处理器可能会对指令重新排序，所以如果多个线程可以调用该方法，线程就不能保证看到完全初始化的对象。您可以使字段不稳定以纠正问题。有关详细信息，请参阅<a href=“http://www.cs.umd.edu/~pugh/java/memoryModel/“>java内存模型网站</a></p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="LI_LAZY_INIT_STATIC">
    <ShortDescription>静态字段的惰性初始化不正确  Incorrect lazy initialization of static field</ShortDescription>
    <LongDescription>{1}中静态字段{2}的惰性初始化不正确</LongDescription>
    <Details>
<![CDATA[<p>此方法包含非易失性静态字段的非同步惰性初始化。因为编译器或处理器可能会对指令重新排序，所以如果多个线程可以调用该方法，线程就不能保证看到完全初始化的对象。您可以使字段不稳定以纠正问题。有关详细信息，请参阅<a href=“http://www.cs.umd.edu/~pugh/java/memoryModel/“>java内存模型网站</a></p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="LI_LAZY_INIT_UPDATE_STATIC">
    <ShortDescription>静态字段的惰性初始化和更新不正确  Incorrect lazy initialization and update of static field</ShortDescription>
    <LongDescription>{1}中静态字段{2}的延迟初始化和更新不正确</LongDescription>
    <Details>
<![CDATA[<p>此方法包含静态字段的非同步惰性初始化。设置字段后，将进一步更新或访问存储在该位置的对象。字段的设置一经设置，其他线程就可以看到。如果设置该字段的方法中的进一步访问用于初始化对象，则会出现非常严重的<em>多线程错误，除非有其他原因阻止任何其他线程在完全初始化之前访问存储的对象</p> <p>即使您确信该方法从未被多个线程调用，在您将其设置为的值完全填充/初始化之前，最好不要设置静态字段</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="JLM_JSR166_LOCK_MONITORENTER">
    <ShortDescription>锁定时执行的同步  Synchronization performed on Lock</ShortDescription>
    <LongDescription>在{1}中的{2}上执行同步</LongDescription>
    <Details>
<![CDATA[<p>此方法对实现java.util.concurrent.locks.Lock的对象执行同步。这样的对象是使用<code>acquire（）</code>/<code>release（）</code>而不是使用<code>synchronized（…）</code>构造来锁定/解锁的</p>]]>
</Details>
  </BugPattern>
  <BugPattern type="JML_JSR166_CALLING_WAIT_RATHER_THAN_AWAIT">
    <ShortDescription>在util上使用监视器样式的等待方法。并行抽象  Using monitor style wait methods on util.concurrent abstraction</ShortDescription>
    <LongDescription>在{1}中调用{2.name}而不是{3.name}</LongDescription>
    <Details>
<![CDATA[<p>此方法在同时提供<code>await（）</code>、<code>signal（）</code>、<code>signalAll。这可能不是您想要的，即使您确实想要它，您也应该考虑更改您的设计，因为其他开发人员会发现它非常令人困惑</p>]]>
</Details>
  </BugPattern>
  <BugPattern type="JLM_JSR166_UTILCONCURRENT_MONITORENTER">
    <ShortDescription>在util上执行同步。并发实例  Synchronization performed on util.concurrent instance</ShortDescription>
    <LongDescription>在{1}中的{2}上执行同步</LongDescription>
    <Details>
<![CDATA[<p>此方法对java.util中类的实例对象执行同步。并发包（或其子类）。这些类的实例有自己的并发控制机制，这些机制与Java关键字<code>synchronized</code>提供的同步是正交的。例如，在<code>AtomicBoolean</code>上同步不会阻止其他线程修改<code>AtomicBoolean</code></p> <p>此类代码可能是正确的，但应仔细审查和记录，并且可能会使以后必须维护代码的人感到困惑</p>]]>
</Details>
  </BugPattern>
  <BugPattern type="UPM_UNCALLED_PRIVATE_METHOD">
    <ShortDescription>从不调用私有方法  Private method is never called</ShortDescription>
    <LongDescription>从未调用私有方法{1}</LongDescription>
    <Details>
<![CDATA[<p>从未调用此私有方法。虽然可以通过反射调用该方法，但很可能从未使用过该方法，应该将其删除</p>]]>
</Details>
  </BugPattern>
  <BugPattern type="UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS">
    <ShortDescription>匿名类中定义的不可调用方法  Uncallable method defined in anonymous class</ShortDescription>
    <LongDescription>匿名类中定义的不可调用方法{1}</LongDescription>
    <Details>
<![CDATA[<p>这个匿名类定义了一个不直接调用的方法，并且不重写超类中的方法。由于其他类中的方法无法直接调用匿名类中声明的方法，因此该方法似乎是不可调用的。该方法可能只是死代码，但也有可能该方法意在重写超类中声明的方法，并且由于输入错误或其他错误，该方法实际上并未重写其意欲重写的方法</p>]]>
</Details>
  </BugPattern>
  <BugPattern type="ODR_OPEN_DATABASE_RESOURCE">
    <ShortDescription>方法可能无法关闭数据库资源  Method may fail to close database resource</ShortDescription>
    <LongDescription>{1} 可能无法关闭{2.excludingPackage}</LongDescription>
    <Details>
<![CDATA[<p>该方法创建数据库资源（如数据库连接或行集），不会将其分配给任何字段、传递给其他方法或返回它，并且似乎不会关闭方法外所有路径上的对象&nbsp；未能关闭方法外所有路径上的数据库资源可能会导致性能低下，并可能导致应用程序与数据库通信出现问题</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH">
    <ShortDescription>方法在发生异常时可能无法关闭数据库资源  Method may fail to close database resource on exception</ShortDescription>
    <LongDescription>{1} 出现异常时可能无法关闭数据库资源</LongDescription>
    <Details>
<![CDATA[<p>该方法创建数据库资源（如数据库连接或行集），不会将其分配给任何字段、传递给其他方法或返回它，并且似乎不会关闭方法外所有异常路径上的对象&nbsp；未能关闭方法外所有路径上的数据库资源可能会导致性能低下，并可能导致应用程序与数据库通信出现问题</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SBSC_USE_STRINGBUFFER_CONCATENATION">
    <ShortDescription>方法在循环中使用+连接字符串  Method concatenates strings using + in a loop</ShortDescription>
    <LongDescription>{1} 在循环中使用+连接字符串</LongDescription>
    <Details>
<![CDATA[<p>该方法似乎正在使用循环中的串联来构建String。在每次迭代中，String被转换为StringBuffer/StringBuilder，附加到String，然后再转换回String。这可能导致迭代次数的成本为二次方，因为在每次迭代中都会重新复制增长的字符串</p> <p>通过显式使用StringBuffer（或Java 1.5中的StringBuilder）可以获得更好的性能</p> <p>例如：</p><pre><code>//这是坏字符串s=“”；对于（int i=0；i&lt；field.length；++i）{s=s+field[i]；}//这是更好的StringBuffer buf=new StringBuff（）；对于（int i=0；i&lt；field.length；++i）{buf.append（field[i]）；}字符串s=buf。到字符串（）</代码></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIL_PREPARE_STATEMENT_IN_LOOP">
    <ShortDescription>方法在循环中调用prepareStatement  Method calls prepareStatement in a loop</ShortDescription>
    <LongDescription>{1} 使用循环中的常量参数调用prepareStatement</LongDescription>
    <Details>
<![CDATA[<p>该方法调用Connection。循环中传递常量参数的prepareStatement。如果PreparedStatement应该执行多次，那么没有理由为每个循环迭代重新创建它。将此调用移出循环</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIL_ELEMENTS_GET_LENGTH_IN_LOOP">
    <ShortDescription>节点列表。在循环中调用getLength（）  NodeList.getLength() called in a loop</ShortDescription>
    <LongDescription>{1} 调用NodeList。getElementsByTagName返回值的循环中的getLength（）</LongDescription>
    <Details>
<![CDATA[<p>该方法调用NodeList。循环内的getLength（）和NodeList是由getElementsByTagName调用生成的。这个NodeList不存储其长度，但每次都以非最佳方式计算它。考虑在循环之前存储变量的长度</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIL_PATTERN_COMPILE_IN_LOOP">
    <ShortDescription>方法调用Pattern。在循环中编译  Method calls Pattern.compile in a loop</ShortDescription>
    <LongDescription>{1} 调用Pattern。在循环中使用常量参数编译</LongDescription>
    <Details>
<![CDATA[<p>该方法调用Pattern。在传递常量参数的循环内编译。如果Pattern应该被多次使用，那么没有理由为每个循环迭代编译它。将此调用移出循环，甚至移入静态final字段</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIL_PATTERN_COMPILE_IN_LOOP_INDIRECT">
    <ShortDescription>方法在循环中编译正则表达式  Method compiles the regular expression in a loop</ShortDescription>
    <LongDescription>{1} 在循环中编译正则表达式</LongDescription>
    <Details>
<![CDATA[<p>该方法在循环内创建相同的正则表达式，因此每次迭代都会编译它。使用Pattern预编译此正则表达式将更为理想。在循环外编译</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIO_INEFFICIENT_INDEX_OF">
    <ShortDescription>String.indexOf（String）使用效率低下  Inefficient use of String.indexOf(String)</ShortDescription>
    <LongDescription>{1} 使用字符串。indexOf（String）而不是String.indexOf</LongDescription>
    <Details>
<![CDATA[<p>此代码将一个长度为1的常量字符串传递给string.indexOf（）。使用String.indexOf（）的整数实现更有效。f、 e.调用<code>myString.indexOf（'.'）</code>而不是<code>myString.indexOf（“.”）</code></p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIO_INEFFICIENT_LAST_INDEX_OF">
    <ShortDescription>String.lastIndexOf（String）使用效率低下  Inefficient use of String.lastIndexOf(String)</ShortDescription>
    <LongDescription>{1} 使用字符串。lastIndexOf（String）而不是String.lastIndexOff（int）</LongDescription>
    <Details>
<![CDATA[<p>此代码将一个长度为1的常量字符串传递给string.lastIndexOf（）。使用String.lastIndexOf（）的整数实现更有效。f、 e.调用<code>myString.lastIndexOf（'.'）</code>而不是<code>myString.lastIndexOf'（“.”）</code></p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ITA_INEFFICIENT_TO_ARRAY">
    <ShortDescription>方法使用具有零长度数组参数的toArray（）  Method uses toArray() with zero-length array argument</ShortDescription>
    <LongDescription>{1} 使用集合。具有零长度数组参数的toArray（）</LongDescription>
    <Details>
<![CDATA[<p>此方法使用集合派生类的toArray（）方法，并传入一个零长度的原型数组参数。使用<code>myCollection更有效。toArray（new Foo[myCollection.size（）]）</code>如果传入的数组足够大，可以存储集合的所有元素，那么它将被填充并直接返回。这避免了创建第二个数组（通过反射）作为结果返回的需要</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD">
    <ShortDescription>JUnit不会注意到run方法中的JUnit断言  JUnit assertion in run method will not be noticed by JUnit</ShortDescription>
    <LongDescription>JUnit不会注意到{1}中的JUnit断言</LongDescription>
    <Details>
<![CDATA[<p>JUnit断言在run方法中执行。失败的JUnit断言只会导致抛出异常。因此，如果此异常发生在调用测试方法的线程以外的线程中，该异常将终止该线程，但不会导致测试失败</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IJU_SETUP_NO_SUPER">
    <ShortDescription>TestCase定义了不调用super.setUp（）的setUp  TestCase defines setUp that doesn't call super.setUp()</ShortDescription>
    <LongDescription>TestCase{0}定义了不调用super.setUp（）的setUp</LongDescription>
    <Details>
<![CDATA[<p>类是JUnit TestCase并实现setUp方法。setUp方法应该调用super。setUp（），但没有</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IJU_TEARDOWN_NO_SUPER">
    <ShortDescription>TestCase定义了不调用super.tearDown（）的tearDown  TestCase defines tearDown that doesn't call super.tearDown()</ShortDescription>
    <LongDescription>TestCase{0}定义了不调用super.tearDown（）的tearDown</LongDescription>
    <Details>
<![CDATA[<p>类是JUnit TestCase并实现tearDown方法。tearDown方法应该调用super。tearDown（），但没有</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IJU_SUITE_NOT_STATIC">
    <ShortDescription>TestCase实现了一个非静态套件方法  TestCase implements a non-static suite method</ShortDescription>
    <LongDescription>TestCase{0}实现了一个非静态套件方法</LongDescription>
    <Details>
<![CDATA[<p>类是JUnit TestCase并实现suite（）方法。suite方法应该声明为静态，但不是</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IJU_BAD_SUITE_METHOD">
    <ShortDescription>TestCase声明了一个错误的套件方法  TestCase declares a bad suite method</ShortDescription>
    <LongDescription>{0}中suite方法的错误声明</LongDescription>
    <Details>
<![CDATA[<p>类是JUnit TestCase并定义suite（）方法。然而，suite方法需要声明为</p><pre><code>publicstaticjunit.framework。测试套件（）</code></pre><p>或</p><pre><code>公共静态junit.framework。测试套件套件（）</code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IJU_NO_TESTS">
    <ShortDescription>TestCase没有测试  TestCase has no tests</ShortDescription>
    <LongDescription>TestCase{0}没有测试</LongDescription>
    <Details>
<![CDATA[<p>类是JUnit TestCase，但尚未实现任何测试方法</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BOA_BADLY_OVERRIDDEN_ADAPTER">
    <ShortDescription>类错误地重写了在超级类Adapter中实现的方法  Class overrides a method implemented in super class Adapter wrongly</ShortDescription>
    <LongDescription>类{0}覆盖了在超类Adapter中错误实现的方法{1}</LongDescription>
    <Details>
<![CDATA[<p>此方法覆盖父类中的方法，其中该类是实现java.awt中定义的侦听器的适配器。事件或javax.swing。事件包。因此，当事件发生时，将不会调用此方法</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BRSA_BAD_RESULTSET_ACCESS" deprecated="true"> <!-- deprecated in favor of SQL_BAD_RESULTSET_ACCESS -->
    <ShortDescription>方法尝试访问索引为0的结果集字段  Method attempts to access a result set field with index 0</ShortDescription>
    <LongDescription>{1} 尝试访问索引为0的结果集字段</LongDescription>
    <Details>
<![CDATA[<p>在字段索引为0的情况下，调用了结果集的getXXX或updateXXX方法。由于结果集字段从索引1开始，因此这总是一个错误</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SQL_BAD_RESULTSET_ACCESS">
    <ShortDescription>方法尝试访问索引为0的结果集字段  Method attempts to access a result set field with index 0</ShortDescription>
    <LongDescription>{1} 尝试访问索引为0的结果集字段</LongDescription>
    <Details>
<![CDATA[<p>在字段索引为0的情况下，调用了结果集的getXXX或updateXXX方法。由于结果集字段从索引1开始，因此这总是一个错误</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SQL_BAD_PREPARED_STATEMENT_ACCESS">
    <ShortDescription>方法尝试访问索引为0的准备好的语句参数  Method attempts to access a prepared statement parameter with index 0</ShortDescription>
    <LongDescription>{1} 尝试访问索引为0的准备好的语句参数</LongDescription>
    <Details>
<![CDATA[<p>在参数索引为0的情况下，调用了预处理语句的setXXX方法。由于参数索引从索引1开始，这总是一个错误</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIO_SUPERFLUOUS_INSTANCEOF">
    <ShortDescription>使用instanceof运算符完成了不必要的类型检查  Unnecessary type check done using instanceof operator</ShortDescription>
    <LongDescription>{1} 当可以静态确定类型时，使用instanceof运算符进行不必要的类型检查</LongDescription>
    <Details>
<![CDATA[<p>使用instanceof运算符执行的类型检查，可以静态确定对象是否为请求的类型</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BAC_BAD_APPLET_CONSTRUCTOR">
    <ShortDescription>错误的Applet构造函数依赖于未初始化的AppletStub  Bad Applet Constructor relies on uninitialized AppletStub</ShortDescription>
    <LongDescription>错误的Applet构造函数依赖于未初始化的AppletStub</LongDescription>
    <Details>
<![CDATA[<p>此构造函数调用父Applet中依赖于AppletStub的方法。由于AppletStub在调用该小程序的init（）方法之前不会初始化，因此这些方法将无法正确执行</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_ARRAY_AND_NONARRAY">
    <ShortDescription>equals（）用于比较数组和非数组  equals() used to compare array and nonarray</ShortDescription>
    <LongDescription>在{1}中调用{3.simpleClass}.equals（{2.simpleClass}）</LongDescription>
    <Details>
<![CDATA[<p>此方法调用.equals（Object o）来比较数组和似乎不是数组的引用。如果被比较的事物是不同类型的，那么它们肯定是不相等的，而且比较几乎肯定是错误的。即使它们都是数组，数组上的equals方法也只能确定这两个数组是同一个对象。要比较数组的内容，请使用java.util.arrays。等于（对象[]，对象[]）</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_BAD_ARRAY_COMPARE">
    <ShortDescription>对数组调用equals（），这等价于==  Invocation of equals() on an array, which is equivalent to ==</ShortDescription>
    <LongDescription>使用.equals比较{1}中的两个{2.simpleClass}（等价于==）</LongDescription>
    <Details>
<![CDATA[<p>此方法在数组上调用.equals（Object o）方法。因为数组不会覆盖Object的equals方法，所以对数组调用equals与比较它们的地址是一样的。要比较数组的内容，请使用java.util.arrays。等于（Object[]，Object[]）</code>。要比较数组的地址，使用<code>==</code>显式检查指针相等性会比较容易</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_INCOMPATIBLE_ARRAY_COMPARE">
    <ShortDescription>用于比较不兼容数组的equals（…）  equals(...) used to compare incompatible arrays</ShortDescription>
    <LongDescription>使用equals比较{1}中的{2.simpleClass}和{3.simpleClass}</LongDescription>
    <Details>
<![CDATA[<p>此方法调用.equals（Object o）来比较两个数组，但比较不兼容类型的数组（例如String[]和StringBuffer[]，或String[]andint[]）。他们永远不会平等。此外，当使用equals（…）比较数组时，它只检查它们是否是同一数组，而忽略数组的内容</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="STI_INTERRUPTED_ON_CURRENTTHREAD">
    <ShortDescription>不需要使用currentThread（）调用来调用interrupted（）  Unneeded use of currentThread() call, to call interrupted()</ShortDescription>
    <LongDescription>{1} 对currentThread（）进行不必要的调用，只是为了调用interrupted（）</LongDescription>
    <Details>
<![CDATA[<p>此方法调用Thread。currentThread（）调用，只调用interrupted（）方法。由于interrupted（）是一个静态方法，所以使用Thread.interrupted（）更简单、更清晰</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="STI_INTERRUPTED_ON_UNKNOWNTHREAD">
    <ShortDescription>静态线程。在线程实例上调用interrupted（）方法  Static Thread.interrupted() method invoked on thread instance</ShortDescription>
    <LongDescription>{1} 调用静态线程。线程实例上的interrupted（）方法</LongDescription>
    <Details>
<![CDATA[<p>此方法调用Thread。线程对象上的interrupted（）方法，该对象似乎是不是当前线程的线程对象。由于interrupted（）方法是静态的，因此将在不同于作者所希望的对象上调用interruptedmethod</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN">
    <ShortDescription>参数在进入方法时死机，但被覆盖  A parameter is dead upon entry to a method but overwritten</ShortDescription>
    <LongDescription>参数{2}到{1}在输入时无效，但被覆盖</LongDescription>
    <Details>
<![CDATA[<p>忽略该参数的初始值，并在此处覆盖该参数。这通常表明错误的想法，即对参数的写入将被传回调用方</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DLS_DEAD_LOCAL_STORE_SHADOWS_FIELD">
    <ShortDescription>隐藏字段的局部变量的死存储  Dead store to local variable that shadows field</ShortDescription>
    <LongDescription>死存储到{2}，而不是{1}中同名的字段</LongDescription>
    <Details>
<![CDATA[<p>此指令为局部变量赋值，但不会在任何后续指令中读取或使用该值。通常，这表示错误，因为计算的值从未使用过。有一个字段与局部变量同名。你是想改为赋值给那个变量吗</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DLS_DEAD_LOCAL_STORE">
    <ShortDescription>局部变量的死存储  Dead store to local variable</ShortDescription>
    <LongDescription>死存储到{1}中的{2}</LongDescription>
    <Details>
<![CDATA[<p>此指令为局部变量赋值，但不会在任何后续指令中读取或使用该值。通常，这表示错误，因为计算的值从未使用过</p> <p>请注意，Sun的javac编译器通常会为最终的局部变量生成死存储。因为SpotBugs是一个基于字节码的工具，所以没有简单的方法来消除这些误报</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="DLS_DEAD_LOCAL_STORE_IN_RETURN">
    <ShortDescription>return语句中无用的赋值  Useless assignment in return statement</ShortDescription>
    <LongDescription>{1}返回的无用赋值</LongDescription>
    <Details>
      <![CDATA[<p>此语句在return语句中分配给局部变量。此分配具有效力。请验证此语句是否正确</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DLS_DEAD_LOCAL_INCREMENT_IN_RETURN">
    <ShortDescription>return语句中无用的增量  Useless increment in return statement</ShortDescription>
    <LongDescription>{1}返回的无用增量</LongDescription>
    <Details>
      <![CDATA[<p>此语句有一个返回值，如<code>return x++</code>/<code>return x--</代码>。后缀递增/递减不会影响表达式的值，因此此递增/递减没有影响。请验证此语句是否正确</p>]]>
    </Details>
  </BugPattern>



  <BugPattern type="DLS_DEAD_STORE_OF_CLASS_LITERAL">
    <ShortDescription>类文字的死存储  Dead store of class literal</ShortDescription>
    <LongDescription>{3}的死存储。{1}中的类</LongDescription>
    <Details>
<![CDATA[<p>此指令将类文字指定给变量，然后从不使用它<a href=“http://www.oracle.com/technetwork/java/javase/compatibility-137462.html#literal“>这在Java 1.4和Java 5中的行为不同。</a>在Java 1.4及更早版本中，对<code>Foo.class</code>的引用将强制执行<code>Foo的静态初始值设定项（如果尚未执行）。在Java 5及更高版本中，则不会。</p><p>请参阅Sun的<a href=”http://www.oracle.com/technetwork/java/javase/compatibility-137462.html#literal“>关于Java SE兼容性的文章</a>，了解更多详细信息和示例，以及关于如何在Java 5中强制类初始化的建议</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DLS_DEAD_LOCAL_STORE_OF_NULL">
    <ShortDescription>局部变量的null死存储  Dead store of null to local variable</ShortDescription>
    <LongDescription>{1}中的空到{2}的死存储</LongDescription>
    <Details>
<![CDATA[<p>代码将null存储到局部变量中，并且不读取存储的值。这个存储可能是为了帮助垃圾收集器而引入的，但从JavaSE6.0开始，它不再需要，也不再有用</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MF_METHOD_MASKS_FIELD">
    <ShortDescription>方法定义隐藏字段的变量  Method defines a variable that obscures a field</ShortDescription>
    <LongDescription>{1} 定义一个隐藏字段{2.givenClass}的变量</LongDescription>
    <Details>
<![CDATA[<p>此方法定义了一个与此类或超类中的字段同名的局部变量。这可能会导致方法从字段中读取未初始化的值，或使字段保持未初始化状态，或两者兼而有之</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MF_CLASS_MASKS_FIELD">
    <ShortDescription>类定义了屏蔽超类字段的字段  Class defines field that masks a superclass field</ShortDescription>
    <LongDescription>字段{1.givenClass}屏蔽超类{2.class}中的字段</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个与超类中的可见实例字段同名的字段。这很令人困惑，如果方法在需要另一个字段时更新或访问其中一个字段，则可能指示错误</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="WMI_WRONG_MAP_ITERATOR">
    <ShortDescription>使用keySet迭代器而不是entrySet迭代者效率低下  Inefficient use of keySet iterator instead of entrySet iterator</ShortDescription>
    <LongDescription>{1} 使用keySet迭代器而不是entrySet迭代者效率低下</LongDescription>
    <Details>
<![CDATA[<p>此方法使用从keySet迭代器检索的键访问Map条目的值。在map的entrySet上使用迭代器更有效，可以避免使用map。获取（键）查找</p>]]>
        </Details>
  </BugPattern>
  <BugPattern type="ISC_INSTANTIATE_STATIC_CLASS">
    <ShortDescription>只提供静态方法的类的无需实例化  Needless instantiation of class that only supplies static methods</ShortDescription>
    <LongDescription>{1} 不必要地实例化只提供静态方法的类</LongDescription>
    <Details>
<![CDATA[<p>此类分配基于仅提供静态方法的类的对象。这个对象不需要创建，只需使用类名作为限定符直接访问静态方法</p>]]>
        </Details>
  </BugPattern>
  <BugPattern type="REC_CATCH_EXCEPTION">
    <ShortDescription>未引发异常时捕获异常  Exception is caught when Exception is not thrown</ShortDescription>
    <LongDescription>在{1}中未抛出异常时捕获异常</LongDescription>
    <Details>
  <![CDATA[<p>此方法使用捕获Exception对象的try-catch块，但不会在try块中引发Exception，也不会显式捕获RuntimeException。一种常见的错误模式是，将try{…}catch（Exception e）{something}作为捕获许多类型的异常的简写，这些异常的catch块都是相同的，但这个构造也意外地捕获了RuntimeException，从而掩盖了潜在的错误</p> <p>更好的方法是显式捕获抛出的特定异常，或者显式捕获RuntimeException异常，重新抛出它，然后捕获所有非运行时异常，如下所示：catch（Exception e）{…处理所有非运行时异常…}</code></pre>]]>
     </Details>
  </BugPattern>
  <BugPattern type="FE_TEST_IF_EQUAL_TO_NOT_A_NUMBER">
    <ShortDescription>与NaN相等的末日考验  Doomed test for equality to NaN</ShortDescription>
    <LongDescription>{1}中NaN相等的注定测试</LongDescription>
    <Details>
   <![CDATA[<p>此代码检查浮点值是否等于特殊的非a数字值（例如，<code>if（x==Double.NaN）</code>）。但是，由于<code>NaN</code>的特殊语义，没有值等于<code>NaN</code>，包括<code]NaN</code>。因此，<code>x==双精度。NaN</code>的计算结果始终为false。要检查<code>x</code>中包含的值是否是特殊的Not a Number值，请使用<code>Double。isNaN（x）</code>（如果<code>x</code>=浮点精度，则<code>Float.isNaN（x）</code>）</p>]]>
     </Details>
  </BugPattern>
  <BugPattern type="FE_FLOATING_POINT_EQUALITY">
    <ShortDescription>浮点相等性测试  Test for floating point equality</ShortDescription>
    <LongDescription>{1}中浮点相等性的测试</LongDescription>
    <Details>
   <![CDATA[<p>此操作比较两个浮点值是否相等。由于浮点计算可能涉及舍入，因此计算的浮点值和双精度值可能不准确。对于必须精确的值，例如货币值，请考虑使用固定精度类型，例如BigDecimal。对于不需要精确的值，请考虑比较某个范围内的相等性，例如：<code>if（Math.abs（x-y）&lt。0000001）</code>。请参阅Java语言规范第4.2.4节</p>]]>
     </Details>
  </BugPattern>
  <BugPattern type="UM_UNNECESSARY_MATH">
    <ShortDescription>方法对常量值调用静态Math类方法  Method calls static Math class method on a constant value</ShortDescription>
    <LongDescription>方法对常量值调用静态Math类方法</LongDescription>
    <Details>
<![CDATA[<p>此方法在常量值上使用java.lang.Path中的静态方法。在这种情况下，这种方法的结果可以静态确定，并且只使用常数更快，有时更准确。检测方法包括：方法参数<td>0.0</td></tr>cbrt</td>0.0或1.0</tr><tr><td>coss</td><td>0.0</td>/tr><tr><td>log10或1.0</tr><tr><td>sin</td><td>0.0</td>tr><tr><td>到Radians]]>
    </Details>
  </BugPattern>
  <BugPattern type="CD_CIRCULAR_DEPENDENCY">
    <ShortDescription>测试类之间的循环依赖关系  Test for circular dependencies among classes</ShortDescription>
    <LongDescription>类{0}与其他类具有循环依赖关系</LongDescription>
    <Details>
   <![CDATA[<p>这个类与其他类有循环依赖关系。这使得构建这些类很困难，因为每个类都依赖于其他类来正确构建。考虑使用接口来打破硬依赖</p>]]>
     </Details>
  </BugPattern>
  <BugPattern type="RI_REDUNDANT_INTERFACES">
    <ShortDescription>类实现与超类相同的接口  Class implements same interface as superclass</ShortDescription>
    <LongDescription>类{0}实现与超类相同的接口</LongDescription>
    <Details>
   <![CDATA[<p>这个类声明它实现了一个也由超类实现的接口。这是多余的，因为一旦一个超类实现了一个接口，默认情况下所有子类也都实现了这个接口。它可能指出，自创建该类以来，继承层次结构已经发生了变化，应该考虑接口实现的所有权</p>]]>
     </Details>
  </BugPattern>
  <BugPattern type="MTIA_SUSPECT_STRUTS_INSTANCE_FIELD">
    <ShortDescription>类扩展Struts-Action类并使用实例变量  Class extends Struts Action class and uses instance variables</ShortDescription>
    <LongDescription>类{0}扩展了Struts-Action类并使用实例变量</LongDescription>
    <Details>
   <![CDATA[<p>此类从Struts Action类扩展而来，并使用实例成员变量。由于struts框架只创建了struts Action类的一个实例，并以多线程的方式使用，因此这种范式非常不可取，而且很可能存在问题。考虑只使用方法局部变量。只报告在监控器外部写入的实例字段</p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="MTIA_SUSPECT_SERVLET_INSTANCE_FIELD">
    <ShortDescription>类扩展Servlet类并使用实例变量  Class extends Servlet class and uses instance variables</ShortDescription>
    <LongDescription>类{0}扩展Servlet类并使用实例变量</LongDescription>
    <Details>
   <![CDATA[<p>此类从Servlet类扩展而来，并使用实例成员变量。由于J2EE框架只创建了Servlet类的一个实例，并以多线程的方式使用，因此强烈建议不要使用这种范式，而且很可能存在问题。考虑只使用方法局部变量</p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="PS_PUBLIC_SEMAPHORES">
    <ShortDescription>类在其公共接口中公开同步和信号量  Class exposes synchronization and semaphores in its public interface</ShortDescription>
    <LongDescription>类{0}在其公共接口中公开同步和信号量</LongDescription>
    <Details>
   <![CDATA[<p>此类将同步与wait（）、notify（）或notifyAll（）一起用于自身（此引用）。此外，使用此类的客户端类可以将此类的实例用作同步对象。因为两个类使用同一对象进行同步，所以多线程的正确性值得怀疑。您不应该对公共引用同步或调用信号量方法。考虑使用内部私有成员变量来控制同步</p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="ICAST_INTEGER_MULTIPLY_CAST_TO_LONG">
    <ShortDescription>整数乘法转换为long的结果  Result of integer multiplication cast to long</ShortDescription>
    <LongDescription>{1}中整数乘法强制转换为long的结果</LongDescription>
    <Details>
<![CDATA[<p>此代码执行整数乘法，然后将结果转换为long，如：</p><pre><code>long convertDaysToMilliseconds（int days）{return 1000*3600*24*days；}</code></pre><p>如果乘法是使用长算术完成的，则可以避免结果溢出的可能性。例如，您可以将上述代码修复为：</p><pre><code>long convertDaysToMilliseconds（int days）{return 1000L*3600*24*days；}</code></pre><p>或</p><pre><code>静态最终长MILLISECONDS_PER_DAY=24L*3600*1000；long convertDaysTo毫秒（int天）{return days*MILLISECONDS_PER_DAY；}</代码></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_INT_2_LONG_AS_INSTANT">
    <ShortDescription>int值转换为long并用作绝对时间  int value converted to long and used as absolute time</ShortDescription>
    <LongDescription>int转换为long并作为绝对时间传递给{1}中的{2}</LongDescription>
    <Details>
<![CDATA[<p>此代码将32位int值转换为64位长的值，然后为需要绝对时间值的方法参数传递该值。绝对时间值是自称为“epoch”的标准基准时间（即1970年1月1日00:00:00 GMT）以来的毫秒数。例如，以下用于将epoch以来的秒数转换为Date的方法严重损坏：</p><pre><code>Date getDate（int seconds）{return new Date（seconds*1000）；}</code></pre><p>乘法是使用32位算术完成的，然后转换为64位值。当32位值转换为64位并用于表示绝对时间值时，只能表示1969年12月和1970年1月的日期</p> <p>上述方法的正确实现是：</p><pre><code>//对于2037年之后的日期getDate（int seconds）{return new Date（seconds*1000L）；}//更好，适用于所有日期Date getDate（长秒）{return new Date（秒*1000）；}</代码></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND">
    <ShortDescription>int值转换为float，然后传递给Math.round  int value cast to float and then passed to Math.round</ShortDescription>
    <LongDescription>int值强制转换为float，然后传递给Math。取整{1}</LongDescription>
    <Details>
<![CDATA[<p>这段代码将int值转换为浮点精度浮点数，然后将结果传递给Math。函数，它返回最接近参数的int/long。此操作应始终为无运算，因为将整数转换为浮点时应给出一个不含小数部分的数字。很可能是生成要传递给Math的值的操作。round旨在使用浮点算法执行</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL">
    <ShortDescription>整数值转换为double，然后传递给Math.ceil  Integral value cast to double and then passed to Math.ceil</ShortDescription>
    <LongDescription>整数值转换为double，然后传递给Math。{1}中的天花板</LongDescription>
    <Details>
<![CDATA[<p>此代码将整数值（例如int或long）转换为双精度浮点数，然后将结果传递给Math。ceil（）函数，它将双精度值舍入到下一个更高的整数值。此操作应始终为no-op，因为将整数转换为double时应给出一个没有小数部分的数字。很可能是生成要传递给Math的值的操作。ceil旨在使用双精度浮点运算执行</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_IDIV_CAST_TO_DOUBLE">
    <ShortDescription>积分除法结果转换为双精度或浮点  Integral division result cast to double or float</ShortDescription>
    <LongDescription>整数除法结果强制转换为{1}中的双精度或浮点</LongDescription>
    <Details>
<![CDATA[<p>此代码将整数除法（例如int或long除法）运算的结果强制转换为double或float。对整数进行除法会将结果截断为最接近零的整数值。结果是加倍，这一事实表明应该保留这种精度。可能的意思是在</em>执行除法之前，将一个或两个操作数转换为加倍<em>。下面是一个示例：</p><pre><code>int x=2；整数y=5；//错误：结果为0.0双精度值1=x/y；//右：结果为0.4 double value2=x/（double）y</代码></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION">
    <ShortDescription>将非序列化对象存储到HttpSession  Store of non serializable object into HttpSession</ShortDescription>
    <LongDescription>将非序列化{2}存储到{1}中的HttpSession</LongDescription>
    <Details>
<![CDATA[<p>此代码似乎正在将非序列化对象存储到HttpSession中。如果此会话被钝化或迁移，将导致错误</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_NONSERIALIZABLE_OBJECT_WRITTEN">
    <ShortDescription>写入ObjectOutput的非序列化对象  Non serializable object written to ObjectOutput</ShortDescription>
    <LongDescription>写入{1}中ObjectOutput的非序列化{2}</LongDescription>
    <Details>
<![CDATA[<p>此代码似乎正在将非序列化对象传递给ObjectOutput。writeObject方法。如果对象确实不可序列化，则会导致错误</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="VA_FORMAT_STRING_USES_NEWLINE">
    <ShortDescription>格式字符串应使用%n而不是\n  Format string should use %n rather than \n</ShortDescription>
    <LongDescription>格式字符串应使用%n而不是{1}中的\n</LongDescription>
    <Details>
<![CDATA[<p>此格式字符串包含换行符（\n）。在格式化字符串中，通常最好使用%n，它将产生特定于平台的行分隔符</p>]]>
     </Details>
  </BugPattern>
  <BugPattern type="VA_PRIMITIVE_ARRAY_PASSED_TO_OBJECT_VARARG">
    <ShortDescription>传递给函数的基元数组需要数量可变的对象参数  Primitive array passed to function expecting a variable number of object arguments</ShortDescription>
    <LongDescription>{2} 传递给{1}中的varargs方法{3}</LongDescription>
    <Details>
<![CDATA[<p>这段代码将一个基元数组传递给一个接受数量可变的对象参数的函数。这将创建一个长度为1的数组来保存基元数组并将其传递给函数</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS">
    <ShortDescription>Equals方法不应假定其参数的类型  Equals method should not assume anything about the type of its argument</ShortDescription>
    <LongDescription>{0}的Equals方法假定参数的类型为{0.givenClass}</LongDescription>
    <Details>
<![CDATA[<p><code>equals（Object o）</code>方法不应该对<code>o的类型做出任何假设。如果<code>o</code>与<code>this</code]不是同一类型，它应该只返回false</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_BAD_CAST_TO_ABSTRACT_COLLECTION">
    <ShortDescription>对抽象集合的强制转换有问题  Questionable cast to abstract collection</ShortDescription>
    <LongDescription>从Collection到{1}中的抽象类{3}的强制转换有问题</LongDescription>
    <Details>
<![CDATA[<p>此代码将Collection转换为抽象集合（例如<code>List</code>、<code>Set</code]或<code=Map</code>>）。确保可以保证对象是要强制转换到的类型。如果只需要能够遍历集合，则无需将其强制转换到Set或List</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_IMPOSSIBLE_CAST_PRIMITIVE_ARRAY">
    <ShortDescription>涉及基元数组的不可能强制转换  Impossible cast involving primitive array</ShortDescription>
    <LongDescription>{1}中涉及基元数组的不可能强制转换</LongDescription>
    <Details>
<![CDATA[<p>此强制转换将始终抛出ClassCastException</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_IMPOSSIBLE_CAST">
    <ShortDescription>不可能的铸造  Impossible cast</ShortDescription>
    <LongDescription>在{1}中不可能从{2}强制转换为{3}</LongDescription>
    <Details>
<![CDATA[<p>此强制转换将始终抛出ClassCastException。SpotBugs跟踪来自instanceof检查的类型信息，还使用关于从方法返回和从字段加载的值类型的更精确信息。因此，它可能具有更精确的信息，而不仅仅是变量的声明类型，并且可以使用此信息来确定强制转换在运行时总是抛出异常</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_IMPOSSIBLE_DOWNCAST">
    <ShortDescription>不可能的沮丧  Impossible downcast</ShortDescription>
    <LongDescription>{1}中不可能从{2}向下投射到{3}</LongDescription>
    <Details>
<![CDATA[<p>此强制转换将始终抛出ClassCastException。分析认为，它知道要转换的值的精确类型，而将其向下转换为子类型的尝试总是会因抛出ClassCastException而失败</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_IMPOSSIBLE_DOWNCAST_OF_TOARRAY">
    <ShortDescription>toArray（）结果不可能向下转换  Impossible downcast of toArray() result</ShortDescription>
    <LongDescription>toArray（）无法向下转换，导致{1}中的{3}</LongDescription>
    <Details>
<![CDATA[<p>此代码将集合上调用<code>toArray（）</code>的结果强制转换为比<code>Object[]更具体的类型，如：</p><pre><code]String[]getAsArray（collection&lt；String&gt；c）{return（String[]）c.toArray）；}</code></pre><p>这通常会因抛出ClassCastException而失败。几乎所有集合的<code>toArray（）</code>都会返回<code>Object[]</code>。它们实际上不能做任何其他事情，因为Collection对象没有引用声明的集合泛型类型<p> 从集合中获取特定类型数组的正确方法是使用<code>c。toArray（新字符串[]）</code>或<code>c。toArray（新字符串[c.size（）]）</code>（后者效率稍高）<p> 对此有一个常见/已知的例外。Arrays.asList（…）</code>返回的列表的<code>toArray（）</code>方法将返回协变类型的数组。例如，<code>Arrays。asArray（新String[]{“a”}）。toArray（）</code>将返回<code>String[]</code>。SpotBugs试图检测和抑制此类情况，但可能会漏掉一些</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_INSTANCEOF">
    <ShortDescription>检查已知的null值以查看它是否是类型的实例  A known null value is checked to see if it is an instance of a type</ShortDescription>
    <LongDescription>检查一个已知的空值，看它是否是{1}中{2}的实例</LongDescription>
    <Details>
<![CDATA[<p>此测试实例将始终返回false，因为被检查的值保证为null。尽管这是安全的，但请确保这不是误解或其他逻辑错误的迹象</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_NULL_INSTANCEOF" deprecated="true"> <!-- deprecated in favor of NP_NULL_INSTANCEOF -->
    <ShortDescription>检查已知的null值以查看它是否是类型的实例  A known null value is checked to see if it is an instance of a type</ShortDescription>
    <LongDescription>检查一个已知的空值，看它是否是{1}中{2}的实例</LongDescription>
    <Details>
<![CDATA[<p>此测试实例将始终返回false，因为被检查的值保证为null。尽管这是安全的，但请确保这不是误解或其他逻辑错误的迹象</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_IMPOSSIBLE_INSTANCEOF">
    <ShortDescription>instanceof将始终返回false  instanceof will always return false</ShortDescription>
    <LongDescription>instanceof在{1}中总是返回false，因为{2}不能是{3}</LongDescription>
    <Details>
<![CDATA[<p>此测试实例将始终返回false。尽管这是安全的，但请确保这不是误解或其他逻辑错误的迹象</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_VACUOUS_INSTANCEOF">
    <ShortDescription>instanceof将始终返回true  instanceof will always return true</ShortDescription>
    <LongDescription>instanceof将始终为{1}中的所有非空值返回true，因为所有{2}都是{3}的实例</LongDescription>
    <Details>
<![CDATA[<p>此测试实例将始终返回true（除非测试的值为null）。尽管这是安全的，但请确保这不是误解或其他逻辑错误的迹象。如果您真的想测试该值是否为null，那么最好做一个null测试，而不是instanceof测试</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_UNCONFIRMED_CAST">
    <ShortDescription>未选中/未确认转换  Unchecked/unconfirmed cast</ShortDescription>
    <LongDescription>{1}中从{2}到{3}的未选中/未确认转换</LongDescription>
    <Details>
<![CDATA[<p>此强制转换未选中，并且不是从中强制转换的类型的所有实例都可以强制转换为要强制转换到的类型。请检查您的程序逻辑以确保此强制转换不会失败</p>]]>
    </Details>
  </BugPattern>
   <BugPattern type="BC_UNCONFIRMED_CAST_OF_RETURN_VALUE">
    <ShortDescription>方法返回值的未选中/未确认转换  Unchecked/unconfirmed cast of return value from method</ShortDescription>
    <LongDescription>{1}中返回值的{2}到{3}的未选中/未确认转换</LongDescription>
    <Details>
<![CDATA[<p>此代码对方法的返回值执行未经检查的强制转换。代码调用方法的方式可能会确保强制转换是安全的，但SpotBugs无法验证强制转换是否安全。检查您的程序逻辑以确保此转换不会失败</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_BAD_CAST_TO_CONCRETE_COLLECTION">
    <ShortDescription>可疑混凝土浇筑集合  Questionable cast to concrete collection</ShortDescription>
    <LongDescription>{1}中从{2}到{3}的转换有问题</LongDescription>
    <Details>
<![CDATA[<p>此代码将抽象集合（如collection、List或Set）强制转换为特定的具体实现（如ArrayList或HashSet）。这可能是不正确的，并且可能会使代码变得脆弱，因为这使得在将来很难切换到其他具体实现。除非您有特殊的原因，否则只需使用抽象集合类</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RE_POSSIBLE_UNINTENDED_PATTERN">
    <ShortDescription>“.”或“|”用于正则表达式  "." or "|" used for regular expression</ShortDescription>
    <LongDescription>“.”或“|”用于{1}中的正则表达式</LongDescription>
    <Details>
<![CDATA[<p>正在调用String函数，并将“.”或“|”传递给以正则表达式作为参数的参数。这是你想要的吗？例如，</p><ul><li>s.replaceAll（“.”，“/”）将返回一个String，其中<em>每个</em>字符都被一个'/'字符替换</li><li>s.split（“..”）<em>始终返回一个字符串</li><li>“ab|cd”的零长度数组。replaceAll（“|”，“/”）将返回“/a/b/|/c/d/”</li><li>“ab|cd”。split（“|”）将返回带有六个（！）的数组元素：[，a，b，|，c，d]</li></ul>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION">
    <ShortDescription>正则表达式的语法无效  Invalid syntax for regular expression</ShortDescription>
    <LongDescription>{1}中正则表达式的语法无效</LongDescription>
    <Details>
<![CDATA[<p>根据正则表达式的语法，此处的代码使用的正则表达式无效。此语句在执行时将抛出PatternSyntaxException</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION">
    <ShortDescription>文件用于正则表达式的分隔符  File.separator used for regular expression</ShortDescription>
    <LongDescription>文件{1}中用于正则表达式的分隔符</LongDescription>
    <Details>
<![CDATA[<p>此处的代码使用<code>File。separator</code>，其中需要正则表达式。这在Windows平台上会失败，其中<code>File。分隔符</code>是一个反斜杠，在正则表达式中它被解释为转义字符。在其他选项中，您可以只使用<code>File。separatorChar=='\\'？“\\\\”：文件。分隔符</code>而不是<code>File。分隔符</code></p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DLS_OVERWRITTEN_INCREMENT">
    <ShortDescription>覆盖的增量  Overwritten increment</ShortDescription>
    <LongDescription>{1}中覆盖的增量</LongDescription>
    <Details>
<![CDATA[<p>代码执行递增/递减操作（例如，<code>i++</code>/<code>i-->/code>），然后立即覆盖它。例如，<code>i=i++</code>/<code>i=i-</code>立即用原始值覆盖递增/递减的值</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT">
    <ShortDescription>无符号右移转换为短/字节  Unsigned right shift cast to short/byte</ShortDescription>
    <LongDescription>{1}中无符号右移强制转换为短/字节</LongDescription>
    <Details>
<![CDATA[<p>代码执行无符号右移，然后将其结果转换为短或字节，丢弃结果的高位。由于高位被丢弃，有符号右移和无符号右移之间可能没有差异（取决于移位的大小）</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BSHIFT_WRONG_ADD_PRIORITY">
    <ShortDescription>移位操作可能分析错误  Possible bad parsing of shift operation</ShortDescription>
    <LongDescription>{1}中移位操作的可能分析错误</LongDescription>
    <Details>
<![CDATA[<p>代码执行类似于（x&lt；&lt；8+y）的操作。虽然这可能是正确的，但它可能是为了执行（x&lt；&lt；8）+y，但移位操作的优先级较低，因此它实际上被解析为x&lt&书信电报；（8+年）</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_BAD_SHIFT_AMOUNT">
    <ShortDescription>32位int移位量不在-31..31范围内  32 bit int shifted by an amount not in the range -31..31</ShortDescription>
    <LongDescription>{1}中32位int移位了{2}位</LongDescription>
    <Details>
<![CDATA[<p>该代码按-31..31范围外的常量对32位int进行移位。其效果是使用整数值的较低5位来决定移位量（例如，移位40位与移位8位相同，移位32位与移位零位相同）。这可能不是预期的，至少让人感到困惑</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IM_MULTIPLYING_RESULT_OF_IREM">
    <ShortDescription>整数余数结果的整数倍  Integer multiply of result of integer remainder</ShortDescription>
    <LongDescription>{1}中整数余数结果的整数倍</LongDescription>
    <Details>
<![CDATA[<p>该代码将剩余整数的结果乘以一个整数常量。确保没有混淆运算符优先级。例如，i%60*1000是（i%60）*1000，而不是i%（60*1000）</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_INVOKING_HASHCODE_ON_ARRAY">
    <ShortDescription>在数组上调用hashCode  Invocation of hashCode on an array</ShortDescription>
    <LongDescription>对{1}中的数组调用hashCode</LongDescription>
    <Details>
<![CDATA[<p>代码在数组上调用hashCode。对数组调用hashCode将返回与System相同的值。identityHashCode，并忽略数组的内容和长度。如果需要依赖于数组内容的hashCode，请使用<code>java.util.Arrays.hashCode（a）</code></p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_INVOKING_TOSTRING_ON_ARRAY">
    <ShortDescription>在数组上调用toString  Invocation of toString on an array</ShortDescription>
    <LongDescription>在{1}中的{2.givenClass}上调用toString</LongDescription>
    <Details>
<![CDATA[<p>代码对数组调用toString，这将生成一个非常无用的结果，例如[C@16f0472.考虑使用数组。toString，将数组转换为一个可读的String，它给出了数组的内容。参见编程难题，第3章，难题12</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_INVOKING_TOSTRING_ON_ANONYMOUS_ARRAY">
    <ShortDescription>在未命名数组上调用toString  Invocation of toString on an unnamed array</ShortDescription>
    <LongDescription>对{1}中的未命名数组调用toString</LongDescription>
    <Details>
<![CDATA[<p>代码在（匿名）数组上调用toString。对数组调用toString会生成一个非常无用的结果，例如[C@16f0472.考虑使用数组。toString，将数组转换为一个可读的String，它给出了数组的内容。参见编程难题，第3章，难题12</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IM_AVERAGE_COMPUTATION_COULD_OVERFLOW">
    <ShortDescription>平均可能溢出的计算  Computation of average could overflow</ShortDescription>
    <LongDescription>{1}中平均可能溢出的计算</LongDescription>
    <Details>
<![CDATA[<p>该代码使用除法或有符号右移计算两个整数的平均值，然后将结果用作数组的索引。如果平均值非常大，则可能溢出（导致计算负平均值）。假设结果是非负的，您可以改用无符号右移。换句话说，与其使用<code>（low+high）/2</code>，不如使用<code>（low+high）&gt&gt&gt；1</code></p><p>此错误存在于许多早期的二进制搜索和合并排序实现中。Martin Buchholz<a href=“http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6412541“>在JDK库中找到并修复了它，Joshua Bloch</a href=”http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html“>广泛宣传了bug模式</a></p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IM_BAD_CHECK_FOR_ODD">
    <ShortDescription>检查不适用于负数的奇异性  Check for oddness that won't work for negative numbers</ShortDescription>
    <LongDescription>检查{1}中不适用于负数的奇异性</LongDescription>
    <Details>
<![CDATA[<p>代码使用x%2==1检查值是否为奇数，但这对负数无效（例如，（-5）%2==-1）。如果此代码打算检查异常，请考虑使用x&amp；1==1，或x%2！=0</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_HARDCODED_ABSOLUTE_FILENAME">
    <ShortDescription>代码包含对绝对路径名的硬编码引用  Code contains a hard coded reference to an absolute pathname</ShortDescription>
    <LongDescription>{1}中对绝对路径名的硬编码引用</LongDescription>
    <Details>
<![CDATA[<p>这段代码使用硬编码的绝对路径名构造File对象（例如，<code>new File（“/home/dannyc/workspace/j2ee/src/share/com/sun/enterprise/deployment”）</代码></p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_BAD_MONTH">
    <ShortDescription>月份的常量值错误  Bad constant value for month</ShortDescription>
    <LongDescription>传递给{1}中{3}的{2}的月份值不正确</LongDescription>
    <Details>
<![CDATA[<p>此代码将超出预期范围0..11的常量月值传递给方法</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_USELESS_SUBSTRING">
    <ShortDescription>调用子字符串（0），它返回原始值  Invocation of substring(0), which returns the original value</ShortDescription>
    <LongDescription>{1} 调用子字符串（0），它返回原始值</LongDescription>
    <Details>
<![CDATA[<p>这段代码调用String上的子字符串（0），它返回原始值</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_CALLING_NEXT_FROM_HASNEXT">
    <ShortDescription>hasNext方法调用next  hasNext method invokes next</ShortDescription>
    <LongDescription>{1} 调用{2.givenClass}</LongDescription>
    <Details>
<![CDATA[<p>hasNex（）方法调用next（）方法。这几乎肯定是错误的，因为hasNext（）方法不应该更改迭代器的状态，而下一个方法应该更改迭代器的状态</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SWL_SLEEP_WITH_LOCK_HELD">
    <ShortDescription>方法调用Thread。持有锁的sleep（）  Method calls Thread.sleep() with a lock held</ShortDescription>
    <LongDescription>{1} 调用线程。持有锁的sleep（）</LongDescription>
    <Details>
      <![CDATA[<p>此方法调用Thread。持有锁的sleep（）。这可能导致性能和可伸缩性非常差，或者死锁，因为其他线程可能正在等待获取锁。最好对锁调用wait（），这样可以释放锁并允许其他线程运行</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="DB_DUPLICATE_BRANCHES">
    <ShortDescription>方法对两个分支使用相同的代码  Method uses the same code for two branches</ShortDescription>
    <LongDescription>{1} 对两个分支使用相同的代码</LongDescription>
    <Details>
      <![CDATA[<p>此方法使用相同的代码实现条件分支的两个分支。检查以确保这不是编码错误</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="DB_DUPLICATE_SWITCH_CLAUSES">
    <ShortDescription>方法对两个switch子句使用相同的代码  Method uses the same code for two switch clauses</ShortDescription>
    <LongDescription>{1} 对两个switch子句使用相同的代码</LongDescription>
    <Details>
      <![CDATA[<p>此方法使用相同的代码实现switch语句的两个子句。这可能是重复代码的情况，但也可能表示编码错误</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="IMA_INEFFICIENT_MEMBER_ACCESS">
    <ShortDescription>方法访问所属类的私有成员变量  Method accesses a private member variable of owning class</ShortDescription>
    <LongDescription>{1} 访问所属类的私有成员变量</LongDescription>
    <Details>
      <![CDATA[<p>内部类的此方法读取或写入所属类的私有成员变量，或调用所属类中的私有方法。编译器必须生成一个特殊方法来访问这个私有成员，这会降低效率。放松成员变量或方法的保护将允许编译器将其视为正常访问</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="XFB_XML_FACTORY_BYPASS">
    <ShortDescription>方法直接分配xml接口的特定实现  Method directly allocates a specific implementation of xml interfaces</ShortDescription>
    <LongDescription>{1} 直接分配xml接口的特定实现</LongDescription>
    <Details>
      <![CDATA[<p>此方法分配xml接口的特定实现。最好使用提供的工厂类来创建这些对象，以便可以在运行时更改实现。请参阅</p><ul><li>javax.xml.parsers。DocumentBuilderFactory</li><li>javax.xml.parsers。SAXParserFactory</li><li>javax.xml.transform。TransformerFactory</li><li>org.w3c.dom.Document公司。创建<i>XXXX</i></li></ul><p>了解详细信息</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="USM_USELESS_SUBCLASS_METHOD">
    <ShortDescription>方法多余地委托给父类方法  Method superfluously delegates to parent class method</ShortDescription>
    <LongDescription>{1} 多余地委托给父类方法</LongDescription>
    <Details>
      <![CDATA[<p>这个派生方法只调用相同的超类方法，传递接收到的确切参数。此方法可以删除，因为它不提供任何附加值</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="USM_USELESS_ABSTRACT_METHOD">
    <ShortDescription>抽象方法已在实现的接口中定义  Abstract Method is already defined in implemented interface</ShortDescription>
    <LongDescription>抽象方法{1}已在实现的接口中定义</LongDescription>
    <Details>
      <![CDATA[<p>这个抽象方法已经在这个抽象类实现的接口中定义。此方法可以删除，因为它不提供任何附加值</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CI_CONFUSED_INHERITANCE">
    <ShortDescription>类是最终的，但声明了受保护字段  Class is final but declares protected field</ShortDescription>
    <LongDescription>类{0}是最终类，但声明了受保护字段{1}</LongDescription>
    <Details>
      <![CDATA[<p>此类声明为final，但声明要保护的字段。由于该类是final类，因此无法从中派生，并且protected的用法令人困惑。字段的访问修饰符应更改为private或public，以表示字段的真正用途</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="QBA_QUESTIONABLE_BOOLEAN_ASSIGNMENT">
    <ShortDescription>方法在布尔表达式中指定布尔文字  Method assigns boolean literal in boolean expression</ShortDescription>
    <LongDescription>{1} 在布尔表达式中指定布尔文字</LongDescription>
    <Details>
      <![CDATA[<p>此方法将文字布尔值（true或false）分配给if或while表达式内的布尔变量。很可能这应该是使用==的布尔比较，而不是使用=的赋值</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="VR_UNRESOLVABLE_REFERENCE">
    <ShortDescription>类引用了无法解析的类或方法  Class makes reference to unresolvable class or method</ShortDescription>
    <LongDescription>{0}对{1}的引用无法解析</LongDescription>
    <Details>
      <![CDATA[<p>这个类引用了一个类或方法，该类或方法无法通过分析它所使用的库来解析</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="GC_UNCHECKED_TYPE_IN_GENERIC_CALL">
    <ShortDescription>泛型调用中未选中的类型  Unchecked type in generic call</ShortDescription>
    <LongDescription>在{1}中需要{3.givenClass}类型的地方提供了Object类型的未选中参数</LongDescription>
    <Details>
     <![CDATA[<p>对泛型集合方法的此调用在编译类型Object时传递参数，其中需要泛型类型参数中的特定类型。因此，无论是标准Java类型系统还是静态分析，都无法提供关于作为参数传递的对象是否属于适当类型的有用信息</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="GC_UNRELATED_TYPES">
    <ShortDescription>泛型参数和方法参数之间没有关系  No relationship between generic parameter and method argument</ShortDescription>
    <LongDescription>{2.givenClass}与{1}中预期的参数类型{3.givenClass{不兼容</LongDescription>
    <Details>
     <![CDATA[<p>对泛型集合方法的此调用包含一个参数，该参数的类与集合参数的类不兼容（即，参数的类型既不是父类型，也不是相应泛型类型参数的子类型）。因此，集合不太可能包含任何与此处使用的方法参数相等的对象。最有可能的是，传递给方法的值是错误的</p> <p>通常，两个不相关类的实例不相等。例如，如果<code>Foo</code>和<code>Bar</code>classes不通过子类型关联，则<code]Foo</code>的实例不应等于<code>0.05 Bar的实例。在其他问题中，这样做可能会导致一个非对称的equals方法。例如，如果您定义了<code>Foo</code>类，以便<code>Foo</code>可以等于<code]String</code>，那么您的等于方法是不对称的，因为<code=String</code>String只能等于<code>String</code></p> <p>在极少数情况下，人们确实定义了非对称的equals方法，但仍然设法使他们的代码工作。尽管没有任何API记录或保证它，但通常情况下，如果您检查<code>Collection&lt；字符串&gt</code>包含一个<code>Foo</code>，这是一个用于执行相等检查的参数的等于方法（例如，<code>Foo</code>类的等于方法）</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_COLLECTIONS_SHOULD_NOT_CONTAIN_THEMSELVES">
    <ShortDescription>集合不应包含自身  Collections should not contain themselves</ShortDescription>
    <LongDescription>集合不应在对{2.givenClass}的调用中包含自己</LongDescription>
    <Details>
     <![CDATA[<p>只有当集合包含自身时（例如，如果<code>s.contains（s）</code>为true），对泛型集合方法的调用才有意义。这不太可能是真的，如果是真的话，可能会导致问题（例如哈希代码的计算导致无限递归）。很可能将错误的值作为参数传递</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_VACUOUS_SELF_COLLECTION_CALL">
    <ShortDescription>虚调用集合  Vacuous call to collections</ShortDescription>
    <LongDescription>对于任何集合c，调用c.{2.name}（c）都没有意义</LongDescription>
    <Details>
     <![CDATA[<p>这个电话没有意义。对于任何集合<code>c</code>，调用<code>c。containsAll（c）</code>应始终为true，<code>c。retainAll（c）</code>应无效</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="PZ_DONT_REUSE_ENTRY_OBJECTS_IN_ITERATORS">
    <ShortDescription>不要在迭代器中重用条目对象  Don't reuse entry objects in iterators</ShortDescription>
    <LongDescription>{0}既是迭代器又是Map.Entry</LongDescription>
    <Details>
     <![CDATA[<p>entrySet（）方法可以返回底层Map的视图，其中包含Iterator和Map.Entry。这个聪明的想法在几个Map实现中得到了应用，但也引入了严重编码错误的可能性。如果map<code>m</code>返回entrySet的迭代器，那么<code>c.addAll（m.entrySet（））</code>将出现严重错误。OpenJDK1.7中的所有Map实现都已重写以避免这种情况，您应该这样做</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_ENTRY_SETS_MAY_REUSE_ENTRY_OBJECTS">
    <ShortDescription>由于entry对象的重用，添加条目集的元素可能会失败  Adding elements of an entry set may fail due to reuse of Entry objects</ShortDescription>
    <LongDescription>由于重复使用{2.simpleClass}，添加条目集的元素可能会失败。{1}中的条目对象</LongDescription>
    <Details>
     <![CDATA[<p>entrySet（）方法可以返回底层Map的视图，其中在迭代期间重用并返回单个Entry对象。在Java1.6中，IdentityHashMap和EnumMap都是这样做的。在迭代这样的Map时，Entry值仅在您前进到下一次迭代之前有效。例如，如果您尝试将这样的entrySet传递给addAll方法，则会出现严重错误</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="DMI_USING_REMOVEALL_TO_CLEAR_COLLECTION">
    <ShortDescription>不使用removeAll清除集合  Don't use removeAll to clear a collection</ShortDescription>
    <LongDescription>removeAll用于清除{1}中的集合</LongDescription>
    <Details>
     <![CDATA[<p>如果要从集合中删除所有元素，请使用<code>c。清除</code>，而不是<code>c.removeAll（c）</code>。呼叫<code>c。清除集合的removeAll（c）</code>不太清晰，容易受到打字错误的影响，效率较低，对于某些集合，可能会引发<code>ConcurrentModificationException</code></p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="STCAL_STATIC_CALENDAR_INSTANCE">
    <ShortDescription>静态日历字段  Static Calendar field</ShortDescription>
    <LongDescription>{1} 是java.util类型的静态字段。日历，它不是线程安全的</LongDescription>
    <Details>
<![CDATA[<p>即使JavaDoc不包含关于它的提示，日历对于多线程使用来说本质上是不安全的。跨线程边界共享单个实例而不进行适当的同步将导致应用程序的不稳定行为。1.4以下的问题似乎比Java 5下的问题出现得少，在Java 5下，您可能会在sun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate（）中看到随机的ArrayIndexOutOfBoundsExceptions或IndexOutofBoundsExeptions</p> <p>您还可能遇到序列化问题</p> <p>建议使用实例字段</p> <p>有关详细信息，请参见<a href=“http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6231579“>JDK Bug#6231579</a>和<a href=”http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6178997“>JDK错误号6178997</a></p>]]>
</Details>
  </BugPattern>
  <BugPattern type="STCAL_INVOKE_ON_STATIC_CALENDAR_INSTANCE">
    <ShortDescription>调用静态日历  Call to static Calendar</ShortDescription>
    <LongDescription>调用静态java.util的方法。{1}中的日历</LongDescription>
    <Details>
<![CDATA[<p>即使JavaDoc不包含关于它的提示，日历对于多线程使用来说本质上是不安全的。检测器发现对Calendar实例的调用，该调用是通过静态字段获得的。这看起来很可疑</p> <p>有关详细信息，请参见<a href=“http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6231579“>JDK Bug#6231579</a>和<a href=”http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6178997“>JDK错误号6178997</a></p>]]>
</Details>
  </BugPattern>
  <BugPattern type="STCAL_STATIC_SIMPLE_DATE_FORMAT_INSTANCE">
    <ShortDescription>静态日期格式  Static DateFormat</ShortDescription>
    <LongDescription>{1} 是java.text类型的静态字段。DateFormat，它不是线程安全的</LongDescription>
    <Details>
<![CDATA[<p>正如JavaDoc所说，DateFormats对于多线程使用来说本质上是不安全的。跨线程边界共享单个实例而不进行适当的同步将导致应用程序的不稳定行为</p> <p>您还可能遇到序列化问题</p> <p>建议使用实例字段</p> <p>有关详细信息，请参见<a href=“http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6231579“>JDK Bug#6231579</a>和<a href=”http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6178997“>JDK错误号6178997</a></p>]]>
</Details>
  </BugPattern>
  <BugPattern type="STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE">
    <ShortDescription>调用静态DateFormat  Call to static DateFormat</ShortDescription>
    <LongDescription>调用静态java.text的方法。{1}中的日期格式</LongDescription>
    <Details>
<![CDATA[<p>正如JavaDoc所说，DateFormats对于多线程使用来说本质上是不安全的。检测器发现对DateFormat实例的调用，该调用是通过静态字段获得的。这看起来很可疑</p> <p>有关详细信息，请参见<a href=“http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6231579“>JDK Bug#6231579</a>和<a href=”http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6178997“>JDK错误号6178997</a></p>]]>
</Details>
  </BugPattern>
  <BugPattern type="TQ_COMPARING_VALUES_WITH_INCOMPATIBLE_TYPE_QUALIFIERS">
    <ShortDescription>将值与不兼容的类型限定符进行比较  Comparing values with incompatible type qualifiers</ShortDescription>
    <LongDescription>将注释为具有类型限定符{2.simpleName}的值与从未具有该限定符的值进行相等性比较</LongDescription>
    <Details>
      <![CDATA[<p>指定为携带类型限定符注释的值将与从未携带该限定符的值进行比较</p> <p>更准确地说，用类型限定符指定when=ALWAYS的值与同一类型限定符规定when=NEVER的值进行比较</p> <p>例如，假设@NonNegative是类型限定符注释@Negatible的昵称（when=when.NEVER）。以下代码将生成此警告，因为return语句需要一个@NonNegative值，但收到一个标记为@Negative</p> <pre><code>公共布尔示例（@Negative Integer value1，@NonNegativeInteger value2）{return value1.equals（value2）；}</代码></pre>]]>
    </Details>
  </BugPattern>


  <BugPattern type="TQ_ALWAYS_VALUE_USED_WHERE_NEVER_REQUIRED">
    <ShortDescription>注释为带有类型限定符的值，在需要不带该限定符的数值时使用  Value annotated as carrying a type qualifier used where a value that must not carry that qualifier is required</ShortDescription>
    <LongDescription>注释为携带类型限定符{2.simpleName}的值，用于需要不携带该限定符的值的情况</LongDescription>
    <Details>
      <![CDATA[<p>指定为携带类型限定符注释的值在要求该值不携带该注释的位置使用</p> <p>更准确地说，用类型限定符注释的值，指定when=ALWAYS，可以保证达到某个用途，或者在相同类型限定符指定when=NEVER时使用</p> <p>例如，假设@NonNegative是类型限定符注释@Negatible的昵称（when=when.NEVER）。以下代码将生成此警告，因为return语句需要一个@NonNegative值，但收到一个标记为@Negative</p> <pre><code>public@NonNegative Integer示例（@NegativeInteger值）{return value；}</代码></pre>]]>
    </Details>
  </BugPattern>


  <BugPattern type="TQ_UNKNOWN_VALUE_USED_WHERE_ALWAYS_STRICTLY_REQUIRED">
    <ShortDescription>如果需要值具有类型限定符，则使用不带类型限定符的值  Value without a type qualifier used where a value is required to have that qualifier</ShortDescription>
    <LongDescription>不带类型限定符的值用于需要{2.simpleName}注释的位置</LongDescription>
    <Details>
      <![CDATA[<p>使用值的方式要求使用类型限定符对值进行注释。类型限定符是严格的，因此该工具拒绝任何没有适当注释的值</p> <p>要强制值具有严格注释，请定义一个标识函数，其中返回值用严格注释进行注释。这是将未注释的值转换为具有严格类型限定符注释的值的唯一方法</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="TQ_NEVER_VALUE_USED_WHERE_ALWAYS_REQUIRED">
    <ShortDescription>注释为从不带类型限定符的值，在需要带类型限定词的值时使用  Value annotated as never carrying a type qualifier used where value carrying that qualifier is required</ShortDescription>
    <LongDescription>注释为从不携带类型限定符{2.simpleName}的值，用于需要携带该限定符的值的地方</LongDescription>
    <Details>
      <![CDATA[<p>指定为不携带类型限定符注释的值可以保证在要求该值携带该注释的位置使用</p> <p>更准确地说，使用类型限定符（指定when=NEVER）注释的值可以保证达到use，或者在相同类型限定符指定when=ALWAYS时使用</p> TODO:示例</p>]]>
    </Details>
  </BugPattern>




  <BugPattern type="TQ_MAYBE_SOURCE_VALUE_REACHES_ALWAYS_SINK">
    <ShortDescription>使用可能不包含类型限定符的值时，总是需要该类型限定符  Value that might not carry a type qualifier is always used in a way requires that type qualifier</ShortDescription>
    <LongDescription>可能不带{2.simpleName}注释的值总是以需要该类型限定符的方式使用</LongDescription>
    <Details>
      <![CDATA[<p>一个注释为可能不是类型限定符所表示值的实例的值，并且该值的使用方式保证需要该类型限定符表示的值</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="TQ_MAYBE_SOURCE_VALUE_REACHES_NEVER_SINK">
    <ShortDescription>可能带有类型限定符的值的使用方式总是禁止它具有该类型限定符  Value that might carry a type qualifier is always used in a way prohibits it from having that type qualifier</ShortDescription>
    <LongDescription>可能带有{2.simpleName}注释的值的使用方式总是禁止它具有该类型限定符</LongDescription>
    <Details>
      <![CDATA[<p>注释为可能是由类型限定符表示的值的实例的值，并保证该值的使用方式禁止该类型限定符所表示的值</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_NEVER_SINK">
    <ShortDescription>值需要没有类型限定符，但标记为未知  Value required to not have type qualifier, but marked as unknown</ShortDescription>
    <LongDescription>值永远不需要为{2.simpleName}，但明确注释为{2.simpleName}未知</LongDescription>
    <Details>
      <![CDATA[<p>值的使用方式要求它永远不是由类型限定符表示的值，但有一个明确的注释表示不知道该值在哪里被禁止使用该类型限定符。用法或注释不正确</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_ALWAYS_SINK">
    <ShortDescription>值需要具有类型限定符，但标记为未知  Value required to have type qualifier, but marked as unknown</ShortDescription>
    <LongDescription>值必须始终为{2.simpleName}，但明确注释为{2.simpleName}未知</LongDescription>
    <Details>
      <![CDATA[<p>值的使用方式要求它始终是由类型限定符表示的值，但有一个明确的注释说明，不知道该值需要在哪里具有该类型限定符。用法或注释不正确</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IO_APPENDING_TO_OBJECT_OUTPUT_STREAM">
    <ShortDescription>试图附加到对象输出流的失败尝试  Doomed attempt to append to an object output stream</ShortDescription>
    <LongDescription>试图追加到{1}中的对象输出流的失败尝试</LongDescription>
    <Details>
      <![CDATA[<p>此代码以附加模式打开文件，然后将结果包装到对象输出流中。这将不允许您附加到存储在文件中的现有对象输出流。如果希望能够附加到对象输出流，则需要保持对象输出流打开</p> <p>以追加模式打开文件并写入对象输出流的唯一情况是，如果在读取文件时，您计划以随机访问模式打开文件，并查找追加开始的字节偏移量</p> <p>TODO:示例</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="WL_USING_GETCLASS_RATHER_THAN_CLASS_LITERAL">
    <ShortDescription>同步getClass而不是class literal  Synchronization on getClass rather than class literal</ShortDescription>
    <LongDescription>在{1}中同步getClass而不是类文字</LongDescription>
    <Details>
      <![CDATA[<p>此实例方法在<code>This.getClass（）</code>上同步。如果这个类是子类，子类将在子类的类对象上同步，这不太可能是有意的。例如，考虑java.awt中的这段代码。标签：</p><pre><code>private static final String base=“Label”；私有静态int nameCounter=0；字符串构造函数ComponentName（）{synchronized（getClass（））{return base+nameCounter++；}}</code></pre><p>标签</code>的子类不会在同一个子类上同步，从而导致数据争用。相反，此代码应该在<code>Label上同步。class</code></p><pre><code>private static final String base=“label”；私有静态int nameCounter=0；字符串构造函数ComponentName（）{synchronized（Label.class）{return base+nameCounter++；}}</code></pre><p>Jason Mehrens贡献的Bug模式</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="OBL_UNSATISFIED_OBLIGATION">
    <ShortDescription>方法可能无法清理流或资源  Method may fail to clean up stream or resource</ShortDescription>
    <LongDescription>{1} 可能无法清理{2}</LongDescription>
    <Details>
          <![CDATA[<p>此方法可能无法清理（关闭、处置）流、数据库对象或其他需要显式清理操作的资源</p> <p>通常，如果一个方法打开了一个流或其他资源，该方法应该使用try/finally块来确保在该方法返回之前清除了该流或资源</p> <p>此错误模式本质上与OS_OPEN_STREAM和ODR_OPEN_DATABASE_RESOURCE错误模式相同，但基于不同（希望更好）的静态分析技术。我们感兴趣的是获得关于此错误模式有用性的反馈。要发送反馈，请检查：</p><ul><li><a href=“https://github.com/spotbugs/spotbugs/blob/master/CONTRIBUTING.md“>贡献指南</a></li><li><a href=”https://github.com/spotbugs/discuss/issues?q=“>恶意列表</a></li></ul><p>特别是，此错误模式的假阳性抑制启发法尚未得到广泛调整，因此有关假阳性的报告对我们很有帮助。</p><p><p]有关分析技术的描述，请参阅Weimer and Necula，<i>查找和防止运行时错误处理错误</i></p>]]>
      </Details>
  </BugPattern>




  <BugPattern type="OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE">
    <ShortDescription>方法可能无法清除选中异常的流或资源  Method may fail to clean up stream or resource on checked exception</ShortDescription>
    <LongDescription>{1} 可能无法清除选中异常的{2}</LongDescription>
    <Details>
          <![CDATA[<p>此方法可能无法清理（关闭、处置）流、数据库对象或其他需要显式清理操作的资源</p> <p>通常，如果一个方法打开了一个流或其他资源，该方法应该使用try/finally块来确保在该方法返回之前清除了该流或资源</p> <p>此错误模式本质上与OS_OPEN_STREAM和ODR_OPEN_DATABASE_RESOURCE错误模式相同，但基于不同（希望更好）的静态分析技术。我们感兴趣的是获得关于此错误模式有用性的反馈。要发送反馈，请检查：</p><ul><li><a href=“https://github.com/spotbugs/spotbugs/blob/master/CONTRIBUTING.md“>贡献指南</a></li><li><a href=”https://github.com/spotbugs/discuss/issues?q=“>恶意列表</a></li></ul><p>特别是，此错误模式的假阳性抑制启发法尚未得到广泛调整，因此有关假阳性的报告对我们很有帮助。</p><p><p]有关分析技术的描述，请参阅Weimer and Necula，<i>查找和防止运行时错误处理错误</i></p>]]>
      </Details>
  </BugPattern>















  <BugPattern type="FB_UNEXPECTED_WARNING">
    <ShortDescription>SpotBugs发出意外/意外警告  Unexpected/undesired warning from SpotBugs</ShortDescription>
    <LongDescription>{1}中出现意外/不需要的{2}SpotBugs警告</LongDescription>
    <Details>
          <![CDATA[<p>根据注释的@NoWarning，SpotBugs生成了一个意外或不需要的警告</p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="FB_MISSING_EXPECTED_WARNING">
    <ShortDescription>SpotBugs缺少预期或期望的警告  Missing expected or desired warning from SpotBugs</ShortDescription>
    <LongDescription>{1}中缺少预期或所需的{2}SpotBugs警告</LongDescription>
    <Details>
          <![CDATA[<p>根据注释的@ExpectedWarning，SpotBugs没有生成生成的警告，这是预期的或期望的</p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="RV_RETURN_VALUE_OF_PUTIFABSENT_IGNORED">
    <ShortDescription>忽略了putIfAbsent的返回值，重用了传递给putIf Abcent的值  Return value of putIfAbsent ignored, value passed to putIfAbsent reused</ShortDescription>
    <LongDescription>putIfAbsent的返回值被忽略，但{4}在{1}中被重用</LongDescription>
    <Details>
          <![CDATA[<code>putIfAbsent</code>方法通常用于确保单个值与给定键相关联（put if absent成功的第一个值）。如果忽略返回值并保留对传入值的引用，则可能会保留一个与映射中的键无关的值。如果你使用的是哪一个，而你使用的不是存储在地图中的那个，那么你的程序将不正确。]]>
      </Details>
  </BugPattern>
  <BugPattern type="LG_LOST_LOGGER_DUE_TO_WEAK_REFERENCE">
    <ShortDescription>OpenJDK中的弱引用可能导致记录器更改丢失  Potential lost logger changes due to weak reference in OpenJDK</ShortDescription>
    <LongDescription>对记录器的更改可能在{1}中丢失</LongDescription>
    <Details>
          <![CDATA[<p>OpenJDK引入了潜在的不兼容性。特别是java.util.logging。记录器行为已更改。它现在不再使用强引用，而是在内部使用弱引用。这是一个合理的更改，但不幸的是，一些代码依赖于旧的行为-当更改记录器配置时，它只是删除了记录器引用。这意味着垃圾收集器可以自由回收该内存，这意味着记录器配置丢失。例如考虑：</p><pre><code>public static void initLogging（）throws Exception{Logger Logger=Logger.getLogger（“edu.umd.cs”）；Logger.addHandler（new FileHandler）；//更改记录器配置Logger.setUseParentHandlers（false）；//另一个更改记录器配置的调用}（它不会转义该方法），因此如果在调用initLogging之后有一个垃圾收集周期，那么记录器配置就会丢失（因为logger只保留弱引用）</p> <pre><code>public static void main（String[]args）throws Exception{initLogging（）；//将文件处理程序添加到记录器System.gc（）；//logger configuration loss logger.getLogger（“edu.umd.cs”）.info（“Some message”）；//这没有按预期记录到文件中}</p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="AT_OPERATION_SEQUENCE_ON_CONCURRENT_ABSTRACTION">
    <ShortDescription>并发抽象的调用序列可能不是原子的  Sequence of calls to concurrent abstraction may not be atomic</ShortDescription>
    <LongDescription>对{2}的调用序列在{1}中可能不是原子的</LongDescription>
    <Details>
          <![CDATA[<p>此代码包含对并发抽象（如并发哈希映射）的一系列调用。这些调用不会自动执行。]]>
      </Details>
  </BugPattern>
  <BugPattern type="DM_DEFAULT_ENCODING">
    <ShortDescription>依赖默认编码  Reliance on default encoding</ShortDescription>
    <LongDescription>在{1}:{2}中发现对默认编码的依赖</LongDescription>
    <Details>
<![CDATA[<p>找到一个对方法的调用，该方法将执行字节到字符串（或字符串到字节）的转换，并将假定默认的平台编码是合适的。这将导致应用程序行为因平台而异。使用替代API并显式指定字符集名称或字符集对象</p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="NP_METHOD_PARAMETER_RELAXING_ANNOTATION">
    <ShortDescription>方法可收紧参数的空注释  Method tightens nullness annotation on parameter</ShortDescription>
    <LongDescription>方法{1}覆盖了nullness注释，从而放宽了祖先方法对参数的要求。</LongDescription>
    <Details>
        <![CDATA[<p>方法应该始终实现它重写的方法的约定。因此，如果一个方法接受一个标记为@Nullable的参数，则不应在子类中使用参数为@Nonnull的方法覆盖该方法。这样做违反了方法应该处理空参数的约定</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_METHOD_PARAMETER_TIGHTENS_ANNOTATION">
    <ShortDescription>方法可收紧参数的空注释  Method tightens nullness annotation on parameter</ShortDescription>
    <LongDescription>方法{1}以不兼容的方式重写参数{2}的空注释</LongDescription>
    <Details>
        <![CDATA[<p>方法应该始终实现它重写的方法的约定。因此，如果一个方法接受一个标记为@Nullable的参数，则不应在子类中使用参数为@Nonnull的方法覆盖该方法。这样做违反了方法应该处理空参数的约定</p>]]>
      </Details>
  </BugPattern>

  <BugPattern type="NP_METHOD_RETURN_RELAXING_ANNOTATION">
    <ShortDescription>方法在返回值上放松nullness注释  Method relaxes nullness annotation on return value</ShortDescription>
    <LongDescription>方法{1}以不兼容的方式重写返回值nullness注释。</LongDescription>
    <Details>
        <![CDATA[<p>方法应该始终实现它重写的方法的约定。因此，如果一个方法take被注释为返回一个@Nonnull值，那么不应该在子类中用注释为返回@Nullable或@CheckForNull值的方法覆盖该方法。这样做违反了方法不应返回null的约定</p>]]>
      </Details>
  </BugPattern>

  <BugPattern type="EOS_BAD_END_OF_STREAM_CHECK">
    <ShortDescription>读取的数据在比较前转换为-1  Data read is converted before comparison to -1</ShortDescription>
    <LongDescription>方法{1}中{2}的返回值在与{4}进行比较之前转换为{3}。</LongDescription>
    <Details>
      <![CDATA[<p>方法java.io.FileInputStream。read（）返回一个int。如果这个int被转换为一个字节，那么-1（表示EOF）和字节0xFF变得无法区分，如果满足字符0xFF，将（转换的）结果与-1进行比较会导致读取（可能在循环中）过早结束。类似地，方法java.io.FileReader。read（）还返回一个int。如果它被转换为char，那么-1将变成0xFFFF，即Character.MAX_VALUE。将结果与-1进行比较毫无意义，因为Java中的字符是无符号的。如果EOF的检查是循环的条件，那么这个循环是无限的</p>]]>
    </Details>
  </BugPattern>
  <!--
  **********************************************************************
   BugCodes
  **********************************************************************
   -->
  <BugCode abbrev="FS">格式字符串问题  Format string problem</BugCode>
  <BugCode abbrev="SKIPPED">已跳过分析  Analysis skipped</BugCode>
  <BugCode abbrev="IL">无限循环  Infinite Loop</BugCode>
  <BugCode abbrev="VO">挥发物的使用  Use of volatile</BugCode>
  <BugCode abbrev="UI">不安全的继承  Unsafe inheritance</BugCode>
  <BugCode abbrev="FL">浮点精度的使用  Use of floating point precision</BugCode>
  <BugCode abbrev="TEST">测试原型和不完整的错误模式  Testing prototype and incomplete bug pattern</BugCode>
  <BugCode abbrev="IMSE">IllegalMonitorStateException的可疑捕获  Dubious catching of IllegalMonitorStateException</BugCode>
  <BugCode abbrev="CN">可克隆习惯用法的错误实现  Bad implementation of cloneable idiom</BugCode>
  <BugCode abbrev="CAA">协变数组赋值  Covariant array assignment</BugCode>
  <BugCode abbrev="AT">可能违反原子性  Possible atomicity violation</BugCode>
  <BugCode abbrev="FI">终结器使用不正确  Incorrect use of finalizers</BugCode>
  <BugCode abbrev="ES">使用==或！检查字符串相等性=  Checking String equality using == or !=</BugCode>
  <BugCode abbrev="ML">更新字段上的同步（可变锁）  Synchronization on updated field (Mutable Lock)</BugCode>
  <BugCode abbrev="UG">非同步获取方法、同步设置方法  Unsynchronized get method, synchronized set method</BugCode>
  <BugCode abbrev="IO">输入/输出问题  Input/Output problem</BugCode>
  <BugCode abbrev="IC">初始化循环  Initialization circularity</BugCode>
  <BugCode abbrev="SI">可疑的静态初始值设定项  Suspicious static initializer</BugCode>
  <BugCode abbrev="MSF">可变servlet字段  Mutable servlet field</BugCode>
  <BugCode abbrev="IS">同步不一致  Inconsistent synchronization</BugCode>
  <BugCode abbrev="Eq">equals（）的实现问题  Problems with implementation of equals()</BugCode>
  <BugCode abbrev="Co">compareTo（）的实现问题  Problems with implementation of compareTo()</BugCode>
  <BugCode abbrev="HE">相等对象必须具有相等的哈希码  Equal objects must have equal hashcodes</BugCode>
  <BugCode abbrev="AM">API误用  API misuse</BugCode>
  <BugCode abbrev="Dm">使用的方法可疑  Dubious method used</BugCode>
  <BugCode abbrev="Bx">原始价值的可疑拳击  Questionable Boxing of primitive value</BugCode>
  <BugCode abbrev="UR">构造函数中字段的未初始化读取  Uninitialized read of field in constructor</BugCode>
  <BugCode abbrev="RR">方法忽略InputStream.read（）的结果  Method ignores results of InputStream.read()</BugCode>
  <BugCode abbrev="NN">裸体通知  Naked notify</BugCode>
  <BugCode abbrev="UW">无条件等待  Unconditional wait</BugCode>
  <BugCode abbrev="SP">方法在字段上旋转  Method spins on field</BugCode>
  <BugCode abbrev="DC">双重检查模式  Double check pattern</BugCode>
  <BugCode abbrev="Wa">等待不在循环中  Wait not in loop</BugCode>
  <BugCode abbrev="No">使用notify（）而不是notifyAll（）  Using notify() rather than notifyAll()</BugCode>
  <BugCode abbrev="DE">已丢弃或忽略异常  Dropped or ignored exception</BugCode>
  <BugCode abbrev="Ru">方法调用run（）  Method invokes run()</BugCode>
  <BugCode abbrev="It">迭代器定义不正确  Incorrect definition of Iterator</BugCode>
  <BugCode abbrev="SnVI">没有版本ID的可序列化类  Serializable class with no Version ID</BugCode>
  <BugCode abbrev="Se">Serializable类的定义不正确  Incorrect definition of Serializable class</BugCode>
  <BugCode abbrev="WS">类的writeObject（）方法已同步，但其他方法均未同步  Class's writeObject() method is synchronized but nothing else is</BugCode>
  <BugCode abbrev="RS">类的readObject（）方法已同步  Class's readObject() method is synchronized</BugCode>
  <BugCode abbrev="SC">构造函数调用Thread.start（）  Constructor invokes Thread.start()</BugCode>
  <BugCode abbrev="MS">可变静态场  Mutable static field</BugCode>
  <BugCode abbrev="ME">可变枚举字段  Mutable enum field</BugCode>
  <BugCode abbrev="EI">返回数组的方法可能公开内部表示  Method returning array may expose internal representation</BugCode>
  <BugCode abbrev="Nm">混淆方法名称  Confusing method name</BugCode>
  <BugCode abbrev="SS">未读字段应为静态  Unread field should be static</BugCode>
  <BugCode abbrev="UuF">未使用的字段  Unused field</BugCode>
  <BugCode abbrev="UrF">未读字段  Unread field</BugCode>
  <BugCode abbrev="UwF">未写入字段  Unwritten field</BugCode>
  <BugCode abbrev="SIC">内部类可以设置为静态  Inner class could be made static</BugCode>
  <BugCode abbrev="TLW">按住两个锁等待  Wait with two locks held</BugCode>
  <BugCode abbrev="RANGE">范围检查  Range checks</BugCode>
  <BugCode abbrev="RV">方法返回值使用错误  Bad use of return value from method</BugCode>
  <BugCode abbrev="LG">记录器问题  Logger problem</BugCode>
  <BugCode abbrev="IA">不明确的调用  Ambiguous invocation</BugCode>
  <BugCode abbrev="HSC">巨大的字符串常量  Huge String constants</BugCode>
  <BugCode abbrev="HRS">HTTP响应拆分漏洞  HTTP Response splitting vulnerability</BugCode>
  <BugCode abbrev="PT">路径遍历  Path traversal</BugCode>
  <BugCode abbrev="XSS">跨站点脚本漏洞  Cross site scripting vulnerability</BugCode>
  <BugCode abbrev="NP">空指针引用  Null pointer dereference</BugCode>
  <BugCode abbrev="NOISE">虚假随机警告  Bogus random warning</BugCode>
  <BugCode abbrev="RpC">重复条件试验  Repeated conditional test</BugCode>
  <BugCode abbrev="OS">未在所有路径上关闭流  Stream not closed on all paths</BugCode>
  <BugCode abbrev="PZLA">首选零长度数组而不是null，表示没有结果  Prefer zero length arrays to null to indicate no results</BugCode>
  <BugCode abbrev="UCF">无用的控制流  Useless control flow</BugCode>
  <BugCode abbrev="RCN">与null的冗余比较  Redundant comparison to null</BugCode>
  <BugCode abbrev="UL">未在所有路径上释放锁  Lock not released on all paths</BugCode>
  <BugCode abbrev="RC">引用相等而不是调用相等的用法有问题  Questionable use of reference equality rather than calling equals</BugCode>
  <BugCode abbrev="EC">比较不兼容类型的相等性  Comparing incompatible types for equality</BugCode>
  <BugCode abbrev="MWN">不匹配的wait（）或notify（）  Mismatched wait() or notify()</BugCode>
  <BugCode abbrev="SA">无用的自动操作  Useless self-operation</BugCode>
  <BugCode abbrev="INT">可疑整数表达式  Suspicious integer expression</BugCode>
  <BugCode abbrev="BIT">可疑的按位逻辑表达式  Suspicious bitwise logical expression</BugCode>
  <BugCode abbrev="LI">非同步延迟初始化  Unsynchronized Lazy Initialization</BugCode>
  <BugCode abbrev="JLM">java.util上的同步。并发对象  Synchronization on java.util.concurrent objects</BugCode>
  <BugCode abbrev="UPM">从不调用私有方法  Private method is never called</BugCode>
  <BugCode abbrev="UMAC">匿名类的不可调用方法  Uncallable method of anonymous class</BugCode>
  <BugCode abbrev="EI2">存储对可变对象的引用  Storing reference to mutable object</BugCode>
  <BugCode abbrev="NS">可疑使用非短路布尔运算符  Suspicious use of non-short-circuit boolean operator</BugCode>
  <BugCode abbrev="ODR">未在所有路径上关闭数据库资源  Database resource not closed on all paths</BugCode>
  <BugCode abbrev="SBSC">使用+运算符在循环中串联字符串  String concatenation in loop using + operator</BugCode>
  <BugCode abbrev="IIL">可以移出循环的低效代码  Inefficient code which can be moved outside of the loop</BugCode>
  <BugCode abbrev="IIO">字符串使用效率低下。indexOf（String）或String.lastIndexOf  Inefficient use of String.indexOf(String) or String.lastIndexOf(String)</BugCode>
  <BugCode abbrev="ITA">收集的使用效率低下。toArray（新Foo[0]）  Inefficient use of collection.toArray(new Foo[0])</BugCode>
  <BugCode abbrev="SW">Swing编码规则  Swing coding rules</BugCode>
  <BugCode abbrev="IJU">未正确实现JUnit TestCase  Improperly implemented JUnit TestCase</BugCode>
  <BugCode abbrev="BOA">被严重覆盖的适配器  Badly Overridden Adapter</BugCode>
  <BugCode abbrev="SF">switch 语句使用不当  Switch case falls through</BugCode>
  <BugCode abbrev="SIO">多余的实例  Superfluous instanceof</BugCode>
  <BugCode abbrev="BAC">错误的Applet构造函数  Bad Applet Constructor</BugCode>
  <BugCode abbrev="UOE">使用对象等于  Use Object Equals</BugCode>
  <BugCode abbrev="STI">可疑线程中断  Suspicious Thread Interrupted</BugCode>
  <BugCode abbrev="DLS">本地商店已死亡  Dead local store</BugCode>
  <BugCode abbrev="IP">忽略的参数  Ignored parameter</BugCode>
  <BugCode abbrev="MF">蒙版字段  Masked Field</BugCode>
  <BugCode abbrev="WMI">无效的映射迭代器  Inefficient Map Iterator</BugCode>
  <BugCode abbrev="ISC">实例化静态类  Instantiated Static Class</BugCode>
  <BugCode abbrev="REC">RuntimeException捕获  RuntimeException capture</BugCode>
  <BugCode abbrev="FE">浮点相等性测试  Test for floating point equality</BugCode>
  <BugCode abbrev="UM">不必要的常量数学  Unnecessary Math on constants</BugCode>
  <BugCode abbrev="UC">无用代码  Useless code</BugCode>
  <BugCode abbrev="CNT">已知常数的粗略值  Rough value of known constant</BugCode>
  <BugCode abbrev="CD">循环依赖项  Circular Dependencies</BugCode>
  <BugCode abbrev="RI">冗余接口  Redundant Interfaces</BugCode>
  <BugCode abbrev="MTIA">多线程实例访问  Multithreaded Instance Access</BugCode>
  <BugCode abbrev="PS">公共信号  Public Semaphores</BugCode>
  <BugCode abbrev="BSHIFT">换档不良  Bad shift</BugCode>
  <BugCode abbrev="ICAST">从整数值强制转换  Casting from integer values</BugCode>
  <BugCode abbrev="RE">正则表达式  Regular expressions</BugCode>
  <BugCode abbrev="SQL">潜在SQL问题  Potential SQL Problem</BugCode>
  <BugCode abbrev="WL">可能锁定错误对象  Possible locking on wrong object</BugCode>
  <BugCode abbrev="ESync">清空同步块  Empty Synchronized blocks</BugCode>
  <BugCode abbrev="QF">循环存在问题  Questionable for loops</BugCode>
  <BugCode abbrev="VA">Vararg问题  Vararg problems</BugCode>
  <BugCode abbrev="BC">对象引用的错误转换  Bad casts of object references</BugCode>
  <BugCode abbrev="IM">整数数学有问题  Questionable integer math</BugCode>
  <BugCode abbrev="ST">误用静态字段  Misuse of static fields</BugCode>
  <BugCode abbrev="JCIP">违反网络。jcip注释  Violation of net.jcip annotations</BugCode>
  <BugCode abbrev="USELESS_STRING">生成了无用/非信息性字符串  Useless/non-informative string generated</BugCode>
  <BugCode abbrev="DMI">可疑的方法调用  Dubious method invocation</BugCode>
  <BugCode abbrev="PZ">Joshua Bloch和Neal Gafter的编程难题引发的警告  Warning inspired by Joshua Bloch's and Neal Gafter's Programming Puzzlers</BugCode>
  <BugCode abbrev="SWL">保持锁定睡眠  Sleep with lock held</BugCode>
  <BugCode abbrev="J2EE">J2EE错误  J2EE error</BugCode>
  <BugCode abbrev="DB">重复的分支  Duplicate Branches</BugCode>
  <BugCode abbrev="IMA">成员访问效率低下  Inefficient Member Access</BugCode>
  <BugCode abbrev="XFB">XML工厂旁路  XML Factory Bypass</BugCode>
  <BugCode abbrev="USM">无用的子类方法  Useless Subclass Method</BugCode>
  <BugCode abbrev="CI">混乱的继承  Confused Inheritance</BugCode>
  <BugCode abbrev="QBA">有问题的布尔赋值  Questionable Boolean Assignment</BugCode>
  <BugCode abbrev="VR">版本兼容性问题  Version compatibility issue</BugCode>
  <BugCode abbrev="DP">使用doPrivileged  Use doPrivileged</BugCode>
  <BugCode abbrev="GC">对通用收集方法的可疑调用  Suspicious calls to generic collection methods</BugCode>
  <BugCode abbrev="STCAL">Calendar或DateFormat类型的静态使用  Static use of type Calendar or DateFormat</BugCode>
  <BugCode abbrev="TQ">类型限定符注释的使用不一致  Inconsistent use of type qualifier annotations</BugCode>
  <BugCode abbrev="OBL">未履行清理河流或资源的义务  Unsatisfied obligation to clean up stream or resource</BugCode>
  <BugCode abbrev="FB">SpotBugs未在方法上生成预期的警告  SpotBugs did not produce the expected warnings on a method</BugCode>
  <BugCode abbrev="DL">共享对象上的锁定导致意外争用或可能的死锁  Unintended contention or possible deadlock due to locking on shared objects</BugCode>
  <BugCode abbrev="JUA">JUnit断言中的问题  Problems in JUnit Assertions</BugCode>
  <BugCode abbrev="EOS">流结尾检查错误  Bad End of Stream check</BugCode>
</MessageCollection>
