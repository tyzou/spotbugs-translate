<?xml version="1.0" encoding="UTF-8"?>
<MessageCollection xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="messagecollection.xsd">
  <!--
  **********************************************************************
  Plugin information
  **********************************************************************
  -->
  <Plugin>
    <ShortDescription>Core SpotBugs plugin</ShortDescription>
    <Details>
<![CDATA[
<p>
This plugin contains all of the standard SpotBugs detectors.
</p>
]]>
    </Details>
    <BugsUrl>https://spotbugs.readthedocs.io/en/latest/bugDescriptions.html</BugsUrl>
    <AllBugsUrl>https://spotbugs.readthedocs.io/en/latest/bugDescriptions.html</AllBugsUrl>
  </Plugin>
  <FindBugsMain cmd="addMessages" class="edu.umd.cs.findbugs.AddMessages">
    <Description>将错误描述（例如，漏洞的文本描述）添加到分析结果中  Add msgs (e.g., textual descriptions of bugs) to analysis results</Description>
  </FindBugsMain>
  <FindBugsMain cmd="analyze" class="edu.umd.cs.findbugs.FindBugs2">
    <Description>执行SpotBugs分析  Perform SpotBugs Analysis</Description>
  </FindBugsMain>
  <FindBugsMain cmd="gui" class="edu.umd.cs.findbugs.gui2.Driver">
    <Description>启动SpotBugs图形用户界面  Launch SpotBugs GUI</Description>
  </FindBugsMain>
  <FindBugsMain cmd="list" class="edu.umd.cs.findbugs.PrintingBugReporter">
    <Description>将分析结果转换为文本形式  Convert analysis results to textual form</Description>
  </FindBugsMain>
  <FindBugsMain cmd="help" class="edu.umd.cs.findbugs.ShowHelp">
    <Description>提供命令帮助  Provide help for commands</Description>
  </FindBugsMain>
  <FindBugsMain cmd="version" class="edu.umd.cs.findbugs.Version">
    <Description>列表显示SpotBugs版本信息  List SpotBugs version</Description>
  </FindBugsMain>
  <FindBugsMain cmd="filter" class="edu.umd.cs.findbugs.workflow.Filter">
    <Description>过滤分析结果  Filter analysis results</Description>
  </FindBugsMain>
  <FindBugsMain cmd="set" class="edu.umd.cs.findbugs.workflow.SetBugDatabaseInfo">
    <Description>设置项目配置/选项  Set project configuration/options</Description>
  </FindBugsMain>
  <FindBugsMain cmd="history" class="edu.umd.cs.findbugs.workflow.MineBugHistory">
    <Description>多版本分析结果的详细信息列表  List details from multi-version analysis results</Description>
  </FindBugsMain>
  <FindBugsMain cmd="union" class="edu.umd.cs.findbugs.workflow.UnionResults">
    <Description>合并来自不相交组件的分析结果  Merge analysis results from disjoint components</Description>
  </FindBugsMain>
  <FindBugsMain cmd="merge" class="edu.umd.cs.findbugs.workflow.Update">
    <Description>将不同版本软件的分析结果结合起来产生多版本分析结果  Combine analysis results from different versions of software to produce multi-version analysis results</Description>
  </FindBugsMain>

  <FindBugsMain cmd="dis" class="edu.umd.cs.findbugs.workflow.PrintClass">
    <Description>反编译类文件  Disassemble a class file</Description>
  </FindBugsMain>
  <FindBugsMain cmd="errors" class="edu.umd.cs.findbugs.workflowListErrors">
    <Description>将结果文件中记录的列表分析错误存储起来  List analysis errors stored in results file</Description>
  </FindBugsMain>

  <!-- On changing this, please also update default cloud id in FindbugsPlugin -->
  <Cloud id="edu.umd.cs.findbugs.cloud.doNothingCloud">
    <Description>(cloud disabled)</Description>
    <Details>Bug reviews are disabled when using this plugin.</Details>
  </Cloud>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.SuppressMultithreaded">
    <Description>抑制多线程正确性问题  Suppress multithreaded correctness issues</Description>
    <Details>抑制所有多线程正确性问题  Suppress all multithreaded correctness issues</Details>
  </PluginComponent>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.SuppressI18N">
    <Description>抑制国际化问题  Suppress internationalization issues</Description>
    <Details>抑制所有国际化问题  Suppress all internationalization issues</Details>
  </PluginComponent>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.SelectivelySuppressI18N">
    <Description>在所有但选定的包中抑制国际化问题  Suppress internationalization issues in all but selected packages</Description>
    <Details>抑制所有国际化问题，除非在i18n.properties资源中指定。  Suppress all internationalization issues except those specified in the i18n.properties resource</Details>
  </PluginComponent>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.MaxRank14">
    <Description>屏蔽排名高于14的所有问题  Suppress all issues with rank higher than 14</Description>
    <Details>抑制优先级高于14的所有问题  Suppress all issues with rank higher than 14</Details>
  </PluginComponent>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.SuppressMalicious">
    <Description>抑制关于恶意代码漏洞的警告  Suppress warnings about vulnerabilities to malicious code</Description>
    <Details>抑制关于恶意代码漏洞的警告  Suppress warnings about vulnerabilities to malicious code</Details>
  </PluginComponent>
  <!--
  **********************************************************************
  Categories (replacing the BugCategoryDescriptions.properties file)
  **********************************************************************
   -->
  <BugCategory category="CORRECTNESS">
    <Description>正确性  Correctness</Description>
    <Abbreviation>C</Abbreviation>
    <Details>可能存在的 Bug - 似乎是开发人员可能无意中犯下的编码错误，导致代码并非开发人员原本的意图。我们力求将误报率保持在较低水平。  Probable bug - an apparent coding mistake resulting in code that was probably not what the developer intended. We strive for a low false positive rate.</Details>
  </BugCategory>
  <BugCategory category="NOISE">
    <Description>无效的随机噪音  Bogus random noise</Description>
    <Abbreviation>N</Abbreviation>
    <Details>虚假的随机噪声：旨在在数据挖掘实验中作为控制变量使用，而不是用于查找软件中的实际 bug。  Bogus random noise: intended to be useful     as a control in data mining experiments, not in finding actual bugs in software</Details>
  </BugCategory>
  <BugCategory category="SECURITY">
    <Description>安全性  Security</Description>
    <Abbreviation>S</Abbreviation>
    <Details>以未信任输入的方式使用，可能会创建一个可远程利用的安全漏洞。  A use of untrusted input in a way that could create a remotely exploitable security vulnerability.</Details>
  </BugCategory>
  <BugCategory category="BAD_PRACTICE">
    <Description>不良做法  Bad practice</Description>
    <Abbreviation>B</Abbreviation>
    <Details>推荐和必需的编码实践中的违规行为。例如，哈希码和equals问题、可克隆模式、丢失异常、Serializable问题以及对finalize方法的误用。我们力求使这种分析准确，尽管一些团队可能不关心某些不良实践。  Violations of recommended and essential coding practice. Examples include hash code and equals problems, cloneable idiom, dropped exceptions, Serializable problems, and misuse of finalize. We strive to make this analysis accurate, although some groups may not care about some of the bad practices.</Details>
  </BugCategory>
  <BugCategory category="STYLE">
    <Description>可疑代码  Dodgy code</Description>
    <Abbreviation>D</Abbreviation>
    <Details>代码混淆、异常或容易引发错误的编写方式。例如，死掉的局部变量存储、switch语句的默认下落、未经确认的类型转换以及对已知为null的值进行冗余的空检查。接受更多的假阳性结果。在SpotBugs的早期版本中，这一类别被称为Style。  Code that is confusing, anomalous, or written in a way that leads itself to errors. Examples include dead local stores, switch fall through, unconfirmed casts, and redundant null check of value known to be null. More false positives accepted. In previous versions of SpotBugs, this category was known as Style.</Details>
  </BugCategory>
  <BugCategory category="PERFORMANCE">
    <Description>性能  Performance</Description>
    <Abbreviation>P</Abbreviation>
    <Details>代码可能不是错误的，但可能是低效的。  Code that is not necessarily incorrect but may be inefficient</Details>
  </BugCategory>
  <BugCategory category="MALICIOUS_CODE">
    <Description>恶意代码漏洞  Malicious code vulnerability</Description>
    <Abbreviation>V</Abbreviation>
    <Details>来自不受信任代码的攻击易受攻击的代码  Code that is vulnerable to attacks from untrusted code</Details>
  </BugCategory>
  <BugCategory category="MT_CORRECTNESS">
    <Description>多线程正确性检查  Multithreaded correctness</Description>
    <Abbreviation>M</Abbreviation>
    <Details>与线程、锁和 volatile 有关的代码缺陷  Code flaws having to do with threads, locks, and volatiles</Details>
  </BugCategory>
  <BugCategory category="I18N">
    <Description>国际化  Internationalization</Description>
    <Abbreviation>I</Abbreviation>
    <Details>与国际化和区域设置相关的代码缺陷  Code flaws having to do with internationalization and locale</Details>
  </BugCategory>
  <BugCategory category="EXPERIMENTAL">
    <Description>实验性功能  Experimental</Description>
    <Abbreviation>X</Abbreviation>
    <Details>实验性的且尚未完全验证的错误模式  Experimental and not fully vetted bug patterns</Details>
  </BugCategory>

  <!--
  **********************************************************************
  Detectors
  **********************************************************************
   -->
  <Detector class="edu.umd.cs.findbugs.detect.OverridingMethodsMustInvokeSuperDetector">
    <Details>
<![CDATA[<p>查找必须调用 super 的覆盖方法。 </p>  <p> Finds overriding methods that must call super. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindRoughConstants">
    <Details>
<![CDATA[<p>查找大约（但不精确）等于已知值（如Math.PI）的常量。 </p>  <p> Finds constants which roughly (but not precisely) equal to known values like Math.PI. </p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InitializeNonnullFieldsInConstructor">
    <Details>
<![CDATA[<p>在构造函数中未写入的非空字段。 </p>  <p> Finds non-null fields that are not written to in constructors. </p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.IntCast2LongAsInstant">
    <Details>
<![CDATA[<p>查找使用32位值表示自纪元以来的毫秒数的用法。 </p>  <p> Finds uses of 32-bit values to describe milliseconds since the epoch. </p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainLongInstantfParams">
    <Details>
<![CDATA[<p>构建一个参数数据库，这些参数表示自纪元以来的毫秒数（使用64位值）。</p>  <p> Builds database of parameters that take a 64 bit value describing milliseconds since the epoch.</p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InconsistentAnnotations">
    <Details>
<![CDATA[<p>此检测器查找直接应用于方法参数的类型限定符与这些方法参数的使用之间的不一致性。 </p>  <p> This detector finds inconsistencies between type qualifiers directly applied to method parameters and uses of those method parameters. </p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.AtomicityProblem">
    <Details>
<![CDATA[<p>查找会对并发抽象进行非原子执行的操作序列（例如，get/put）。</p>  <p> Finds sequences of operations (e.g., get/put) on a concurrent abstraction     that will not be executed atomically.     </p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SynchronizationOnSharedBuiltinConstant">
    <Details>
<![CDATA[<p>此检测器查找对共享内置常量（如字符串）的同步操作。</p>  <p> This detector looks for synchronization on a shared built-in constant (such as a String).</p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SynchronizeAndNullCheckField">
    <Details>
<![CDATA[<p>该检测器查找一个既同步又为空检查的字段。</p>  <p> This detector looks for a field that is synchronized on and then null checked.</p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckImmutableAnnotation">
    <Details>
<![CDATA[<p>查找被标注为net.jcip.annotations.Immutable或javax.annotation.concurrent.Immutable的类违反规则的情况。</p>  <p> Looks for violations of the rules for classes annotated as net.jcip.annotations.Immutable or javax.annotation.concurrent.Immutable.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.VarArgsProblems">
    <Details>
<![CDATA[<p>查找源自Java 5可变参数的问题。</p>  <p> Looks for problems with arising from Java 5 varargs.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteJCIPAnnotation">
    <Details>
<![CDATA[<p>记录来自net.jcip.annotations包的注解。</p>  <p> Record annotations from the net.jcip.annotations package.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteDirectlyRelevantTypeQualifiers">
    <Details>
<![CDATA[<p>注意与分析方法相关的类型限定符。</p>  <p> Note the type qualifiers relevant to analyzing a method.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BuildInterproceduralCallGraph">
    <Details>
      <![CDATA[<p>构建调用图。</p>  <p>Builds the interprocedural call graph.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BuildObligationPolicyDatabase">
    <Details>
          <![CDATA[构建FindUnsatisfiedObligation检测器所需的债务类型和方法的数据库。  <p>Builds the database of obligation types and methods used by the FindUnsatisfiedObligation detector.]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteSuppressedWarnings">
    <Details>
<![CDATA[<p>基于使用edu.umd.cs.findbugs.annotations.NoteSuppressWarnings注解来抑制警告。</p>  <p> Suppresses warnings based on use of the edu.umd.cs.findbugs.annotations.NoteSuppressWarnings annotation.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteAnnotationRetention">
    <Details>
<![CDATA[<p>记录注解保留。</p>  <p> Records annotation retention.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteSyntheticElements">
    <Details>
      <![CDATA[<p>记录合成类、方法、字段等。</p>  <p>Records synthetic classes, methods, fields, etc.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.Methods">
    <Details>
<![CDATA[<p>为其他检测器构建一个包含所有分析类中定义的方法的数据库。</p>  <p> Builds a database of all methods defined in analyzed classes, for use by other detectors.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ReflectiveClasses">
    <Details>
<![CDATA[<p>尝试确定哪些类对其 .class 对象进行了常量引用。</p>  <p> Try to determine which classes have constant references to their .class objects.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CalledMethods">
    <Details>
<![CDATA[<p>构建一个包含所有调用方法的数据库，供其他检测器使用。</p>  <p> Builds a database of all methods invoked in analyzed classes, for use by other detectors.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNoSideEffectMethods">
    <Details>
<![CDATA[<p>查找没有副作用，仅仅返回一些值的方法。</p>  <p> Looks for the methods which have no side effect, just return some value.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BuildStringPassthruGraph">
    <Details>
<![CDATA[<p>构建数据库，记录从一个方法传递到另一个方法且未发生变化的字符串参数。</p>  <p> Builds the database of string parameters passed from method to method unchanged.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FunctionsThatMightBeMistakenForProcedures">
    <Details>
<![CDATA[<p>查找那些返回该类新实例的方法的不可变类，以防人们可能会错误地认为这些方法会修改调用它的实例。</p>  <p> Looks for immutable classes with methods that return new instances of that class, where people might accidentally think those methods mutate the instance they are invoked on. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ConfusionBetweenInheritedAndOuterMethod">
    <Details>
<![CDATA[<p>查找继承方法和外部方法之间可能引起的混淆。</p>  <p> Looks for potential confusion between inherited and outer methods.</p>]]>
    </Details>
  </Detector>
    <Detector class="edu.umd.cs.findbugs.detect.NoteCheckReturnValueAnnotations">
    <Details>
<![CDATA[<p>查找注解以检查方法的返回值。 </p>  <p> Looks for annotations to check return values of a method. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SynchronizeOnClassLiteralNotGetClass">
    <Details>
      <![CDATA[<p>查找使用getClass的结果而不是类常量进行同步的代码。</p>  <p> Looks for code that synchronizes on the results of getClass rather than on class literals. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FieldItemSummary">
    <Details>
      <![CDATA[<p>     该检测器生成有关存储到字段中的信息的摘要。</p>  <p>     This detector produces summary information for what is stored     into fields. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteNonNullAnnotations">
    <Details>
      <![CDATA[<p>查找方法、字段和参数上的 @Nonnull 注解。这些注解可以被 FindNullDeref 检测器用于生成警告，当在仅应使用非空值的上下文中使用可能为空的值时。</p>  <p> Looks for @Nonnull annotations on methods, fields, and parameters. These can be used by the FindNullDeref detector to generate warnings when a possibly-null value is used in a context where only non-null values should be used. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteUnconditionalParamDerefs">
    <Details>
      <![CDATA[<p>分析应用程序中的所有方法，确定哪些方法无条件地解引用参数。这些信息将在后续的分析过程中用于找到可能传递空值给这些方法的调用点。</p>
<p>这是一个运行较慢的检测器。</p>  <p> Analyze all methods in the application to determine which dereference parameters unconditionally.  This information is used in a later analysis pass to find call sites where null values may be passed to those methods. </p> <p> This is a slow detector. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteNonnullReturnValues">
    <Details>
      <![CDATA[<p>分析应用程序中的所有方法以确定哪些方法总是返回非空值。</p>  <p> Analyze all methods in the application to determine which     methods always return non-null values. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BooleanReturnNull">
    <Details>
<![CDATA[<p>查找返回布尔类型但显式返回null值的方法。</p>  <p> Looks for methods with Boolean return type that return explicit null values.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.OptionalReturnNull">
    <Details>
<![CDATA[<p>查找返回类型为 Optional 但明确返回 null 值的方法。</p>  <p> Looks for methods with Optional return type that return explicit null values.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUselessObjects">
    <Details>
<![CDATA[<p>查找无用的对象。</p>  <p> Looks for useless objects.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MutableEnum">
    <Details>
          <![CDATA[<p>检查并警告关于可变枚举字段。</p>  <p> Looks and warns about mutable enum fields.</p>]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BadUseOfReturnValue">
    <Details>
<![CDATA[<p>查找函数返回值在检查非空后被丢弃的情况。  </p>  <p> Looks for cases where the return value of a function is discarded after being checked for non-null.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InheritanceUnsafeGetResource">
    <Details>
<![CDATA[<p>查找对 this.getClass().getResource(...) 的使用，如果该类被另一个包中的类扩展，则可能会得到意外的结果。 </p>  <p> Looks for uses of this.getClass().getResource(...), which can give unexpected results if the class is extended by a class in another package. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InfiniteRecursiveLoop">
    <Details>
<![CDATA[<p>查找无限递归循环。</p>  <p> Looks for an infinite recursive loop. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InfiniteLoop">
    <Details>
<![CDATA[<p>查找无限循环。</p>  <p> Looks for an infinite loop. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.VolatileUsage">
    <Details>
<![CDATA[<p>查找对volatile字段使用的错误模式。 </p>  <p> Looks for bug patterns in the usage of volatile fields. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.EmptyZipFileEntry">
    <Details>
<![CDATA[这会检查创建空ZIP文件条目的情况。它是一个中等速度的检测器。  <p> This looks for creation of empty ZIP file entries. It is a moderately fast detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.UncallableMethodOfAnonymousClass">
    <Details>
<![CDATA[<p>该检测器查找定义了可能意图重写超类中方法但实际上并未重写的方法的匿名内部类。 </p>  <p> This detector looks for anonymous inner classes that define methods that are probably intended to but do not override methods in a superclass. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DontUseEnum">
    <Details>
<![CDATA[<p>检查字段和方法不要使用assert或enum作为名称，因为它们是Java 5中的关键字。</p>  <p>Checks that fields and methods don't use the name assert or enum as they are keywords in Java 5.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.URLProblems">
    <Details>
<![CDATA[<p>在<code>java.net.URL</code>类中，equals和hashCode方法会解析域名。因此，这些操作可能会非常昂贵，这个检测器会查找可能调用这些方法的地方。 </p>  <p> The equals and hashCode method on <code>java.net.URL</code> resolve the domain name. As a result, these operations can be very expensive, and this detector looks for places where those methods might be invoked. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FinalizerNullsFields">
    <Details>
<![CDATA[<p>此检测器查找对类的字段进行清空(finalizer)的操作。这种操作并不会帮助垃圾收集器，清空字段也不会产生任何影响。</p>  <p> This detector looks for finalizers that null out fields of a class. This does not help the garbage collector in any way, the nulling out of fields has no effect. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CrossSiteScripting">
    <Details>
<![CDATA[<p>此检测器用于查找明显的跨站脚本漏洞。</p>  <p> This detector looks for obvious/blatant cases of cross site scripting vulnerabilities.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.RepeatedConditionals">
    <Details>
<![CDATA[这个检测器查找包含重复条件测试的代码，例如 (x == 5 || x == 5)。  <p> This detector looks for code containing repeated conditional tests, such as (x == 5 || x == 5).]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.RedundantConditions">
    <Details>
<![CDATA[这个检测器会查找包含无用条件的代码，比如这个表达式中的第二个条件：(x >= 10 && x >= 5)。  <p> This detector looks for code containing useless conditions like the second condition in this expression: (x >= 10 && x >= 5).]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CallToUnsupportedMethod">
    <Details>
<![CDATA[此检测器用于查找对不支持方法的调用。  <p> This detector looks for calls to methods that are unsupported.]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FormatStringChecker">
    <Details>
<![CDATA[<p>检查不正确的格式字符串。</p>  <p> Checks for incorrect format strings. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.EqualsOperandShouldHaveClassCompatibleWithThis">
    <Details>
<![CDATA[检查equals方法是否将其操作数实例化为与定义equals方法的类不兼容的类。  <p> Checks for equals methods that check for their operand being an instance of a class that is not compatible with the class defining the equals method. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestingGround">
    <Details>
<![CDATA[<p>这个检测器只是一个用于测试新检测器的挂钩。通常情况下，这个检测器什么也不做。</p>  <p> This detector is just a hook for testing new detectors. Normally, this detector does nothing.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestingGround2">
    <Details>
<![CDATA[<p>这个检测器只是一个用于测试新检测器的钩子。通常情况下，这个检测器不会做任何事情。</p>  <p> This detector is just a hook for testing new detectors. Normally, this detector does nothing.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.LostLoggerDueToWeakReference">
    <Details>
<![CDATA[<p>此检测器查找在使用弱引用持有Log器的情况下，代码在OpenJDK 6下行为不同的情况。</p>  <p> This detector finds code that behaves differently under OpenJDK 6, where weak references are used to hold onto Loggers. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestingGround2">
    <Details>
<![CDATA[<p>这个检测器只是一个用于测试新检测器的钩子。通常情况下，这个检测器不会做任何事情。</p>  <p> This detector is just a hook for testing new detectors. Normally, this detector does nothing.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.Noise">
    <Details>
<![CDATA[<p>这个检测器生成随机信号：这些警告基于方法执行的操作的哈希值。这些警告是虚假的随机噪声，旨在作为数据挖掘实验中的控制变量，而不是用于查找软件中的实际错误。通常情况下，这个检测器什么也不做，只是一个测试新检测器的钩子。</p>  <p> This detector generates a random signal: warnings that are just based on hash values of the operations performed by methods. These warnings are bogus random noise, intended to be useful   as a control in data mining experiments, not in finding actual bugs in software.   This detector is just a hook for testing new detectors. Normally, this detector does nothing.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoiseNullDeref">
    <Details>
<![CDATA[<p>一种用于检测空指针的操作噪声探测器。旨在作为关于警告的有效性或预测能力的实验中的控制变量使用，而不是用于查找代码中的问题。</p>  <p> Noisy detector for null dereferences. Intended to be used as a control in experiments about the validity or predictive ability of warnings, not as a way to find problems in code. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.HugeSharedStringConstants">
    <Details>
<![CDATA[<p>该检测器查找跨多个类文件中重复的字符串常量。 </p>  <p> This detector looks for string constants that are duplicated across multiple classfiles. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DoInsideDoPrivileged">
    <Details>
<![CDATA[<p>查找应在doPrivileged块中执行的代码。</p>  <p> Looks for code that should be executed inside doPrivileged blocks.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ResolveAllReferences">
    <Details>
<![CDATA[<p>检查所有引用是否可以解析。 </p>  <p> Checks that all references call be resolved.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SwitchFallthrough">
    <Details>
<![CDATA[<p>该检测器查找包含延续嵌入的switch语句。</p>  <p> This detector looks for switch statements containing fall through. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindFieldSelfAssignment">
    <Details>
<![CDATA[<p>这个检测器寻找字段赋值时读取同一字段值的情况。 </p>  <p> This detector looks for places where a field is assigned by reading the value of the same field.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSelfComparison">
    <Details>
<![CDATA[<p>这个检测器查找将值与其自身的比较之处。</p>  <p> This detector looks for places where a value is compared with itself.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSelfComparison2">
    <Details>
<![CDATA[<p>此检测器查找将值与其自身进行比较的地方。</p>  <p> This detector looks for places where a value is compared with itself.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNonShortCircuit">
    <Details>
<![CDATA[<p>此检测器查找可疑使用非短路布尔运算符（<code>|</code> 和 <code>&amp;</code> 而不是 <code>||</code> 和 <code>&&amp;&amp;</code>）的情况。</p>  <p> This detector looks for suspicious uses of non-short-circuiting boolean operators (<code>|</code> and <code>&amp;</code> instead of <code>||</code> and <code>&amp;&amp;</code>).</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DontCatchIllegalMonitorStateException">
    <Details>
<![CDATA[<p>此检测器查找捕获IllegalMonitorStateException的try-catch块。</p>  <p> This detector looks for try-catch blocks that catch an IllegalMonitorStateException.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindFloatMath">
    <Details>
<![CDATA[<p>该检测器查找浮点数学的使用情况。它是一个中等速度的检测器。</p>  <p> This detector looks for uses of floating point math. It is a moderately fast detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CloneIdiom">
    <Details>
<![CDATA[<p>该检测器寻找违反可克隆类编写惯用法的违规情况。</p>  <p> This detector looks for violations of the idioms for writing cloneable classes. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ThrowingExceptions">
    <Details>
<![CDATA[<p>该检测器查找抛出 RuntimeException 的方法以及在其 throws 子句中包含 Exception 或 Throwable 的方法。 </p>  <p> This detector looks for methods throwing RuntimeException and methods  that have Exception or Throwable in their throws clause. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ComparatorIdiom">
    <Details>
<![CDATA[<p>该检测器用于查找实现<code>Comparator</code>接口的类编写idiom规范的违规情况。</p>  <p> This detector looks for violations of the idioms for writing classes that implement <code>Comparator</code>. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DroppedException">
    <Details>
<![CDATA[<p>该检测器查找捕获了异常但未对异常进行处理的代码。  </p>  <p> This detector looks for code where an exception is caught, but nothing is done to handle the exception.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.LoadOfKnownNullValue">
    <Details>
<![CDATA[<p>查找许多已知为null的值。</p>  <p> Looks for loads of values known to be null. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DumbMethodInvocations">
    <Details>
<![CDATA[<p>此检测器会查找传递给方法的不良参数（例如，substring(0)）。 </p>  <p> This detector looks for bad arguments being passed to methods (e.g., substring(0)). </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DumbMethods">
    <Details>
<![CDATA[<p>该检测器查找调用无意义方法的调用，例如无参的String构造函数。 </p>  <p> This detector looks for calls to pointless methods, such as the no-argument String constructor. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CovariantArrayAssignment">
    <Details>
<![CDATA[<p>该检测器查找类似于 `Object[] array = new String[10]` 的协变数组赋值，可能会在运行时导致 ArrayStoreException。</p>  <p> This detector looks for covariant array assignments like Object[] array = new String[10] which may cause ArrayStoreException at runtime. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NumberConstructor">
    <Details>
<![CDATA[<p>查找对以原始类型作为参数的Number构造函数的调用。 </p>  <p> Looks for calls to Number constructors with primitive arguments. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindDoubleCheck">
    <Details>
<![CDATA[<p>此检测器用于查找双重锁定实例。 </p>  <p> This detector looks for instances of double-checked locking. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindFinalizeInvocations">
    <Details>
<![CDATA[<p>该检测器查找对 finalize() 的调用以及其他与最终化相关的问题。  </p>  <p> This detector looks for calls to finalize() and other finalizer-related issues.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindHEmismatch">
    <Details>
<![CDATA[<p>该检测器查找 hashCode() 和 equals() 方法定义中的问题。 </p>  <p> This detector looks for problems in the definition of the hashCode() and equals() methods.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.OverridingEqualsNotSymmetrical">
    <Details>
<![CDATA[查找重写超类中的equals方法，但其中的等价关系可能不是对称的。  <p> Looks for equals methods that override equals methods in a superclass where the equivalence relationship might not be symmetrical. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNakedNotify">
    <Details>
<![CDATA[<p>该检测器查找那些似乎未修改可变对象状态的对notify()的调用。  </p>  <p> This detector looks for calls to notify() that don't seem to modify mutable object state.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindReturnRef">
    <Details>
<![CDATA[<p>该检测器查找返回可变静态数据的方法。</p>  <p> This detector looks for methods that return mutable static data. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindRunInvocations">
    <Details>
<![CDATA[<p>此检测器会查找对 Thread.run() 的调用。它是一个快速的检测器。</p>  <p> This detector looks for calls to Thread.run().  It is a fast detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSpinLoop">
    <Details>
<![CDATA[<p>这个检测器查找会从字段读取数据的循环。</p>  <p> This detector looks for loops that spin reading from a field. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindTwoLockWait">
    <Details>
<![CDATA[<p>此检测器会查找持有两个（或多个）锁的情况下调用wait()的情况。它是一个较慢的检测器。</p>  <p> This detector looks for calls to wait() with two (or more) locks held. It is a slow detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnconditionalWait">
    <Details>
<![CDATA[<p>该检测器查找不在条件语句或循环中的wait()调用。</p>  <p> This detector looks for calls to wait() not in a conditional or loop. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUninitializedGet">
    <Details>
<![CDATA[<p>该检测器查找构造函数中读取未初始化字段的情况。</p>  <p> This detector looks for reads of uninitialized fields in constructors. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnsyncGet">
    <Details>
<![CDATA[<p>此检测器寻找在其中get方法未同步而set方法已同步的获取和设置方法。  </p>  <p> This detector looks for get and set methods where the get is unsynchronized while the set is synchronized.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InitializationChain">
    <Details>
<![CDATA[<p>该检测器查找潜在的循环类初始化依赖关系。</p>  <p> This detector looks for potentially circular class initialization dependencies.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.IteratorIdioms">
    <Details>
<![CDATA[<p>该检测器查找Iterator类定义中存在的问题。 </p>  <p> This detector looks for problems in how Iterator classes are defined. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.LockedFields">
    <Details>
<![CDATA[<p>该检测器查找以不一致的锁定方式访问字段的情况。</p>  <p> This detector looks for fields that are accessed in an inconsistent manner with respect to locking.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.EqStringTest">
    <Details>
<![CDATA[<p>该检测器查找使用 == 或 != 操作符比较 String 对象的情况。</p>  <p> This detector looks for comparisons of String objects using the == or != operators.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MutableLock">
    <Details>
<![CDATA[<p>该检测器查找对来自修改字段的对象进行同步的情况。 </p>  <p> This detector looks for synchronization on objects read from modified fields.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SynchronizingOnContentsOfFieldToProtectField">
    <Details>
<![CDATA[<p>这个检测器寻找可能在为了保护对该字段的更新而对字段进行同步的代码。</p>  <p> This detector looks for code that seems to be synchronizing on a field in order to guard updates of that field. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MutableStaticFields">
    <Details>
<![CDATA[<p>此检测器寻找可能被恶意代码修改的静态字段。  </p>  <p> This detector looks for static fields that may be modified by malicious code.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.Naming">
    <Details>
<![CDATA[<p>此检测器会查找名称可疑的方法。 </p>  <p> This detector looks for suspiciously-named methods.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ReadReturnShouldBeChecked">
    <Details>
<![CDATA[<p>这个检测器会查找对InputStream.read()或InputStream.skip()方法的调用，其中返回值被忽略。 </p>  <p> This detector looks for calls to InputStream.read() or InputStream.skip() where the return value is ignored.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SerializableIdiom">
    <Details>
<![CDATA[<p>该检测器用于查找可序列化类实现中的潜在问题。  </p>  <p> This detector looks for potential problems in the implementation of Serializable classes.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.StartInConstructor">
    <Details>
<![CDATA[<p>此检测器查找启动线程的构造函数。  </p>  <p> This detector looks for constructors that start threads.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindBadForLoop">
    <Details>
<![CDATA[<p>此检测器寻找错误的for循环。 </p>  <p> This detector looks for incorrect for loops. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ExplicitSerialization">
    <Details>
<![CDATA[<p>查找显式的序列化，通过检查使用了readObject和writeObject方法来证明该类确实进行了序列化。</p>  <p> Looks for explicit serialization via readObject and     writeObject as evidence that this class is, indeed, serialized. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.UnreadFields">
    <Details>
<![CDATA[<p>这个检测器查找从未被读取的字段。</p>  <p> This detector looks for fields whose value is never read.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.WaitInLoop">
    <Details>
<![CDATA[<p>该检测器查找不在循环中的wait()调用。</p>  <p> This detector looks for calls to wait() that are not in a loop. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BCPMethodReturnCheck">
    <Details>
<![CDATA[<p>此检测器用于查找调用返回值被可疑忽略的方法的实例。这是一个运行速度较慢的检测器。</p>  <p> This detector looks for calls to methods where the return value is suspiciously ignored.  It is a slow detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindComparatorProblems">
    <Details>
<![CDATA[<p>该检测器用于查找Comparator.compare或Comparable.compareTo实现中的问题。</p>  <p> This detector looks for problems in Comparator.compare or Comparable.compareTo implementation.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNullDeref">
    <Details>
<![CDATA[<p>这个检测器会查找可能会抛出空指针异常的地方。它还会检查对引用值与null的冗余比较。这是一个运行较慢的检测器。</p>  <p> This detector looks for places where a null pointer exception might occur.  It also looks for redundant comparisons of reference values against null.  It is a slow detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNullDerefsInvolvingNonShortCircuitEvaluation">
    <Details>
<![CDATA[<p>该检测器查找可能出现空指针异常的地方，而使用非短路评估会使得常规技术失效。</p>  <p> This detector looks for places where a null pointer exception might occur, and the use of non-short-circuit evaluation causes the usual techniques to fail. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindOpenStream">
    <Details>
<![CDATA[<p>该检测器查找不会从方法中逃逸且在所有路径结束时似乎未被关闭的IO流对象。这是一个运行较慢的检测器。</p>  <p> This detector looks for IO stream objects which do not escape the method and do not appear to be closed on all paths out of the method. It is a slow detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.PreferZeroLengthArrays">
    <Details>
<![CDATA[<p>该检测器查找返回数组或显式空引用的方法。在这种情况下，返回空数组通常比返回空引用更可取。</p>  <p> This detector looks for methods that return either arrays or an explicit null reference. Returning a zero length array is generally preferred in this context to returning a null reference. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUselessControlFlow">
    <Details>
<![CDATA[<p>该检测器查找没有效果的控制流语句。 </p>  <p> This detector looks for control flow statements which have no effect. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnreleasedLock">
    <Details>
<![CDATA[<p>此检测器查找在方法中获取但未在所有路径上释放的 JSR-166（<code>java.util.concurrent</code>）锁。这是一个相对较快的检测器。请注意，为了使用此检测器，您需要将 <code>java.util.concurrent</code> 包添加到辅助类路径中（或者正在分析该包本身）。 </p>  <p> This detector looks for JSR-166 (<code>java.util.concurrent</code>) locks which are acquired, but not released on all paths out of the method.&nbsp; It is a moderately fast detector.&nbsp; Note that in order to use this detector, you need to have the <code>java.util.concurrent</code> package in the auxiliary classpath (or be analyzing the package itself).</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindRefComparison">
    <Details>
<![CDATA[<p>此检测器会查找使用 == 或 != 运算符比较两个引用值的地方，并且被比较的类是类型（如 <code>java.lang.String</code>），在这种情况下，比较引用值通常是一个错误。这是一个较慢的检测器。</p>  <p> This detector looks for places where two reference values are compared with the == or != operator, and the class is of a type (such as <code>java.lang.String</code>) where comparing reference values is generally an error.  It is a slow detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindMismatchedWaitOrNotify">
    <Details>
<![CDATA[<p>该检测器会查找未在当前锁定的对象上调用wait()、notify()或notifyAll()的方法调用。这是一个相对较快的检测器。<b>由于该检测器仍在开发中，并会产生过多的误报，因此已禁用此检测器。</b></p>  <p> This detector looks for calls to wait(), notify(), or notifyAll() which do not appear to be made on an object which is currently locked.&nbsp; It is a moderately fast detector.&nbsp; <b>This detector is disabled because it is still under development, and produces too many false positives.</b></p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindEmptySynchronizedBlock">
    <Details>
<![CDATA[<p>此检测器用于查找空的同步块。</p>  <p> This detector looks for empty synchronized blocks.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindInconsistentSync2">
    <Details>
<![CDATA[<p>该检测器查找以不一致的方式访问字段的情况，特别是与锁定相关的情况。这是一个运行较慢的检测器。</p>  <p> This detector looks for fields that are accessed in an inconsistent manner with respect to locking.  It is a slow detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindLocalSelfAssignment2">
    <Details>
<![CDATA[<p>该检测器寻找局部变量的自我赋值情况。 </p>  <p> This detector looks for self assignments of local variables. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.IncompatMask">
    <Details>
<![CDATA[<p>该检测器寻找可疑的位逻辑表达式。</p>  <p> This detector looks for suspicious bitwise logical expressions. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.LazyInit">
    <Details>
<![CDATA[<p>此检测器用于查找非易失性字段的懒初始化情况。它是一种较快的检测器。</p>  <p> This detector looks for lazy field initialization where the field is not volatile.  It is a moderately fast detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindJSR166LockMonitorenter">
    <Details>
<![CDATA[<p>该检测器用于查找在JSR166锁上进行的普通同步操作。它是一个较快的检测器。</p>  <p> This detector looks for ordinary synchronization performed on JSR166 locks.  It is a moderately fast detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUncalledPrivateMethods">
    <Details>
<![CDATA[<p>该检测器查找从未被调用的私有方法。 </p>  <p> This detector looks for private methods that are never called. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.StringConcatenation">
    <Details>
<![CDATA[<p>此检测器会在循环中查找使用+进行的字符串连接。</p>  <p> This detector looks for String concatenation in loops using +. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InefficientInitializationInsideLoop">
    <Details>
<![CDATA[<p>该检测器寻找在循环中初始化的对象，以便将其移出循环以提高性能。</p>  <p> This detector looks for objects initialized within loop which can be moved outside for better performance. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InefficientIndexOf">
    <Details>
<![CDATA[<p>该检测器查找使用 String.indexOf(String) 或 String.lastIndexOf(String)，并且传递的常量字符串长度为1的代码。建议使用更高效的整数实现方法。这是一个快速检测器。 </p>  <p> This detector looks for code that uses String.indexOf(String) or String.lastIndexOf(String), passing a constant string of length 1. It is recommended to use the more efficient integer implementations. A fast detector. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InefficientToArray">
    <Details>
<![CDATA[<p>该检测器查找使用包含零长度数组参数的toArray()方法将集合转换为数组的代码。</p>  <p> This detector looks for code that converts Collections to arrays using the toArray() method that takes a prototype array, passing an array argument which is zero-length. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InvalidJUnitTest">
    <Details>
<![CDATA[<p>该检测器用于查找格式错误的JUnit测试。 </p>  <p> This detector looks for JUnit tests that are malformed. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BadlyOverriddenAdapter">
    <Details>
<![CDATA[<p>该检测器查找扩展了Adapter类并用错误的签名重写了Listener方法的代码。 </p>  <p> This detector looks for code that extends an Adapter class and overrides a Listener method with the wrong signature. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BadResultSetAccess">
    <Details>
<![CDATA[<p>此检测器会查找对结果集的 getXXX 或 setXXX 方法的调用，其中字段索引为 0。由于结果集的字段从索引 1 开始，因此这总是错误的。 </p>  <p> This detector looks for calls to getXXX or setXXX methods of a result set where the field index is 0. As ResultSet fields start at index 1, this is always a mistake. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SuperfluousInstanceOf">
    <Details>
<![CDATA[<p>此检测器查找使用 instanceof 运算符进行类型检查的情况，而这些判断可以通过静态分析来确定。 </p>  <p> This detector looks for type checks using the instanceof operator where the determination can be done statically. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BadAppletConstructor">
    <Details>
<![CDATA[<p>该检测器会查找调用依赖于Applet Stub的方法的Applet构造函数。由于Applet Stub直到init方法执行前不久才会被初始化，因此这些方法在构造函数中将无法正常工作。</p>  <p> This detector looks for Applet constructors that call methods in the parent Applet that rely on the Applet stub. Since this stub isn't initialized until just before the init() method, these methods will fail in the constructor. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SuspiciousThreadInterrupted">
    <Details>
<![CDATA[<p>此检测器会查找从非静态上下文调用Thread.interrupted()的情况。如果它是从Thread.currentThread().interrupted()调用的，则只是多余的步骤，直接使用Thread.interrupted()即可。但是，如果在任意线程对象上调用该方法，则很可能是一个错误，因为interrupted()总是针对当前线程调用的。 </p>  <p> This detector looks for calls to Thread.interrupted() from a non-static context. If it is called from Thread.currentThread().interrupted(), then it is just a useless exercise, just use Thread.interrupted(). However if it is called on an arbitrary thread object, it is most probably an error, as interrupted() is always called on the current thread. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSqlInjection">
    <Details>
<![CDATA[<p>该检测器使用数据流分析来查找在SQL语句中以非常量字符串作为参数调用execute方法的情况。</p>  <p> This detector uses data flow analysis to look for invocations of execute methods on SQL statements in which something other than a constant string is passed as an argument. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindDeadLocalStores">
    <Details>
<![CDATA[<p>该检测器查找从未后续读取的局部变量的赋值。它是一个相对较快的检测器。</p>  <p> This detector looks for assignments to local variables that are never subsequently read. It is a moderately fast detector. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindMaskedFields">
    <Details>
<![CDATA[<p>该检测器查找被方法内定义的局部字段遮蔽的类级别字段。</p>  <p> This detector looks for class level fields that are masked by local fields defined in methods. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.WrongMapIterator">
    <Details>
<![CDATA[<p>此检测器查找使用从 keySet 迭代器检索的键来访问 Map 入口值的情况。</p>  <p> This detector looks for accessing the value of a Map entry, using a key that was retrieved from a keySet iterator. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InstantiateStaticClass">
    <Details>
<![CDATA[<p>这个检测器查找基于仅定义静态方法的类创建对象的代码。</p>  <p> This detector looks for code that creates objects based on classes that only define static methods. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.RuntimeExceptionCapture">
    <Details>
<![CDATA[<p>这个检测器查找捕获Exception异常的catch子句，但在该块中并没有抛出Exception异常的情况。 </p>  <p> This detector looks for catch clauses that catch Exception, when no code in the block throws Exception. </p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DontCatchNullPointerException">
    <Details>
<![CDATA[<p>不应捕获空指针异常。</p>  <p>Nullpointer exceptions should not be caught.</p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindFloatEquality">
    <Details>
<![CDATA[<p>查找浮点数相等表达式。快速检测器。</p>  <p> Looks for floating point equality expressions. A fast detector. </p>]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnsatisfiedObligation">
    <Details>
<![CDATA[<p>该检测器会在方法的所有路径出口查找未清理的I/O流和数据库资源。这是一个运行较慢的检测器。</p>  <p>This detector looks for I/O streams and database resources that are not cleaned up on all paths out of a method.  This is a slow detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.UnnecessaryMath">
    <Details>
<![CDATA[<p>此检测器查找对常量值调用 java.lang.Math 静态方法的代码，其中结果值是静态已知的常量。直接使用常量而不是调用方法有时会更快且更准确。</p>  <p>This detector looks for code that calls java.lang.Math static methods on constant values, where the resultant value is a statically known constant. It is faster, and sometimes more accurate, to use the constant instead.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindCircularDependencies">
    <Details>
<![CDATA[<p>此检测器用于查找类之间的循环依赖关系。 </p>  <p>This detector looks for circular dependencies among classes. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.RedundantInterfaces">
    <Details>
<![CDATA[<p>此检测器查找声明实现与超类相同接口的类。如果超类实现了某个接口，那么子类自然也实现了该接口，这是多余的。</p>  <p>This detector looks for classes that declare they implement the same interface as a super class. This is redundant, if a superclass implements an interface, so does the subclass.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MultithreadedInstanceAccess">
    <Details>
<![CDATA[<p>该检测器寻找实现Struts框架时可能出现的问题。 </p>  <p>This detector looks for potential problems in implementing the Struts framework. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.PublicSemaphores">
    <Details>
<![CDATA[<p>此检测器查找公开类，这些类实现了同步并且使用了 wait()、notify() 或 notifyAll() 方法操作 <b>this</b>。这将同步实现暴露为类的公共构件。该类的客户端可能使用该类的一个实例作为其自己的同步对象，并对基础实现造成破坏。</p>  <p>This detector looks for public classes that synchronize and use wait(), notify() or notifyAll() on <b>this</b>. This exposes a synchronization implementation as a public artifact of the class. Clients of the class may use an instance of the class as its own synchronizing object, and cause havoc to the base implementation. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MethodReturnCheck">
    <Details>
<![CDATA[<p>此检测器查找对返回值被可疑忽略的方法调用的检测。  </p>  <p> This detector looks for calls to methods where the return value is suspiciously ignored.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.IDivResultCastToDouble">
    <Details>
<![CDATA[<p>该检测器寻找将整数除法的结果强制转换为双精度浮点数的情况。通常，本意应该是将整数操作数强制转换为双精度浮点数然后再进行除法运算。</p>  <p> This detector looks for places where the result of integer division is cast to double. Often, what was meant was to cast the integer operands to double and then perform the division. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindBadCast2">
    <Details>
<![CDATA[<p>该检测器使用数据流分析查找对象引用的不良转换。 </p>  <p> This detector looks for bad casts of object references using data flow analysis. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNonSerializableStoreIntoSession">
    <Details>
<![CDATA[<p>该检测器查找将非序列化对象存储到HTTP会话中的情况。</p>  <p> This detector looks for stores of non Serializable objects into HTTP sessions. </p>]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindUseOfNonSerializableValue">
    <Details>
<![CDATA[<p>该检测器查找在需要实现序列化的上下文中使用非序列化对象的情况。</p>  <p> This detector looks for uses of non Serializable objects in contexts that require them to be serializable. </p>]]>
    </Details>
  </Detector>


  <Detector class="edu.umd.cs.findbugs.detect.FindNonSerializableValuePassedToWriteObject">
    <Details>
<![CDATA[<p>该检测器查找传递给ObjectOutput的writeObject方法的非Serializable对象。 </p>  <p> This detector looks for non Serializable objects passed to the writeObject method of an ObjectOutput. </p>]]>
    </Details>
  </Detector>



  <Detector class="edu.umd.cs.findbugs.detect.BadSyntaxForRegularExpression">
    <Details>
<![CDATA[<p>该检测器查找无效语法的正则表达式。  </p>  <p> This detector looks for regular expressions that have invalid syntax.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindPuzzlers">
    <Details>
<![CDATA[<p>此检测器查找由约书亚·布洛奇和尼尔·加佛在《编程困惑》一书中提到的一些琐碎的小错误。  </p>  <p> This detector looks for miscellaneous small errors mentioned by Joshua Bloch and Neal Gafter in their work on Programming Puzzlers.   </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSleepWithLockHeld">
    <Details>
      <![CDATA[<p>    这个检测器会在持有锁的情况下寻找对Thread.sleep()的调用。它是一个较慢的检测器。</p>  <p>    This detector looks for calls to Thread.sleep() made with    a lock held.  It is a slow detector. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DuplicateBranches">
    <Details>
<![CDATA[这个检测器会查找包含相同代码的 if/else 或 switch 语句的两个分支，从而使测试变得没有意义。这种情况通常是由复制粘贴两个分支引起的，导致一个分支的逻辑错误。  <p> This detector looks for if/else or switch statements that have the same code for two branches, thus rendering the test useless. This often is caused by copying and pasting the two branches, causing incorrect logic for the one branch.</p><p></p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InefficientMemberAccess">
    <Details>
<![CDATA[<p>此检测器寻找在内部类中写入拥有类的私有成员变量的情况。在这种情况下，需要使用特殊编译器生成的访问器方法来写入该变量。将可见性放宽至protected可以允许直接写入该字段。</p> <p></p>  <p> This detector looks for internal classes that write to member variables of the owning class, when that member variable is private. In this case, a special compiler generated accessor method needs to be used to write to this variable. Relaxing the visibility to protected will allow the field to be directly written.</p> <p></p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.XMLFactoryBypass">
    <Details>
<![CDATA[<p>此检测器查找直接分配XML接口实现的实例。这将代码绑定到特定的实现，而不是使用提供的工厂模式来创建这些对象。</p> <p></p>  <p> This detector looks for direct allocations of implementations of XML interfaces. This ties the code to a specific implementation, rather than using the supplied factory pattern to create these objects.</p> <p></p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.UselessSubclassMethod">
    <Details>
      <![CDATA[<p>该检测器查找子类中实现的由超类定义的方法，这些方法只是原封不动地将参数传递给父类的方法。这些方法可以直接删除。</p>  <p> This detector looks for subclasses that implement methods defined in the super class, that only pass the parameters untouched to the parent class method. These methods can just be removed. </p> <p></p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ConfusedInheritance">
    <Details>
      <![CDATA[<p>此检测器查找声明了受保护成员的最终类。由于此类无法派生，成员使用受保护访问级别是不正确的。应将访问级别更改为 public 或 private 以正确表示该字段的意图。这可能是由于未完全将该类的所有部分转换为新的范式而仅改变了其用途所导致的。</p>  <p> This detector looks for final classes that declare protected members. As this class cannot be derived from, the use of protected access for members is incorrect. The access should be changed to public or private to represent the correct intention of the field. This was probably caused by a change in use for this class, without completely changing all of the class to the new paradigm. </p> <p></p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.QuestionableBooleanAssignment">
    <Details>
      <![CDATA[<p>这个检测器寻找将字面量布尔值简单赋给变量用于条件表达式中的情况。</p>  <p> This detector looks for simple assignments of literal boolean values to variables in conditional expressions. </p> <p></p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainNullReturnValues">
    <Details>
      <![CDATA[<p> TrainNullReturnValues 确定哪些方法可能返回 null，并将这些方法保存到一个文件中。生成的文件可以在后续检查中使用，以提高空指针检测器的精度。由于这只是训练过程，因此不会报告任何警告。 </p>
<p> 这是一个较慢的检测器。 </p>  <p> TrainNullReturnValues determines which methods may return null and saves them to a file.  The resulting file may be used in a subsequent pass to improve the precision of the null-dereference detector. Since this is just a training pass, no warnings are reported. </p> <p> This is a slow detector. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainUnconditionalDerefParams">
    <Details>
      <![CDATA[<p>TrainUnconditionalParamDerefs确定哪些方法可能无条件地反查参数，并将这些信息保存到一个文件中。生成的文件可以在后续处理中使用，以提高空指针检测器的精确度。由于这只是训练过程，因此不会报告任何警告。</p>
<p>这是一个较慢的检测器。</p>  <p> TrainUnconditionalParamDerefs determines which methods may unconditionally dereference parameters and saves them to a file. The resulting file may be used in a subsequent pass to improve the precision of the null-dereference detector. Since this is just a training pass, no warnings are reported. </p> <p> This is a slow detector. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainFieldStoreTypes">
    <Details>
      <![CDATA[<p>TrainFieldStoreTypes分析存储在字段中的类型，并将这些类型存储到数据库中。稍后可以使用该数据库来进行更精确的类型分析。</p>
<p>这是一个较慢的检测器。</p>  <p> TrainFieldStoreTypes analyzes the types stored into fields and stores them to a database.  The database may be used in a later pass to make type analysis more precise. </p> <p> This is a slow detector. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainNonNullAnnotations">
    <Details>
      <![CDATA[<p>TrainNonNullAnnotations 收集 @Nonnull 和 @PossiblyNull 注解，并将其存储到数据库文件中。这是一个快速检测器。</p>  <p> TrainNonNullAnnotations collects @Nonnull and @PossiblyNull annotations and stores them to database files.  This is a fast detector. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckCalls">
    <Details>
      <![CDATA[<p>此检测器仅用于调试SpotBugs中的方法调用解析，请勿启用。</p>  <p>This detector is just for debugging method call resolution in SpotBugs. Don't enable it.</p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindBugsSummaryStats">
    <Details>
<![CDATA[<p>这个检测器仅仅收集分析过程的摘要统计信息。 </p>  <p> This detector just collects summary statistics information about the analysis process. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestASM">
    <Details>
    <![CDATA[<p>     这个检测器是一个示例，展示了如何使用ASM字节码分析框架编写一个SpotBugs检测器。     </p>  <p>     This detector is a code example showing how to write a SpotBugs     detector using the ASM bytecode analysis framework.     </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ViewCFG">
    <Details>
      <![CDATA[<p>从控制流图（CFG）生成DOT文件。 </p>  <p> Generate DOT files from the CFGs. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnrelatedTypesInGenericContainer">
    <Details>
    <![CDATA[<p>这个检测器会检查传递给泛型集合方法的参数，这些方法接收一个<code>java.lang.Object</code>。它会查看该参数的类型是否与集合的参数相关。如果参数的类类型与集合无关，则该参数永远不会在集合中出现。例如，如果<code>foo</code>是一个<code>List&lt;String&gt;</code>，而<code>bar</code>是一个<code>StringBuffer</code>，那么调用<code>foo.contains(bar)</code>总是会返回false。这是一个快速的检测器。</p>  <p> This detector looks at the arguments of calls to generic     collection methods that receive a <code>java.lang.Object</code>     to see if the argument's type is related to the collection's     parameter. Arguments with unrelated class types are never going     to be in the collection. For example, if <code>foo</code> is a     <code>List&lt;String&gt;</code> and <code>bar</code> is a     <code>StringBuffer</code>, the call <code>foo.contains(bar)</code>     will always return false. This is a fast detector.     </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.StaticCalendarDetector">
    <Details>
<![CDATA[<p>此检测器会警告关于类型为 java.util.Calendar 或 java.text.DateFormat（及其子类）的静态字段，因为 Calendar 在多线程环境中使用是不安全的。 </p>  <p>This detector warns about static fields of type java.util.Calendar or java.text.DateFormat (and subclasses) because  Calendars are inherently unsafe for multithreaded use. </p>]]>
</Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestDataflowAnalysis">
    <Details>
      <![CDATA[这是一款仅用于测试数据流分析的内部检测器。它默认不启用。  <p>This is an internal detector used only for testing dataflow analyses.     It is not enabled by default.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckTypeQualifiers">
    <Details>
      <![CDATA[<p>检查由JSR-305类型注解指定的属性违规情况。</p>  <p>Check for violations of properties specified by JSR-305   type qualifier annotations.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.AppendingToAnObjectOutputStream">
    <Details>
      <![CDATA[<p>查找向对象输出流追加的尝试。</p>  <p>Looks for an attempt to append to an object output stream.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckExpectedWarnings">
    <Details>
          <![CDATA[<p>检查@ExpectedWarning和@NoWarning注释。此检测器仅用于测试SpotBugs。</p>  <p>Checks @ExpectedWarning and @NoWarning annotations.     This detector is used only for testing SpotBugs.</p>]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DontIgnoreResultOfPutIfAbsent">
    <Details>
          <![CDATA[<p>检查如果忽略了 putIfAbsent 的结果，则第二个参数传递的值不应被重用。</p>  <p>Checks that if the result of putIfAbsent is ignored, the value passed as the second argument is not reused. </p>]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ReadOfInstanceFieldInMethodInvokedByConstructorInSuperclass">
    <Details>
          <![CDATA[<p>检查从构造方法调用的 superclass 方法。 </p>  <p>Checks for methods invoked from constructors for superclasses.  </p>]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DefaultEncodingDetector">
    <Details>
<![CDATA[<p>检查对使用用户默认平台编码进行字节到字符串（或字符串到字节）转换的方法调用。这可能会导致应用程序的行为在不同平台上有所不同。 </p>  <p> Checks for calls to methods which perform a byte to String (or String to byte) conversion using the user's default  platform encoding. This can cause the application behavior to vary between platforms.  </p>]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckRelaxingNullnessAnnotation">
    <Details>
      <![CDATA[检查重写的方法不得放宽返回值的@Nonnull注解（使其变为@CheckForNull），或参数的@CheckForNull注解（使其变为@Nonnull）。  <p>Checks that overriding methods do not relax @Nonnull (made @CheckForNull) on return values   or @CheckForNull (made @Nonnull) on parameters.</p>]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DontAssertInstanceofInTests">
    <Details>
      <![CDATA[<p>JUnit测试中的模式检测器，用于检查对象类型是否通过assertinstanceof操作符断言。</p>
<p>应避免这样做，因为不适当的强制转换可能导致ClassCastException，这可能提供更多关于错误原因的信息，而不是assert instanceoft操作符结果的“false is not true”消息。</p>
<p>这是一个快速的检测器。</p>  <p>Detector for patterns in JUnit tests where the type of an object    is checked by asserting the instanceof operator.</p> <p>    This should be avoided as the ClassCastException that would result    from an improper cast may provide more information regarding the    cause of the error than a "false is not true" message which would    result from asserting the result of the instanceof operator. </p>    <p>It is a fast detector</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindBadEndOfStreamCheck">
    <Details>
      <![CDATA[<p>检测将 java.io.FileInputStream.read() 或 java.io.FileReader.read() 的返回值在与 -1 比较之前进行转换的模式。</p>
<p>这两个方法都返回 int。如果将 int 转换为 byte（对于 FileInputStream.read()），那么 -1 和字节 0xFF 就无法区分。如果将其转换为 char（对于 FileReader.read()），-1 将变为 0xFFFF，这在 Java 中字符是无符号的情况下等同于 Character.MAX_VALUE。</p>  <p>Detector for patterns where the return value of java.io.FileInputStream.read() or    java.io.FileReader.read() is converted before checking against -1.</p> <p>    Both methods return an int. If this int is converted to byte (in the case of    FileInputStream.read()) then -1 and the byte 0xFF become indistinguishable.    If it is converted to char (in the case of FileReader.read()) then -1 becomes    0xFFFF which is Character.MAX_VALUE since characters are unsigned in Java. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ReflectionIncreaseAccessibility">
    <Details>
      <![CDATA[<p>检测公开方法在其参数中实例化类的情况。</p>
<p>攻击者可能会使用没有公共构造函数的类调用此方法。</p>  <p>Detector for public methods instantiating a class they get in their parameter.</p>    <p> An attacker may invoke this method with a class that has no public constructor.    </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindOverridableMethodCall">
    <Details>
      <![CDATA[<p>检测从构造函数或clone()方法调用可覆盖方法的模式。</p>
<p>从构造函数调用可覆盖方法可能会使用未初始化的数据。从clone()方法调用此类方法是不安全的。</p>  <p>Detector for patterns where a constructor or a clone() method calls an overridable    method.</p> <p>    Calling an overridable method from a constructor may result in the use of    uninitialized data. Calling such method from a clone() method is insecure. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindInstanceLockOnSharedStaticData">
    <Details>
      <![CDATA[<p>   用于检测共享静态数据被实例级别非静态同步方法修改，或者在使用非静态锁对象的同步块中修改的情况。</p>
<p>    程序不得使用实例锁来保护静态共享数据，因为当创建了类的多个实例时，实例锁是无效的。因此，如果不使用静态锁对象，共享状态将无法得到并发访问的保护。</p>  <p>   Detector for patterns where a shared static data is modified by either an instance level non-static synchronized   method, or inside a synchronized block, which used a non-static lock object. </p> <p>    Programs must not use instance locks to protect static shared data because instance locks are ineffective    when two or more instances of the class are created.    Consequently, failure to use a static lock object leaves the shared state unprotected against concurrent access. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DontUseFloatsAsLoopCounters">
    <Details>
      <![CDATA[<p>检查循环计数器中是否使用了浮点数。</p>  <p>Checks for floats in loop counters.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.PermissionsSuper">
    <Details>
      <![CDATA[<p>检查实现接口 <code>java.security.SecureClassLoader</code> 的类中的 <code>getPermissions()</code> 方法。这些方法必须始终调用 <code>super.getPermissions()</code> 以获取对象的初始值，该值他们在最后返回。</p>  <p>Checks method getPermissions() of classes implementing interface    java.security.SecureClassLoader. The methods must always call    super.getPermissions() to get the initial value of the object    which they return at the end.   </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindPotentialSecurityCheckBasedOnUntrustedSource">
    <Details>
      <![CDATA[<p>在进入doPrivileged块之前查找对不可信源的安全检查。</p>  <p>Looks for potential security checks on an untrusted source before entering a    doPrivileged block.</p>]]>
    </Details>
  </Detector>
  <!--
  **********************************************************************
  BugPatterns
  **********************************************************************
   -->

  <BugPattern type="JUA_DONT_ASSERT_INSTANCEOF_IN_TESTS">
    <ShortDescription>在测试中使用 `instanceof` 断言值是不推荐的。  Asserting value of instanceof in tests is not recommended.</ShortDescription>
    <LongDescription>在{2}位置的{0}断言可能隐藏了类型转换失败的原因。</LongDescription>
    <Details>
      <![CDATA[<p>在测试中断言类型检查不被推荐，因为类转换异常信息可能比使用 instanceof 断言提供的消息更能指示为何会使用错误类型的实例。</p>
<p>当调试因无效类型转换而导致失败的测试时，观察 ClassCastException 的输出可能会更有用，因为它可以提供实际遇到的类型的信息。而在强制转换之前断言类型则会导致“false is not true”这样不那么有信息量的消息。</p>
<p>如果使用 JUnit 与 hamcrest，可以考虑使用 hamcrest 中的 <a href="https://junit.org/junit4/javadoc/latest/index.html?org/hamcrest/core/IsInstanceOf.html"><code>IsInstanceOf</code></a> 类来代替。</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="OVERRIDING_METHODS_MUST_INVOKE_SUPER">
    <ShortDescription>使用了@OverridingMethodsMustInvokeSuper注解的方法，但重写方法并未调用超类方法。  Super method is annotated with @OverridingMethodsMustInvokeSuper, but the overriding method isn't calling the super method.</ShortDescription>
    <LongDescription>使用了@OverridingMethodsMustInvokeSuper注解的方法，但{1}没有调用父类方法。</LongDescription>
    <Details>
      <![CDATA[<p>@OverridingMethodsMustInvokeSuper 注解了超方法，但覆盖方法并未调用super方法。</p>]]>
    </Details>  </BugPattern>
  <BugPattern type="CNT_ROUGH_CONSTANT_VALUE">
    <ShortDescription>已知常量的近似值被找到  Rough value of known constant found</ShortDescription>
    <LongDescription>找到的近似值为 {3}：{2}</LongDescription>
    <Details>
      <![CDATA[<p>建议使用预定义的库常量以提高代码清晰度和精度。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SKIPPED_CLASS_TOO_BIG">
    <ShortDescription>分析的类太大了。  Class too big for analysis</ShortDescription>
    <LongDescription>{0} 分析起来太大了。</LongDescription>
    <Details>
      <![CDATA[<p>这个类的大小超过了可以有效处理的范围，并且没有完全分析出其中的所有错误。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NOISE_NULL_DEREFERENCE">
    <ShortDescription>关于空指针解引用的虚假警告  Bogus warning about a null pointer dereference</ShortDescription>
    <LongDescription>在{1}处有关空指针解引用的虚假警告</LongDescription>
    <Details>
      <![CDATA[<p>虚假警告。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NOISE_METHOD_CALL">
    <ShortDescription>关于方法调用的虚假警告  Bogus warning about a method call</ShortDescription>
    <LongDescription>在《1》中，关于方法调用{2}存在虚假警告</LongDescription>
    <Details>
      <![CDATA[<p>虚假警告。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NOISE_FIELD_REFERENCE">
    <ShortDescription>关于字段引用的虚假警告  Bogus warning about a field reference</ShortDescription>
    <LongDescription>关于在{1}中引用{2}的虚假警告</LongDescription>
    <Details>
      <![CDATA[<p>无效警告。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NOISE_OPERATION">
    <ShortDescription>关于操作的虚假警告  Bogus warning about an operation</ShortDescription>
    <LongDescription>关于操作 {1} 的虚假警告</LongDescription>
    <Details>
      <![CDATA[<p>无效警告。</p>]]>
    </Details>
  </BugPattern>
    <BugPattern type="DMI_BIGDECIMAL_CONSTRUCTED_FROM_DOUBLE">
        <ShortDescription>从非精确表示的double构造BigDecimal  BigDecimal constructed from double that isn't represented precisely</ShortDescription>
        <LongDescription>从 `{1}` 构造了 `BigDecimal` 对象 `{4}`</LongDescription>
        <Details>
      <![CDATA[<p>这段代码从一个double值创建了一个BigDecimal，但这个转换并不理想。例如，有人可能会认为在Java中编写 `new BigDecimal(0.1)` 会生成一个正好等于0.1的BigDecimal（无标量值为1，比例为1），但实际上它等于0.1000000000000000055511151231257827021181583404541015625。你可能应该使用 `BigDecimal.valueOf(double d)` 方法，该方法使用double的字符串表示来创建BigDecimal（例如，`BigDecimal.valueOf(0.1)` 给出的是0.1）。 </p>]]>
    </Details>
    </BugPattern>

    <BugPattern type="DMI_DOH">
        <ShortDescription>阿嚏！一个毫无意义的方法调用  D'oh! A nonsensical method invocation</ShortDescription>
        <LongDescription>哎呀！在{1}中无意义地调用了{2.nameAndSignature}。</LongDescription>
        <Details>
      <![CDATA[<p>这种方法调用没有意义，原因从检查即可明显看出。 </p>]]>
    </Details>
    </BugPattern>

  <BugPattern type="DMI_VACUOUS_CALL_TO_EASYMOCK_METHOD">
    <ShortDescription>对EasyMock方法的无用/空洞调用  Useless/vacuous call to EasyMock method</ShortDescription>
    <LongDescription>在{1}中对{2}进行了无用/多余的调用</LongDescription>
    <Details>
      <![CDATA[<p>这个调用没有向EasyMock方法传递任何对象，因此该调用什么也没有做。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_SCHEDULED_THREAD_POOL_EXECUTOR_WITH_ZERO_CORE_THREADS">
    <ShortDescription>创建带有零核心线程的ScheduledThreadPoolExecutor  Creation of ScheduledThreadPoolExecutor with zero core threads</ShortDescription>
    <LongDescription>在{1}中创建核心线程数为零的ScheduledThreadPoolExecutor</LongDescription>
    <Details>
      <![CDATA[<p>(<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html#ScheduledThreadPoolExecutor-int-">Javadoc</a>) 一个核心线程数为零的 ScheduledThreadPoolExecutor 将不会执行任何任务；对最大线程池大小的更改将被忽略。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_FUTILE_ATTEMPT_TO_CHANGE_MAXPOOL_SIZE_OF_SCHEDULED_THREAD_POOL_EXECUTOR">
    <ShortDescription>尝试更改 ScheduledThreadPoolExecutor 的最大线程池大小无济于事  Futile attempt to change max pool size of ScheduledThreadPoolExecutor</ShortDescription>
    <LongDescription>在 {1} 中尝试更改 ScheduledThreadPoolExecutor 的最大线程池大小失败</LongDescription>
    <Details>
      <![CDATA[<p>(<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html">Javadoc</a>) 尽管 ScheduledThreadPoolExecutor 继承自 ThreadPoolExecutor，但其中一些继承来的调优方法对其并不适用。特别是，由于它作为一个固定大小的线程池使用 corePoolSize 个线程和一个无界队列工作，对 maximumPoolSize 的调整没有实际效果。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_UNSUPPORTED_METHOD">
    <ShortDescription>调用不支持的方法  Call to unsupported method</ShortDescription>
    <LongDescription>在{1}中调用了不支持的方法{2}</LongDescription>
    <Details>
      <![CDATA[<p>此方法调用的所有目标都会抛出 UnsupportedOperationException。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_EMPTY_DB_PASSWORD">
    <ShortDescription>空数据库密码  Empty database password</ShortDescription>
    <LongDescription>在{1}中使用了空的数据库密码</LongDescription>
    <Details>
      <![CDATA[<p>此代码使用空密码创建数据库连接，这表明该数据库未受密码保护。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_CONSTANT_DB_PASSWORD">
    <ShortDescription>硬编码的数据库密码  Hardcoded constant database password</ShortDescription>
    <LongDescription>在 {1} 中硬编码了数据库密码常量</LongDescription>
    <Details>
      <![CDATA[<p>这段代码使用硬编码的常量密码创建数据库连接。任何人都可以轻松获取源代码或编译后的代码来学习到这个密码。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="HRS_REQUEST_PARAMETER_TO_COOKIE">
    <ShortDescription>来自不受信任输入的HTTP_cookie  HTTP cookie formed from untrusted input</ShortDescription>
    <LongDescription>从不可信输入{1}形成的HTTP Cookie</LongDescription>
    <Details>
      <![CDATA[<p>这段代码使用了一个不可信的HTTP参数来构建HTTP Cookie。如果将这个Cookie添加到HTTP响应中，将会导致HTTP响应拆分漏洞。更多详情请参见：<a href="http://en.wikipedia.org/wiki/HTTP_response_splitting">http://en.wikipedia.org/wiki/HTTP_response_splitting</a>。</p>
<p>SpotBugs 只会寻找最明显的HTTP响应拆分漏洞。如果 SpotBugs 发现了任何这样的情况，你几乎肯定还有其他未被报告的漏洞。如果你担心HTTP响应拆分问题，你应该考虑使用商业静态分析或渗透测试工具进行更全面的安全检查。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="HRS_REQUEST_PARAMETER_TO_HTTP_HEADER">
    <ShortDescription>HTTP 响应拆分漏洞  HTTP Response splitting vulnerability</ShortDescription>
    <LongDescription>在{1}中，直接将HTTP参数写入HTTP头部输出。</LongDescription>
    <Details>
            <![CDATA[<p>这段代码直接将HTTP参数写入HTTP标头中，这允许发生HTTP响应拆分漏洞。更多详细信息请参见 <a href="http://en.wikipedia.org/wiki/HTTP_response_splitting">http://en.wikipedia.org/wiki/HTTP_response_splitting</a>。</p>
<p>SpotBugs 只查找最明显的HTTP响应拆分漏洞情况。如果 SpotBugs 发现了任何此类问题，你几乎可以肯定还有其他未被报告的漏洞。如果你担心 HTTP 响应拆分问题，你应该认真考虑使用商业静态代码分析或渗透测试工具。</p>]]>
        </Details>
  </BugPattern>



  <BugPattern type="PT_RELATIVE_PATH_TRAVERSAL">
    <ShortDescription>相对路径遍历在Servlet中的使用  Relative path traversal in servlet</ShortDescription>
    <LongDescription>在{1}中存在相对路径遍历漏洞</LongDescription>
    <Details>
<![CDATA[<p>该软件使用HTTP请求参数构建文件路径名，并且该路径应该限制在一个特定目录内，但并未妥善中和诸如 ".." 这样的序列，这些序列可能会解析到一个位于该目录之外的位置。更多详情请参阅 <a href="http://cwe.mitre.org/data/definitions/23.html">http://cwe.mitre.org/data/definitions/23.html</a>。</p>
<p>SpotBugs 只查找最明显的相对路径遍历漏洞。如果 SpotBugs 发现了任何这样的情况，你很可能还有其他未被报告的漏洞。如果你担心相对路径遍历问题，你应该考虑使用商业静态分析或渗透测试工具进行更详细的检查。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="PT_ABSOLUTE_PATH_TRAVERSAL">
    <ShortDescription>在Servlet中使用绝对路径遍历  Absolute path traversal in servlet</ShortDescription>
    <LongDescription>在{1}中存在绝对路径遍历漏洞</LongDescription>
    <Details>
<![CDATA[<p>该软件使用HTTP请求参数构建文件路径，且该路径应该位于一个受限目录内，但并未妥善中和如“/abs/path”这样的绝对路径序列，这些序列可能会解析到超出该目录的位置。更多详情请参见：<a href="http://cwe.mitre.org/data/definitions/36.html">http://cwe.mitre.org/data/definitions/36.html</a></p>
<p>SpotBugs 仅查找最明显、最明显的绝对路径遍历情况。如果 SpotBugs 发现了任何此类问题，你几乎可以确定还有其他未报告的漏洞。如果你担心绝对路径遍历的问题，强烈建议使用商业静态分析或渗透测试工具。 </p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER">
    <ShortDescription>反射型跨站脚本漏洞  Servlet reflected cross site scripting vulnerability</ShortDescription>
    <LongDescription>在{1}中将HTTP参数写入Servlet输出。</LongDescription>
    <Details>
<![CDATA[<p>此代码直接将HTTP参数写入Servlet输出，这允许发生反射型跨站脚本漏洞。有关更多信息，请参阅 <a href="http://en.wikipedia.org/wiki/Cross-site_scripting">http://en.wikipedia.org/wiki/Cross-site_scripting</a>。</p>
<p>SpotBugs 只查找最明显、最直接的跨站脚本漏洞案例。如果 SpotBugs 发现了任何此类情况，你几乎可以确定还有其他未被报告的跨站脚本漏洞。如果你担心跨站脚本问题，你应该认真考虑使用商业静态分析或渗透测试工具。</p>]]>
    </Details>
  </BugPattern>


  <BugPattern type="XSS_REQUEST_PARAMETER_TO_SEND_ERROR">
    <ShortDescription>错误页面中反射的跨站脚本漏洞  Servlet reflected cross site scripting vulnerability in error page</ShortDescription>
    <LongDescription>在{1}中，HTTP参数被写入Servlet错误页面。</LongDescription>
    <Details>
<![CDATA[<p>该代码直接将HTTP参数写入Server错误页面（使用HttpServletResponse.sendError）。回显这种不受信任的输入可能会导致反射型跨站脚本漏洞。有关更多信息，请参阅 <a href="http://en.wikipedia.org/wiki/Cross-site_scripting">http://en.wikipedia.org/wiki/Cross-site_scripting</a>。</p>
<p>SpotBugs 只查找最明显、最直接的跨站脚本案例。如果 SpotBugs 发现了任何这类问题，你很可能还有其他未被报告的跨站脚本漏洞。如果你担心跨站脚本问题，你应该认真考虑使用商业静态分析或渗透测试工具。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="XSS_REQUEST_PARAMETER_TO_JSP_WRITER">
    <ShortDescription>反射型跨站脚本漏洞  JSP reflected cross site scripting vulnerability</ShortDescription>
    <LongDescription>直接将HTTP参数写入JSP输出，导致在{1.class}中存在反射型XSS漏洞。</LongDescription>
    <Details>
<![CDATA[<p>这段代码直接将HTTP参数写入JSP输出，这允许发生跨站脚本漏洞。更多信息请参阅 <a href="http://en.wikipedia.org/wiki/Cross-site_scripting">http://en.wikipedia.org/wiki/Cross-site_scripting</a>。</p>
<p>SpotBugs 只会查找最明显的跨站脚本漏洞案例。如果 SpotBugs 发现了任何这种情况，你很可能还有其他未被报告的跨站脚本漏洞。如果你担心跨站脚本问题，你应该认真考虑使用商业静态分析或渗透测试工具。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SW_SWING_METHODS_INVOKED_IN_SWING_THREAD">
    <ShortDescription>某些Swing方法需要在Swing线程中调用  Certain swing methods need to be invoked in Swing thread</ShortDescription>
    <LongDescription>在 `{1}` 中对 swing 方法的调用需要在 Swing 事件线程中执行</LongDescription>
    <Details>
<![CDATA[<p>(来自JDC技术提示): Swing 方法 show()、setVisible() 和 pack() 会为框架创建相应的同辈对象。随着同辈对象的创建，系统会创建事件分派线程。这会使事情变得复杂，因为事件分派线程可能会在 pack 和 validate 处理过程中通知监听者。这种情况下，两个线程可能会通过 Swing 基于组件的 GUI 进行操作——这是一个严重的缺陷，可能导致死锁或其他相关线程问题。pack 调用会导致组件被实现。当它们正在被实现（即不一定可见）时，可能会在事件分派线程上触发监听者通知。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IL_INFINITE_LOOP">
    <ShortDescription>一个明显的无限循环  An apparent infinite loop</ShortDescription>
    <LongDescription>在{1}中有明显的无限循环。</LongDescription>
    <Details>
<![CDATA[<p>这个循环似乎没有终止的方式（除非通过抛出异常）。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IL_INFINITE_RECURSIVE_LOOP">
    <ShortDescription>明显的无限递归循环  An apparent infinite recursive loop</ShortDescription>
    <LongDescription>在{1}中有明显的无限递归循环。</LongDescription>
    <Details>
<![CDATA[<p>该方法无条件地调用自身。这似乎表明存在一个无限递归循环，最终会导致堆栈溢出。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IL_CONTAINER_ADDED_TO_ITSELF">
    <ShortDescription>一个集合将其自身添加到其中。  A collection is added to itself</ShortDescription>
    <LongDescription>在 `{1}` 中，一个集合将其自身添加到其中。</LongDescription>
    <Details>
<![CDATA[<p>将一个集合添加到它自己中。结果，计算这个集合的hashCode将会抛出StackOverflowException异常。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="VO_VOLATILE_REFERENCE_TO_ARRAY">
    <ShortDescription>一个对数组的volatile引用并不会将数组元素本身标记为volatile。  A volatile reference to an array doesn't treat the array elements as volatile</ShortDescription>
    <LongDescription>{1} 是一个易变引用指向的数组；数组元素是非易变的。</LongDescription>
    <Details>
<![CDATA[<p>这声明了一个对数组的volatile引用，可能不是你想要的效果。带有volatile引用的数组，对其引用的读写会作为volatile处理，但数组元素本身是非volatile的。如果你需要volatile数组元素，可以使用java.util.concurrent中的原子数组类（在Java 5.0中提供）。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="VO_VOLATILE_INCREMENT">
    <ShortDescription>对volatile字段的增量操作不是原子性的。  An increment to a volatile field isn't atomic</ShortDescription>
    <LongDescription>在{1}中对volatile字段{2}进行增量操作</LongDescription>
    <Details>
<![CDATA[<p>这段代码会递增/递减一个volatile字段。volatile字段的递增/递减排不是原子操作。如果多个线程同时递增/递减该字段，可能会丢失某些递增/递减操作。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UI_INHERITANCE_UNSAFE_GETRESOURCE">
    <ShortDescription>如果类被扩展，使用 GetResource 可能是不安全的。  Usage of GetResource may be unsafe if class is extended</ShortDescription>
    <LongDescription>在 `{1}` 中使用 `GetResource` 可能存在安全隐患，如果类被扩展的话。</LongDescription>
    <Details>
<![CDATA[<p>如果此类被另一个包中的类扩展，则调用<code>this.getClass().getResource(...)</code>可能会得到与预期不同的结果。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_BOOLEAN_RETURN_NULL">
    <ShortDescription>方法返回布尔类型但显式返回了null  Method with Boolean return type returns explicit null</ShortDescription>
    <LongDescription>{1}具有布尔返回类型，并显式返回了null。</LongDescription>
    <Details>
       <![CDATA[<p>返回 Boolean.TRUE、Boolean.FALSE 或 null 的方法是一个潜在的问题。此方法可以像返回布尔类型值一样被调用，编译器会自动对 Boolean 值进行拆箱处理。如果返回 null 值，则会导致NullPointerException。</p>]]>
       </Details>
  </BugPattern>
  <BugPattern type="NP_OPTIONAL_RETURN_NULL">
    <ShortDescription>带有Optional返回类型的-method-显式返回null  Method with Optional return type returns explicit null</ShortDescription>
    <LongDescription>{1} 使用了Optional返回类型，并且显式地返回了null。</LongDescription>
    <Details>
       <![CDATA[<p>Optional返回类型（java.util.Optional 或 com.google.common.base.Optional）的使用始终意味着设计中不希望显式返回null值。在这种情况下返回null将违反契约，并很可能会破坏客户端代码。</p>]]>
       </Details>
  </BugPattern>
  <BugPattern type="NP_NONNULL_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR">
    <ShortDescription>非空字段未初始化  Non-null field is not initialized</ShortDescription>
    <LongDescription>非空字段 {2.name} 未在 {1} 中初始化</LongDescription>
    <Details>
       <![CDATA[<p>该字段被标记为非空，但构造函数没有对其进行初始化。该字段可能在构造函数的其他地方进行了初始化，或者可能在使用前始终会被初始化。</p>]]>
       </Details>
  </BugPattern>
  <BugPattern type="NP_SYNC_AND_NULL_CHECK_FIELD">
    <ShortDescription>在同一字段上进行同步和空值检查。  Synchronize and null check on the same field.</ShortDescription>
    <LongDescription>在 {1} 中，字段 {2.givenClass} 被同步并检查是否为空。</LongDescription>
    <Details>
<![CDATA[<p>由于该字段是同步锁定的，似乎不太可能是空值。如果它是空值然后进行同步，则会抛出NullPointerException，从而使检查变得没有意义。最好同步另一个字段。</p>]]>
     </Details>
  </BugPattern>
  <BugPattern type="RpC_REPEATED_CONDITIONAL_TEST">
    <ShortDescription>重复的条件判断  Repeated conditional tests</ShortDescription>
    <LongDescription>在{1}中重复了条件测试</LongDescription>
    <Details>
<![CDATA[代码中包含两次对同一个条件的测试，一个紧跟在另一个后面（例如，`x == 0 || x == 0`）。也许第二次测试应该是其他内容（例如，`x == 0 || y == 0`）。]]>
    </Details>
  </BugPattern>
  <BugPattern type="TESTING">
    <ShortDescription>测试  Testing</ShortDescription>
    <LongDescription>在{1}生成警告信息</LongDescription>
    <Details>
<![CDATA[<p>这个错误模式仅由新开发的、尚未完全实现的错误检测器生成。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="TESTING1">
    <ShortDescription>测试 1  Testing 1</ShortDescription>
    <LongDescription>在{1}生成了测试警告1</LongDescription>
    <Details>
<![CDATA[<p>这个错误模式仅由新开发的、尚未完全实现的错误检测器生成。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="TESTING2">
    <ShortDescription>测试 2  Testing 2</ShortDescription>
    <LongDescription>在{1}生成了警告2</LongDescription>
    <Details>
<![CDATA[<p>此错误模式仅由新的、不完全实现的bug检测器生成。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="TESTING3">
    <ShortDescription>测试 3  Testing 3</ShortDescription>
    <LongDescription>在{1}生成了测试警告3</LongDescription>
    <Details>
<![CDATA[<p>这个错误模式仅由新的、尚未完全实现的错误检测器生成。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UNKNOWN">
    <ShortDescription>未知的错误模式  Unknown bug pattern</ShortDescription>
    <LongDescription>在第{1}行未知错误模式 BUG_PATTERN</LongDescription>
    <Details>
<![CDATA[<p>记录了一个警告，但SpotBugs无法找到该错误模式的描述，因此无法对其进行说明。这种情况仅应在SpotBugs本身或其配置存在bug、或者使用插件生成分析结果但当前未加载该插件的情况下发生。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="AM_CREATES_EMPTY_ZIP_FILE_ENTRY">
    <ShortDescription>创建一个空的zip文件条目  Creates an empty zip file entry</ShortDescription>
    <LongDescription>在 {1} 中创建了空的 ZIP 文件条目</LongDescription>
    <Details>
<![CDATA[<p>代码调用了<code>putNextEntry()</code>，紧接着又调用了<code>closeEntry()</code>。这会导致一个空的Zip文件条目。应在<code>putNextEntry()</code>和<code>closeEntry()</code>之间写入条目的内容。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="AM_CREATES_EMPTY_JAR_FILE_ENTRY">
    <ShortDescription>创建一个空的jar文件条目  Creates an empty jar file entry</ShortDescription>
    <LongDescription>在 {1} 中创建了空的 JAR 文件条目</LongDescription>
    <Details>
<![CDATA[<p>代码调用了<code>putNextEntry()</code>，紧接着又调用了<code>closeEntry()</code>。这会导致一个空的JarFile条目。应在调用<code>putNextEntry()</code>和<code>closeEntry()</code>之间向JarFile写入条目的内容。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IMSE_DONT_CATCH_IMSE">
    <ShortDescription>可疑的捕获IllegalMonitorStateException异常  Dubious catching of IllegalMonitorStateException</ShortDescription>
    <LongDescription>在{1}中可疑地捕获了IllegalMonitorStateException</LongDescription>
    <Details>
<![CDATA[<p>`IllegalMonitorStateException` 通常仅在您的代码设计存在缺陷时（例如，在未持有对象锁的情况下调用 `wait` 或 `notify`）抛出。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FL_MATH_USING_FLOAT_PRECISION">
    <ShortDescription>方法使用浮点精度进行数学运算  Method performs math using floating point precision</ShortDescription>
    <LongDescription>{1} 使用浮点精度进行数学运算</LongDescription>
    <Details>
<![CDATA[<p>    该方法使用浮点精度进行数学运算。浮点精度非常不精确。例如，16777216.0f + 1.0f = 16777216.0f。考虑改为使用双精度数学运算。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CAA_COVARIANT_ARRAY_FIELD">
    <ShortDescription>_covariant数组赋值给字段_  Covariant array assignment to a field</ShortDescription>
    <LongDescription>类型为{2}的数组被分配给了类型为{3}的字段</LongDescription>
    <Details>
<![CDATA[<p>协变数组类型被分配给一个字段。这可能会造成混淆，并且如果后来在该数组中存储了其他类型的引用，可能会在运行时引发ArrayStoreException，如下所示的代码：</p>
<pre><code>Number[] arr = new Integer[10]; arr[0] = 1.0; </code></pre>
<p>考虑更改创建的数组类型或字段类型。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CAA_COVARIANT_ARRAY_LOCAL">
    <ShortDescription>协变数组分配给局部变量  Covariant array assignment to a local variable</ShortDescription>
    <LongDescription>类型为 {2} 的数组被赋值给类型为 {3} 的变量</LongDescription>
    <Details>
<![CDATA[<p>协变类型数组被分配给一个局部变量。这可能会导致混淆，并且如果后来在这个数组中存储了其他类型的引用，可能会在运行时引发ArrayStoreException，如下代码所示： </p> <pre><code>Number[] arr = new Integer[10]; arr[0] = 1.0; </code></pre> <p>考虑更改创建的数组类型或局部变量的类型。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CAA_COVARIANT_ARRAY_RETURN">
    <ShortDescription>方法返回了协变数组  Covariant array is returned from the method</ShortDescription>
    <LongDescription>从返回类型为{3}的方法中返回了{2}类型的数组。</LongDescription>
    <Details>
<![CDATA[<p>方法返回协变数组。这可能会引起混淆，并且如果调用代码尝试将其他类型的引用存储在返回的数组中，可能会在运行时引发ArrayStoreException。</p>
<p>考虑更改创建的数组类型或方法的返回类型。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CAA_COVARIANT_ARRAY_ELEMENT_STORE">
    <ShortDescription>协变数组中存储了可能不兼容的元素  Possibly incompatible element is stored in covariant array</ShortDescription>
    <LongDescription>类型为{2}的值被存储到元素类型为{3}的数组中</LongDescription>
    <Details>
<![CDATA[<p>将值存储到数组中，但值的类型与数组类型不匹配。分析显示实际数组类型窄于其变量或字段声明的类型，并且此赋值不符合原始数组类型的要求。这种赋值可能会在运行时导致ArrayStoreException。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CN_IDIOM">
    <ShortDescription>类实现了Cloneable接口，但未定义或使用clone方法。  Class implements Cloneable but does not define or use clone method</ShortDescription>
    <LongDescription>类 {0} 实现了 Cloneable 但未定义或使用 clone 方法</LongDescription>
    <Details>
<![CDATA[<p>    该类实现了Cloneable接口，但未定义或使用clone方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE">
    <ShortDescription>类定义了clone() 但没有实现Cloneable接口  Class defines clone() but doesn't implement Cloneable</ShortDescription>
    <LongDescription>{0} 定义了 clone() 但没有实现 Cloneable 接口</LongDescription>
    <Details>
<![CDATA[<p>该类定义了clone()方法，但类没有实现Cloneable。在某些情况下这是可以接受的（例如，您希望控制子类如何进行克隆），但在这种情况下请确保这就是您的意图。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CN_IDIOM_NO_SUPER_CALL">
    <ShortDescription>克隆方法没有调用super.clone()  clone method does not call super.clone()</ShortDescription>
    <LongDescription>{1} 没有调用 super.clone()</LongDescription>
    <Details>
<![CDATA[<p>这个非最终类定义了一个 `clone()` 方法，该方法未调用 `super.clone()`。如果此类（<i>A</i>）被子类（<i>B</i>）继承，并且子类 <i>B</i> 调用了 `super.clone()`，那么很可能 <i>B</i> 的 `clone()` 方法会返回一个类型为 <i>A</i> 的对象，这违反了 `clone()` 标准合约。</p>
<p>如果所有 `clone()` 方法都调用 `super.clone()`，则可以保证它们使用 `Object.clone()`，而 `Object.clone()` 总是会返回正确类型的对象。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_FUTURE_KEYWORD_USED_AS_IDENTIFIER">
    <ShortDescription>在较新版本的Java中，使用关键字作为标识符  Use of identifier that is a keyword in later versions of Java</ShortDescription>
    <LongDescription>{1} 使用了 {2} 作为变量名，在较新的版本的Java中，{2} 是一个关键字。</LongDescription>
    <Details>
<![CDATA[<p>标识符是预留为Java后期版本的关键词，因此您需要修改代码以便在后期版本的Java中编译。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_FUTURE_KEYWORD_USED_AS_MEMBER_IDENTIFIER">
    <ShortDescription>在较新版本的Java中，使用关键字作为标识符  Use of identifier that is a keyword in later versions of Java</ShortDescription>
    <LongDescription>{1} 与较新版本Java中的关键字冲突</LongDescription>
    <Details>
<![CDATA[<p>该标识符在较新的Java版本中被用作关键字。此代码以及引用该API的任何代码都需要进行更改，以便在较新的Java版本中编译。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DE_MIGHT_DROP">
    <ShortDescription>方法可能会丢弃异常  Method might drop exception</ShortDescription>
    <LongDescription>{1} 可能会丢失 {2}</LongDescription>
    <Details>
<![CDATA[<p>该方法可能会抛出异常。通常情况下，异常应该以某种方式处理或报告，或者从方法中抛出。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DE_MIGHT_IGNORE">
    <ShortDescription>方法可能忽略了异常  Method might ignore exception</ShortDescription>
    <LongDescription>{1} 可能会忽略 {2}</LongDescription>
    <Details>
<![CDATA[<p>该方法可能会忽略一个异常。通常情况下，异常应该以某种方式处理或报告，或者从方法中抛出。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DP_DO_INSIDE_DO_PRIVILEGED">
    <ShortDescription>应该仅在 `doPrivileged` 块内调用的方法被调用了。  Method invoked that should be only be invoked inside a doPrivileged block</ShortDescription>
    <LongDescription>在{1}中调用了{2}，而应该在其内部使用doPrivileged块进行调用。</LongDescription>
    <Details>
<![CDATA[<p>此代码调用了需要进行安全权限检查的方法。如果该代码将被授予安全权限，但可能会由未获得安全权限的代码调用，则该调用需要发生在doPrivileged块中。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DP_DO_INSIDE_DO_PRIVILEDGED"> <!-- misspelled for backward compatibility -->
    <ShortDescription>应该仅在 `doPrivileged` 块内调用的方法被调用了。  Method invoked that should be only be invoked inside a doPrivileged block</ShortDescription>
    <LongDescription>在{1}中调用了{2}，而应该在doPrivileged块内调用它。</LongDescription>
    <Details>
<![CDATA[<p>此代码调用了需要进行安全权限检查的方法。如果此代码将被授予安全权限，但可能由未获得安全权限的代码调用，则该调用需要发生在doPrivileged块中。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED">
    <ShortDescription>类加载器应该仅在 doPrivileged 块中创建  Classloaders should only be created inside doPrivileged block</ShortDescription>
    <LongDescription>{1} 创建了一个 {2} 类加载器，这应该在 doPrivileged 块中执行。</LongDescription>
    <Details>
<![CDATA[<p>这段代码创建了一个类加载器，如果安装了安全管理器，则需要相应的权限。如果这段代码可能由不具备安全权限的代码调用，那么类加载器的创建需要发生在doPrivileged块中。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="JCIP_FIELD_ISNT_FINAL_IN_IMMUTABLE_CLASS">
    <ShortDescription>不可变类的字段应为 final  Fields of immutable classes should be final</ShortDescription>
    <LongDescription>{1.givenClass} 应该被声明为 final，因为 {0} 被标记为 Immutable。</LongDescription>
    <Details>
<![CDATA[<p>该类使用了net.jcip.annotationsImmutable或javax.annotation.concurrent.Immutable注解，而这些注解的规则要求所有字段必须是final类型的。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_THREAD_PASSED_WHERE_RUNNABLE_EXPECTED">
    <ShortDescription>线程参数预期为Runnable接口实例  Thread passed where Runnable expected</ShortDescription>
    <LongDescription>在{1}处，使用了Thread，但期望的是Runnable。</LongDescription>
    <Details>
<![CDATA[<p>将一个 Thread 对象作为参数传递给预期接收 Runnable 的方法中，这相当不常见，并且可能会指示逻辑错误或导致意外的行为。   </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_COLLECTION_OF_URLS">
    <ShortDescription>映射和集合中的URL可能会成为性能瓶颈  Maps and sets of URLs can be performance hogs</ShortDescription>
    <LongDescription>{1} 使用了URL映射或集合，这可能会成为一个性能瓶颈。</LongDescription>
    <Details>
<![CDATA[<p>该方法或字段使用了URL类型的Map或Set。由于URL的equals和hashCode方法会进行域名解析，这可能会导致性能显著下降。更多详细信息请参见<a href="http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html">http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html</a>。考虑使用<code>java.net.URI</code>代替。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_BLOCKING_METHODS_ON_URL">
    <ShortDescription>URL的equals和hashCode方法是存在问题的。  The equals and hashCode methods of URL are blocking</ShortDescription>
    <LongDescription>在{1}中调用了{2}，该方法会阻塞以执行域名解析。</LongDescription>
    <Details>
<![CDATA[<p>URL的equals和hashCode方法会进行域名解析，这可能会导致性能下降。更多信息请参见<a href="http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html">http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html</a>。考虑使用<code>java.net.URI</code>代替。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION">
    <ShortDescription>无法在不运行时保留注解的情况下使用反射检查注解是否存在  Cannot use reflection to check for presence of annotation without runtime retention</ShortDescription>
    <LongDescription>使用反射检查 {1} 中是否存在没有运行时保留的注解 {3}。</LongDescription>
    <Details>
<![CDATA[<p>除非该注解本身被标记为 @Retention(RetentionPolicy.RUNTIME)，否则无法通过反射（例如，使用 isAnnotationPresent 方法）来观察该注解。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_EXIT">
    <ShortDescription>方法调用了System.exit(...)。  Method invokes System.exit(...)</ShortDescription>
    <LongDescription>{1} 调用了 `System.exit(...)`, 这将关闭整个虚拟机。</LongDescription>
    <Details>
<![CDATA[<p>调用System.exit会关闭整个Java虚拟机。只有在适当的情况下才应这样做。这样的调用会让其他代码难以或无法调用你的代码。考虑抛出一个RuntimeException代替。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_RUN_FINALIZERS_ON_EXIT">
    <ShortDescription>方法调用了危险的方法 runFinalizersOnExit  Method invokes dangerous method runFinalizersOnExit</ShortDescription>
    <LongDescription>{1} 调用了危险的方法 runFinalizersOnExit</LongDescription>
    <Details>
<![CDATA[<p>永远不要调用System.runFinalizersOnExit或Runtime.runFinalizersOnExit：它们是Java库中最危险的方法之一。——Joshua Bloch</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_STRING_CTOR">
    <ShortDescription>方法调用了效率低的 `new String(String)` 构造函数  Method invokes inefficient new String(String) constructor</ShortDescription>
    <LongDescription>{1} 调用了低效的 `new String(String)` 构造函数</LongDescription>
    <Details>
<![CDATA[<p>使用 <code>java.lang.String(String)</code> 构造函数浪费内存，因为这样构造的对象将与传入的 <code>String</code> 参数功能上无法区分。直接使用参数 <code>String</code> 即可。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_STRING_VOID_CTOR">
    <ShortDescription>方法调用了不高效的 `new String()` 构造函数  Method invokes inefficient new String() constructor</ShortDescription>
    <LongDescription>{1} 调用了低效的 `new String()` 构造函数</LongDescription>
    <Details>
<![CDATA[<p>使用无参构造函数创建新的 <code>java.lang.String</code> 对象会浪费内存，因为这样创建的对象在功能上将与空字符串常量 <code>""</code> 无法区分。Java 保证相同的字符串常量将由同一个 <code>String</code> 对象表示。因此，你应该直接使用空字符串常量。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_STRING_TOSTRING">
    <ShortDescription>方法调用了String对象的toString()方法。  Method invokes toString() method on a String</ShortDescription>
    <LongDescription>{1} 对字符串调用toString()方法</LongDescription>
    <Details>
<![CDATA[调用 `String.toString()` 是一个多余的操作。可以直接使用字符串本身。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_GC">
    <ShortDescription>显式的垃圾回收；除非在基准代码中，否则极其可疑。  Explicit garbage collection; extremely dubious except in benchmarking code</ShortDescription>
    <LongDescription>{1} 强制进行垃圾回收；除了在基准代码中以外，这种情况极为可疑。</LongDescription>
    <Details>
<![CDATA[<p>代码显式调用了垃圾回收。除了特定的基准测试用途，这通常是不明智的。</p>
<p>在过去，人们在关闭或 finalize 方法等常规中显式调用垃圾收集器的情况导致了巨大的性能瓶颈。垃圾收集可能很昂贵。任何会导致数百甚至数千次垃圾收集的情景都会使机器运行缓慢。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_BOOLEAN_CTOR">
    <ShortDescription>方法调用了低效的Boolean构造函数；请使用Boolean.valueOf(...)代替。  Method invokes inefficient Boolean constructor; use Boolean.valueOf(...) instead</ShortDescription>
    <LongDescription>{1} 调用了低效的 Boolean 构造函数；请使用 Boolean.valueOf(...) 代替。</LongDescription>
    <Details>
<![CDATA[<p>创建新的 <code>java.lang.Boolean</code> 实例会浪费内存，因为 <code>Boolean</code> 对象是不可变的，并且这种类型只有两个有用的价值。请使用 <code>Boolean.valueOf()</code> 方法（或 Java 5 的自动装箱）来代替创建 <code>Boolean</code> 对象。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_NUMBER_CTOR">
    <ShortDescription>方法调用了效率低的Number构造函数；改为使用静态valueOf方法。  Method invokes inefficient Number constructor; use static valueOf instead</ShortDescription>
    <LongDescription>{1} 调用了低效的 {2} 构造函数；请使用 {3} 代替。</LongDescription>
    <Details>
      <![CDATA[<p>使用 `new Integer(int)` 总是会创建一个新的对象，而 `Integer.valueOf(int)` 允许编译器、类库或JVM进行值缓存。使用缓存的值可以避免对象分配，代码运行速度更快。</p>
<p>-128到127之间的值都有对应的缓存实例，并且使用 `valueOf` 方法比构造函数大约快3.5倍。对于常量范围以外的值，两种风格的性能相同。</p>
<p>除非类必须与早于Java 5的JVM兼容，在创建 `Long`、`Integer`、`Short`、`Character` 和 `Byte` 的实例时，请使用自动装箱或 `valueOf()` 方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_FP_NUMBER_CTOR">
    <ShortDescription>方法调用了效率低的浮点Number构造函数；请使用静态valueOf代替。  Method invokes inefficient floating-point Number constructor; use static valueOf instead</ShortDescription>
    <LongDescription>{1} 调用了低效的 {2} 构造函数；请使用 {3} 代替。</LongDescription>
    <Details>
      <![CDATA[<p>使用 `new Double(double)` 总是会创建一个新的对象，而 `Double.valueOf(double)` 允许编译器、类库或 JVM 进行值缓存。使用缓存的值可以避免对象分配，从而使代码更快。</p>
<p>除非类必须与早于 Java 5 的 JVM 兼容，否则在创建 `Double` 和 `Float` 的实例时，请使用自动装箱或 `valueOf()` 方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_CONVERT_CASE">
    <ShortDescription>考虑使用Locale参数化的调用方法版本  Consider using Locale parameterized version of invoked method</ShortDescription>
    <LongDescription>在 {1} 中使用未本地化的 String.toUpperCase() 或 String.toLowerCase() 方法</LongDescription>
    <Details>
<![CDATA[<p>正在使用平台默认编码将 String 转换为大写或小写。这在处理国际字符时可能会导致不正确的转换。请改用以下版本：</p>
<ul>
    <li>String.toUpperCase(Locale l)</li>
    <li>String.toLowerCase(Locale l)</li>
</ul>
<p>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR">
    <ShortDescription>原始值在三元运算符中被拆箱并强制转换  Primitive value is unboxed and coerced for ternary operator</ShortDescription>
    <LongDescription>原始值在{1}中的三元操作符中进行了拆箱和类型转换。</LongDescription>
    <Details>
<![CDATA[<p>在条件三元运算符（<code>b ? e1 : e2</code>）的评估过程中，包裹型原始值会被拆箱并转换为另一种原始类型。Java 的语义规定，如果 <code>e1</code> 和 <code>e2</code> 是包装数值类型，则这些值会进行拆箱操作，并被转换/强制转换为其共同类型（例如，如果 <code>e1</code> 的类型是 <code>Integer</code> 而 <code>e2</code> 的类型是 <code>Float</code>，那么 <code>e1</code> 会被拆箱、转换为浮点值并重新封装。参见 JLS 第 15.25 节）。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BX_BOXING_IMMEDIATELY_UNBOXED">
    <ShortDescription>原始值被装箱然后立即拆箱  Primitive value is boxed and then immediately unboxed</ShortDescription>
    <LongDescription>原始值被装箱然后立即拆箱在{1}中</LongDescription>
    <Details>
<![CDATA[<p>一个原始类型被包装成对象，然后立即又被拆箱。这可能是由于在一个需要未包装值的地方手动进行了包装操作，从而迫使编译器立即取消了包装的操作。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BX_UNBOXING_IMMEDIATELY_REBOXED">
    <ShortDescription>装箱值随即被拆箱然后重新进行装箱  Boxed value is unboxed and then immediately reboxed</ShortDescription>
    <LongDescription>在{1}中，已装箱的值随即又被拆箱并重新进行装箱。</LongDescription>
    <Details>
<![CDATA[<p>一个装箱值被拆箱然后立即再次装箱。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION">
    <ShortDescription>原始值被装箱然后拆箱以执行原始类型的转换  Primitive value is boxed then unboxed to perform primitive coercion</ShortDescription>
    <LongDescription>原始值被装箱然后拆箱在{1}中执行原生类型转换</LongDescription>
    <Details>
<![CDATA[<p>使用装箱操作构建了一个原始值，然后立即转换为不同的原始类型（例如：<code>new Double(d).intValue()</code>)。直接进行原始类型的转换即可（例如：<code>(int) d</code>)。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_BOXED_PRIMITIVE_TOSTRING">
    <ShortDescription>方法分配了一个装箱原始类型只是为了调用toString方法  Method allocates a boxed primitive just to call toString</ShortDescription>
    <LongDescription>只是为了调用toString方法而将原始类型进行装箱在{1}处</LongDescription>
    <Details>
<![CDATA[<p>为了调用 `toString()`，会为一个原始类型分配一个包装对象。直接使用接受原始值的静态 `toString` 形式更为有效。因此，可以将：</p>
<table>
<tr><th>替换...</th><th>改为...</th></tr>
<tr><td>`new Integer(1).toString()`</td><td>`Integer.toString(1)`</td></tr>
<tr><td>`new Long(1).toString()`</td><td>`Long.toString(1)`</td></tr>
<tr><td>`new Float(1.0).toString()`</td><td>`Float.toString(1.0)`</td></tr>
<tr><td>`new Double(1.0).toString()`</td><td>`Double.toString(1.0)`</td></tr>
<tr><td>`new Byte(1).toString()`</td><td>`Byte.toString(1)`</td></tr>
<tr><td>`new Short(1).toString()`</td><td>`Short.toString(1)`</td></tr>
<tr><td>`new Boolean(true).toString()`</td><td>`Boolean.toString(true)`</td></tr>
</table>]]>
    </Details>
  </BugPattern>
    <BugPattern type="DM_BOXED_PRIMITIVE_FOR_PARSING">
    <ShortDescription>将原始类型进行装箱/拆箱以解析  Boxing/unboxing to parse a primitive</ShortDescription>
    <LongDescription>将原始类型进行装箱/拆箱以解析 {1}</LongDescription>
    <Details>
<![CDATA[<p>从字符串创建了一个装箱原始值，仅仅只是为了提取未装箱的原始值。直接调用静态parseXXX方法更为高效。</p>]]>
    </Details>
  </BugPattern>
    <BugPattern type="DM_BOXED_PRIMITIVE_FOR_COMPARE">
    <ShortDescription>将原始类型装箱以便进行比较  Boxing a primitive to compare</ShortDescription>
    <LongDescription>原始类型被包装来调用 {2}：请使用 {3} 替代。</LongDescription>
    <Details>
<![CDATA[<p>为了调用<code>compareTo()</code>方法而创建了一个装箱原始类型。自Java 1.4起可以使用静态比较方法（对于double和float类型），自Java 7起可以用于其他原始类型，直接在原始类型上工作更有效率。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_NEW_FOR_GETCLASS">
    <ShortDescription>方法分配了一个对象，只是为了获取类对象  Method allocates an object, only to get the class object</ShortDescription>
    <LongDescription>仅分配对象以获取类对象</LongDescription>
    <Details>
<![CDATA[<p>该方法只是为了调用其上的getClass()而分配了一个对象，以便获取该对象的Class对象。直接访问类的.class属性更为简单。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_MONITOR_WAIT_ON_CONDITION">
    <ShortDescription>在Condition上调用wait()  Monitor wait() called on Condition</ShortDescription>
    <LongDescription>在{1}中调用了Condition的wait()方法</LongDescription>
    <Details>
      <![CDATA[<p>该方法对一个<code>java.util.concurrent.locks.Condition</code>对象调用了<code>wait()</code>。使用<code>Condition</code>接口定义的<code>await()</code>方法来等待<code>Condition</code>更为合适。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="RV_01_TO_INT">
    <ShortDescription>从0到1之间的随机值被强制转换为整数0  Random value from 0 to 1 is coerced to the integer 0</ShortDescription>
    <LongDescription>{1} 使用生成一个0到1之间的随机值，然后将该值强制转换为整数0。</LongDescription>
    <Details>
<![CDATA[<p>一个在0到1之间的随机值被强制转换为整数值0。你可能想要在强制转换之前将随机值乘以其他某个值，或者使用<code>Random.nextInt(n)</code>方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_INVALID_MIN_MAX">
    <ShortDescription>Math.max 和 Math.min 的不正确组合  Incorrect combination of Math.max and Math.min</ShortDescription>
    <LongDescription>Math.max 和 Math.min 的组合使用不正确：该代码始终返回 {2}</LongDescription>
    <Details>
<![CDATA[<p>这段代码尝试使用类似 `Math.min(0, Math.max(100, value))` 的构造来限制值的范围。然而，这里的常量顺序不正确：应该为 `Math.min(100, Math.max(0, value))`。因此，这段代码总是产生相同的结果（或者如果值是 NaN，则返回 NaN）。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_NEXTINT_VIA_NEXTDOUBLE">
    <ShortDescription>使用 `Random` 的 `nextInt` 方法而不是 `nextDouble` 生成随机整数。  Use the nextInt method of Random rather than nextDouble to generate a random integer</ShortDescription>
    <LongDescription>{1} 使用 Random 的 nextDouble 方法生成随机整数；使用 nextInt 更高效。</LongDescription>
    <Details>
<![CDATA[如果 `r` 是一个 `java.util.Random`，你可以使用 `r.nextInt(n)` 来生成从 `0` 到 `n-1` 的随机数，而不是使用 `(int)(r.nextDouble() * n)`。  
`nextInt` 方法的参数必须为正数。例如，如果你想生成一个从 -99 到 0 的随机值，可以使用 `-r.nextInt(100)`。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE">
    <ShortDescription>在SQL语句的execute或addBatch方法中传递了非常量字符串  Nonconstant string passed to execute or addBatch method on an SQL statement</ShortDescription>
    <LongDescription>{1} 向SQL语句的execute或addBatch方法传递非常量String参数</LongDescription>
    <Details>
<![CDATA[<p>该方法对一个看起来像是动态生成的字符串调用了SQL语句的execute或addBatch方法。建议改为使用预编译语句。这样做既更高效，又能减少SQL注入攻击的风险。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING">
    <ShortDescription>从非常量字符串生成了预编译语句。  A prepared statement is generated from a nonconstant String</ShortDescription>
    <LongDescription>从非常量字符串{1}生成了预编译语句。</LongDescription>
    <Details>
<![CDATA[<p>该代码从一个非常量字符串创建SQL预编语句。如果不进行检查，用户提供的受污染数据可能会被用于构建这个字符串，从而可能利用SQL注入使预编语句执行意想不到且不希望的结果。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_USELESS_THREAD">
    <ShortDescription>使用默认的空run方法创建了一个线程。  A thread was created using the default empty run method</ShortDescription>
    <LongDescription>{1} 使用默认的空run方法创建线程</LongDescription>
    <Details>
<![CDATA[<p>该方法创建了一个线程，既没有通过继承Thread类也没有通过传递Runnable对象指定run方法。这个线程只是浪费时间，并没有做任何事情。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DC_DOUBLECHECK">
    <ShortDescription>可能的字段双重检查  Possible double-check of field</ShortDescription>
    <LongDescription>在 {1} 中可能对 {2} 进行了双重检查</LongDescription>
    <Details>
<![CDATA[<p>该方法可能包含双次锁存的实例。根据Java内存模型的语义，这种idiom是不正确的。更多信息，请参阅网页 <a href="http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html" >http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html</a>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DC_PARTIALLY_CONSTRUCTED">
    <ShortDescription>可能暴露部分初始化的对象  Possible exposure of partially initialized object</ShortDescription>
    <LongDescription>在 {1} 中可能存在部分初始化的对象的暴露问题</LongDescription>
    <Details>
<![CDATA[<p>看起来这个方法使用了双重检查锁定的延迟字段初始化。虽然字段被正确声明为volatile，但在字段赋值之后，对象的内部结构可能会发生变化，从而另一个线程可能看到一个部分初始化的对象。</p>
<p>要解决这个问题，请考虑首先将对象存储到局部变量中，仅在对象完全构造后才将其保存到volatile字段中。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_FINALIZER_NULLS_FIELDS">
    <ShortDescription>最终化器使字段为空  Finalizer nulls fields</ShortDescription>
    <LongDescription>在 `{1.class}` 类的 `finalize` 方法中将 `{3}` 设置为 null</LongDescription>
    <Details>
<![CDATA[<p>这个最终化器清空字段。这通常是一个错误，因为它无助于垃圾回收，而且对象很快就会被垃圾回收。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_FINALIZER_ONLY_NULLS_FIELDS">
    <ShortDescription>仅使字段为null  Finalizer only nulls fields</ShortDescription>
    <LongDescription>仅检查空字段</LongDescription>
    <Details>
<![CDATA[<p>这个终结器除了将字段置为空之外没有任何操作。这完全是多余的，并且需要对象被垃圾回收、终结，然后再被垃圾回收一次。你应该直接移除finalize方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_PUBLIC_SHOULD_BE_PROTECTED">
    <ShortDescription>finalizer 应该是受保护的，而不是公共的  Finalizer should be protected, not public</ShortDescription>
    <LongDescription>{1} 是公共的；应该设置为受保护的</LongDescription>
    <Details>
<![CDATA[<p>一个类的 <code>finalize()</code> 方法应具有受保护访问权限，而不是公共访问权限。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_EMPTY">
    <ShortDescription>空的 finalize 方法应该被删除  Empty finalizer should be deleted</ShortDescription>
    <LongDescription>{1} 是空的，应该被删除。</LongDescription>
    <Details>
<![CDATA[<p>空的<code>finalize()</code>方法是没有用的，因此应该删除它们。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_NULLIFY_SUPER">
    <ShortDescription>最终化器取消了超类的最终化器  Finalizer nullifies superclass finalizer</ShortDescription>
    <LongDescription>{1} 是使 {2}.finalize() 失效。这正是您所希望的吗？</LongDescription>
    <Details>
<![CDATA[<p>这个空的<code>finalize()</code>方法明确抵消了其超类定义的任何终结器的效果。除非有特殊原因，否则不会执行超类中定义的任何终结器操作，请删除此方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_USELESS">
    <ShortDescription>最终化器除了调用超类的最终化器之外不做其他事情。  Finalizer does nothing but call superclass finalizer</ShortDescription>
    <LongDescription>{1} 除了调用 super.finalize() 外不做任何事情；可以删除它。</LongDescription>
    <Details>
<![CDATA[<p>这个 `finalize()` 方法唯一做的事是调用超类的 `finalize()` 方法，因此它是多余的。请删除它。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_MISSING_SUPER_CALL">
    <ShortDescription>finalizer 未调用父类的 finalizer  Finalizer does not call superclass finalizer</ShortDescription>
    <LongDescription>{1} 缺少对 `super.finalize()` 的调用，因此 {2}.finalize() 并没有被调用。</LongDescription>
    <Details>
<![CDATA[<p>这个 `finalize()` 方法没有调用其父类的 `finalize()` 方法。因此，父类中定义的任何终结器操作将不会执行。请添加对 `super.finalize()` 的调用。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_EXPLICIT_INVOCATION">
    <ShortDescription>显式调用最终化方法  Explicit invocation of finalizer</ShortDescription>
    <LongDescription>在 {1} 中显式调用 {2}</LongDescription>
    <Details>
<![CDATA[<p>该方法显式调用了对象的 <code>finalize()</code> 方法。因为 finalizer 方法应该只由 VM 一次性执行，所以这样做是不好的。</p>
<p>如果一组相关对象开始进行终结化，则 VM 将在同一时间在不同的线程中对所有可终结的对象调用 finalize 方法。因此，在类 X 的 finalize 方法中引用的对象 X 进行 finalize 调用是一个特别糟糕的想法，因为它们可能已经在其他线程中正在进行终结化。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS">
    <ShortDescription>等于检查不兼容的操作数  Equals checks for incompatible operand</ShortDescription>
    <LongDescription>{1} 检查操作数是否为 {2.givenClass}</LongDescription>
    <Details>
<![CDATA[<p>此 `equals` 方法用于检查参数是否为不兼容类型（即既不是定义 `equals` 方法的类的超类也不是子类的类）。例如，Foo 类的 `equals` 方法可能看起来像这样：</p>
<pre><code>public boolean equals(Object o) {     if (o instanceof Foo)   return name.equals(((Foo)o).name);     else if (o instanceof String)   return name.equals(o);     else return false; }
</code></pre>
<p>这种做法被认为是不良习惯，因为它使得实现对称和传递性的 `equals` 方法变得非常困难。没有这些属性，可能会出现非常意外的行为。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_DONT_DEFINE_EQUALS_FOR_ENUM">
    <ShortDescription>定义在枚举中的协变equals()方法  Covariant equals() method defined for enum</ShortDescription>
    <LongDescription>枚举 {0} 定义了 equals({0.givenClass})</LongDescription>
    <Details>
<![CDATA[<p>该类定义了一个枚举，并且枚举间的相等性是基于对象身份来定义的。为枚举值定义协变的equals方法是一种极其不良的实践，因为这可能会导致使用协变枚举方法有两个不同的枚举值比较为相等，而在正常情况下比较却不相等。不要这样做。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_SELF_USE_OBJECT">
    <ShortDescription>covariant equals() 方法定义，继承自 Object.equals(Object)  Covariant equals() method defined, Object.equals(Object) inherited</ShortDescription>
    <LongDescription>{0} 定义了 equals({0.givenClass}) 方法，并使用了 Object.equals(Object) 方法。</LongDescription>
    <Details>
<![CDATA[<p>该类定义了一个协变版本的<code>equals()</code>方法，但继承了从基类<code>java.lang.Object</code>定义的正常<code>equals(Object)</code>方法。此类应该可能定义一个<code>boolean equals(Object)</code>方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_OTHER_USE_OBJECT">
    <ShortDescription>定义了 equals() 方法但未重写 Object 类的 equals(Object) 方法  equals() method defined that doesn't override Object.equals(Object)</ShortDescription>
    <LongDescription>{0} 定义了 {1.givenClass} 方法，并使用了 Object.equals(Object) 方法</LongDescription>
    <Details>
<![CDATA[<p>这个类定义了一个<code>equals()</code>方法，该方法没有覆盖基础的<code>java.lang.Object</code>类中定义的<code>equals(Object)</code>方法。类应该可能定义一个<code>boolean equals(Object)</code>方法。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_OTHER_NO_OBJECT">
    <ShortDescription>定义的 equals() 方法没有重写 Object 的 equals(Object) 方法。  equals() method defined that doesn't override equals(Object)</ShortDescription>
    <LongDescription>{0} 定义了 {1.givenClass} 方法，但未重写 equals(Object) 方法。</LongDescription>
    <Details>
<![CDATA[<p>这个类定义了一个<code>equals()</code>方法，这个方法没有覆盖基类<code>java.lang.Object</code>中定义的正常<code>equals(Object)</code>方法。相反，它继承了一个来自超类的<code>equals(Object)</code>方法。这个类应该 probably 定义一个<code>boolean equals(Object)</code>方法。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_DOESNT_OVERRIDE_EQUALS">
    <ShortDescription>类未在超类中重写 equals 方法  Class doesn't override equals in superclass</ShortDescription>
    <LongDescription>{0} 没有重写 {2.givenClass}</LongDescription>
    <Details>
<![CDATA[<p>这个类扩展了一个定义了 equals 方法的类，并添加了字段，但自己没有定义 equals 方法。因此，此类实例之间的相等性将忽略子类的身份和添加的字段。请确保这是预期的行为，并且你不需要覆盖 equals 方法。即使你不需要覆盖 equals 方法，也考虑重写它以记录子类的 equals 方法只是返回调用 super.equals(o) 的结果。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_SELF_NO_OBJECT">
    <ShortDescription>协变定义的 equals() 方法  Covariant equals() method defined</ShortDescription>
    <LongDescription>{0} 定义了 equals({0.givenClass}) 方法，但未定义 equals(Object) 方法。</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个协变版本的<code>equals()</code>方法。要正确重写来自<code>java.lang.Object</code>的<code>equals()</code>方法，<code>equals()</code>的方法参数必须是<code>java.lang.Object</code>类型。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_OVERRIDING_EQUALS_NOT_SYMMETRIC">
    <ShortDescription>`equals` 方法覆盖了超类中的 `equals`，并且可能不是对称的。  equals method overrides equals in superclass and may not be symmetric</ShortDescription>
    <LongDescription>在 `{2.class.givenClass}` 中，`{1.class}` 覆盖了 `equals` 方法，并且可能不具备对称性。</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个equals方法，该方法覆盖了超类中的equals方法。两种equals方法都在判断两个对象是否相等时使用了<code>instanceof</code>关键字。这存在很大的风险，因为重要的是equals方法应该是对称的（换句话说，<code>a.equals(b) == b.equals(a)</code>)。如果B是A的子类型，并且A的equals方法检查参数是否为A的实例，而B的equals方法检查参数是否为B的实例，那么由这些方法定义的等价关系很可能不是对称的。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_GETCLASS_AND_CLASS_CONSTANT">
    <ShortDescription>equals 方法在子类型中会失败  equals method fails for subtypes</ShortDescription>
    <LongDescription>{1} 对于子类型失败</LongDescription>
    <Details>
<![CDATA[<p>该类包含一个equals方法，如果被子类继承可能会导致equals方法失效。它会将一个类字面量与参数的类进行比较（例如，在`Foo`类中可能检查`Foo.class == o.getClass()`）。更好的做法是检查`this.getClass() == o.getClass()`。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_UNUSUAL">
    <ShortDescription>不寻常的equals方法  Unusual equals method</ShortDescription>
    <LongDescription>{1} 是不寻常的</LongDescription>
    <Details>
<![CDATA[<p>这个类没有使用我们识别的任何模式来检查参数类型是否与当前对象的类型兼容。这段代码可能没有任何问题，但值得进行一下审查。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_COMPARING_CLASS_NAMES">
    <ShortDescription>equals方法比较的是类名而不是类对象。  equals method compares class names rather than class objects</ShortDescription>
    <LongDescription>{1} 比较类名而不是类对象</LongDescription>
    <Details>
<![CDATA[<p>这个类定义了一个 equals 方法，用于通过比较两个对象的类名来检查它们是否为同一类。可以由不同的类装载器加载具有相同名称的不同类。只需检查类对象是否相同即可。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_ALWAYS_TRUE">
    <ShortDescription>equals方法总是返回true  equals method always returns true</ShortDescription>
    <LongDescription>总是返回true</LongDescription>
    <Details>
<![CDATA[<p>这个类定义了一个总是返回true的equals方法。这虽然有趣，但并不聪明。而且这意味着equals方法不是对称的。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_ALWAYS_FALSE">
    <ShortDescription>equals方法始终返回false  equals method always returns false</ShortDescription>
    <LongDescription>始终返回false</LongDescription>
    <Details>
<![CDATA[<p>这个类定义了一个始终返回 false 的 equals 方法。这意味着对象与其自身不相等，因此无法用此类创建有用的 Maps 或 Sets。从根本上说，这也意味着 equals 不具有反射性，这是 equals 方法的要求之一。</p>
<p>你可能希望实现的对象身份语义：即一个对象与其自身相等。这种行为继承自类 <code>Object</code>。如果你需要从不同的超类继承并重写 equals 方法，可以使用以下代码：</p>
<pre><code>public boolean equals(Object o) {     return this == o; } </code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="HSC_HUGE_SHARED_STRING_CONSTANT">
    <ShortDescription>巨大的字符串常量在多个类文件中重复使用  Huge string constants is duplicated across multiple class files</ShortDescription>
    <LongDescription>{1} 被初始化为一个长度为 {2} 的字符串常量，并且在其他 {3} 个类文件中进行了重复定义。</LongDescription>
    <Details>
      <![CDATA[<p>多个类文件中重复使用了一个较长的字符串常量。这很可能是因为一个final字段被初始化为一个字符串常量，而Java语言规定其他类中的所有对该final字段的引用必须内联到该类文件中。有关此错误的一个示例，请参见<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6447475">JDK问题6447475</a>，其中描述了此错误在JDK中的发生情况，并说明解决该问题使JDK的大小减少了1兆字节。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_ARGUMENT_MIGHT_BE_NULL">
    <ShortDescription>方法未检查传入的空值参数  Method does not check for null argument</ShortDescription>
    <LongDescription>{1} 不检查空参数</LongDescription>
    <Details>
      <![CDATA[<p>     该方法的某个参数已被识别为始终需要检查是否为空（null），但该参数在未进行前置空值检查的情况下被去引用使用了。 </p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT">
    <ShortDescription>equals() 方法未检查空参数  equals() method does not check for null argument</ShortDescription>
    <LongDescription>{1} 不检查null参数</LongDescription>
    <Details>
      <![CDATA[<p>此实现中的 equals(Object) 方法违反了由 java.lang.Object.equals() 定义的合同，因为它没有检查传递的参数是否为 null。所有 equals() 方法如果传递了 null 值，都应返回 false。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="RV_NEGATING_RESULT_OF_COMPARETO">
    <ShortDescription>对比结果的否定  Negating the result of compareTo()/compare()</ShortDescription>
    <LongDescription>{1} 负面化了 {2} 的返回值。</LongDescription>
    <Details>
<![CDATA[<p>该代码反向了compareTo或compare方法的返回值。这是一种值得怀疑或不良的编程实践，因为如果返回值是Integer.MIN_VALUE，反向返回值不会改变结果的符号。通过反转操作数的顺序而不是反向结果，可以实现相同的目的。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CO_COMPARETO_RESULTS_MIN_VALUE">
    <ShortDescription>`compareTo()`/`compare()` 方法返回 `Integer.MIN_VALUE`  compareTo()/compare() returns Integer.MIN_VALUE</ShortDescription>
    <LongDescription>{1} 返回 `Integer.MIN_VALUE`，这个值无法被取反。</LongDescription>
    <Details>
<![CDATA[在某些情况下，这个 `compareTo` 或者 `compare` 方法返回常量 `Integer.MIN_VALUE`，这是一种非常糟糕的实践。返回值的唯一重要之处在于其符号。但人们有时会取 `compareTo` 返回值的负数，期望这样可以改变结果的符号。然而，在返回值为 `Integer.MIN_VALUE` 的情况下，这种方法不起作用。因此，直接返回 -1 而不是 `Integer.MIN_VALUE`。]]>
    </Details>
  </BugPattern>
  <BugPattern type="CO_COMPARETO_INCORRECT_FLOATING">
    <ShortDescription>compareTo()/compare() 方法错误地处理了浮点值（如float或double）  compareTo()/compare() incorrectly handles float or double value</ShortDescription>
    <LongDescription>{1} 不正确地处理了 {2} 值</LongDescription>
    <Details>
<![CDATA[<p>此方法使用以下模式比较双精度或浮点值：val1 > val2 ? 1 : val1 < val2 ? -1 : 0。该模式在处理-0.0和NaN值时会出错，可能导致排序结果不正确或集合损坏（如果比较值用作键）。建议使用Double.compare或Float.compare静态方法，这些方法可以正确处理所有特殊情况。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CO_SELF_NO_OBJECT">
    <ShortDescription>可变的compareTo()方法定义  Covariant compareTo() method defined</ShortDescription>
    <LongDescription>{0} 定义了 `compareTo({0.givenClass})` 方法，但没有定义 `compareTo(Object)` 方法。</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个协变版本的 `compareTo()` 方法。为了正确覆盖 `Comparable` 接口中的 `compareTo()` 方法，`compareTo()` 的参数类型必须为 `java.lang.Object`。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_SIGNATURE_DECLARES_HASHING_OF_UNHASHABLE_CLASS">
    <ShortDescription>签名声明在哈希构造中使用了不可哈希的类  Signature declares use of unhashable class in hashed construct</ShortDescription>
    <LongDescription>在 `{1}` 中，`{2}` 没有定义 `hashCode()` 方法，但被用于散列上下文中。</LongDescription>
    <Details>
<![CDATA[<p>在一个泛型签名中声明的方法、字段或类使用了非哈希类，而在需要哈希类的上下文中应该使用可哈希类。声明了equals方法但继承自Object的hashCode()方法的类是不可哈希的，因为它没有满足相等对象具有相同hashCodes的要求。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_USE_OF_UNHASHABLE_CLASS">
    <ShortDescription>在哈希数据结构中未使用`hashCode()`方法的类  Use of class without a hashCode() method in a hashed data structure</ShortDescription>
    <LongDescription>在 `{1}` 中，`{2}` 没有定义 `hashCode()` 方法，但却被用于一个哈希数据结构中。</LongDescription>
    <Details>
<![CDATA[<p>一个类定义了equals(Object)方法但没有定义hashCode()方法，因此未能满足相等对象具有相同hashCode的要求。如果该类的实例被用于哈希数据结构中，则修复此问题的重要性非常高。]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_HASHCODE_USE_OBJECT_EQUALS">
    <ShortDescription>类定义了hashCode()方法并使用了Object的equals()方法  Class defines hashCode() and uses Object.equals()</ShortDescription>
    <LongDescription>{0} 定义了 `hashCode` 并使用了 `Object.equals()` 方法。</LongDescription>
    <Details>
<![CDATA[<p>该类定义了<code>hashCode()</code>方法，但继承了<code>java.lang.Object</code>的<code>equals()</code>方法（<code>java.lang.Object</code>通过比较对象引用定义了相等性）。尽管这可能满足相等的对象必须具有相同哈希码的合同，但这可能不是覆盖<code>hashCode()</code>方法所期望的行为。（覆盖<code>hashCode()</code>意味着对象的身份基于比简单的引用相等更为复杂的标准。）</p>
<p>如果认为此类的实例不会插入到HashMap/HashTable中，则推荐使用的<code>hashCode</code>实现为：</p>
<pre><code>public int hashCode() {     assert false : "hashCode not designed";     return 42; // 任意常量均可 } </code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_COMPARETO_USE_OBJECT_EQUALS">
    <ShortDescription>类定义了compareTo(...)方法，并使用了Object.equals()方法。  Class defines compareTo(...) and uses Object.equals()</ShortDescription>
    <LongDescription>{0} 定义了 {1.givenClass} 并使用了 Object.equals() 方法</LongDescription>
    <Details>
<![CDATA[<p>此类定义了<code>compareTo(...)</code>方法，但继承了来自<code>java.lang.Object</code>的<code>equals()</code>方法。通常情况下，<code>compareTo</code>返回零当且仅当<code>equals</code>返回真。如果违反这一规则，在如PriorityQueue等类中会出现奇怪和不可预测的故障。在Java 5中，<code>PriorityQueue.remove</code>方法使用了<code>compareTo</code>方法；而在Java 6中，则使用了<code>equals</code>方法。</p>
<p>Comparable接口中<code>compareTo</code>方法的JavaDoc如下：<blockquote>强烈建议（但不是严格要求）<code>(x.compareTo(y)==0) == (x.equals(y))</code>。通常来说，任何实现Comparable接口并违反此条件的类都应该明确指出这一点。推荐的语言是“注意：此类具有与equals不一致的自然排序顺序。”</blockquote></p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_HASHCODE_NO_EQUALS">
    <ShortDescription>类定义了hashCode()方法但未定义equals()方法  Class defines hashCode() but not equals()</ShortDescription>
    <LongDescription>{0} 定义了hashCode方法但未定义equals方法</LongDescription>
    <Details>
<![CDATA[<p>该类定义了<code>hashCode()</code>方法但未定义<code>equals()</code>方法。因此，该类可能会违反相等对象必须具有相同哈希码的不变量。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_EQUALS_USE_HASHCODE">
    <ShortDescription>类定义了equals()方法并使用了Object.hashCode()方法  Class defines equals() and uses Object.hashCode()</ShortDescription>
    <LongDescription>{0} 定义了 `equals` 方法并使用了 `Object.hashCode()`。</LongDescription>
    <Details>
<![CDATA[<p>此类重写了<code>equals(Object)</code>，但未重写<code>hashCode()</code>，继承了<code>java.lang.Object</code>的<code>hashCode()</code>实现（返回的是对象的身份哈希码，由虚拟机随机分配的一个值）。因此，该类很可能违反相等的对象必须具有相同哈希码的不变量。</p>
<p>如果认为此类的实例永远不会插入到HashMap/HashTable中，则推荐使用的<code>hashCode</code>实现是：</p>
<pre><code>public int hashCode() {     assert false : "hashCode not designed";     return 42; // 任何任意常量都可以 </code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_INHERITS_EQUALS_USE_HASHCODE">
    <ShortDescription>类继承了equals()方法并且使用了Object.hashCode()方法  Class inherits equals() and uses Object.hashCode()</ShortDescription>
    <LongDescription>{0} 继承了 `equals` 方法并使用了 `Object.hashCode()` 方法。</LongDescription>
    <Details>
<![CDATA[<p>该类从抽象超类继承了<code>equals(Object)</code>方法，并从<code>java.lang.Object</code>继承了<code>hashCode()</code>(返回的是对象的身份哈希码，由虚拟机任意分配的一个值)。因此，该类很可能违反相等的对象必须具有相同哈希码的不变量。</p>
<p>如果不希望定义<code>hashCode</code>方法，或者认为对象永远不会被放入HashMap/Hashtable中，则可以将<code>hashCode()</code>方法定义为抛出<code>UnsupportedOperationException</code>异常。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_EQUALS_NO_HASHCODE">
    <ShortDescription>类定义了equals()方法但未定义hashCode()方法  Class defines equals() but not hashCode()</ShortDescription>
    <LongDescription>{0} 定义了 equals 但未定义 hashCode</LongDescription>
    <Details>
<![CDATA[<p>该类重写了<code>equals(Object)</code>，但没有重写<code>hashCode()</code>。因此，类可能会违反相等对象必须具有相同哈希码的不变量。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_ABSTRACT_SELF">
    <ShortDescription>抽象类定义了协变的equals()方法  Abstract class defines covariant equals() method</ShortDescription>
    <LongDescription>抽象类 {0} 定义了 equals({0.givenClass}) 方法</LongDescription>
    <Details>
<![CDATA[<p>该类定义了一个协变版本的 <code>equals()</code> 方法。为了正确重写 <code>java.lang.Object</code> 中的 <code>equals()</code> 方法，<code>equals()</code> 的参数必须具有类型 <code>java.lang.Object</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ES_COMPARING_STRINGS_WITH_EQ">
    <ShortDescription>使用 `==` 或 `!=` 比较String对象  Comparison of String objects using == or !=</ShortDescription>
    <LongDescription>在{1}中使用==或!=比较String对象。</LongDescription>
    <Details>
<![CDATA[<p>这段代码使用 == 或 != 运算符比较 <code>java.lang.String</code> 对象的引用相等性。除非两个字符串都是源文件中的常量，或者已经通过 <code>String.intern()</code> 方法 intern 化，否则相同的字符串值可能由两个不同的 String 对象表示。考虑使用 <code>equals(Object)</code> 方法代替。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ES_COMPARING_PARAMETER_STRING_WITH_EQ">
    <ShortDescription>使用 `==` 或 `!=` 比较 String 参数  Comparison of String parameter using == or !=</ShortDescription>
    <LongDescription>在{1}中使用 == 或 != 比较String参数</LongDescription>
    <Details>
<![CDATA[<p>该代码使用 == 或 != 操作符比较一个 <code>java.lang.String</code> 参数的引用等价性。要求调用者仅传递字符串常量或 interned 字符串给方法是不必要的脆弱，并且很少能带来可测量的性能提升。考虑改用 <code>equals(Object)</code> 方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CO_ABSTRACT_SELF">
    <ShortDescription>抽象类定义了协变的compareTo()方法  Abstract class defines covariant compareTo() method</ShortDescription>
    <LongDescription>抽象类 {0} 定义了 compareTo({0.givenClass}) 方法</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个协变版本的 <code>compareTo()</code> 方法。为了正确覆盖 <code>Comparable</code> 接口中的 <code>compareTo()</code> 方法，<code>compareTo()</code> 的参数必须是 <code>java.lang.Object</code> 类型。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IS_FIELD_NOT_GUARDED">
    <ShortDescription>字段未防护以防止并发访问  Field not guarded against concurrent access</ShortDescription>
    <LongDescription>{1.givenClass} 未保护免于并发访问；有 {2}% 的时间被锁定</LongDescription>
    <Details>
<![CDATA[<p>该字段被标注为 net.jcip.annotations.GuardedBy 或 javax.annotation.concurrent.GuardedBy，但似乎以违反这些注释的方式被访问。</p>]]>
</Details>
  </BugPattern>
  <BugPattern type="MSF_MUTABLE_SERVLET_FIELD">
    <ShortDescription>可变的servlet字段  Mutable servlet field</ShortDescription>
    <LongDescription>{1} 是一个可变的servlet字段</LongDescription>
    <Details>
<![CDATA[<p>通常，web服务器只会为Servlet或JSP类创建一个实例（即，将类视为单例），并且会用多个线程在同一实例上调用方法以服务多个同时请求。因此，拥有可变的实例字段通常会产生竞态条件。]]>
    </Details>
  </BugPattern>
  <BugPattern type="IS2_INCONSISTENT_SYNC">
    <ShortDescription>不一致的同步  Inconsistent synchronization</ShortDescription>
    <LongDescription>{1}的同步不一致；锁定了{2}%的时间</LongDescription>
    <Details>
<![CDATA[<p>此类的字段似乎在同步方面不一致地被访问。该错误报告表明，错误模式检测器判断：</p>
<ul>
<li>该类包含锁定和未锁定访问的混合,</li>
<li>该类没有使用 javax.annotation.concurrent.NotThreadSafe 注解,</li>
<li>该类的一个方法执行了锁定访问,</li>
<li>未同步字段访问（读取和写入）的数量不超过所有访问的三分之一，写操作的权重是读操作的两倍。</li>
</ul>
<p>一个典型的符合这种错误模式的问题是在本应线程安全的类中忘记对某个方法进行同步。</p>
<p>你可以选择标记为“未同步访问”的节点以显示检测器认为没有同步地访问字段的代码位置。</p>
<p>请注意，此检测器存在多种不准确性来源；例如，检测器无法静态检测所有持有锁的情况。即使在检测器准确地区分锁定和未锁定访问的情况下，所涉及的代码也可能是正确的。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NN_NAKED_NOTIFY">
    <ShortDescription>裸露的通知  Naked notify</ShortDescription>
    <LongDescription>在{1}中使用了裸通知（Naked notify）</LongDescription>
    <Details>
<![CDATA[<p>在调用<code>notify()</code>或<code>notifyAll()</code>方法时，并没有伴随任何（明显的）对可变对象状态的修改。通常，在一个监视器上调用通知方法是因为某些条件已经变为真，这个条件使得另一个线程可以继续执行。然而，为了使这种状况有意义，它必须涉及一个两个线程都能访问的堆对象。</p>    
<p>此错误不一定表示存在错误，因为对可变对象状态的修改可能在调用通知方法之前的方法中进行。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_EXPOSE_REP">
    <ShortDescription>公共静态方法可能通过返回数组暴露内部表示。  Public static method may expose internal representation by returning array</ShortDescription>
    <LongDescription>Public static {} 可能通过返回 {2.givenClass} 暴露内部表示。</LongDescription>
    <Details>
<![CDATA[<p>一个公共静态方法返回一个数组的引用，该数组是类的静态状态的一部分。调用此方法的任何代码都可以自由修改底层数组。一种修复方法是返回数组的副本。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_REP">
    <ShortDescription>可能通过返回可变对象的引用暴露内部表示形式  May expose internal representation by returning reference to mutable object</ShortDescription>
    <LongDescription>{1} 可能会通过返回 {2.givenClass} 曝露内部表示。</LongDescription>
    <Details>
<![CDATA[<p>返回存储在对象某个字段中的可变对象引用会暴露该对象的内部表示形式。如果实例被不受信任的代码访问，并且对可变对象的未检查更改会危及安全或其他重要属性，您可能需要采取不同的措施。在许多情况下，返回对象的新副本是更好的方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_REP2">
    <ShortDescription>可能通过包含对可变对象的引用而暴露内部表示。  May expose internal representation by incorporating reference to mutable object</ShortDescription>
    <LongDescription>将一个外部可变对象存储到{2.givenClass}中可能会暴露内部表示。</LongDescription>
    <Details>
<![CDATA[<p>这段代码将对外可变对象的引用存储在对象的内部表示中。如果实例被不可信代码访问，并且对可变对象的未检查更改会危及安全性或其他重要属性，您需要采取不同的措施。在许多情况下，存储对象的副本是更好的方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_STATIC_REP2">
    <ShortDescription>可能通过将可变对象存储到静态字段中暴露内部的静态状态  May expose internal static state by storing a mutable object into a static field</ShortDescription>
    <LongDescription>{1} 可能会通过将可变对象存储到静态字段中而暴露内部的静态状态 {2}</LongDescription>
    <Details>
<![CDATA[<p>这段代码将对外可变对象的引用存储到了一个静态字段中。如果该可变对象未经过检查就发生改变，可能会损害安全或其他重要属性，在这种情况下你需要采取不同的方法。在许多情况下，复制对象并存储副本是一个更好的做法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_EXPOSE_BUF">
    <ShortDescription>可能通过返回共享非公开数据的缓冲区暴露内部表示。  May expose internal representation by returning a buffer sharing non-public data</ShortDescription>
    <LongDescription>{1} 可能会通过返回 {2.givenClass} 暴露内部表示。</LongDescription>
    <Details>
<![CDATA[<p>一个公共静态方法要么返回一个缓冲区（java.nio.*Buffer），该缓冲区通过仅持有对类的静态状态中部分数组的引用来封装这个数组，要么返回一个与原始缓冲区共享引用的缓冲区的浅拷贝。任何调用此方法的代码都可以自由修改底层数组。一种修复方法是返回一个只读缓冲区或一个新的包含数组副本的缓冲区。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_BUF">
    <ShortDescription>可能通过返回共享非公共数据的缓冲区暴露内部表示形式  May expose internal representation by returning a buffer sharing non-public data</ShortDescription>
    <LongDescription>{1} 可能会通过返回 {2.givenClass} 暴露内部表示。</LongDescription>
    <Details>
<![CDATA[<p>返回一个缓冲区（java.nio.*Buffer）的引用，该缓冲区封装了对象某字段中存储的一个数组，会暴露数组元素的内部表示形式，因为缓冲区只存储对数组的引用而不是复制其内容。类似地，通过使用其duplicate()方法返回这样的缓冲区的浅拷贝并将其存储在对象的某个字段中也会暴露缓冲区的内部表示形式。如果实例被不可信代码访问，并且对数组的未检查更改会危及安全或其他重要属性，则您需要采取不同的措施。在这种情况下，在许多情况下，返回一个只读缓冲区（使用其asReadOnly()方法）或将数组复制到新缓冲区（使用其put()方法）是一个更好的选择。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_BUF2">
    <ShortDescription>可能通过创建包含数组引用的缓冲区来暴露内部表示。  May expose internal representation by creating a buffer which incorporates reference to array</ShortDescription>
    <LongDescription>{1} 可能会通过创建包含外部数组的缓冲区来暴露内部表示，并将其注入到 {2.givenClass} 中。</LongDescription>
    <Details>
<![CDATA[<p>这段代码创建了一个缓冲区，其中存储了对外部数组或外部缓冲区数组的引用到对象的内部表示中。如果实例被不受信任的代码访问，并且对数组的未检查更改会危害安全或其他重要属性，那么您需要采取不同的措施。在许多情况下，复制数组是一个更好的方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_STATIC_BUF2">
    <ShortDescription>可能通过将外部数组存储到静态字段中而暴露内部静态状态  May expose internal static state by creating a buffer which stores an external array into a static field</ShortDescription>
    <LongDescription>{1} 可能会通过将外部数组存储到静态字段中来暴露内部静态状态 {2}</LongDescription>
    <Details>
<![CDATA[<p>此代码创建一个缓冲区，该缓冲区存储对外部数组或外部缓冲区的引用到一个静态字段中。如果对外部数组进行未检查的修改会损害安全或其他重要属性，您需要采取不同的措施。在许多情况下，复制数组是一个更好的方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RU_INVOKE_RUN">
    <ShortDescription>在线程中调用了run（您本意是要启动它吗？）  Invokes run on a thread (did you mean to start it instead?)</ShortDescription>
    <LongDescription>{1} 显式地对线程调用了 run 方法（您本意是要启动它吗？）</LongDescription>
    <Details>
<![CDATA[<p>该方法显式地在对象上调用了<code>run()</code>。通常，类实现<code>Runnable</code>接口是因为它们的<code>run()</code>方法将在新线程中被调用，在这种情况下，应该使用<code>Thread.start()</code>来调用。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SP_SPIN_ON_FIELD">
    <ShortDescription>方法依赖于字段的旋转  Method spins on field</ShortDescription>
    <LongDescription>在{1}中旋转于{2.givenClass}</LongDescription>
    <Details>
<![CDATA[<p>该方法在一个循环中读取一个字段。编译器可以合法地将该读操作移出循环，从而使代码变成无限循环。应该更改类以使用适当的同步（包括wait和notify调用）。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NS_DANGEROUS_NON_SHORT_CIRCUIT">
    <ShortDescription>非短路逻辑使用可能存在危险  Potentially dangerous use of non-short-circuit logic</ShortDescription>
    <LongDescription>在{1}处使用了可能危险的非短路逻辑</LongDescription>
    <Details>
<![CDATA[<p>这段代码似乎使用了非短路逻辑（例如，& 或 |）而不是短路逻辑（&& 或 ||）。此外，根据左操作数的值，可能不需要评估右操作数（因为这可能会引起副作用、抛出异常或代价昂贵。</p>

<p>非短路逻辑会导致表达式的两边都被评估，即使可以根据左操作数的结果来推断最终结果。这可能导致效率较低，并且如果左操作数用于屏蔽在评估右操作数时会产生错误的情况，则可能会导致错误。</p>

<p>有关详细信息，请参见 <a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.22.2">Java 语言规范</a>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NS_NON_SHORT_CIRCUIT">
    <ShortDescription>非短路逻辑的可疑使用  Questionable use of non-short-circuit logic</ShortDescription>
    <LongDescription>在 {1} 中使用了可疑的非短路逻辑</LongDescription>
    <Details>
<![CDATA[<p>这段代码似乎使用了非短路逻辑（例如，& 或 |）而不是短路逻辑（&& 或 ||）。非短路逻辑会导致表达式的两边即使结果可以仅通过知道左边的情况来推断时也会被评估。这可能会导致效率较低，并且如果左边的条件在评估右边时会产生错误，则可能导致错误。</p>
<p>详细信息请参见 <a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.22.2">Java 语言规范</a>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="TLW_TWO_LOCK_WAIT">
    <ShortDescription>持有两个锁的情况下等待  Wait with two locks held</ShortDescription>
    <LongDescription>在{1}中持有了两个锁后调用了wait()方法。</LongDescription>
    <Details>
<![CDATA[在持有两个锁的情况下等待监视器可能会导致死锁。仅当进行等待时会释放所等待的对象的锁，而不会释放其他任何锁。这不一定是一个错误，但值得仔细检查。]]>
    </Details>
  </BugPattern>
  <BugPattern type="TLW_TWO_LOCK_NOTIFY" deprecated="true"> <!-- never generated -->
    <ShortDescription>持有两个锁后进行通知  Notify with two locks held</ShortDescription>
    <LongDescription>在{1}处持有了两个锁的情况下使用notify()或notifyAll*()方法。</LongDescription>
    <Details>
<![CDATA[<p>代码在持有两个锁的情况下调用了notify()或notifyAll()方法。如果这个通知意图唤醒一个正在持有相同锁的wait()方法，可能会导致死锁，因为wait只会放弃一个锁，而notify将无法获取这两个锁，从而导致通知失败。如果有关于双锁wait的通知提示，出现错误的可能性非常高。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UW_UNCOND_WAIT">
    <ShortDescription>无条件等待  Unconditional wait</ShortDescription>
    <LongDescription>在{1}中无条件等待</LongDescription>
    <Details>
<![CDATA[<p>该方法中调用了<code>java.lang.Object.wait()</code>，但没有用条件控制流进行防护。代码应在调用wait之前验证它想要等待的条件是否已经满足；否则之前的通知将被忽略。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UR_UNINIT_READ">
    <ShortDescription>在构造函数中读取未初始化的字段  Uninitialized read of field in constructor</ShortDescription>
    <LongDescription>在{1}中对未初始化的{2.name}进行了读取</LongDescription>
    <Details>
<![CDATA[<p>该构造函数读取了一个尚未被赋值的字段。这通常是由程序员错误地使用了字段而不是构造函数的一个参数所引起的。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UR_UNINIT_READ_CALLED_FROM_SUPER_CONSTRUCTOR">
    <ShortDescription>从超类构造函数中调用的未初始化读取字段方法  Uninitialized read of field method called from constructor of superclass</ShortDescription>
    <LongDescription>在从超类构造函数调用时，{1}.{2.name} 没有被初始化。</LongDescription>
    <Details>
<![CDATA[<p>此方法在超类的构造函数中被调用。此时，类的字段尚未初始化。</p>
<p>为了使这一点更具体，请考虑以下类：</p>
<pre><code>abstract class A {     int hashCode;     abstract Object getValue();      A() {   hashCode = getValue().hashCode();     } }  class B extends A {     Object value;      B(Object v) {   this.value = v;     }      Object getValue() {   return value;     } } </code></pre>
<p>当创建一个 <code>B</code> 对象时，<code>A</code> 类的构造函数在 <code>B</code> 构造函数设置 <code>value</code> 之前被调用。因此，在 <code>A</code> 的构造函数调用 <code>getValue</code> 时会读取一个未初始化的 <code>value</code> 值。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UG_SYNC_SET_UNSYNC_GET">
    <ShortDescription>未同步的get方法，同步的set方法  Unsynchronized get method, synchronized set method</ShortDescription>
    <LongDescription>{1} 是未同步的，{2} 是同步的</LongDescription>
    <Details>
<![CDATA[<p>该类包含同名的方法，其中 set 方法是同步的，而 get 方法不是。这可能导致运行时出现错误行为，因为调用 get 方法的代码不一定能看到对象的一致状态。get 方法应该被设置为同步的。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IC_INIT_CIRCULARITY">
    <ShortDescription>初始化循环依赖  Initialization circularity</ShortDescription>
    <LongDescription>{0} 和 {1} 之间的初始化循环依赖</LongDescription>
    <Details>
<![CDATA[<p>在两个引用了错误实例的类的静态初始化器中检测到了循环依赖。此类循环可能导致许多意想不到的行为。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION">
    <ShortDescription>在初始化时使用了子类  Superclass uses subclass during initialization</ShortDescription>
    <LongDescription>初始化{0}访问了类{2}，但该类还没有初始化完毕。</LongDescription>
    <Details>
<![CDATA[在类的初始化过程中，该类主动使用了一个子类。此时子类还未被初始化。例如，在下面的代码中，`foo` 将会是 `null`。

```java
public class CircularClassInitialization {    
    static class InnerClassSingleton extends CircularClassInitialization {   
        static InnerClassSingleton singleton = new InnerClassSingleton();     
    }     
    
    static CircularClassInitialization foo = InnerClassSingleton.singleton; 
}
```]]>
    </Details>
  </BugPattern>
  <BugPattern type="IT_NO_SUCH_ELEMENT">
    <ShortDescription>Iterator next() 方法不能抛出 NoSuchElementException 异常  Iterator next() method cannot throw NoSuchElementException</ShortDescription>
    <LongDescription>"{1}" 不能抛出 NoSuchElementException 异常。</LongDescription>
    <Details>
<![CDATA[<p>该类实现了<code>java.util.Iterator</code>接口。然而，其<code>next()</code>方法无法抛出<code>java.util.NoSuchElementException</code>。应将<code>next()</code>方法修改为，在没有更多元素可返回时调用该方法时抛出<code>NoSuchElementException</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DL_SYNCHRONIZATION_ON_SHARED_CONSTANT">
    <ShortDescription>同步操作在interned字符串上  Synchronization on interned String</ShortDescription>
    <LongDescription>在 `{1}` 中对 interned String 进行同步</LongDescription>
    <Details>
<![CDATA[<p>代码使用 interned 的 String 进行同步。</p>
<pre><code>private static String LOCK = "LOCK"; ... synchronized(LOCK) {     ... } ... </code></pre>
<p>常量字符串会被 intern 并在 JVM 加载的所有其他类之间共享。因此，这段代码是在对其他代码也可能锁定的对象进行同步。这可能会导致非常奇怪且难以诊断的阻塞和死锁行为。参见 <a href="http://www.javalobby.org/java/forums/t96352.html">http://www.javalobby.org/java/forums/t96352.html</a> 和 <a href="http://jira.codehaus.org/browse/JETTY-352">http://jira.codehaus.org/browse/JETTY-352</a>。</p>
<p>更多详细信息，请参阅 CERT <a href="https://www.securecoding.cert.org/confluence/display/java/CON08-J.+Do+not+synchronize+on+objects+that+may+be+reused">CON08-J. 不要对可能被重用的对象进行同步</a>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DL_SYNCHRONIZATION_ON_BOOLEAN">
    <ShortDescription>同步布尔值  Synchronization on Boolean</ShortDescription>
    <LongDescription>在{1}中对布尔值进行同步</LongDescription>
    <Details>
      <![CDATA[<p>代码使用了包装原始类型的常量进行同步，例如 Boolean。</p>
<pre><code>private static Boolean inited = Boolean.FALSE; ... synchronized(inited) {     if (!inited) {   init();   inited = Boolean.TRUE;     } } ...
</code></pre>
<p>由于通常只有两个 Boolean 对象存在，这段代码可能会与无关的其他代码同步于相同的对象上，导致响应性变差甚至可能出现死锁。</p>
<p>更多详情请参见 CERT <a href="https://www.securecoding.cert.org/confluence/display/java/CON08-J.+Do+not+synchronize+on+objects+that+may+be+reused">CON08-J. 不要在可能被重用的对象上进行同步</a>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DL_SYNCHRONIZATION_ON_UNSHARED_BOXED_PRIMITIVE">
    <ShortDescription>同步于装箱原始值  Synchronization on boxed primitive values</ShortDescription>
    <LongDescription>在{1}中对{2}进行了同步</LongDescription>
    <Details>
      <![CDATA[<p>代码对一个显式未共享的装箱原始类型进行同步，例如一个 Integer。</p>
<pre><code>private static final Integer fileLock = new Integer(1); ... synchronized(fileLock) {     .. do something .. } ... </code></pre>
<p>在这种情况下，最好重新声明 fileLock 为</p>
<pre><code>private static final Object fileLock = new Object(); </code></pre>
<p>现有代码可能没有问题，但这样做会让人困惑。未来如果进行“移除装箱”重构（例如在 IntelliJ 中），可能会将此更改为使用在整个 JVM 中共享的interned Integer 对象，这会导致非常混淆的行为以及潜在的死锁。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DL_SYNCHRONIZATION_ON_BOXED_PRIMITIVE">
    <ShortDescription>同步操作基于装箱原始类型  Synchronization on boxed primitive</ShortDescription>
    <LongDescription>在 {1} 中对 {2} 进行同步</LongDescription>
    <Details>
      <![CDATA[<p>代码对一个装箱原始常量（例如，Integer）进行了同步。</p>
<pre><code>private static Integer count = 0; ... synchronized(count) {     count++; } ... </code></pre>
<p>由于Integer对象可能会被缓存并共享，这段代码可能在与其他无关的代码同步同一个对象上，从而导致响应性差甚至可能出现死锁。</p>
<p>详见CERT <a href="https://www.securecoding.cert.org/confluence/display/java/CON08-J.+Do+not+synchronize+on+objects+that+may+be+reused">CON08-J. 不要在可能被重用的对象上进行同步</a> 获取更多详细信息。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ESync_EMPTY_SYNC">
    <ShortDescription>空的同步块  Empty synchronized block</ShortDescription>
    <LongDescription>在{1}中存在空的同步块</LongDescription>
    <Details>
<![CDATA[<p>代码中包含一个空的同步块：</p>
<pre><code>synchronized() { }
</code></pre>
<p>空的同步块比大多数人认识到的还要更加微妙且更难正确使用，而且空的同步块几乎 never 是比其他解决方案更好的选择。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IS_INCONSISTENT_SYNC">
    <ShortDescription>不一致的同步  Inconsistent synchronization</ShortDescription>
    <LongDescription>不一致的同步；{1} 锁定 {2}% 的时间</LongDescription>
    <Details>
<![CDATA[<p>此类的字段似乎在同步方面不一致地被访问。该错误报告指出，错误模式检测器判断：</p>
<ul>
<li>该类包含锁定和未锁定访问的混合,</li>
<li>至少一个锁定访问是由该类自身的某个方法执行的,</li>
<li>未同步的字段访问（读取和写入）的数量不超过总访问次数的三分之一，其中写操作被赋予读操作两倍的重要性。</li>
</ul>

<p>符合这种错误模式的一个典型 bug 是在本应线程安全的类中忘记对某个方法进行同步。</p>

<p>请注意，此检测器存在多种准确性来源；例如，检测器无法静态检测所有持有锁的情况。即使检测器准确地区分了锁定和未锁定访问，所涉代码也可能是正确的。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ML_SYNC_ON_FIELD_TO_GUARD_CHANGING_THAT_FIELD">
    <ShortDescription>在尝试保护字段时对字段进行同步，这是一项无效的努力  Synchronization on field in futile attempt to guard that field</ShortDescription>
    <LongDescription>在{2.givenClass}上进行同步，企图保护它（但实际上可能是多余的或不必要的）</LongDescription>
    <Details>
<![CDATA[<p>这种方法似乎试图通过在字段上进行同步来防止同时更新该字段。但是，保护一个字段实际上是对引用对象加锁，而不是对字段本身加锁。这可能无法提供你需要的互斥访问，并且其他线程可能会以其他目的对引用对象加锁。这种模式的一个例子如下：</p>
<pre><code>private Long myNtfSeqNbrCounter = new Long(0); 
private Long getNotificationSequenceNumber() {  
    Long result = null;  
    synchronized(myNtfSeqNbrCounter) {  
        result = new Long(myNtfSeqNbrCounter.longValue() + 1);  
        myNtfSeqNbrCounter = new Long(result.longValue());  
    }  
    return result;  
} </code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ML_SYNC_ON_UPDATED_FIELD">
    <ShortDescription>方法在更新字段后对该字段进行同步锁定  Method synchronizes on an updated field</ShortDescription>
    <LongDescription>{s1} 对更新的字段 {2.givenClass} 进行同步操作</LongDescription>
    <Details>
<![CDATA[<p>该方法对一个引用了可变字段的对象进行同步。由于不同的线程可能在同步不同的对象，因此这种做法不太likely会有有意义的语义。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_OOI_PKGPROTECT">
    <ShortDescription>字段应该从接口中移动出来，并改为包私有访问级别  Field should be moved out of an interface and made package protected</ShortDescription>
    <LongDescription>应该将 `{1}` 移出接口，并改为包私有访问级别。</LongDescription>
    <Details>
<![CDATA[<p>接口中定义的一个 final 静态字段引用了一个可变对象，如数组或哈希表。该可变对象可能会被恶意代码或来自其他包的代码意外修改。为了解决这个问题，需要将该字段移到一个类中，并将其改为包私有访问级别，以避免这种漏洞。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_FINAL_PKGPROTECT">
    <ShortDescription>字段应该既是 final 的，又是包私有（package-private）的。  Field should be both final and package protected</ShortDescription>
    <LongDescription>{1} 应该既被声明为 final，也应该是包可见（package-private）。</LongDescription>
    <Details>
<![CDATA[<p>    可变的静态字段可能会被恶意代码或另一包中的意外操作修改。可以将该字段设为包私有和/或将字段声明为final以避免此漏洞。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_SHOULD_BE_REFACTORED_TO_BE_FINAL">
    <ShortDescription>字段不是最终的，但应 refactor 为最终的  Field isn't final but should be refactored to be so</ShortDescription>
    <LongDescription>{1} 不是最终变量，但应重新设计使其成为最终变量。</LongDescription>
    <Details>
<![CDATA[<p>这个静态字段是 public 但不是 final，可能会被恶意代码或不小心从另一个包中更改。可以将该字段设为 final 以避免此漏洞，但静态初始化器对字段进行了多次写操作，因此这样做需要进行一些重构。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_SHOULD_BE_FINAL">
    <ShortDescription>字段不是最终变量但应当是  Field isn't final but should be</ShortDescription>
    <LongDescription>{1} 不是最终变量但应该被声明为最终变量</LongDescription>
    <Details>
<![CDATA[<p>这个静态字段是public但不是final，可能会被恶意代码或从另一个包中的意外操作修改。可以将该字段声明为final以避免这种漏洞。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_PKGPROTECT">
    <ShortDescription>字段应为包私有访问级别  Field should be package protected</ShortDescription>
    <LongDescription>{1} 应该是包私有访问级别</LongDescription>
    <Details>
<![CDATA[<p>可变的静态字段可能会被恶意代码或意外更改。可以将该字段改为包保护级别以避免此漏洞。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_MUTABLE_HASHTABLE">
    <ShortDescription>字段是一个可变的Hashtable。  Field is a mutable Hashtable</ShortDescription>
    <LongDescription>{1} 是一个可变的Hashtable。</LongDescription>
    <Details>
<![CDATA[<p>一个最终静态字段引用了一个Hashtable，并且可以从另一个包中恶意代码或不小心访问。这段代码可以自由地修改Hashtable的内容。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_MUTABLE_COLLECTION">
    <ShortDescription>字段是一个可变集合  Field is a mutable collection</ShortDescription>
    <LongDescription>{1} 是一个可变集合</LongDescription>
    <Details>
<![CDATA[<p>将可变集合实例赋值给一个最终静态字段，从而可能会被恶意代码或在另一个包中不小心更改。考虑使用 Collections.unmodifiableSet/List/Map 等方法对该字段进行包装，以避免此漏洞。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_MUTABLE_COLLECTION_PKGPROTECT">
    <ShortDescription>字段是一个可变集合，应该设置为包私有访问级别  Field is a mutable collection which should be package protected</ShortDescription>
    <LongDescription>{1} 是一个可变集合，应该声明为包私有。</LongDescription>
    <Details>
<![CDATA[<p>将可变集合实例赋值给一个最终静态字段，从而可能被恶意代码或从另一个包中的意外操作所更改。可以将该字段改为包保护级以避免此漏洞。或者你可以通过使用 Collections.unmodifiableSet/List/Map 等方法来封装这个字段，以避免此漏洞。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_MUTABLE_ARRAY">
    <ShortDescription>字段是一个可变数组  Field is a mutable array</ShortDescription>
    <LongDescription>{1} 是一个可变数组</LongDescription>
    <Details>
<![CDATA[<p>一个最终静态字段引用了一个数组，并且可能被恶意代码或从另一个包中的意外代码访问。这段代码可以自由地修改数组的内容。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_CANNOT_BE_FINAL">
    <ShortDescription>字段不是最终变量，无法防止恶意代码对其进行修改  Field isn't final and cannot be protected from malicious code</ShortDescription>
    <LongDescription>{1} 不是最终变量，无法防止恶意代码的修改</LongDescription>
    <Details>
<![CDATA[<p>可变的静态字段可能会被恶意代码或意外地从另一个包中更改。不幸的是，该字段的使用方式并不允许对此问题进行简单的修复。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ME_MUTABLE_ENUM_FIELD">
    <ShortDescription>枚举字段是公共可变的  Enum field is public and mutable</ShortDescription>
    <LongDescription>{1} 字段是公共可变的</LongDescription>
    <Details>
<![CDATA[<p>在公共枚举中定义了一个可变的公共字段，因此可能被恶意代码或不小心从另一个包更改。尽管可变的枚举字段可以用于懒汉初始化，但向外部暴露它们是一种不良做法。考虑将此字段声明为 final 和/或 包私有。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ME_ENUM_FIELD_SETTER">
    <ShortDescription>公共枚举方法无条件地设置其字段  Public enum method unconditionally sets its field</ShortDescription>
    <LongDescription>{1} 无条件设置了字段 {2.name}</LongDescription>
    <Details>
<![CDATA[<p>此公有方法在公共枚举中无条件地设置了枚举字段，因此该字段可以从另一个包中的恶意代码或意外更改。尽管可变的枚举字段可以用于懒汉初始化，但对外暴露这些字段是一种不良实践。考虑移除此方法或将其实限为包私有。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IA_AMBIGUOUS_INVOCATION_OF_INHERITED_OR_OUTER_METHOD">
    <ShortDescription>可能具有歧义性的方法调用，可能是继承来的或外部的。  Potentially ambiguous invocation of either an inherited or outer method</ShortDescription>
    <LongDescription>在 `{1}` 中可能存在含糊其辞的调用，可能是对外部方法或继承的方法的调用 `{2}`。</LongDescription>
    <Details>
<![CDATA[<p>一个内部类调用了既可以解析为继承来的方法也可以解析为外部类中定义的方法。例如，你调用<code>foo(17)</code>，该方法既在超类中定义也在外部类中定义。根据Java语义，它会被解析为调用继承来的那个方法，但这可能不是你的意图。</p>
<p>如果你确实想调用继承来的那个方法，可以通过super来调用（例如调用<code>super.foo(17)</code>），这样其他阅读你代码的人以及SpotBugs都会清楚你想要调用的是继承来的那个方法而不是外部类中的方法。</p>
<p>如果你调用了<code>this.foo(17)</code>，则会调用继承来的那个方法。然而，由于SpotBugs只检查.class文件，它无法区分对<code>this.foo(17)</code>和<code>foo(17)</code>的调用，因此仍然会抱怨可能存在模糊的方法调用。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_SAME_SIMPLE_NAME_AS_SUPERCLASS">
    <ShortDescription>类名不应该遮蔽超类的简单名称  Class names shouldn't shadow simple name of superclass</ShortDescription>
    <LongDescription>类名 {0} � contrasted 着超类的简单名称 {1}</LongDescription>
    <Details>
<![CDATA[<p>这个类的简单名称与其超类相同，只是其超类在不同的包中（例如，`alpha.Foo` 扩展了 `beta.Foo`）。这可能会引起极大的混淆，在很多情况下需要查看导入语句来解析引用，并且会有很多机会不小心定义不覆盖超类方法的方法。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_SAME_SIMPLE_NAME_AS_INTERFACE">
    <ShortDescription>类名不应该屏蔽实现接口的简单名称  Class names shouldn't shadow simple name of implemented interface</ShortDescription>
    <LongDescription>类名{0}遮蔽了实现接口{1}的简单名称</LongDescription>
    <Details>
<![CDATA[<p>该类/接口的简单名称与实现/扩展的接口的简单名称相同，只是接口位于不同的包中（例如，`alpha.Foo` 扩展了 `beta.Foo`）。这可能会造成极大的混淆，在引用时需要查看导入语句来解析引用，并且很容易不小心定义不覆盖超类方法的方法。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_CLASS_NAMING_CONVENTION">
    <ShortDescription>类名应以大写字母开头  Class names should start with an upper case letter</ShortDescription>
    <LongDescription>类名 {0} 没有以大写字母开头</LongDescription>
    <Details>
<![CDATA[<p>类名应为名词，采用驼峰命名法，每个内部单词的首字母大写。尽量使类名简洁且具有描述性。使用完整的单词，避免使用缩写和简称（除非该缩写比长形式更广泛使用，例如 URL 或 HTML）。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_METHOD_NAMING_CONVENTION">
    <ShortDescription>方法名应以小写字母开头  Method names should start with a lower case letter</ShortDescription>
    <LongDescription>方法名 `{1}` 没有以小写字母开头</LongDescription>
    <Details>
<![CDATA[<p>方法应使用动词，并采用混合大小写的形式，首字母小写，内部单词的首字母大写。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_FIELD_NAMING_CONVENTION">
    <ShortDescription>字段名应以小写字母开头  Field names should start with a lower case letter</ShortDescription>
    <LongDescription>字段名 {1} 不是以小写字母开头的</LongDescription>
    <Details>
<![CDATA[<p>如果不是最终字段的名称应采用混合大小写格式，首字母小写，后续单词的首字母大写。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_VERY_CONFUSING">
    <ShortDescription>非常混乱的方法命名  Very confusing method names</ShortDescription>
    <LongDescription>方法 {1} 和 {3} 很容易让人感到困惑。</LongDescription>
    <Details>
<![CDATA[<p>引用的方法名称仅在大小写上有所不同。这非常令人困惑，因为如果大小写完全相同，则一个方法会覆盖另一个方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_VERY_CONFUSING_INTENTIONAL">
    <ShortDescription>方法名称非常混淆（但可能是有意而为）  Very confusing method names (but perhaps intentional)</ShortDescription>
    <LongDescription>方法 {1} 和 {3} 的命名非常令人困惑（也许这是故意的）。</LongDescription>
    <Details>
<![CDATA[<p>引用的方法名称仅通过大小写不同。这非常容易引起混淆，因为如果大小写相同，则一个方法将覆盖另一个方法。从其他方法的存在来看，似乎这两个方法同时存在是有意的，但这确实很令人困惑。你应该尽量消除其中一个方法，除非由于冻结的API不得不保留两者。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_WRONG_PACKAGE">
    <ShortDescription>方法由于参数的错误包名而不 overriding 上级类中的方法  Method doesn't override method in superclass due to wrong package for parameter</ShortDescription>
    <LongDescription>{1} 没有覆盖上级类中的方法，因为参数类型 {4} 不匹配上级类中的参数类型 {5}</LongDescription>
    <Details>
<![CDATA[子类中的方法并未覆盖超类中类似的某个方法，因为参数的类型与超类中相应参数的类型不完全匹配。例如，如果有如下代码：

```java
import alpha.Foo;
public class A {
    public int f(Foo x) { return 17; }
}
---
import beta.Foo;
public class B extends A {
    public int f(Foo x) { return 42; }
}
```

类 `B` 中定义的 `f(Foo)` 方法并未覆盖类 `A` 中定义的 `f(Foo)` 方法，因为参数类型为不同包中的 `Foo`。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_WRONG_PACKAGE_INTENTIONAL">
    <ShortDescription>方法没有覆盖超类中的方法，因为参数的包名错误。  Method doesn't override method in superclass due to wrong package for parameter</ShortDescription>
    <LongDescription>{1} 没有覆盖超类中的方法，因为参数类型 {4} 与超类参数类型 {5} 不匹配</LongDescription>
    <Details>
<![CDATA[<p>子类中的方法没有覆盖超类中的类似方法，因为参数的类型与超类中对应参数的类型不完全匹配。例如，如果有如下代码：</p>
<pre><code>import alpha.Foo;  
public class A {     
    public int f(Foo x) { return 17; } 
} ---- import beta.Foo;  

public class B extends A {     
    public int f(Foo x) { return 42; }     
    public int f(alpha.Foo x) { return 27; } 
}</code></pre>
<p>子类 <code>B</code> 中定义的 <code>f(Foo)</code> 方法并没有覆盖超类 <code>A</code> 中定义的 <code>f(Foo)</code> 方法，因为参数类型来自不同的包。</p>
<p>在这种情况下，子类确实定义了一个与 superclass 中的方法签名完全相同的 метод，所以这似乎是可以理解的。然而，这样的方法会非常令人困惑。你应该强烈考虑移除或弃用具有相似但不完全相同签名的方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_CONFUSING">
    <ShortDescription>混淆的方法名称  Confusing method names</ShortDescription>
    <LongDescription>方法 `{1}` 和 `{3}` 易混淆</LongDescription>
    <Details>
<![CDATA[<p>引用的方法名称仅通过大写和小写的区别不同。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_METHOD_CONSTRUCTOR_CONFUSION">
    <ShortDescription>方法/构造器混淆  Apparent method/constructor confusion</ShortDescription>
    <LongDescription>{1} 可能是想要定义一个构造函数</LongDescription>
    <Details>
<![CDATA[<p>该方法的名称与定义它的类相同。这很可能意味着本意是要将此方法定义为构造函数。如果确实是想将其定义为构造函数，则需要移除返回值类型声明（void）。 如果您不小心定义了该方法，后来意识到错误并定义了一个正确的构造函数，但由于向后兼容性原因无法删除该方法，请对该方法进行弃用处理。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_LCASE_HASHCODE">
    <ShortDescription>Class 定义了 hashcode()；应该写成 hashCode() 吗？  Class defines hashcode(); should it be hashCode()?</ShortDescription>
    <LongDescription>类 {0} 中定义了 `hashcode()`；应该写成 `hashCode()` 吗？</LongDescription>
    <Details>
<![CDATA[<p>该类定义了一个名为 `<code>hashcode()</code>` 的方法。这个方法并未重写自 `java.lang.Object` 中的 `<code>hashCode()</code>` 方法，这可能是开发者原本的意图。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_LCASE_TOSTRING">
    <ShortDescription>类定义了tostring()；应该写成toString()？  Class defines tostring(); should it be toString()?</ShortDescription>
    <LongDescription>类 {0} 定义了 `tostring()`；应该使用 `toString()` 吗？</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个名为 `tostring()` 的方法。该方法并未重写来自 `java.lang.Object` 的 `toString()` 方法，这可能是作者的本意。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_BAD_EQUAL">
    <ShortDescription>类定义了 equal(Object)；应该使用 equals(Object) 吗？  Class defines equal(Object); should it be equals(Object)?</ShortDescription>
    <LongDescription>类 {0} 定义了 equal(Object)；应该使用 equals(Object) 吗？</LongDescription>
    <Details>
<![CDATA[<p>该类定义了一个方法<code>equal(Object)</code>。此方法并未重写自<code>java.lang.Object</code>中的<code>equals(Object)</code>方法，这可能是开发者本意要做的。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_CLASS_NOT_EXCEPTION">
    <ShortDescription>类并未从异常类继承，尽管它的名称表明它是一个异常。  Class is not derived from an Exception, even though it is named as such</ShortDescription>
    <LongDescription>类 {0} 没有继承自 Exception，尽管它的名称看起来像是一个异常类。</LongDescription>
    <Details>
<![CDATA[<p>此类没有继承其他异常，但却以 'Exception' 结尾。这会给使用此类的用户带来混淆。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RR_NOT_CHECKED">
    <ShortDescription>方法忽略了InputStream.read()的方法调用结果。  Method ignores results of InputStream.read()</ShortDescription>
    <LongDescription>{1} 忽略了 {2} 的结果</LongDescription>
    <Details>
<![CDATA[<p>此方法忽略了其中一个版本的 <code>java.io.InputStream.read()</code> 的返回值，该方法可以返回多个字节。如果不检查返回值，在调用者请求读取特定数量字节的情况下，可能会无法正确处理实际读取的字节数少于请求的数量的情况。这是一种特别隐蔽的bug，因为在许多程序中，从输入流读取通常会读取完整数据量，导致程序仅在某些情况下失效。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SR_NOT_CHECKED">
    <ShortDescription>方法忽略了InputStream.skip()的方法调用结果。  Method ignores results of InputStream.skip()</ShortDescription>
    <LongDescription>{1} 忽略了 {2} 的返回结果</LongDescription>
    <Details>
<![CDATA[<p>此方法忽略了 <code>java.io.InputStream.skip()</code> 的返回值，该方法可以跳过多个字节。如果不检查返回值，调用者将无法正确处理实际被跳过的字节数少于请求跳过的字节数的情况。这是一种特别隐蔽的 bug，因为在许多程序中，从输入流中跳过的数据通常确实会跳过所请求的全部数量的数据，导致程序仅偶尔失效。然而，在使用缓冲流的情况下，<code>skip()</code> 只会在缓冲区中跳过数据，并且经常无法跳过所请求的数量的字节。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_READ_RESOLVE_IS_STATIC">
    <ShortDescription>readResolve 方法不得声明为静态方法。  The readResolve method must not be declared as a static method.</ShortDescription>
    <LongDescription>{1} 应该声明为实例方法而不是静态方法。</LongDescription>
    <Details>
<![CDATA[为了使 readResolve 方法被序列化机制识别，它不能声明为静态方法。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_PRIVATE_READ_RESOLVE_NOT_INHERITED">
    <ShortDescription>私有readResolve方法不会被子类继承  Private readResolve method not inherited by subclasses</ShortDescription>
    <LongDescription>{0}中的私有readResolve方法未被子类继承。</LongDescription>
    <Details>
<![CDATA[<p>该类定义了一个私有的 readResolve 方法。由于是私有的，因此不会被子类继承。这可能是有意为之且可以接受的，但应该进行审查以确保这是预期的行为。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_READ_RESOLVE_MUST_RETURN_OBJECT">
    <ShortDescription>readResolve 方法必须声明为返回类型为 Object。  The readResolve method must be declared with a return type of Object.</ShortDescription>
    <LongDescription>方法 `{1}` 必须声明为返回类型为 `Object`，而不是 `{1.returnType}`。</LongDescription>
    <Details>
<![CDATA[<p>为了使读取反序列化方法被序列化机制识别，该方法必须声明为返回类型为Object。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_TRANSIENT_FIELD_OF_NONSERIALIZABLE_CLASS">
    <ShortDescription>非序列化类中的瞬暂字段。  Transient field of class that isn't Serializable.</ShortDescription>
    <LongDescription>`{1.givenClass}` 是 transient 的，但 `{0}` 并不是 Serializable 的。</LongDescription>
    <Details>
<![CDATA[<p>该字段被标记为 transient，但该类并不实现 Serializable 接口，因此将其标记为 transient 没有任何效果。这可能是之前版本的代码中该类实现了 Serializable 接口时留下的痕迹，也可能表示对序列化的工作原理存在误解。</p>
<p><em>仅在设置了特殊选项 <tt>reportTransientFieldOfNonSerializableClass</tt> 时报告此错误。</em></p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_TRANSIENT_FIELD_NOT_RESTORED">
    <ShortDescription>反序列化时不被设置的 transient 字段。  Transient field that isn't set by deserialization.</ShortDescription>
    <LongDescription>字段 {1} 是 transient 的，但在反序列化时并未被设置。</LongDescription>
    <Details>
<![CDATA[<p>这个类包含一个字段，在该类的多个地方都会更新它，因此看起来它是类的状态的一部分。然而，由于该字段被标记为 transient，并且不在 readObject 或 readResolve 中设置，所以在任何反序列化的类实例中，该字段都将包含默认值。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_METHOD_MUST_BE_PRIVATE">
    <ShortDescription>为了使序列化生效，该方法必须声明为私有。  Method must be private in order for serialization to work</ShortDescription>
    <LongDescription>方法 `{1.givenClass}` 必须是私有（private）的，才能在序列化/反序列化 `{0}` 时被调用。</LongDescription>
    <Details>
<![CDATA[<p>该类实现了<code>Serializable</code>接口，并定义了一个自定义序列化/反序列化的方法。但由于该方法没有声明为私有，因此会在序列化/反序列化API中被默默地忽略。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION">
    <ShortDescription>类实现了Externalizable接口，但没有定义无参构造函数。  Class is Externalizable but doesn't define a void constructor</ShortDescription>
    <LongDescription>{0}实现了Externalizable接口，但没有定义无参构造函数。</LongDescription>
    <Details>
<![CDATA[<p>该类实现了 <code>Externalizable</code> 接口，但没有定义一个公共空构造函数。当反序列化 Externalizable 对象时，它们首先需要通过调用公共空构造函数来构建。由于该类没有定义此类构造函数，因此在运行时进行序列化和反序列化将会失败。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NO_SUITABLE_CONSTRUCTOR">
    <ShortDescription>类实现了Serializable接口，但其超类没有定义无参构造函数。  Class is Serializable but its superclass doesn't define a void constructor</ShortDescription>
    <LongDescription>{0}实现了Serializable接口，但其超类没有定义可访问的无参构造函数。</LongDescription>
    <Details>
<![CDATA[<p>该类实现了<code>Serializable</code>接口，而其超类并未实现。当此类的对象进行反序列化时，需要通过调用超类的无参构造函数来初始化超类的字段。由于超类没有提供这样的构造函数，因此在运行时会因序列化和反序列化失败。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NO_SERIALVERSIONID">
    <ShortDescription>类是可序列化的，但没有定义serialVersionUID  Class is Serializable, but doesn't define serialVersionUID</ShortDescription>
    <LongDescription>{0} 实现了Serializable接口；考虑声明一个serialVersionUID。</LongDescription>
    <Details>
<![CDATA[<p>该类实现了<code>Serializable</code>接口，但没有定义<code>serialVersionUID</code>字段。简单地添加对.class对象的引用将向类中添加合成字段，不幸的是这会改变隐式的<code>serialVersionUID</code>(例如，添加对<code>String.class</code>的引用会产生一个静态字段<code>class$java$lang$String</code>)。此外，不同的源代码到字节码编译器可能会使用不同的命名约定来生成用于类对象或内部类引用的合成变量。为了确保不同版本之间的可互操作性，考虑添加一个显式的<code>serialVersionUID</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_COMPARATOR_SHOULD_BE_SERIALIZABLE">
    <ShortDescription>Comparator 没有实现 Serializable 接口  Comparator doesn't implement Serializable</ShortDescription>
    <LongDescription>{0} 实现了 Comparator 但未实现 Serializable</LongDescription>
    <Details>
<![CDATA[<p>该类实现了<code>Comparator</code>接口。您应该考虑它是否也应该实现<code>Serializable</code>接口。如果使用比较器来构建有序集合（例如<code>TreeMap</code>），那么只有当比较器也是可序列化的时候，<code>TreeMap</code>才会是可序列化的。由于大多数比较器几乎没有或根本没有状态，使它们成为可序列化的通常很容易，并且也是一种良好的防御性编程实践。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SF_SWITCH_FALLTHROUGH">
    <ShortDescription>在 switch 语句中发现一个 case 没有明确的结束，导致代码会 fall through 到下一个 case。  Switch statement found where one case falls through to the next case</ShortDescription>
    <LongDescription>在 {1} 中发现 switch 语句，其中一种情况会直接跳到下一个情况。</LongDescription>
    <Details>
<![CDATA[<p>该方法包含一个 switch 语句，其中某个 case 分支会延续到下一个 case。通常你需要在该 case 结尾处添加一个 break 或 return。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SF_SWITCH_NO_DEFAULT">
    <ShortDescription>发现 Switch 语句缺少默认情况"default case"。  Switch statement found where default case is missing</ShortDescription>
    <LongDescription>在{1}中发现了switch语句且缺少default情况处理。</LongDescription>
    <Details>
<![CDATA[<p>此方法包含一个缺少默认情况（default case）的switch语句。通常需要提供默认情况。</p>
<p>由于分析仅检查生成的字节码，因此如果默认情况位于switch语句末尾且该switch语句其他情况下没有break语句，则此警告可能会被错误触发。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH">
    <ShortDescription>由于开关语句连贯性导致的死存储  Dead store due to switch statement fall through</ShortDescription>
    <LongDescription>在switch语句的fall through情况下，{2.givenClass}从上一个案例中的值被覆盖了。</LongDescription>
    <Details>
<![CDATA[<p>在此处，上一个 switch 情况中存储的值被覆盖了。这可能是你忘记在前一个情况的末尾放置 break 或 return 语句所致。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH_TO_THROW">
    <ShortDescription>由于switch语句的fall-through导致了死.store  Dead store due to switch statement fall through to throw</ShortDescription>
    <LongDescription>在此处由于switch语句导致fall through到throw，因此之前案例中的{2.givenClass}值丢失了。</LongDescription>
    <Details>
<![CDATA[<p>在这里，由于开关语句穿透到了一个抛出异常的地方，之前switch case中的值被忽略了。很可能你在前一个case的末尾忘记添加break或return语句。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="WS_WRITEOBJECT_SYNC">
    <ShortDescription>类的 `writeObject()` 方法是同步的，但其他部分都不是。  Class's writeObject() method is synchronized but nothing else is</ShortDescription>
    <LongDescription>{0} 的 `writeObject` 方法是同步的，但其他部分却没有同步。</LongDescription>
    <Details>
<![CDATA[<p>此类包含一个同步的<code>writeObject()</code>方法；然而，该类的其他方法都没有同步。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RS_READOBJECT_SYNC">
    <ShortDescription>类的readObject()方法是同步的  Class's readObject() method is synchronized</ShortDescription>
    <LongDescription>{0} 的 readObject 方法是同步的</LongDescription>
    <Details>
<![CDATA[<p>此可序列化的类定义了一个同步的<code>readObject()</code>方法。根据定义，通过反序列化创建的对象仅可被一个线程访问，因此无需将<code>readObject()</code>方法声明为同步方法。如果<code>readObject()</code>方法本身导致对象变得可见于另一个线程，则这属于非常可疑的编程风格。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NONSTATIC_SERIALVERSIONID">
    <ShortDescription>serialVersionUID 不是静态的  serialVersionUID isn't static</ShortDescription>
    <LongDescription>"{1} 不是静态的"</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个非静态的 <code>serialVersionUID</code> 字段。如果该字段用于指定序列化的目的版本UID，则应将其声明为静态。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NONFINAL_SERIALVERSIONID">
    <ShortDescription>serialVersionUID 不是 final  serialVersionUID isn't final</ShortDescription>
    <LongDescription>"{1}" 不是最终变量</LongDescription>
    <Details>
<![CDATA[<p>该类定义了一个未声明为 final 的 <code>serialVersionUID</code> 字段。如果打算将此字段用于序列化版本标识符的目的，应将其声明为 final。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NONLONG_SERIALVERSIONID">
    <ShortDescription>serialVersionUID 不是 long 类型  serialVersionUID isn't long</ShortDescription>
    <LongDescription>"{1} 并不长"</LongDescription>
    <Details>
<![CDATA[<p>该类定义了一个不是长整型的 `serialVersionUID` 字段。如果打算为了序列化目的指定版本UID，应将此字段改为长整型。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_BAD_FIELD">
    <ShortDescription>在可序列化的类中存在非瞬态且非序列化的实例字段  Non-transient non-serializable instance field in serializable class</ShortDescription>
    <LongDescription>类 {0} 定义了非暂存且非序列化的实例字段 {1.name}</LongDescription>
    <Details>
<![CDATA[<p>该可序列化类定义了一个非原始实例字段，该字段既不是 transient、Serializable 或 java.lang.Object 类型，并且似乎也没有实现 Externalizable 接口或 readObject() 和 writeObject() 方法。如果此字段中存储了非序列化对象，则该类的对象在反序列化时将无法正确解析。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_BAD_FIELD_INNER_CLASS">
    <ShortDescription>非序列化类包含一个可序列化的内部类  Non-serializable class has a serializable inner class</ShortDescription>
    <LongDescription>{0}是可以序列化，但同时也是非序列化类的内部类。</LongDescription>
    <Details>
<![CDATA[<p>这个可序列化的内部类是一个非可序列化类的内部类。因此，尝试对该内部类进行序列化时，也会试图将与之关联的外部类的实例一起进行序列化，从而导致运行时错误。</p>
<p>如果可能的话，将内部类改为静态内部类可以解决这个问题。使外部类可序列化也可能行得通，但这意味着对内部类实例进行序列化时总是会同时序列化外部类的实例，而这通常不是你真正想要的结果。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_INNER_CLASS">
    <ShortDescription>可序列化的内部类  Serializable inner class</ShortDescription>
    <LongDescription>{0}是可以序列化的内部类</LongDescription>
    <Details>
<![CDATA[<p>这个可序列化的类是一个内部类。任何尝试序列化它的操作也会序列化相关的外部实例。由于外部实例是可序列化的，所以这不会失败，但可能会序列化比预期更多的数据。如果可能的话，将内部类改为静态内部类（也称为嵌套类）可以解决这个问题。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_BAD_FIELD_STORE">
    <ShortDescription>可序列化的类中实例字段存储了不可序列化的值  Non-serializable value stored into instance field of a serializable class</ShortDescription>
    <LongDescription>存储在非易失性字段 {1.givenClass} 中</LongDescription>
    <Details>
<![CDATA[<p>可序列化的类中存储了一个非序列化值到一个非瞬态字段。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SC_START_IN_CTOR">
    <ShortDescription>构造函数调用了Thread.start()  Constructor invokes Thread.start()</ShortDescription>
    <LongDescription>{1} 调用了 {2}</LongDescription>
    <Details>
<![CDATA[<p>构造函数启动了一个线程。如果该类以后被扩展/子类化，这很可能不对，因为线程将在子类构造函数启动之前启动。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SS_SHOULD_BE_STATIC">
    <ShortDescription>未读字段：这个字段应该声明为静态的吗？  Unread field: should this field be static?</ShortDescription>
    <LongDescription>未读字段：{1}；该字段应该被声明为静态吗？</LongDescription>
    <Details>
<![CDATA[<p>该类包含一个实例最终字段，并且该字段初始化为编译时静态值。考虑将该字段声明为静态。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UUF_UNUSED_FIELD">
    <ShortDescription>未使用字段  Unused field</ShortDescription>
    <LongDescription>未使用的字段：{1}</LongDescription>
    <Details>
<![CDATA[<p>此字段从未使用。考虑从类中移除它。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="URF_UNREAD_FIELD">
    <ShortDescription>未读字段  Unread field</ShortDescription>
    <LongDescription>未读字段：{1}</LongDescription>
    <Details>
<![CDATA[<p>此字段从未被读取。考虑从类中移除它。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD">
    <ShortDescription>未使用的公共或受保护字段  Unused public or protected field</ShortDescription>
    <LongDescription>未使用的公共或保护字段：{1}</LongDescription>
    <Details>
<![CDATA[<p>此字段从未使用过。该字段是公共或保护类型，也许它是打算与其他未包含在分析中的类一起使用。如果不是这种情况，请考虑从类中移除它。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD">
    <ShortDescription>未读取的公共/受保护字段  Unread public/protected field</ShortDescription>
    <LongDescription>未读取的公共/受保护字段：{1}</LongDescription>
    <Details>
<![CDATA[<p>此字段从未被读取。该字段是公共或受保护的，也许它是打算与其他分析中未见到的类一起使用。如果不是这样，请考虑从类中移除它。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="QF_QUESTIONABLE_FOR_LOOP">
    <ShortDescription>复杂的、微妙的或错误的for循环增量  Complicated, subtle or wrong increment in for-loop</ShortDescription>
    <LongDescription>在for循环中复杂的、微妙的或错误的递增操作 {1}</LongDescription>
    <Details>
<![CDATA[你确定这个for循环是正确地增加了/减少了变量吗？似乎另一个变量是由for循环初始化和检查的。]]>
    </Details>
  </BugPattern>
  <BugPattern type="UWF_NULL_FIELD">
    <ShortDescription>字段仅被设置为 null  Field only ever set to null</ShortDescription>
    <LongDescription>仅被设置为null：{1}</LongDescription>
    <Details>
<![CDATA[<p>此字段的所有写入都是常量值null，因此所有对该字段的读取都将返回null。检查是否有错误，如果没有用处则可以移除该字段。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD">
    <ShortDescription>未定义的公共或受保护字段  Unwritten public or protected field</ShortDescription>
    <LongDescription>未定义的公共或保护字段：{1}</LongDescription>
    <Details>
<![CDATA[<p>未对该公共/受保护字段进行写操作。所有对其的读取将返回默认值。检查是否存在错误（它本应被初始化吗？），或者如果该字段无用，则可以将其移除。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UWF_UNWRITTEN_FIELD">
    <ShortDescription>未定义的字段  Unwritten field</ShortDescription>
    <LongDescription>未定义的字段：{1}</LongDescription>
    <Details>
<![CDATA[<p>此字段从未被写入。所有对该字段的读取都将返回默认值。检查是否存在错误（是否应该对其进行初始化？），或者如果它是无用的，则可以删除它。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD">
    <ShortDescription>从实例方法中写入静态字段  Write to static field from instance method</ShortDescription>
    <LongDescription>从实例方法 {1} 向静态字段 {2} 写入值</LongDescription>
    <Details>
<![CDATA[<p>该实例方法写入了一个静态字段。如果多个实例被同时操作，这会很难正确实现，并且通常被视为不良实践。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_LOAD_OF_KNOWN_NULL_VALUE">
    <ShortDescription>已知为空值的加载  Load of known null value</ShortDescription>
    <LongDescription>在 {1} 中加载已知的空值</LongDescription>
    <Details>
<![CDATA[<p>在此点引用的变量已知为null，因为之前对该变量进行了null检查。虽然这是有效的，但这可能是错误（也许您本应引用的是另一个变量，或者之前的检查应该是检查该变量是否非null）。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_DEREFERENCE_OF_READLINE_VALUE">
    <ShortDescription>从读取行的结果中解引用而未进行空检查  Dereference of the result of readLine() without nullcheck</ShortDescription>
    <LongDescription>在 `{1}` 处使用 `readLine()` 的结果进行解引用而未进行空检查。</LongDescription>
    <Details>
<![CDATA[<p>调用readLine()的结果未检查是否为null即被解引用。如果已无更多文本行可读取，readLine()将返回null，并对null进行解引将会引发空指针异常。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_IMMEDIATE_DEREFERENCE_OF_READLINE">
    <ShortDescription>立即解引用 `readLine()` 的结果  Immediate dereference of the result of readLine()</ShortDescription>
    <LongDescription>立即 dereference 读取结果 readLine() 的返回值在 {1} 中</LongDescription>
    <Details>
<![CDATA[<p>调用 readLine() 的结果立即解引用。如果没有更多的文本行可供读取，readLine() 将返回 null，并解引用该值会导致空指针异常。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_UNWRITTEN_FIELD">
    <ShortDescription>未写入的字段读取  Read of unwritten field</ShortDescription>
    <LongDescription>在 `{1}` 中读取未写入的字段 `{2.name}`</LongDescription>
    <Details>
<![CDATA[<p>该程序正在解引用一个似乎从未被写入非空值的字段。除非该字段是通过分析未看到的一些机制初始化的，否则解引用此值将生成空指针异常。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD">
    <ShortDescription>读取未初始化的公共或受保护字段  Read of unwritten public or protected field</ShortDescription>
    <LongDescription>在 {1} 中读取未写入的公共或保护字段 {2.name}</LongDescription>
    <Details>
<![CDATA[<p>该程序正在引用一个公有或保护类型的字段，而分析结果显示该字段似乎从未被写入非空值。除非该字段是通过某些未被分析捕获的机制初始化的，否则引用这个值将会生成空指针异常。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIC_THREADLOCAL_DEADLY_EMBRACE">
    <ShortDescription>非静态内部类与线程本地变量的致命拥抱  Deadly embrace of non-static inner class and thread local</ShortDescription>
    <LongDescription>{0} 需要声明为 _static_ 以避免与 {1} 的相互依赖。</LongDescription>
    <Details>
<![CDATA[<p>这个类是一个内部类，但很可能应该定义为静态内部类。由于它不是一个静态内部类，因此会保留对外部类的引用。如果外部类中的线程局部变量包含对内部类实例的引用，那么内外部类的实例都将可达，并且不具备被垃圾回收的机会。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIC_INNER_SHOULD_BE_STATIC">
    <ShortDescription>应该是一个静态内部类  Should be a static inner class</ShortDescription>
    <LongDescription>{0} 应该是一个静态内部类 _static_ 吗？</LongDescription>
    <Details>
<![CDATA[<p>这个内类并不使用它对创建它的对象的引用。这个引用会使该类的实例变大，并可能使对创建者对象的引用保持活跃的时间比必要的时间更长。如果可能，应该将该类声明为静态类。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR">
    <ShortDescription>字段在构造函数中未初始化但未经空检查就进行了引用  Field not initialized in constructor but dereferenced without null check</ShortDescription>
    <LongDescription>在构造函数中未初始化 `{1.givenClass}`，并在 `{2}` 中解引用。</LongDescription>
    <Details>
<![CDATA[<p>该字段在任何构造函数中都没有被初始化，因此对象构建完成后可能会是null。而在其他地方，该字段没有进行空检查就被加载和解引用了。这可能是错误或设计不当，因为这意味着如果在该字段未初始化之前对其进行解引用来访问它，则会产生空指针异常。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIC_INNER_SHOULD_BE_STATIC_ANON">
    <ShortDescription>可以重构为命名的静态内部类  Could be refactored into a named static inner class</ShortDescription>
    <LongDescription>类 {0} 可以重构为一个命名的 _静态_ 内部类</LongDescription>
    <Details>
<![CDATA[<p>这个类是内部类，但并未使用其对创建它的对象的引用。该引用使得该类的对象变大，并可能使对该创建者对象的引用保持存活时间过长。如果可行，应该将该类声明为静态内部类。由于匿名内部类不能标记为静态，因此这需要重构内部类，使其成为命名的内部类。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS">
    <ShortDescription>可以重构为静态内部类  Could be refactored into a static inner class</ShortDescription>
    <LongDescription>类 {0} 可以重构为一个 _静态_ 内部类</LongDescription>
    <Details>
<![CDATA[<p>这个内部类是一个嵌套类，但除了在构建内部对象时，它不使用来自创建它的对象的引用。这个引用使该类的实例更大，并且可能会使对外部对象的引用保持存活的时间比必要的时间更长。如果可能的话，应该将这个类改为静态内部类。由于在构建内部实例时需要对外部对象的引用，因此内部类需要重新整理，以便向内部类构造函数传递对外部实例的引用。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="WA_NOT_IN_LOOP">
    <ShortDescription>不在循环中等待  Wait not in loop</ShortDescription>
    <LongDescription>在{1}中不要等待循环中</LongDescription>
    <Details>
<![CDATA[<p>该方法中包含对 <code>java.lang.Object.wait()</code> 的调用，但不在循环中。如果锁用于多个条件，则调用者希望等待的条件可能并不是实际发生的那个条件。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="WA_AWAIT_NOT_IN_LOOP">
    <ShortDescription>Condition.await() 不要在循环中使用  Condition.await() not in loop</ShortDescription>
    <LongDescription>在{1}中不要使用Condition.await()替代循环。</LongDescription>
    <Details>
<![CDATA[<p>该方法中包含对<code>java.util.concurrent.await()</code>&nbsp;(或其变体) 的调用，但这些调用不在循环中。如果对象用于多个条件，则实际等待的发生条件可能不是调用者所预期的那个条件。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NO_NOTIFY_NOT_NOTIFYALL">
    <ShortDescription>使用 `notify()` 而不是 `notifyAll()`  Using notify() rather than notifyAll()</ShortDescription>
    <LongDescription>在{1}中使用notify而不是notifyAll</LongDescription>
    <Details>
<![CDATA[<p>此方法调用了<code>notify()</code> 而不是<code>notifyAll()</code>。Java 监视器通常用于多个条件。<code>notify()</code> 只会唤醒一个线程，这意味着被唤醒的线程可能并不是等待由调用者刚刚满足的条件的那个线程。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UC_USELESS_VOID_METHOD">
    <ShortDescription>无用的非空void方法  Useless non-empty void method</ShortDescription>
    <LongDescription>方法 {1} 看起来是无用的</LongDescription>
    <Details>
<![CDATA[<p>我们的分析表明，这个非空的void方法实际上并没有执行任何有用的工作。请检查一下：可能它的代码中出现了错误，或者其内容完全可以被移除。</p>
<p>我们尽量减少误报的情况，但在某些情况下这种警告可能是错误的。常见的误报情况包括：</p>
<ul>
<li>该方法旨在触发某些类的加载，这可能会产生一些副作用。</li>
<li>该方法旨在隐式抛出某种不显而见的异常。</li>
</ul>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UC_USELESS_CONDITION">
    <ShortDescription>条件没有效果  Condition has no effect</ShortDescription>
    <LongDescription>无用条件：此时已知{2}</LongDescription>
    <Details>
<![CDATA[<p>此条件总是与之前受限的变量值产生相同的结果。可能原本意图不同，或者此条件可以被移除。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UC_USELESS_CONDITION_TYPE">
    <ShortDescription>条件语句由于变量类型的原因无效。  Condition has no effect due to the variable type</ShortDescription>
    <LongDescription>无用的条件：因为它变量类型为{3}，所以总是{2}</LongDescription>
    <Details>
<![CDATA[<p>由于涉及变量的类型范围，此条件总是产生相同的结果。可能是另有其他意图，或者该条件可以被移除。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UC_USELESS_OBJECT">
    <ShortDescription>创建了不必要的对象  Useless object created</ShortDescription>
    <LongDescription>在方法 `{1}` 中存储在变量 `{2}` 中的无用对象</LongDescription>
    <Details>
<![CDATA[<p>我们的分析显示这个对象是无用的。它被创建并修改，但其值从未离开方法范围之外或产生任何副作用。要么是存在错误，对象本应被使用，要么可以移除。</p>
<p>这种分析很少产生误报。常见的误报情况包括：</p>
<ul>
    <li>- 该对象用于隐式抛出某些不明显的异常。</li>
    <li>- 该对象用作占位符来通用代码。</li>
    <li>- 该对象用于持有对弱引用/软引用对象的强引用。</li>
</ul>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UC_USELESS_OBJECT_STACK">
    <ShortDescription>在栈上创建了不必要的对象  Useless object created on stack</ShortDescription>
    <LongDescription>在方法 {1} 中创建了不必要的对象</LongDescription>
    <Details>
<![CDATA[<p>这个对象仅用于执行一些没有副作用的修改。可能原本另有他用，或者这个对象可以被移除。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RANGE_ARRAY_INDEX">
    <ShortDescription>数组索引越界  Array index is out of bounds</ShortDescription>
    <LongDescription>数组索引超出范围：{3}</LongDescription>
    <Details>
<![CDATA[<p>执行了数组操作，但数组索引超出范围，在运行时将导致ArrayIndexOutOfBoundsException。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RANGE_ARRAY_OFFSET">
    <ShortDescription>数组越界  Array offset is out of bounds</ShortDescription>
    <LongDescription>数组越界：{3}</LongDescription>
    <Details>
<![CDATA[<p>方法使用了数组参数和偏移量参数，但偏移量越界。这将在运行时导致索引越界异常（IndexOutOfBoundsException）。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RANGE_ARRAY_LENGTH">
    <ShortDescription>数组长度越界  Array length is out of bounds</ShortDescription>
    <LongDescription>数组长度越界：{3}</LongDescription>
    <Details>
<![CDATA[<p>方法使用数组参数和长度参数调用，但长度超出了范围。这将在运行时导致索引越界异常（IndexOutOfBoundsException）。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RANGE_STRING_INDEX">
    <ShortDescription>字符串索引超出范围  String index is out of bounds</ShortDescription>
    <LongDescription>在调用{5}时，字符串索引越界：{3}</LongDescription>
    <Details>
<![CDATA[<p>调用了String方法并且指定的字符串索引越界。这将在运行时导致StringIndexOutOfBoundsException异常。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_CHECK_FOR_POSITIVE_INDEXOF">
    <ShortDescription>方法检查 `String.indexOf` 的结果是否为正数  Method checks to see if result of String.indexOf is positive</ShortDescription>
    <LongDescription>{1} 检查 `String.indexOf` 的结果是否为正数</LongDescription>
    <Details>
<![CDATA[<p>该方法调用了String.indexOf，并检查其结果是否为正数或非正数。通常的做法是检查结果是否为负数或非负数。只有当要查找的子字符串出现在字符串的起始位置以外的地方时，结果才是正值。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_DONT_JUST_NULL_CHECK_READLINE">
    <ShortDescription>在检查 `readLine` 返回值是否非空之后，方法忽略了其返回结果  Method discards result of readLine after checking if it is non-null</ShortDescription>
    <LongDescription>{1} 在检查 `readLine` 返回值是否非空后，丢弃了其返回结果</LongDescription>
    <Details>
<![CDATA[<p>在检查readLine返回值是否非空之后，返回的值被丢弃。在几乎所有情况下，如果结果是非空的，你通常会想使用这个非空值。再次调用readLine将给你不同的行。</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="RV_RETURN_VALUE_IGNORED_INFERRED">
    <ShortDescription>方法忽略了返回值，这可以接受吗？  Method ignores return value, is this OK?</ShortDescription>
    <LongDescription>{2.给定类}的方法返回值被忽略了，在{1}中这样可以接受吗？</LongDescription>
    <Details>
<![CDATA[<p>此代码调用了一个方法并忽略了返回值。该返回值与调用方法的对象类型相同，从我们的分析来看，返回值可能很重要（例如，类似于忽略<code>String.toLowerCase()</code>的方法返回值）。</p>
<p>仅仅从对方法体的简单分析中，我们猜测忽略返回值可能是不明智的。您可以使用 @CheckReturnValue 注解来指示 SpotBugs 是否认为忽略此方法的返回值是重要的或可接受的。</p>
<p>请仔细调查以决定是否可以忽略返回值。</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT">
    <ShortDescription>方法无副作用的返回值被忽略  Return value of method without side effect is ignored</ShortDescription>
    <LongDescription>{2.givenClass}方法的返回值被忽略，但该方法没有副作用。</LongDescription>
    <Details>
<![CDATA[<p>该代码调用了一个方法并忽略了返回值。然而，我们的分析显示，该方法（包括其任何子类的实现）除了返回值外没有任何其他效果。因此可以移除这个调用。</p>
<p>我们尽量减少误报的情况，但在某些情况下，这条警告可能是错误的。常见的误报情况包括：</p>
<ul>
    <li>- 该方法被设计为覆写并在其他项目中产生副作用（而这些项目超出了分析的范围）。</li>
    <li>- 调用该方法是为了触发类加载，可能会产生副作用。</li>
    <li>- 调用该方法只是为了抛出一些异常。</li>
</ul>
<p>如果您认为我们的假设不正确，可以使用 @CheckReturnValue 注解来指示 SpotBugs 忽略对该方法返回值的忽略是可以接受的。 </p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="RV_RETURN_VALUE_IGNORED">
    <ShortDescription>方法忽略了返回值  Method ignores return value</ShortDescription>
    <LongDescription>在 {1} 中忽略了 {2.givenClass} 的返回值。</LongDescription>
    <Details>
<![CDATA[<p>此方法的返回值应当被检查。这种警告的一个常见原因是，在调用不可变对象的方法时，程序员误以为该方法会更新对象。例如，在以下代码片段中：</p>
<pre><code>String dateString = getHeaderField(name); dateString.trim(); </code></pre>
<p>程序员似乎认为 trim() 方法将更新由 dateString 引用的 String 对象。但由于 String 是不可变的，trim() 函数返回一个新的 String 值，并且在这里被忽略了。代码应更正为：</p>
<pre><code>String dateString = getHeaderField(name); dateString = dateString.trim(); </code></pre>]]>
    </Details>
  </BugPattern>


  <BugPattern type="RV_RETURN_VALUE_IGNORED_BAD_PRACTICE">
    <ShortDescription>方法忽略了异常返回值的处理  Method ignores exceptional return value</ShortDescription>
    <LongDescription>在{1}中忽略了{2}的异常返回值</LongDescription>
    <Details>
<![CDATA[<p>该方法返回一个值但未进行检查。应该检查返回值，因为这可以表明函数执行出现了异常或意外情况。例如，<code>File.delete()</code> 方法在无法成功删除文件时会返回 false（而不是抛出异常）。如果不检查结果，你将不会注意到方法调用通过返回非典型值来信号化异常行为。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_CHECK_COMPARETO_FOR_SPECIFIC_RETURN_VALUE">
    <ShortDescription>代码检查特定值的返回情况，这些值由compareTo方法返回。  Code checks for specific values returned by compareTo</ShortDescription>
    <LongDescription>检查{2.givenClass}的返回值是否等于{3}</LongDescription>
    <Details>
<![CDATA[这段代码调用了 `compareTo` 或 `compare` 方法，并检查返回值是否为某个特定值，如 1 或 -1。在调用这些方法时，你应该只检查结果的符号，而不是具体的非零值。虽然许多或大多数 `compareTo` 和 `compare` 方法只会返回 -1、0 或 1，但其中一些方法会返回其他值。]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_EXCEPTION_NOT_THROWN">
    <ShortDescription>异常创建后未抛出而是被丢弃  Exception created and dropped rather than thrown</ShortDescription>
    <LongDescription>在 `{1}` 中未抛出 `{2.givenClass}`。</LongDescription>
    <Details>
<![CDATA[<p>这段代码创建了一个异常（或错误）对象，但没有对其进行任何处理。例如：</p>
<pre><code>if (x < 0) {     new IllegalArgumentException("x必须是非负数"); }</code></pre>
<p>程序员大概本意是抛出这个创建的异常：</p>
<pre><code>if (x < 0) {     throw new IllegalArgumentException("x必须是非负数"); }</code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_ALWAYS_NULL">
    <ShortDescription>空指针解引用  Null pointer dereference</ShortDescription>
    <LongDescription>在 `{1}` 中对 `{2.givenClass}` 进行了空指针解引用。</LongDescription>
    <Details>
<![CDATA[<p>在这里解引用了一个空指针。当代码执行时，这将导致一个<code>NullPointerException</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_CLOSING_NULL">
    <ShortDescription>在调用 `close()` 时，传递的值始终为 `null`。  close() invoked on a value that is always null</ShortDescription>
    <LongDescription>在 `{1}` 中，`{2.givenClass}` 总是为 `null` ，因此无法关闭它。</LongDescription>
    <Details>
<![CDATA[`close()` 方法正在被调用在一个始终为 null 的值上。如果执行此语句，将会发生空指针异常。但更大的风险在于你关闭了本不应该关闭的东西。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_STORE_INTO_NONNULL_FIELD">
    <ShortDescription>将空值存储到标注了@Nonnull的字段中  Store of null value into field annotated @Nonnull</ShortDescription>
    <LongDescription>在第{1}行将空值存储到了由@Nonnull注解标注的字段{2.givenClass}中</LongDescription>
    <Details>
      <![CDATA[<p>将可能为 null 的值存储到了已被标注为@Nonnull 的字段中。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_ALWAYS_NULL_EXCEPTION">
    <ShortDescription>在异常路径中对空指针进行解引用  Null pointer dereference in method on exception path</ShortDescription>
    <LongDescription>在异常路径上，{1} 中的 {2.givenClass} 发生空指针解引用错误。</LongDescription>
    <Details>
<![CDATA[<p>在异常路径中，一个为空的指针被解引用了。这将在代码执行时导致<code>NullPointerException</code>。请注意，因为SpotBugs目前不会剪枝不可能的异常路径，所以这可能是一个假警告。</p>
<p>另外需要注意的是，SpotBugs 认为 switch 语句中的 default 情况是异常路径的一部分，因为 default 情况通常是不可行的。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE">
    <ShortDescription>参数必须为非空，但被标记为可为空。  Parameter must be non-null but is marked as nullable</ShortDescription>
    <LongDescription>`{2}` 必须是非空的，但被标记为可为空。</LongDescription>
    <Details>
<![CDATA[<p>这个参数总是以非空的方式使用，但该参数明确标注为Nullable。要么参数的使用方式有误，要么注解不正确。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_ON_SOME_PATH">
    <ShortDescription>可能的空指针脱引用  Possible null pointer dereference</ShortDescription>
    <LongDescription>在 `{1}` 中可能存在对 `{2.givenClass}` 的空指针解引用。</LongDescription>
    <Details>
<![CDATA[<p>存在一个分支语句，<em>如果执行</em>的话，会保证出现空值引用，从而在代码执行时生成<code>NullPointerException</code>。当然，问题可能是该分支或语句是不可行的，并且空指针异常永远不会被执行；决定这一点超出了SpotBugs的能力。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_ON_SOME_PATH_MIGHT_BE_INFEASIBLE">
    <ShortDescription>在可能不可达的分支上进行空指针解引用  Possible null pointer dereference on branch that might be infeasible</ShortDescription>
    <LongDescription>在{1}中，可能存在不可行分支上的{2.givenClass}的空指针解引用问题。</LongDescription>
    <Details>
<![CDATA[<p>存在一个分支语句，如果执行的话，会保证出现空值引用，从而在代码运行时生成<code>NullPointerException</code>。当然，问题可能是该分支或语句是不可行的，空指针异常实际上永远不会发生；SpotBugs 无法判断这一点。由于之前已经对该值进行了空值检测，这种情况确实有可能发生。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_ON_SOME_PATH_EXCEPTION">
    <ShortDescription>在异常路径中可能存在空指针脱引引用的情况  Possible null pointer dereference in method on exception path</ShortDescription>
    <LongDescription>在异常路径上，{1} 中对 {2.givenClass} 可能会发生空指针解引用。</LongDescription>
    <Details>
<![CDATA[<p>在某些异常控制路径上，参考值为 null，在这里对其进行了解引用操作。这可能在代码执行时导致 <code>NullPointerException</code>。请注意，由于 SpotBugs 目前不剪枝不可能的异常路径，因此这可能会是一个误报。</p>
<p>此外，请注意，SpotBugs 认为 switch 语句的默认情况也是异常路径的一部分，因为默认情况通常是不可能发生的。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE">
    <ShortDescription>调用方法的返回值可能导致空指针解引用  Possible null pointer dereference due to return value of called method</ShortDescription>
    <LongDescription>在调用方法的返回值可能导致空指针解引用{1}</LongDescription>
    <Details>
      <![CDATA[<p>从方法中返回的值在没有进行空检查的情况下被解引用，而该方法的返回值通常是应该进行空检查的。这可能在代码执行时导致<code>NullPointerException</code>。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_PARAM_DEREF_NONVIRTUAL">
    <ShortDescription>非虚拟方法调用传递了非null参数为null  Non-virtual method call passes null for non-null parameter</ShortDescription>
    <LongDescription>在 `{1}` 中，非虚拟方法调用传递了 `null` 给 `{2.givenClass}` 的非空参数。</LongDescription>
    <Details>
      <![CDATA[<p>传递了一个可能为空的值给一个非空的方法参数。要么该参数被注解为始终不应为空，要么分析表明它总是会被解引用。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS">
    <ShortDescription>方法调用为非空参数传递了null值  Method call passes null for non-null parameter</ShortDescription>
    <LongDescription>在 `{1}` 中，传递了空值给非空参数 `{2.givenClass}`。</LongDescription>
    <Details>
      <![CDATA[在一个调用点传递了一个可能为null的值，而所有已知目标方法都需要该参数非null。要么该参数被标注为始终不应为null的参数，要么分析已经表明它将总是会被引用。]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_PARAM_DEREF">
    <ShortDescription>方法调用传入了非空参数的空值  Method call passes null for non-null parameter</ShortDescription>
    <LongDescription>在{1}中为{2.givenClass}的非空参数传递了空值</LongDescription>
    <Details>
      <![CDATA[<p>该方法调用传递了一个空值给一个非空的方法参数。要么该参数被标注为总是不应该为空的参数，要么分析已经显示它总是会被解引用。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_NONNULL_PARAM_VIOLATION">
    <ShortDescription>方法调用向非空参数传递了null值  Method call passes null to a non-null parameter</ShortDescription>
    <LongDescription>在{1}中，为{2.givenClass}的非空参数传递了null。</LongDescription>
    <Details>
      <![CDATA[<p>此方法将一个空值作为参数传递给必须为非空的方法。要么该参数已被显式标记为@Nonnull，要么分析已确定该参数始终会被解引用。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_NONNULL_RETURN_VIOLATION">
    <ShortDescription>方法可能返回null，但声明为@Nonnull  Method may return null, but is declared @Nonnull</ShortDescription>
    <LongDescription>{1} 可能返回 null，但声明为 @Nonnull</LongDescription>
    <Details>
      <![CDATA[<p>该方法可能会返回一个空值，但该方法（或它所重写的超类方法）被声明为返回@Nonnull。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_CLONE_COULD_RETURN_NULL">
    <ShortDescription>克隆方法可能返回null  Clone method may return null</ShortDescription>
    <LongDescription>{1} 可能返回 null</LongDescription>
    <Details>
      <![CDATA[<p>     这个克隆方法在某些情况下似乎会返回null，但克隆操作从未被允许返回null值。如果你确信这条路径是不可达的，请抛出一个AssertionError代替。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_TOSTRING_COULD_RETURN_NULL">
    <ShortDescription>`toString` 方法可能返回 `null`  toString method may return null</ShortDescription>
    <LongDescription>{1} 可能返回 null</LongDescription>
    <Details>
      <![CDATA[<p>     这个toString方法在某些情况下似乎会返回null。规范的宽松解释可能会允许这种情况，但这很可能不是一个好主意，并且可能会导致其他代码出错。应该返回空字符串或其他合适的字符串而不是null。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_GUARANTEED_DEREF">
    <ShortDescription>空值保证会被解引用  Null value is guaranteed to be dereferenced</ShortDescription>
    <LongDescription>在 `{1}` 中，`{2.givenClass}` 可能为 `null` 并且保证会被解引用。</LongDescription>
    <Details>
          <![CDATA[<p>如果执行某个语句或分支会在该点保证一个值为null，并且除了涉及运行时异常的向前路径外，该值会被解引用，则认为存在这样的语句或分支。</p>
<p>请注意，类似于<code>if (x == null) throw new NullPointerException();</code>的检查也被视为对<x>的解引用。</p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH">
    <ShortDescription>值为null，并且在异常路径中保证会被解引用。  Value is null and guaranteed to be dereferenced on exception path</ShortDescription>
    <LongDescription>在异常路径上，{1} 中保证了对 {2.name} 为空的去引用操作是安全的。</LongDescription>
    <Details>
          <![CDATA[<p>在异常路径上有一条语句或分支，如果执行该语句可以保证在此处有一个值为null，并且该值将在后续代码中被解引用（除非涉及运行时异常的向前路径）。 </p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="SI_INSTANCE_BEFORE_FINALS_ASSIGNED">
    <ShortDescription>静态初始化器在所有静态final字段赋值之前创建实例  Static initializer creates instance before all static final fields assigned</ShortDescription>
    <LongDescription>对于{0}，静态初始化器在所有static final字段赋值之前创建了实例</LongDescription>
    <Details>
<![CDATA[该类的静态初始化器在所有静态最终字段被赋值之前创建了类的一个实例。]]>
    </Details>
  </BugPattern>
  <BugPattern type="OS_OPEN_STREAM">
    <ShortDescription>方法可能无法关闭流  Method may fail to close stream</ShortDescription>
    <LongDescription>{1} 可能未能关闭流</LongDescription>
    <Details>
<![CDATA[<p>该方法创建了一个IO流对象，但未将其分配给任何字段，也没有将其传递给其他可能关闭它的方法，或返回它，并且在方法的所有退出路径中都没有看到对该流进行关闭的操作。这可能会导致文件描述符泄漏。通常来说，在finally块中确保流被关闭是一个好习惯。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="OS_OPEN_STREAM_EXCEPTION_PATH">
    <ShortDescription>方法在异常情况下可能无法关闭流  Method may fail to close stream on exception</ShortDescription>
    <LongDescription>{1} 在异常情况下可能无法关闭流。</LongDescription>
    <Details>
<![CDATA[<p>该方法创建了一个IO流对象，但没有将其赋值给任何字段、传递给其他方法或返回它，并且在方法的所有可能异常退出路径中都没有对其进行关闭。这可能会导致文件描述符泄漏。通常来说，在finally块中确保流被关闭是一个好主意。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="PZLA_PREFER_ZERO_LENGTH_ARRAYS">
    <ShortDescription>考虑返回一个空数组而不是null  Consider returning a zero length array rather than null</ShortDescription>
    <LongDescription>{1}应该返回一个空数组而不是null？</LongDescription>
    <Details>
<![CDATA[<p>通常设计上返回长度为零的数组而不是空引用以表示没有结果（即，结果为空列表）是一个更好的选择。这样客户端的方法就不需要进行空值检查。</p>
<p>另一方面，使用空引用表示“对这个问题没有答案”可能是合适的。例如，<code>File.listFiles()</code> 如果给定的是一个不包含文件的目录，则返回一个空列表；如果给定的文件不是一个目录，则返回 null。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UCF_USELESS_CONTROL_FLOW">
    <ShortDescription>无用的控制流  Useless control flow</ShortDescription>
    <LongDescription>在 {1} 中存在多余的控制流。</LongDescription>
    <Details>
<![CDATA[<p>该方法包含一个无用的控制流语句，无论分支是否被取，控制流都会继续到同一个地方。例如，这是由于在一个 <code>if</code> 语句中有一个空语句块导致的：</p> 
<pre><code>if (argv.length == 0) {     // TODO: 处理这种情况 } </code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UCF_USELESS_CONTROL_FLOW_NEXT_LINE">
    <ShortDescription>无用的控制流跳转到下一行  Useless control flow to next line</ShortDescription>
    <LongDescription>在{1}中使用了不必要的控制流移到下一行</LongDescription>
    <Details>
<![CDATA[<p>该方法包含一个无用的控制流语句，在此语句中，无论分支是否被执行，控制流都会跟随到同一行或后续行。这通常是由不小心将空语句作为 <code>if</code> 语句的身体导致的，例如：</p>
<pre><code>if (argv.length == 1);     System.out.println("Hello, " + argv[0]); </code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE">
    <ShortDescription>之前解引用过的值的空检查  Nullcheck of value previously dereferenced</ShortDescription>
    <LongDescription>在第{4#lineNumber}行的{2#givenClass}中的空值检查，在第{1}处之前已经对该值进行了解引用。</LongDescription>
    <Details>
<![CDATA[<p>在这里检查一个值是否为 null，但该值实际上不可能为 null，因为之前对该值进行了解引用操作，如果它为 null，则在之前的解引用操作中会抛出空指针异常。本质上，这段代码与之前的解引用操作就该值是否可以为 null 存在分歧。要么这个检查是多余的，要么之前的解引用操作有误。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE">
    <ShortDescription>已知值为null的冗余空指针检查  Redundant nullcheck of value known to be null</ShortDescription>
    <LongDescription>在{1}中，{2}已知为null因此对其进行冗余的空检查</LongDescription>
    <Details>
<![CDATA[<p>该方法中对已知空值进行了冗余检查，将其与常量 null 进行比较。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE">
    <ShortDescription>已知值非空的冗余空指针检查  Redundant nullcheck of value known to be non-null</ShortDescription>
    <LongDescription>在{1}中已知{2}为非空的情况下，对其进行冗余的空检查</LongDescription>
    <Details>
<![CDATA[<p>该方法中对已知非空值进行了冗余的常量null检查。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES">
    <ShortDescription>两个空值之间的冗余比较  Redundant comparison of two null values</ShortDescription>
    <LongDescription>在 {1} 中进行了两个空值的冗余比较。</LongDescription>
    <Details>
<![CDATA[<p>该方法中包含两个已知为必定为空的引用之间的冗余比较。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE">
    <ShortDescription>对非空值进行与null的冗余比较  Redundant comparison of non-null value to null</ShortDescription>
    <LongDescription>在 {1} 中对非空值进行了与 null 的冗余比较</LongDescription>
    <Details>
<![CDATA[<p>该方法中包含一个已知非空的引用和另一个已知为空的引用。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_CHECKED_NULL_COMPARISON" deprecated="true"> <!-- deprecated in favor of two separate RCN_ patterns -->
    <ShortDescription>对之前已检查过的值进行多余的与空值的比较  Redundant comparison to null of previously checked value</ShortDescription>
    <LongDescription>在{1}中，对之前已检查过的{2}进行了多余的null比较。</LongDescription>
    <Details>
<![CDATA[<p>该方法中包含对引用值与null的冗余比较。报告了两种类型的冗余比较：</p>
<ul>
<li>被比较的两个值都肯定为null</li>
<li>一个值肯定为null，另一个值肯定不为null</li>
</ul>
<p>这种警告通常表明对已知不会为null的值进行了与null的检查。虽然进行这样的检查是不必要的，但它可能只是出于防御性编程。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UL_UNRELEASED_LOCK">
    <ShortDescription>方法不在所有路径上释放锁  Method does not release lock on all paths</ShortDescription>
    <LongDescription>在所有路径上未释放锁</LongDescription>
    <Details>
<![CDATA[<p>该方法获取了一个JSR-166（<code>java.util.concurrent</code>）锁，但在方法的所有出口路径上并未释放该锁。通常正确使用JSR-166锁的模式如下：</p>
<pre><code>Lock l = ...;  
l.lock();  
try {  
    // 执行某些操作  
} finally {  
    l.unlock();  
} </code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UL_UNRELEASED_LOCK_EXCEPTION_PATH">
    <ShortDescription>方法在所有异常路径上都没有释放锁  Method does not release lock on all exception paths</ShortDescription>
    <LongDescription>在所有异常路径上都没有释放锁。</LongDescription>
    <Details>
<![CDATA[<p>此方法获取了一个 JSR-166（`java.util.concurrent`）锁，但在方法的所有异常退出路径中并未释放该锁。通常使用 JSR-166 锁的正确方式是：</p>
<pre><code>Lock l = ...;  
l.lock();  
try {  
    // 执行一些操作  
} finally {  
    l.unlock();  
}  
</code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RC_REF_COMPARISON">
    <ShortDescription>可疑的引用比较  Suspicious reference comparison</ShortDescription>
    <LongDescription>在{1}中对{2}的引用进行了可疑比较。</LongDescription>
    <Details>
<![CDATA[<p>此方法使用 == 或 != 操作符比较两个引用值，而此类实例通常应使用 equals() 方法进行比较。有可能创建出相等但不是同一个对象的独立实例。一般不应按引用比较以下类，如 java.lang.Integer、java.lang.Float 等。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RC_REF_COMPARISON_BAD_PRACTICE">
    <ShortDescription>将常量与可疑引用进行比较  Suspicious reference comparison to constant</ShortDescription>
    <LongDescription>在{1}中将{2}引用与常量进行可疑比较</LongDescription>
    <Details>
<![CDATA[<p>此方法使用 == 或 != 操作符将引用值与常量进行比较，而通常情况下，应使用 equals() 方法来比较此类的实例。可能创建出值相等但对象不同的独立实例。一般不应按引用比较的类示例包括 java.lang.Integer、java.lang.Float 等。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN">
    <ShortDescription>布尔值的可疑引用比较  Suspicious reference comparison of Boolean values</ShortDescription>
    <LongDescription>在 {1} 中进行了布尔引用的可疑比较。</LongDescription>
    <Details>
<![CDATA[<p>此方法使用 == 或 != 运算符比较两个布尔值。通常只有两种布尔值（Boolean.TRUE 和 Boolean.FALSE），但可以使用 <code>new Boolean(b)</code> 构造函数创建其他布尔对象。最好避免使用这些对象，但如果它们确实存在，则使用 == 或 != 检查布尔对象的相等性将得到与使用 <code>.equals(...)</code> 不同的结果。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_UNRELATED_TYPES_USING_POINTER_EQUALITY">
    <ShortDescription>使用指针相等性比较不同类型的对象  Using pointer equality to compare different types</ShortDescription>
    <LongDescription>在{1}中使用指针相等性比较一个{2.givenClass}与一个{3.givenClass}。</LongDescription>
    <Details>
<![CDATA[<p>该方法使用指针相等性来比较两个看似是不同类型的引用。这种比较在运行时的结果总是为假。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_UNRELATED_TYPES">
    <ShortDescription>调用equals()方法比较不同类型的对象  Call to equals() comparing different types</ShortDescription>
    <LongDescription>在 {1} 中调用了 {3.simpleClass}.equals({2.simpleClass}) 方法</LongDescription>
    <Details>
<![CDATA[<p>该方法对不同类类型的两个引用调用了equals(Object)方法，并且分析表明在运行时它们将是不同类的对象。进一步检查将要调用的equals方法表明，要么此调用总是返回false，要么equals方法不具备对称性（这是类Object中equals合同所要求的属性之一）。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_UNRELATED_INTERFACES">
    <ShortDescription>在比较不同接口类型时调用了equals()方法  Call to equals() comparing different interface types</ShortDescription>
    <LongDescription>在 `{1}` 中调用了 `{3.simpleClass}.equals({2.simpleClass})` 方法。</LongDescription>
    <Details>
<![CDATA[<p>该方法对两个不相关接口类型的引用调用了equals(Object)方法，而这两个接口既无一方是另一方的子类型，也没有已知的具体类同时实现了这两个接口。因此，在运行时比较的对象很可能不属于同一个类（除非某些应用类未被分析，或者可以在运行时动态加载类）。根据equals()的方法合同，不同类的对象应该始终比较为不相等；因此，根据java.lang.Object.equals(Object)定义的合同，在运行时该比较的结果总是会是false。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_UNRELATED_CLASS_AND_INTERFACE">
    <ShortDescription>在使用 `equals()` 方法比较不相关的类和接口时调用。  Call to equals() comparing unrelated class and interface</ShortDescription>
    <LongDescription>在{1}中调用了{3.simpleClass}.equals({2.simpleClass})方法</LongDescription>
    <Details>
      <![CDATA[<p>该方法对一个类和一个接口的引用调用了equals(Object)方法，但该类及其非抽象子类均未实现该接口。因此，在运行时比较的对象很可能不属于同一个类（除非某些应用类没有被分析，或者可以在运行时动态加载类）。根据equals()的方法合同，不同类的对象应该始终比较为不相等；因此，按照java.lang.Object.equals(Object)定义的合同，在运行时这种比较的结果总是会是false。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="EC_NULL_ARG">
    <ShortDescription>对null调用equals方法  Call to equals(null)</ShortDescription>
    <LongDescription>在 {1} 中调用了 equals(null) 方法</LongDescription>
    <Details>
<![CDATA[<p>该方法调用了 equals(Object) 方法，并将 null 作为参数传递。根据 equals() 方法的合同，这种调用应该始终返回 <code>false</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MWN_MISMATCHED_WAIT">
    <ShortDescription>不匹配的wait()  Mismatched wait()</ShortDescription>
    <LongDescription>在{1}中发现了不匹配的wait()方法</LongDescription>
    <Details>
<![CDATA[<p>此方法在显然未持有该对象锁的情况下调用了Object.wait()。在未持有锁的情况下调用wait()将会抛出<code>IllegalMonitorStateException</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MWN_MISMATCHED_NOTIFY">
    <ShortDescription>不匹配的notify()  Mismatched notify()</ShortDescription>
    <LongDescription>在 {1} 中发现了不匹配的 notify() 方法</LongDescription>
    <Details>
<![CDATA[<p>该方法在未明显持有对象锁的情况下调用了Object.notify()或Object.notifyAll()。在未持有所需锁的情况下调用notify()或notifyAll()将会抛出<code>IllegalMonitorStateException</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_LOCAL_SELF_ASSIGNMENT_INSTEAD_OF_FIELD">
    <ShortDescription>局部变量的自我赋值而不是字段赋值  Self assignment of local rather than assignment to field</ShortDescription>
    <LongDescription>在{1}中，{2}进行了自我赋值而不是分配给字段。</LongDescription>
    <Details>
<![CDATA[<p>该方法中对一个局部变量进行了自我赋值，同时存在同名的字段，例如：</p>
<pre><code>    int foo;
    public void setFoo(int foo) {
        foo = foo;
    }
</code></pre>
<p>这种赋值是多余的。您是否应该将值分配给字段而不是局部变量？ </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_LOCAL_SELF_ASSIGNMENT">
    <ShortDescription>局部变量的自赋值  Self assignment of local variable</ShortDescription>
    <LongDescription>在 {1} 中对 {2} 进行自我赋值</LongDescription>
    <Details>
<![CDATA[<p>该方法包含对局部变量的自我赋值；例如：</p>
<pre><code>public void foo() {     int x = 3;     x = x; } </code></pre>
<p>这样的赋值是多余的，并且可能表示逻辑错误或打字错误。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_FIELD_SELF_ASSIGNMENT">
    <ShortDescription>字段的自我赋值  Self assignment of field</ShortDescription>
    <LongDescription>在 `{1}` 中，字段 `{2.givenClass}` 的自我赋值。</LongDescription>
    <Details>
<![CDATA[<p>该方法中包含对字段的自赋值；例如：</p>
<pre><code>int x;
public void foo() {
    x = x;
}</code></pre>
<p>这样的赋值是无用的，并且可能指示逻辑错误或打字错误。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_FIELD_DOUBLE_ASSIGNMENT">
    <ShortDescription>字段的双重赋值  Double assignment of field</ShortDescription>
    <LongDescription>在 {1} 中为字段 {2.givenClass} 进行了双重赋值。</LongDescription>
    <Details>
<![CDATA[<p>该方法中对字段进行了双重赋值；例如：</p>
<pre><code>int x,y;
public void foo() {
    x = x = 17;
}</code></pre>
<p>对字段进行两次赋值是多余的，可能会表明存在逻辑错误或打字错误。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_LOCAL_DOUBLE_ASSIGNMENT">
    <ShortDescription>局部变量的双重赋值  Double assignment of local variable</ShortDescription>
    <LongDescription>在 {1} 中，在 {2} 处发生了双重赋值。</LongDescription>
    <Details>
<![CDATA[<p>此方法中局部变量存在双重赋值；例如：</p>
<pre><code>public void foo() {     int x,y;     x = x = 17; }</code></pre>
<p>将相同的值两次赋给同一个变量是多余的，并且可能会指示逻辑错误或打字错误。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_FIELD_SELF_COMPUTATION">
    <ShortDescription>涉及字段的自计算（例如，x &amp; x）是无意义的  Nonsensical self computation involving a field (e.g., x &amp; x)</ShortDescription>
    <LongDescription>在{1}中，{2.givenClass}对自己进行了自我计算。</LongDescription>
    <Details>
<![CDATA[<p>此方法进行了一种无意义的计算，将一个字段与同一个字段的另一个引用进行了操作（例如 x&x 或 x-x）。由于该计算的本质，这种操作似乎没有意义，并且可能表明存在拼写错误或逻辑错误。请重新检查该计算。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_LOCAL_SELF_COMPUTATION">
    <ShortDescription>涉及变量的自运算（例如，x &amp; x）无意义  Nonsensical self computation involving a variable (e.g., x &amp; x)</ShortDescription>
    <LongDescription>在{1}中，{2}与自身进行 nonsensical 的自我计算。</LongDescription>
    <Details>
<![CDATA[<p>该方法进行了一种无意义的计算，将一个局部变量与同一个变量的另一个引用进行了操作（例如 x&x 或 x-x）。由于计算的本质，这种操作似乎没有意义，并且可能表示存在 typos 或逻辑错误。请检查该计算是否正确。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_FIELD_SELF_COMPARISON">
    <ShortDescription>将字段与自身进行比较  Self comparison of field with itself</ShortDescription>
    <LongDescription>在{1}中，{2.givenClass} 与自身进行了自我比较。</LongDescription>
    <Details>
<![CDATA[<p>该方法将一个字段与其自身进行比较，可能表明存在拼写错误或逻辑错误。请确保您比较的是正确的内容。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_LOCAL_SELF_COMPARISON">
    <ShortDescription>将自己的值与自身进行比较  Self comparison of value with itself</ShortDescription>
    <LongDescription>将{2}本身与{1}进行自我比较</LongDescription>
    <Details>
<![CDATA[<p>该方法将本地变量与其自身进行比较，可能会指示打字错误或逻辑错误。请确保您比较的是正确的内容。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT">
    <ShortDescription>在对一个 int 类型进行 Double.longBitsToDouble 调用时  Double.longBitsToDouble invoked on an int</ShortDescription>
    <LongDescription>在 `{1}` 中，`Double.longBitsToDouble` 被调用在一个 `int` 上。</LongDescription>
    <Details>
<![CDATA[<p>调用了 Double.longBitsToDouble 方法，但传递的是一个 32 位 int 值。这几乎肯定不是预期的行为，并且很可能不会得到预期的结果。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_ARGUMENTS_WRONG_ORDER">
    <ShortDescription>反转的方法参数  Reversed method arguments</ShortDescription>
    <LongDescription>在{1}中，对{2.name}的调用参数顺序错误。</LongDescription>
    <Details>
<![CDATA[<p>这个方法调用的参数顺序似乎不对。例如，调用<code>Preconditions.checkNotNull("message", message)</code>时，保留了参数顺序：要检查的值应该是第一个参数。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_RANDOM_USED_ONLY_ONCE">
    <ShortDescription>随机对象只创建并使用一次  Random object created and used only once</ShortDescription>
    <LongDescription>在{1}中，仅使用一次的随机对象创建并使用。</LongDescription>
    <Details>
<![CDATA[<p>这段代码创建了一个 java.util.Random 对象，使用它生成一个随机数，然后丢弃该 Random 对象。这会产生质量一般的随机数，并且效率低下。如果可能的话，请重写代码，使其只在一开始创建一个 Random 对象并保存起来，在每次需要新随机数时调用现有 Random 对象的方法来获取。</p>
<p>如果生成的随机数不能被猜测到非常重要，则 <em>必须</em> 不为每个随机数创建一个新的 Random；因为这些值很容易被猜中。你应该强烈考虑使用 java.security.SecureRandom（并且避免为每次需要的随机数分配一个新的 SecureRandom）。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_ABSOLUTE_VALUE_OF_RANDOM_INT">
    <ShortDescription>尝试计算有符号随机整数的绝对值是错误的  Bad attempt to compute absolute value of signed random integer</ShortDescription>
    <LongDescription>在{1}中尝试计算有符号随机整数的绝对值是不良做法。</LongDescription>
    <Details>
<![CDATA[<p>这段代码生成一个随机的带符号整数，然后计算该随机整数的绝对值。如果随机数生成器返回的是<code>Integer.MIN_VALUE</code>，那么结果也将是负数（因为<code>Math.abs(Integer.MIN_VALUE) == Integer.MIN_VALUE</code>)。同样的问题也适用于long类型的值。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_ABSOLUTE_VALUE_OF_HASHCODE">
    <ShortDescription>尝试计算带符号32位哈希码的绝对值是不良做法。  Bad attempt to compute absolute value of signed 32-bit hashcode</ShortDescription>
    <LongDescription>尝试计算带符号32位哈希码的绝对值在{1}中是不良做法。</LongDescription>
    <Details>
<![CDATA[<p>这段代码生成一个哈希码，然后计算该哈希码的绝对值。如果哈希码是 <code>Integer.MIN_VALUE</code>，那么结果也将是负数（因为 <code>Math.abs(Integer.MIN_VALUE) == Integer.MIN_VALUE</code>)。</p>
<p>大约每2^32个字符串的哈希码为 Integer.MIN_VALUE，包括 "polygenelubricants"、"GydZG_" 和 "DESIGNING WORKHOUSES"。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_REM_OF_RANDOM_INT">
    <ShortDescription>32位有符号随机整数的余数  Remainder of 32-bit signed random integer</ShortDescription>
    <LongDescription>在{1}中计算32位带符号随机整数的余数</LongDescription>
    <Details>
<![CDATA[<p>此代码生成一个随机的带符号整数，然后计算该值与另一个值取模的结果。由于随机数可以是负数，因此取余操作的结果也可能为负数。请确保这是有意为之，并强烈考虑使用 Random.nextInt(int) 方法代替。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_REM_OF_HASHCODE">
    <ShortDescription>hashCode的余数可能是负数  Remainder of hashCode could be negative</ShortDescription>
    <LongDescription>在 `{1}` 中，`hashCode` 的余数可能是负数。</LongDescription>
    <Details>
<![CDATA[<p>此代码计算哈希码，然后将该值对另一个值取余。由于哈希码可能是负数，因此取余操作的结果也可能为负。</p>
<p>假设您希望确保计算结果是非负数，则可能需要更改代码。如果知道除数是2的幂次，则可以使用位与运算符代替（即，而不是使用<xcode>x.hashCode()%n</xcode>，可以使用<xcode>x.hashCode()&(n-1)</xcode>）。这通常比计算余数更快。如果不了解除数是否为2的幂次，则可以取取余操作结果的绝对值（即，使用<xcode>Math.abs(x.hashCode()%n)</xcode>）。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE">
    <ShortDescription>非负值与负常量或零进行不良比较  Bad comparison of nonnegative value with negative constant or zero</ShortDescription>
    <LongDescription>在{1}中，非负值与{2}进行了不良比较。</LongDescription>
    <Details>
<![CDATA[<p>该代码将一个 Guaranteed 非负的值与一个负常量或零进行比较。</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="INT_BAD_COMPARISON_WITH_SIGNED_BYTE">
    <ShortDescription>对有符号字节的不良比较  Bad comparison of signed byte</ShortDescription>
    <LongDescription>在{1}中，使用了对带符号字节与{2}的不良比较。</LongDescription>
    <Details>
<![CDATA[<p>带符号的字节只能在 -128 到 127 的范围内取值。将带符号的字节 <code>b</code> 与范围之外的值进行比较是空洞的操作，并且很可能不正确。要将带符号的字节 <code>b</code> 转换为 0..255 范围内的无符号值，可以使用 <code>0xff &amp; b</code>。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="INT_BAD_COMPARISON_WITH_INT_VALUE">
    <ShortDescription>将int值与long常量进行不良比较  Bad comparison of int value with long constant</ShortDescription>
    <LongDescription>在{1}中将int与{2}进行不良比较</LongDescription>
    <Details>
<![CDATA[<p>该代码将一个 int 值与一个超出 int 可表示值范围的 long 常量进行了比较。这种比较是空洞的，并且可能是不正确的。</p>]]>
    </Details>
  </BugPattern>


  <BugPattern type="INT_VACUOUS_BIT_OPERATION">
    <ShortDescription>对整数值进行虚幻位掩码操作  Vacuous bit mask operation on integer value</ShortDescription>
    <LongDescription>在{1}中对{3}执行空操作{2}</LongDescription>
    <Details>
<![CDATA[这是一些不执行任何有用工作的整数位操作（如 and、or、exclusive or，例如 <code>v & 0xffffffff</code>)。]]>
    </Details>
  </BugPattern>
  <BugPattern type="INT_VACUOUS_COMPARISON">
    <ShortDescription>整数值的虚比较  Vacuous comparison of integer value</ShortDescription>
    <LongDescription>整数值 {1} 的空洞比较</LongDescription>
    <Details>
<![CDATA[<p>存在一个整数比较总是返回相同值的情况（例如，x <= Integer.MAX_VALUE）。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="INT_BAD_REM_BY_1">
    <ShortDescription>整数对1取余  Integer remainder modulo 1</ShortDescription>
    <LongDescription>在{1}中计算了整数的余模1。</LongDescription>
    <Details>
<![CDATA[<p>表达式 (exp % 1) 总是返回零。您是要使用 (exp & 1) 或 (exp % 2) 吗？</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_IOR_OF_SIGNED_BYTE">
    <ShortDescription>有符号字节值的位或运算  Bitwise OR of signed byte value</ShortDescription>
    <LongDescription>在{1}中计算了有符号字节值的按位或运算。</LongDescription>
    <Details>
<![CDATA[<p>加载一个字节值（例如，从字节数组中加载或由返回类型为 byte 的方法返回的值），并对其进行位或操作。在对值进行任何位运算之前，字节值会被扩展到 32 位。因此，如果 `b[0]` 包含值 `0xff`，而 `x` 初始值为 0，则代码 `((x << 8) | b[0])` 将会将 `0xff` 扩展为 `0xffffffff`，从而给出结果值 `0xffffffff`。</p>
<p>特别是下面用于将字节数组打包到 int 中的代码是错误的：</p>
<pre><code>int result = 0;
for (int i = 0; i &lt; 4; i++) {
    result = ((result << 8) | b[i]);
}
</code></pre>
<p>可以使用以下模式代替：</p>
<pre><code>int result = 0;
for (int i = 0; i &lt; 4; i++) {
    result = ((result << 8) | (b[i] &amp; 0xff));
}
</code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_ADD_OF_SIGNED_BYTE">
    <ShortDescription>有符号字节值的位运算加法  Bitwise add of signed byte value</ShortDescription>
    <LongDescription>在{1}中计算了带符号字节值的位运算加法</LongDescription>
    <Details>
<![CDATA[<p>将一个字节值和一个已知其最低8位为清零的值进行加法运算。从字节数组加载的值会在进行任何位操作前扩展到32位。因此，如果`b[0]`包含值`0xff`，而`x`最初为0，那么代码`((x << 8) + b[0])` 将会将`0xff`扩展到`0xffffffff`，从而给出结果`0xffffffff`。</p> 
<p>特别是以下用于将字节数组打包成一个int的代码是错误的：</p>
<pre><code>int result = 0;
for (int i = 0; i < 4; i++)    
    result = ((result << 8) + b[i]);
</code></pre>
<p>可以使用以下方式替代： </p>
<pre><code>int result = 0;
for (int i = 0; i < 4; i++)    
    result = ((result << 8) + (b[i] & 0xff));
</code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_AND">
    <ShortDescription>不兼容的位掩码  Incompatible bit masks</ShortDescription>
    <LongDescription>在 `(e &amp; {2} == {3})` 中使用不兼容的位掩码会在 `{1}` 中产生常量结果。</LongDescription>
    <Details>
<![CDATA[<p>该方法将表达式(e & C)与D进行比较，由于常量C和D的具体值，这种比较总是不相等的。这可能表明存在逻辑错误或打字错误。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_SIGNED_CHECK">
    <ShortDescription>检查位运算符号使用情况  Check for sign of bitwise operation</ShortDescription>
    <LongDescription>检查{1}中的位运算符号。</LongDescription>
    <Details>
<![CDATA[<p>此方法比较表达式如 <code>((event.detail &amp; SWT.SELECTED) &gt; 0)</code>。使用位算术然后与大于运算符进行比较可能会导致意想不到的结果（当然这取决于 `SWT.SELECTED` 的值）。如果 `SWT.SELECTED` 是一个负数，这是一个潜在的bug候选。即使 `SWT.SELECTED` 不是负数，使用 `!= 0` 而不是 `&gt; 0` 看起来也是良好的实践。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_SIGNED_CHECK_HIGH_BIT">
    <ShortDescription>检查位运算涉及负数的符号  Check for sign of bitwise operation involving negative number</ShortDescription>
    <LongDescription>在 {1} 中检查涉及 {2} 的位运算符号。</LongDescription>
    <Details>
<![CDATA[<p>该方法比较位运算表达式，例如 <code>((val & CONSTANT) > 0)</code>，其中 CONSTANT 是负数。使用位算术然后与大于操作符进行比较可能会导致意外结果。这种比较不太可能按预期工作。良好的做法是使用 '!= 0' 替代 '> 0'。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_AND_ZZ">
    <ShortDescription>检查是否为 ((...) &amp; 0) == 0  Check to see if ((...) &amp; 0) == 0</ShortDescription>
    <LongDescription>检查 {(...) &amp; 0} == 0 在 {1} 中是否存在</LongDescription>
    <Details>
<![CDATA[<p>该方法将表达式 <code>(e & 0)</code> 与 0 进行比较，这始终会比较相等。这可能表明存在逻辑错误或打字错误。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_IOR">
    <ShortDescription>不兼容的位掩码  Incompatible bit masks</ShortDescription>
    <LongDescription>在 `(e | 2 == 3)` 中使用不兼容的位掩码会导致在 `{1}` 中得到常量结果。</LongDescription>
    <Details>
<![CDATA[<p>该方法比较形如 <code>(e | C)</code> 的表达式与 D，由于常量 C 和 D 的特定值，这种比较总是不相等。这可能表示存在逻辑错误或打字错误。</p>
<p>通常，这个bug是因为代码想要在一个位集上执行成员测试，但使用了按位或运算符（"|") 而不是按位与运算符 ("&amp;")。</p>
<p>类似的bug也可能出现在如下的表达式中： <code>(e &amp; A | B) == C</code>，它会被解析为 <code>((e &amp; A) | B) == C</code> 而不是期望的 <code>(e &amp; (A | B)) == C</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="LI_LAZY_INIT_INSTANCE" deprecated="true"> <!-- never generated? -->
    <ShortDescription>实例字段的懒初始化不正确  Incorrect lazy initialization of instance field</ShortDescription>
    <LongDescription>在{1}中，实例字段{2}的懒初始化不正确</LongDescription>
    <Details>
<![CDATA[<p>该方法包含一个未同步的懒初始化非易失性字段。由于编译器或处理器可能会重排指令，因此当此方法能够由多个线程调用时，线程不能保证看到完全初始化的对象。你可以将字段声明为volatile以纠正这个问题。更多信息，请参见<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/">Java内存模型网站</a>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="LI_LAZY_INIT_STATIC">
    <ShortDescription>静态字段的懒初始化错误  Incorrect lazy initialization of static field</ShortDescription>
    <LongDescription>在 {1} 中静态字段 {2} 的延迟初始化不正确</LongDescription>
    <Details>
<![CDATA[<p>该方法包含一个非易失性静态字段的未同步懒初始化。由于编译器或处理器可能会重新排序指令，因此如果该方法可以被多个线程调用，则线程无法保证看到完全初始化的对象。您可以将字段声明为易失性以纠正此问题。更多信息，请参阅<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/">Java内存模型网站</a>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="LI_LAZY_INIT_UPDATE_STATIC">
    <ShortDescription>不正确的懒初始化和静态字段的更新  Incorrect lazy initialization and update of static field</ShortDescription>
    <LongDescription>在{1}中，静态字段{2}的懒初始化和更新不正确。</LongDescription>
    <Details>
<![CDATA[<p>该方法包含一个未同步的延迟初始化静态字段。一旦字段被设置，存储在其位置的对象将被进一步更新或访问。当字段被设置时，其设置对其他线程是可见的。如果在设置字段的方法中进行的进一步访问用于初始化对象，则除非有其他机制防止任何其他线程在此对象完全初始化之前访问它，否则这将是一个非常严重的多线程错误。</p>
<p>即使你觉得该方法绝不会被多个线程同时调用，也最好是在要设置的对象完全填充/初始化后再设置静态字段。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="JLM_JSR166_LOCK_MONITORENTER">
    <ShortDescription>同步操作执行在Lock上  Synchronization performed on Lock</ShortDescription>
    <LongDescription>在 {1} 中对 {2} 进行了同步操作。</LongDescription>
    <Details>
<![CDATA[<p>该方法对实现 java.util.concurrent.locks.Lock 接口的对象进行同步。这样的对象是通过使用 <code>acquire()</code>/<code>release()</code> 而不是使用 <code>synchronized (...)</code> 构造来加锁/解锁的。</p>]]>
</Details>
  </BugPattern>
  <BugPattern type="JML_JSR166_CALLING_WAIT_RATHER_THAN_AWAIT">
    <ShortDescription>使用 util.concurrent 抽象层的监控风格等待方法  Using monitor style wait methods on util.concurrent abstraction</ShortDescription>
    <LongDescription>在{1}中调用{2.name}而不是{3.name}</LongDescription>
    <Details>
<![CDATA[<p>此方法在一个同时提供了<code>await()</code>、<code>signal()</code>、<code>signalAll()</code>方法的对象上调用了<code>wait()</code>、<code>notify()</code>或<code>notifyAll()</code>。这很可能不是你想要的效果，即使你需要这样做，你也应该考虑改变你的设计，因为其他开发者会发现这一点极其 confusing。</p>]]>
</Details>
  </BugPattern>
  <BugPattern type="JLM_JSR166_UTILCONCURRENT_MONITORENTER">
    <ShortDescription>同步操作执行于util.concurrent 实例上  Synchronization performed on util.concurrent instance</ShortDescription>
    <LongDescription>在 {1} 中对 {2} 进行了同步处理</LongDescription>
    <Details>
<![CDATA[<p>该方法对一个来自 java.util.concurrent 包（或其子类）的类实例进行同步。这些类的实例具有独立于 Java 关键字 <code>synchronized</code> 提供的同步机制的并发控制机制。例如，对一个 <code>AtomicBoolean</code> 进行同步并不会阻止其他线程修改该 <code>AtomicBoolean</code>。</p>
<p>这样的代码可能是正确的，但应仔细审查并进行文档记录，并且可能会使以后维护代码的人感到困惑。</p>]]>
</Details>
  </BugPattern>
  <BugPattern type="UPM_UNCALLED_PRIVATE_METHOD">
    <ShortDescription>私有方法从未被调用  Private method is never called</ShortDescription>
    <LongDescription>私有方法 `{1}` 从未被调用</LongDescription>
    <Details>
<![CDATA[<p>这个私有方法从不被调用。虽然有可能通过反射来调用该方法，但更可能的是该方法从未使用过，并应该被移除。</p>]]>
</Details>
  </BugPattern>
  <BugPattern type="UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS">
    <ShortDescription>在匿名类中定义了无法调用的方法  Uncallable method defined in anonymous class</ShortDescription>
    <LongDescription>匿名类中定义了无法调用的方法 {1}</LongDescription>
    <Details>
<![CDATA[<p>这个匿名类定义了一个未直接调用的方法，并且没有覆盖超类中的方法。由于其他类不能直接调用在匿名类中声明的方法，似乎这个方法是不可调用的。该方法可能是死代码，但也有可能该方法原本意图覆盖超类中声明的方法，但由于拼写错误或其他错误，实际并未覆盖预期的方法。</p>]]>
</Details>
  </BugPattern>
  <BugPattern type="ODR_OPEN_DATABASE_RESOURCE">
    <ShortDescription>方法可能无法关闭数据库资源  Method may fail to close database resource</ShortDescription>
    <LongDescription>{1} 可能无法关闭 {2.excludingPackage}</LongDescription>
    <Details>
<![CDATA[<p>该方法创建了一个数据库资源（例如数据库连接或行集），但未将其分配给任何字段、传递给其他方法或返回它，并且在方法的所有路径结束时都没有关闭对象。如果在方法的所有路径结束时未正确关闭数据库资源，可能会导致性能不佳，并可能导致应用程序与数据库通信出现问题。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH">
    <ShortDescription>方法在异常情况下可能无法关闭数据库资源。  Method may fail to close database resource on exception</ShortDescription>
    <LongDescription>在异常情况下，可能无法关闭数据库资源。</LongDescription>
    <Details>
<![CDATA[<p>该方法创建了一个数据库资源（例如，数据库连接或行集），但并未将其分配给任何字段、传递给其他方法或返回它，并且在所有从方法退出的异常路径中都没有出现关闭对象的情况。如果不通过所有路径正确关闭数据库资源，可能会导致性能不佳，并可能导致应用程序与数据库通信出现问题。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SBSC_USE_STRINGBUFFER_CONCATENATION">
    <ShortDescription>方法在循环中使用+号拼接字符串  Method concatenates strings using + in a loop</ShortDescription>
    <LongDescription>{1} 在循环中使用 + 连接字符串</LongDescription>
    <Details>
<![CDATA[<p>该方法似乎是在循环中通过连接操作构建一个String。在每次迭代中，字符串会被转换为StringBuilder（或StringBuffer），追加内容后再转换回String。这会导致性能下降，因为随着字符串的增长，在每一届都会进行重新复制，其代价可能会是迭代次数的平方。</p>
<p>通过显式使用StringBuilder（Java 5中的情况为StringBuffer）可以获得更好的性能。</p>
<p>例如：</p>
<pre><code>// 这种方法不好
String s = "";
for (int i = 0; i < field.length; ++i) {
    s = s + field[i];
}

// 这种方法更好
StringBuffer buf = new StringBuffer();
for (int i = 0; i < field.length; ++i) {
    buf.append(field[i]);
}
String s = buf.toString();
</code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIL_PREPARE_STATEMENT_IN_LOOP">
    <ShortDescription>在循环中调用prepareStatement方法  Method calls prepareStatement in a loop</ShortDescription>
    <LongDescription>{1} 在循环中使用常量参数调用prepareStatement方法</LongDescription>
    <Details>
<![CDATA[<p>该代码在循环中调用了 Connection.prepareStatement 方法并传入了常量参数。如果PreparedStatement需要多次执行，就没有必要在每次循环迭代时都重新创建它。请将此调用移到循环之外。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIL_ELEMENTS_GET_LENGTH_IN_LOOP">
    <ShortDescription>在循环中调用了NodeList.getLength()方法  NodeList.getLength() called in a loop</ShortDescription>
    <LongDescription>{1} 循环调用 NodeList 的 getLength() 方法来获取 getElementsByTagName 返回的值。</LongDescription>
    <Details>
<![CDATA[<p>该方法在循环中调用了NodeList.getLength()，而NodeList是通过getElementsByTagName获取的。NodeList没有存储其长度，而是每次都在不太优化的方式下重新计算它。可以在循环前将长度存到一个变量中考虑一下。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIL_PATTERN_COMPILE_IN_LOOP">
    <ShortDescription>在循环中调用 `Pattern.compile` 方法  Method calls Pattern.compile in a loop</ShortDescription>
    <LongDescription>{1} 在循环中使用常量参数调用 Pattern.compile 方法</LongDescription>
    <Details>
<![CDATA[<p>该方法在循环中调用 Pattern.compile，并传递常量参数。如果 Pattern 在多次使用，请勿在每次循环迭代时都进行编译。可以将此调用移出循环，甚至放入静态最终字段中。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIL_PATTERN_COMPILE_IN_LOOP_INDIRECT">
    <ShortDescription>方法在循环中编译正则表达式  Method compiles the regular expression in a loop</ShortDescription>
    <LongDescription>{1} 在循环中编译正则表达式</LongDescription>
    <Details>
<![CDATA[<p>该方法在循环中创建了相同的正则表达式，因此会在每次迭代时进行编译。将使用Pattern.compile在循环外部预编译该正则表达式会更加高效。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIO_INEFFICIENT_INDEX_OF">
    <ShortDescription>对 `String.indexOf(String)` 的使用不够高效  Inefficient use of String.indexOf(String)</ShortDescription>
    <LongDescription>{1} 使用 `String.indexOf(String)` 代替 `String.indexOf(int)`</LongDescription>
    <Details>
<![CDATA[<p>这段代码将长度为1的常量字符串传递给String.indexOf()方法。使用整数版本的String.indexOf()更为高效，例如调用<code>myString.indexOf('.')</code>而不是<code>myString.indexOf(".')</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIO_INEFFICIENT_LAST_INDEX_OF">
    <ShortDescription>对 `String.lastIndexOf(String)` 的无效使用  Inefficient use of String.lastIndexOf(String)</ShortDescription>
    <LongDescription>{1} 使用了 `String.lastIndexOf(String)` 而不是 `String.lastIndexOf(int)`。</LongDescription>
    <Details>
<![CDATA[<p>这段代码将长度为1的常量字符串传递给String.lastIndexOf()方法。使用整数版本的String.lastIndexOf()更加高效，例如调用<code>myString.lastIndexOf('.')</code>而不是<code>myString.lastIndexOf(".')</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ITA_INEFFICIENT_TO_ARRAY">
    <ShortDescription>方法使用了带零长度数组参数的 `toArray()` 方法  Method uses toArray() with zero-length array argument</ShortDescription>
    <LongDescription>{1} 使用了 `Collection.toArray()` 并带有一个空数组作为参数。</LongDescription>
    <Details>
<![CDATA[<p>此方法使用集合派生类的 `toArray()` 方法，并传递一个零长度原型数组参数。更高效的做法是使用 <code>myCollection.toArray(new Foo[myCollection.size()])</code>。如果传入的数组大小足以容纳集合中的所有元素，那么该数组会被直接填充并返回，从而避免通过反射创建第二个数组来作为结果返回。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD">
    <ShortDescription>在 `run` 方法中的 JUnit 断言将不会被 JUnit 检测到。  JUnit assertion in run method will not be noticed by JUnit</ShortDescription>
    <LongDescription>在 `{1}` 中的 JUnit 断言不会被 JUnit 检测到。</LongDescription>
    <Details>
<![CDATA[<p>在run方法中执行了一个JUnit断言。失败的JUnit断言仅仅会导致异常被抛出。因此，如果这个异常发生在调用测试方法的线程以外的线程中，该异常将会终止相关线程但不会导致测试失败。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IJU_SETUP_NO_SUPER">
    <ShortDescription>testCase定义了setUp方法，但没有调用super.setUp()方法。  TestCase defines setUp that doesn't call super.setUp()</ShortDescription>
    <LongDescription>测试用例 {0} 定义了 `setUp` 但没有调用 `super.setUp()` 方法。</LongDescription>
    <Details>
<![CDATA[<p>Class是一个JUnit TestCase，并实现了setUp方法。但是，setUp方法没有调用super.setUp()。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IJU_TEARDOWN_NO_SUPER">
    <ShortDescription>测试用例定义了tearDown方法，但没有调用super.tearDown()。  TestCase defines tearDown that doesn't call super.tearDown()</ShortDescription>
    <LongDescription>测试用例 {0} 定义了 `tearDown`，但没有调用 `super.tearDown()`。</LongDescription>
    <Details>
<![CDATA[<p>Class是一个JUnit测试案例，并实现了tearDown方法。但是，tearDown方法没有调用super.tearDown()。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IJU_SUITE_NOT_STATIC">
    <ShortDescription>testCase 实现了一个非静态套件方法  TestCase implements a non-static suite method</ShortDescription>
    <LongDescription>测试用例 {0} 实现了一个非静态的套件方法</LongDescription>
    <Details>
<![CDATA[<p>Class是一个JUnit测试案例，并实现了suite()方法。但suite方法没有被声明为静态。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IJU_BAD_SUITE_METHOD">
    <ShortDescription>testCase 声明了一个不良的套件方法  TestCase declares a bad suite method</ShortDescription>
    <LongDescription>在{0}中套件方法的声明有误</LongDescription>
    <Details>
<![CDATA[<p>Class是一个JUnit TestCase，并定义了一个suite()方法。但是，suite方法需要声明为以下之一：</p>
<pre><code>public static junit.framework.Test suite()
</code></pre>
<p>或者</p>
<pre><code>public static junit.framework.TestSuite suite()
</code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IJU_NO_TESTS">
    <ShortDescription>.TestCase中没有任何测试用例  TestCase has no tests</ShortDescription>
    <LongDescription>测试用例 {0} 没有测试项</LongDescription>
    <Details>
<![CDATA[<p>Class是一个JUnit TestCase，但没有实现任何测试方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BOA_BADLY_OVERRIDDEN_ADAPTER">
    <ShortDescription>类错误地覆写了超类适配器中实现的方法  Class overrides a method implemented in super class Adapter wrongly</ShortDescription>
    <LongDescription>类 {0} 在继承自适配器（Adapter）类的方法 {1} 实现上存在问题。</LongDescription>
    <Details>
<![CDATA[<p>该方法重写了父类中的一个方法，而该父类是一个适配器，实现了 java.awt.event 或 javax.swing.event 包中定义的监听器接口。因此，当事件发生时，此方法将不会被调用。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BRSA_BAD_RESULTSET_ACCESS" deprecated="true"> <!-- deprecated in favor of SQL_BAD_RESULTSET_ACCESS -->
    <ShortDescription>方法尝试使用索引 0 访问结果集字段。  Method attempts to access a result set field with index 0</ShortDescription>
    <LongDescription>尝试使用索引0访问结果集字段</LongDescription>
    <Details>
<![CDATA[<p>在结果集上调用了getXXX或updateXXX方法，并且字段索引为0。由于结果集的字段从索引1开始，这始终是一个错误。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SQL_BAD_RESULTSET_ACCESS">
    <ShortDescription>方法尝试使用索引 0 访问结果集字段。  Method attempts to access a result set field with index 0</ShortDescription>
    <LongDescription>尝试使用索引 0 访问结果集字段。</LongDescription>
    <Details>
<![CDATA[<p>在调用结果集的getXXX或updateXXX方法时，字段索引为0。由于结果集中的字段从索引1开始，因此总是错误的。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SQL_BAD_PREPARED_STATEMENT_ACCESS">
    <ShortDescription>方法尝试使用索引 0 访问预处理语句参数。  Method attempts to access a prepared statement parameter with index 0</ShortDescription>
    <LongDescription>尝试使用索引 0 访问预编译语句参数。</LongDescription>
    <Details>
<![CDATA[<p>在调用预处理语句的setXXX方法时，参数索引为0。由于参数索引从1开始，这始终是一个错误。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIO_SUPERFLUOUS_INSTANCEOF">
    <ShortDescription>使用 `instanceof` 运算符进行的不必要的类型检查  Unnecessary type check done using instanceof operator</ShortDescription>
    <LongDescription>{1} 使用 `instanceof` 运算符进行不必要的类型检查，当可以通过静态分析确定时</LongDescription>
    <Details>
<![CDATA[<p>使用 instanceof 运算符进行类型检查，在确定对象是否为所需类型的静态情况下。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BAC_BAD_APPLET_CONSTRUCTOR">
    <ShortDescription>不良的Applet构造函数依赖于未初始化的AppletStub  Bad Applet Constructor relies on uninitialized AppletStub</ShortDescription>
    <LongDescription>不良的Applet构造函数依赖于未初始化的AppletStub</LongDescription>
    <Details>
<![CDATA[<p>这个构造函数调用了依赖于 AppletStub 的父 Applet 中的方法。由于 AppletStub 只有在该 Applet 的 init() 方法被调用后才会初始化，因此这些方法将无法正确执行。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_ARRAY_AND_NONARRAY">
    <ShortDescription>使用 `equals()` 来比较数组和非数组类型。  equals() used to compare array and nonarray</ShortDescription>
    <LongDescription>在{1}中调用了{3.simpleClass}.equals({2.simpleClass})方法。</LongDescription>
    <Details>
<![CDATA[<p>此方法使用 .equals(Object o) 来比较一个数组和一个看起来不是数组的引用。如果被比较的对象类型不同，它们肯定会不相等，并且这种比较几乎肯定是一个错误。即使两者都是数组，数组的 equals() 方法只能确定两个数组是否是同一个对象。要比较数组的内容，请使用 java.util.Arrays.equals(Object[], Object[])。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_BAD_ARRAY_COMPARE">
    <ShortDescription>对数组调用equals()方法，这等同于使用==进行比较。  Invocation of equals() on an array, which is equivalent to ==</ShortDescription>
    <LongDescription>在{1}中，使用.equals来比较两个{2.simpleClass}的实例（相当于==）。</LongDescription>
    <Details>
<![CDATA[<p>此方法调用了数组的 .equals(Object o) 方法。由于数组未重写 Object 的 equals 方法，因此调用数组的 equals 方法相当于比较它们的地址。要比较数组的内容，请使用 <code>java.util.Arrays.equals(Object[], Object[])</code>。如果要比较数组的地址，则明确地使用 <code>==</code> 检查指针是否相等会更清楚。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_INCOMPATIBLE_ARRAY_COMPARE">
    <ShortDescription>使用了 `equals(...)` 来比较不兼容的数组。  equals(...) used to compare incompatible arrays</ShortDescription>
    <LongDescription>在第1行使用equals比较一个{2.simpleClass}和一个{3.simpleClass}</LongDescription>
    <Details>
<![CDATA[<p>该方法使用 .equals(Object o) 来比较两个数组，但这两个数组的类型不兼容（例如 String[] 和 StringBuffer[]，或者 String[] 和 int[]）。它们永远不会相等。此外，当使用 equals(...) 方法来比较数组时，它只会检查这两个数组是否是同一个数组，并忽略数组的内容。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="STI_INTERRUPTED_ON_CURRENTTHREAD">
    <ShortDescription>不必要的使用currentThread()调用，应使用interrupted()方法。  Unneeded use of currentThread() call, to call interrupted()</ShortDescription>
    <LongDescription>{1} 仅仅为了调用 `interrupted()` 而调用了不必要的 `currentThread()`。</LongDescription>
    <Details>
<![CDATA[<p>该方法调用了<code>Thread.currentThread()</code>，仅仅为了调用<code>interrupted()</code>方法。由于<code>interrupted()</code>是一个静态方法，直接使用<code>Thread.interrupted()</code>更加简单和清晰。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="STI_INTERRUPTED_ON_UNKNOWNTHREAD">
    <ShortDescription>在线程实例上调用静态的 `Thread.interrupted()` 方法  Static Thread.interrupted() method invoked on thread instance</ShortDescription>
    <LongDescription>{1} 在线程实例上调用静态的 `Thread.interrupted()` 方法</LongDescription>
    <Details>
<![CDATA[<p>该方法调用了Thread对象上的Thread.interrupted()方法，而该Thread对象似乎不是当前线程。由于interrupted()方法是静态的，因此实际上将调用的是一个不同的对象而不是作者想要调用的对象。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN">
    <ShortDescription>参数在方法入口时是无效的，但被覆盖了。  A parameter is dead upon entry to a method but overwritten</ShortDescription>
    <LongDescription>参数 {2} 在进入 {1} 时已死亡，但被覆盖了。</LongDescription>
    <Details>
<![CDATA[<p>此参数的初始值将被忽略，并在此处被覆盖。这通常表明有人错误地认为对参数的写操作会传递回调用者。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DLS_DEAD_LOCAL_STORE_SHADOWS_FIELD">
    <ShortDescription>遮盖字段的局部变量的死.store  Dead store to local variable that shadows field</ShortDescription>
    <LongDescription>在{1}中，对名为相同的字段进行了死存储操作而不是使用该字段。</LongDescription>
    <Details>
<![CDATA[<p>这条指令给局部变量赋值，但该值并未在后续指令中被读取或使用。通常这表示存在错误，因为计算出的值从未被使用过。存在一个同名的字段。你是不是应该把值赋给那个变量？ </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DLS_DEAD_LOCAL_STORE">
    <ShortDescription>对局部变量进行死存储检查  Dead store to local variable</ShortDescription>
    <LongDescription>在{1}中对{2}进行了死存储</LongDescription>
    <Details>
<![CDATA[<p>这条指令给局部变量赋值，但该值在后续的指令中并未被读取或使用。通常这表示存在错误，因为计算出的值从未被利用。</p>
<p>请注意，Sun的javac编译器往往会为final局部变量生成无效存储。由于SpotBugs是一个基于字节码的工具，因此没有简单的方法来消除这些误报。</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="DLS_DEAD_LOCAL_STORE_IN_RETURN">
    <ShortDescription>返回语句中的无用赋值  Useless assignment in return statement</ShortDescription>
    <LongDescription>从 `{1}` 返回中的无用赋值</LongDescription>
    <Details>
      <![CDATA[<p>该语句在一个返回语句中给局部变量赋值，但这个赋值并没有效果。请确认该语句是否正确。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DLS_DEAD_LOCAL_INCREMENT_IN_RETURN">
    <ShortDescription>在返回语句中不必要的递增  Useless increment in return statement</ShortDescription>
    <LongDescription>从{1}返回时的无用递增</LongDescription>
    <Details>
      <![CDATA[<p>该语句包含返回值如<code>return x++;</code> / <code>return x--;</code>。后缀增量/ decrement不会影响表达式的值，因此这个增量/ decrement没有效果。请确认该语句是否正确。</p>]]>
    </Details>
  </BugPattern>



  <BugPattern type="DLS_DEAD_STORE_OF_CLASS_LITERAL">
    <ShortDescription>类字面量的死存储  Dead store of class literal</ShortDescription>
    <LongDescription>在 {1} 中检测到对 {3}.class 的死存储。</LongDescription>
    <Details>
<![CDATA[<p>该指令将一个类字面量分配给一个变量，但从未使用它。在Java 1.4和Java 5中此行为有所不同。<a href="http://www.oracle.com/technetwork/java/javase/compatibility-137462.html#literal">在Java 1.4及更早版本中，对 `Foo.class` 的引用会强制执行 `Foo` 的静态初始化器（如果尚未执行的话）。而在Java 5及其之后的版本中，则不会这样做。</a></p>
<p>有关更多细节和示例以及如何在Java 5+中强制类初始化，请参阅Oracle的<a href="http://www.oracle.com/technetwork/java/javase/compatibility-137462.html#literal">Java SE兼容性文章</a>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DLS_DEAD_LOCAL_STORE_OF_NULL">
    <ShortDescription>对局部变量进行null的死存储  Dead store of null to local variable</ShortDescription>
    <LongDescription>在{1}中对null进行了死存储到{2}</LongDescription>
    <Details>
<![CDATA[<p>代码将 null 存储到一个局部变量中，且存储的值并未被读取。这种存储可能曾用于辅助垃圾回收器工作，但自 Java SE 6.0 起，这已不再需要或有用。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MF_METHOD_MASKS_FIELD">
    <ShortDescription>方法定义了变量遮掩了字段  Method defines a variable that obscures a field</ShortDescription>
    <LongDescription>{1} 定义了一个变量，遮蔽了字段 {2.givenClass}</LongDescription>
    <Details>
<![CDATA[<p>此方法定义了一个局部变量，其名称与该类或超类中的一个字段同名。这可能会导致方法从字段中读取未初始化的值、使字段保持未初始化状态，或者两者兼有。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MF_CLASS_MASKS_FIELD">
    <ShortDescription>类定义的字段遮掩了超类的字段  Class defines field that masks a superclass field</ShortDescription>
    <LongDescription>字段 `{1.givenClass}` � contrasted 字段在其超类 `{2.class}` 中同名存在</LongDescription>
    <Details>
<![CDATA[<p>该类定义了一个字段，其名称与超类中的可见实例字段同名。这可能会造成混淆，并且如果方法更新或访问这些字段时本应使用另一个字段，则可能存在错误。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="WMI_WRONG_MAP_ITERATOR">
    <ShortDescription>使用键集迭代器代替条目集迭代器导致效率低下  Inefficient use of keySet iterator instead of entrySet iterator</ShortDescription>
    <LongDescription>{1} 不-efficient 使用了 keySet 迭代器而不是 entrySet 迭代器。</LongDescription>
    <Details>
<![CDATA[<p>此方法使用从 keySet 迭代器获取的键来访问 Map 元素的值。直接在 map 的 entrySet 上使用迭代器进行遍历更为高效，可以避免执行 Map.get(key) 查找操作。</p>]]>
        </Details>
  </BugPattern>
  <BugPattern type="ISC_INSTANTIATE_STATIC_CLASS">
    <ShortDescription>仅提供静态方法的类不必要的实例化  Needless instantiation of class that only supplies static methods</ShortDescription>
    <LongDescription>{1} 无需实例化的类仅提供了静态方法</LongDescription>
    <Details>
<![CDATA[<p>该类分配了一个基于只提供静态方法的类的对象。不需要创建这个对象，可以直接通过类名作为限定符访问其静态方法。</p>]]>
        </Details>
  </BugPattern>
  <BugPattern type="REC_CATCH_EXCEPTION">
    <ShortDescription>当未抛出异常时捕获异常  Exception is caught when Exception is not thrown</ShortDescription>
    <LongDescription>在{1}中捕获了异常，但未抛出异常</LongDescription>
    <Details>
  <![CDATA[<p>该方法使用了 try-catch 块来捕获 Exception 对象，但 try 块内部没有抛出 Exception，并且没有显式捕获 RuntimeException。用 try { ... } catch (Exception e) { something } 来简短地捕获多种类型的异常是一种常见的错误模式，因为这种结构也会意外地捕获到 RuntimeException，从而掩盖潜在的错误。</p>
<p>更好的做法是要么明确捕获实际抛出的具体异常，要么显式捕获 RuntimeException 并重新抛出它，然后捕获所有非-RuntimeException 异常，如下所示：</p>
<pre><code>try {     ... } catch (RuntimeException e) {     throw e; } catch (Exception e) {     ... 处理所有非运行时异常 ... } </code></pre>]]>
     </Details>
  </BugPattern>
  <BugPattern type="DCN_NULLPOINTER_EXCEPTION">
    <ShortDescription>空指针异常捕获  NullPointerException caught</ShortDescription>
    <LongDescription>不要像{1}那样捕获NullPointerException</LongDescription>
    <Details>
   <![CDATA[根据SEI Cert规则<https://wiki.sei.cmu.edu/confluence/display/java/ERR08-J.+Do+not+catch+NullPointerException+or+any+of+its+ancestors>，不应该捕获NullPointerException。处理NullPointerException被视为比空值检查劣质的替代方案。 

以下是非合规代码示例，它捕获NullPointerException以检查传入参数是否为null：

```java
boolean hasSpace(String m) {   
    try {     
        String ms[] = m.split(" ");     
        return names.length != 1;   
    } catch (NullPointerException e) {     
        return false;   
    } 
}
```

合规的解决方案应使用空值检查，如下所示：

```java
boolean hasSpace(String m) {    
    if (m == null) return false;    
    String ms[] = m.split(" ");    
    return names.length != 1; 
}
```]]>
     </Details>
  </BugPattern>
  <BugPattern type="FE_TEST_IF_EQUAL_TO_NOT_A_NUMBER">
    <ShortDescription>对NaN进行相等性测试的 doomed 测试  Doomed test for equality to NaN</ShortDescription>
    <LongDescription>在{1}中对NaN进行相等性测试</LongDescription>
    <Details>
   <![CDATA[<p>这段代码检查一个浮点值是否等于特殊的非数字值（例如，<code>if (x == Double.NaN)</code>)。但由于非数字值 `<code>NaN</code>` 的特殊语义，没有任何值等于 `NaN`，包括 `NaN` 本身。因此，<code>x == Double.NaN</code> 总是评估为 false。要检查 `<code>x</code>` 中包含的值是否为特殊的非数字值，应使用 <code>Double.isNaN(x)</code>(如果 `<code>x</code>` 是单精度浮点数，则使用 <code>Float.isNaN(x)</code>)。</p>]]>
     </Details>
  </BugPattern>
  <BugPattern type="FE_FLOATING_POINT_EQUALITY">
    <ShortDescription>测试浮点数是否相等  Test for floating point equality</ShortDescription>
    <LongDescription>在{1}中测试浮点数相等性</LongDescription>
    <Details>
   <![CDATA[<p>     这个操作用于比较两个浮点值是否相等。由于浮点运算可能会涉及舍入，因此计算得到的 float 和 double 值可能不够准确。对于必须精确的值，例如货币值，可以考虑使用固定精度类型，如 BigDecimal。对于不需要精确的值，可以考虑在某个范围内进行相等性比较，例如：<code>if (Math.abs(x - y) < .0000001)</code>。参见 Java 语言规范，第 4.2.4 节。</p>]]>
     </Details>
  </BugPattern>
  <BugPattern type="UM_UNNECESSARY_MATH">
    <ShortDescription>在常量值上调用静态Math类的方法  Method calls static Math class method on a constant value</ShortDescription>
    <LongDescription>方法调用静态Math类的常量值方法</LongDescription>
    <Details>
<![CDATA[<p>该方法在一个常量值上使用了来自 java.lang.Math 的静态方法。在这种情况下，该方法的结果可以静态确定，并且直接使用常量可能会更快且有时更准确。检测到的方法如下：</p>
<table>
<tr>
    <th>方法</th>
    <th>参数</th>
</tr>
<tr>
    <td>abs</td>
    <td>-任何-</td>
</tr>
<tr>
    <td>acos</td>
    <td>0.0 或 1.0</td>
</tr>
<tr>
    <td>asin</td>
    <td>0.0 或 1.0</td>
</tr>
<tr>
    <td>atan</td>
    <td>0.0 或 1.0</td>
</tr>
<tr>
    <td>atan2</td>
    <td>0.0</td>
</tr>
<tr>
    <td>cbrt</td>
    <td>0.0 或 1.0</td>
</tr>
<tr>
    <td>ceil</td>
    <td>-任何-</td>
</tr>
<tr>
    <td>cos</td>
    <td>0.0</td>
</tr>
<tr>
    <td>cosh</td>
    <td>0.0</td>
</tr>
<tr>
    <td>exp</td>
    <td>0.0 或 1.0</td>
</tr>
<tr>
    <td>expm1</td>
    <td>0.0</td>
</tr>
<tr>
    <td>floor</td>
    <td>-任何-</td>
</tr>
<tr>
    <td>log</td>
    <td>0.0 或 1.0</td>
</tr>
<tr>
    <td>log10</td>
    <td>0.0 或 1.0</td>
</tr>
<tr>
    <td>rint</td>
    <td>-任何-</td>
</tr>
<tr>
    <td>round</td>
    <td>-任何-</td>
</tr>
<tr>
    <td>sin</td>
    <td>0.0</td>
</tr>
<tr>
    <td>sinh</td>
    <td>0.0</td>
</tr>
<tr>
    <td>sqrt</td>
    <td>0.0 或 1.0</td>
</tr>
<tr>
    <td>tan</td>
    <td>0.0</td>
</tr>
<tr>
    <td>tanh</td>
    <td>0.0</td>
</tr>
<tr>
    <td>toDegrees</td>
    <td>0.0 或 1.0</td>
</tr>
<tr>
    <td>toRadians</td>
    <td>0.0</td>
</tr>
</table>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CD_CIRCULAR_DEPENDENCY">
    <ShortDescription>测试类之间的循环依赖关系  Test for circular dependencies among classes</ShortDescription>
    <LongDescription>类 {0} 存在与其他类的循环依赖关系</LongDescription>
    <Details>
   <![CDATA[<p>     这个类与其他类存在循环依赖关系。这使得构建这些类变得困难，因为每个类都依赖于其他类来正确构建。考虑使用接口来打破这种硬性依赖。     </p>]]>
     </Details>
  </BugPattern>
  <BugPattern type="RI_REDUNDANT_INTERFACES">
    <ShortDescription>类实现了超类相同的接口  Class implements same interface as superclass</ShortDescription>
    <LongDescription>类 {0} 实现了与超类相同的接口</LongDescription>
    <Details>
   <![CDATA[<p>    该类声明实现了由超类也已实现的接口。由于一旦超类实现了某个接口，所有子类默认也会继承此接口的实现在大多数情况下这是冗余的。这可能表明自创建此类以来继承层次结构发生了变化，并且应考虑接口实现的所有权问题。</p>]]>
     </Details>
  </BugPattern>
  <BugPattern type="MTIA_SUSPECT_STRUTS_INSTANCE_FIELD">
    <ShortDescription>该类扩展自Struts Action类，并使用了实例变量。  Class extends Struts Action class and uses instance variables</ShortDescription>
    <LongDescription>类 {0} 扩展了 Struts 动作类，并使用了实例变量</LongDescription>
    <Details>
   <![CDATA[<p>     这个类从一个 Struts 行动类继承，并使用了一个实例成员变量。由于 Struts 框架只会创建一个 Struts 行动类的实例，并以多线程方式使用，这种模式被高度 discouraged 并且很可能存在问题。请考虑仅使用方法本地变量。只有在监控之外写入的实例字段才会被报告。     </p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="MTIA_SUSPECT_SERVLET_INSTANCE_FIELD">
    <ShortDescription>类扩展了Servlet类并且使用了实例变量  Class extends Servlet class and uses instance variables</ShortDescription>
    <LongDescription>类 {0} 扩展了 Servlet 类并且使用了实例变量</LongDescription>
    <Details>
   <![CDATA[<p>     这个类从Servlet类继承，并使用了一个实例成员变量。由于J2EE框架只会创建一个Servlet类的实例，并以多线程方式使用，因此这种模式被高度 discourage 并且很可能存在问题。考虑仅使用方法本地变量。     </p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="PS_PUBLIC_SEMAPHORES">
    <ShortDescription>类在其公共接口中暴露了同步和信号量机制。  Class exposes synchronization and semaphores in its public interface</ShortDescription>
    <LongDescription>类 {0} 在其公共接口中暴露了同步和信号量功能</LongDescription>
    <Details>
   <![CDATA[<p>     这个类使用了同步，并且在该类（this引用）上使用了wait()、notify()或notifyAll()。客户端类如果使用此类，还可能将该类的一个实例用作同步对象。由于两个类共用了同一个对象进行同步，因此多线程正确性值得怀疑。你不应该对公共引用进行同步或调用信号量方法。可以考虑使用一个内部的私有成员变量来控制同步。</p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="ICAST_INTEGER_MULTIPLY_CAST_TO_LONG">
    <ShortDescription>整数相乘后的结果强制转换为long类型  Result of integer multiplication cast to long</ShortDescription>
    <LongDescription>在{1}中，整数相乘的结果被强制转换为long类型。</LongDescription>
    <Details>
<![CDATA[<p>这段代码执行整数相乘，然后将结果转换为长整型，例如：</p>
<pre><code>long convertDaysToMilliseconds(int days) { return 1000*3600*24*days; }</code></pre>
<p>如果使用长整型算术进行乘法运算，可以避免结果溢出。例如，你可以将上述代码修复为：</p>
<pre><code>long convertDaysToMilliseconds(int days) { return 1000L*3600*24*days; }</code></pre>
<p>或者</p>
<pre><code>static final long MILLISECONDS_PER_DAY = 24L*3600*1000;
long convertDaysToMilliseconds(int days) { return days * MILLISECONDS_PER_DAY; }</code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_INT_2_LONG_AS_INSTANT">
    <ShortDescription>将整数值转换为长整型并用作绝对时间  int value converted to long and used as absolute time</ShortDescription>
    <LongDescription>将int转换为long，并作为绝对时间传递给{1}中的{2}</LongDescription>
    <Details>
<![CDATA[<p>这段代码将一个32位的int值转换为64位的long值，然后将其作为需要绝对时间值的方法参数传递。绝对时间值是从所谓的“纪元”（即1970年1月1日UTC时间0点）以来的毫秒数。例如，以下旨在将自纪元以来的秒转换为Date的方法是严重错误的：</p>
<pre><code>Date getDate(int seconds) { return new Date(seconds * 1000); } </code></pre>
<p>这里的乘法使用了32位算术运算，并随后转换为64位值。当一个32位值被转换为64位并用于表示绝对时间值时，只能表示1969年12月和1970年1月的日期。</p>
<p>上述方法的正确实现如下：</p>
<pre><code>// 在2037年后会失败 Date getDate(int seconds) { return new Date(seconds * 1000L); }  // 更好，适用于所有日期 Date getDate(long seconds) { return new Date(seconds * 1000); } </code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND">
    <ShortDescription>将整数值强制转换为浮点类型，然后传递给 `Math.round` 方法。  int value cast to float and then passed to Math.round</ShortDescription>
    <LongDescription>将整数值转换为浮点数，然后传递给 `Math.round` 在 `{1}` 处</LongDescription>
    <Details>
<![CDATA[<p>这段代码将一个 int 值转换为浮点数，并带有精确的小数位，然后将其结果传递给 Math.round() 函数，该函数返回最接近参数的 int/long。由于将整数转换为浮点数应该不会产生小数部分，因此此操作始终应该是无害的操作。很可能生成要传递给 Math.round() 的值的操作本应使用浮点算术来执行。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL">
    <ShortDescription>将整数值转换为double类型，然后传递给Math.ceil方法  Integral value cast to double and then passed to Math.ceil</ShortDescription>
    <LongDescription>在 `{1}` 中，整数值被强制转换为双精度值，然后传递给 `Math.ceil`。</LongDescription>
    <Details>
<![CDATA[<p>这段代码将一个整数值（例如，int 或 long）转换为双精度浮点数，然后将结果传递给Math.ceil()函数，该函数会将double值向上舍入到下一个更高位的整数。由于将整数转换为双精度浮点数应该得到没有小数部分的数字，因此此操作始终应该是无操作的。很可能生成要传递给Math.ceil()的值的操作本应使用双精度浮点数算术来执行。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_IDIV_CAST_TO_DOUBLE">
    <ShortDescription>整数除法结果强制转换为double或float  Integral division result cast to double or float</ShortDescription>
    <LongDescription>在 `{1}` 中，整数除法的结果应转换为 double 或 float。</LongDescription>
    <Details>
<![CDATA[<p>此代码将整数除法（例如，int 或 long 除法）运算的结果强制转换为 double 或 float。在整数除法中，结果会被截断为最接近零的整数值。强制转换为 double 表明应该保留这种精度。实际上应该是将一个或两个操作数在进行除法之前强制转换为 double。例如：</p>
<pre><code>int x = 2;
int y = 5;
// 错误：结果为 0.0
double value1 = x / y;

// 正确：结果为 0.4
double value2 = x / (double) y;</code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION">
    <ShortDescription>将非序列化的对象存储到HttpSession中  Store of non serializable object into HttpSession</ShortDescription>
    <LongDescription>在{1}中将非序列化的{2}存储到HttpSession中</LongDescription>
    <Details>
<![CDATA[<p>这段代码似乎将一个非序列化对象存储到了HttpSession中。如果该会话被静默处理或迁移，将会导致错误。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_NONSERIALIZABLE_OBJECT_WRITTEN">
    <ShortDescription>非序列化对象写入到ObjectOutput中  Non serializable object written to ObjectOutput</ShortDescription>
    <LongDescription>非序列化对象 {2} 写入了 ObjectOutput 在 {1} 中</LongDescription>
    <Details>
<![CDATA[<p>这段代码似乎将一个不可序列化的对象传递给了ObjectOutput.writeObject方法。如果该对象确实不可序列化，将会导致错误。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="VA_FORMAT_STRING_USES_NEWLINE">
    <ShortDescription>格式字符串应该使用%n 而不是\n  Format string should use %n rather than \n</ShortDescription>
    <LongDescription>格式字符串应该使用%n 而不是\n 在{1}处</LongDescription>
    <Details>
<![CDATA[<p>该格式字符串包含一个换行字符（\n）。在格式字符串中，通常更推荐使用%n，它会生成平台pecific的行分隔符。 </p>]]>
     </Details>
  </BugPattern>
  <BugPattern type="VA_PRIMITIVE_ARRAY_PASSED_TO_OBJECT_VARARG">
    <ShortDescription>原始数组传递给期望可变数量对象参数的函数  Primitive array passed to function expecting a variable number of object arguments</ShortDescription>
    <LongDescription>将参数 {2} 传递给方法 {3} 中的可变长度参数列表 {1}</LongDescription>
    <Details>
<![CDATA[<p>这段代码将一个原始数组传递给一个接受可变数量对象参数的函数。为此，创建了一个长度为一的数组来容纳原始数组，并将其传递给该函数。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS">
    <ShortDescription>equals方法不应该假设其参数的类型。  Equals method should not assume anything about the type of its argument</ShortDescription>
    <LongDescription>{0}的equals方法假设参数为类型{0.givenClass}</LongDescription>
    <Details>
<![CDATA[<p><code>equals(Object o)</code> 方法不应该假设 <code>o</code> 的类型。如果 <code>o</code> 不是与 <code>this</code> 相同的类型，应该直接返回 false。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_BAD_CAST_TO_ABSTRACT_COLLECTION">
    <ShortDescription>将抽象集合进行可疑转换  Questionable cast to abstract collection</ShortDescription>
    <LongDescription>在{1}中，从Collection进行到抽象类{3}的可疑类型转换{2}</LongDescription>
    <Details>
<![CDATA[<p>这段代码将一个集合强制转换为抽象集合（如 <code>List</code>、<code>Set</code> 或 <code>Map</code>）。请确保你在进行类型转换时，对象确实是你所要转换成的类型。如果你只是为了遍历集合中的元素，并不需要将其转换为 Set 或 List。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_IMPOSSIBLE_CAST_PRIMITIVE_ARRAY">
    <ShortDescription>涉及原始数组的不可能转换  Impossible cast involving primitive array</ShortDescription>
    <LongDescription>在{1}中涉及原始数组的不可能转换</LongDescription>
    <Details>
<![CDATA[<p>这种转换总是会抛出一个ClassCastException。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_IMPOSSIBLE_CAST">
    <ShortDescription>无法进行此类转换  Impossible cast</ShortDescription>
    <LongDescription>从 {2} 到 {3} 的类型转换在 {1} 中是不可能的</LongDescription>
    <Details>
<![CDATA[<p>这种转换总是会抛出 ClassCastException。SpotBugs 跟踪从 instanceof 检查获取的类型信息，并且还使用方法返回值和字段加载值的更精确类型信息。因此，它可能拥有比变量声明类型更为精确的信息，并可以利用这些信息来确定一个转换将在运行时总是引发异常。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_IMPOSSIBLE_DOWNCAST">
    <ShortDescription>不可能的向下转型  Impossible downcast</ShortDescription>
    <LongDescription>从 {2} 到 {3} 在 {1} 中无法进行向下转换</LongDescription>
    <Details>
<![CDATA[<p>此类型转换总是会抛出ClassCastException。分析认为它知道被转换值的精确类型，将该值向下转换为子类型总是会失败并抛出ClassCastException。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_IMPOSSIBLE_DOWNCAST_OF_TOARRAY">
    <ShortDescription>将 `toArray()` 方法的结果进行不安全的向下转换  Impossible downcast of toArray() result</ShortDescription>
    <LongDescription>将 `toArray()` 方法的结果向下转换为 `{3}` 在 `{1}` 中是不可能的。</LongDescription>
    <Details>
<![CDATA[<p>此代码将调用集合上的 `toArray()` 方法的结果强制转换为比 `Object[]` 更具体的类型，如下所示：</p>
<pre><code>String[] getAsArray(Collection&lt;String&gt; c) {     return (String[]) c.toArray(); }
</code></pre>
<p>这通常会通过抛出 `ClassCastException` 而失败。几乎所有集合的 `toArray()` 方法返回的是 `Object[]`。这是因为 Collection 对象无法引用集合声明的泛型类型。 <p>从 collection 中获取特定类型的数组的正确方法是使用 `c.toArray(new String[0]);` 或 `c.toArray(new String[c.size()]);`（前者自 Java 6 晚期以来略显高效）。 <p>有一种常见的/已知的例外情况。通过 `Arrays.asList(...)` 返回的列表的 `toArray()` 方法将返回协变类型的数组。例如，`Arrays.asList(new String[] { "a" }).toArray()` 将返回一个 `String []`。SpotBugs 会尝试检测并抑制此类情况，但可能会遗漏一些。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_INSTANCEOF">
    <ShortDescription>已知的空值检查是否是某类型的实例。  A known null value is checked to see if it is an instance of a type</ShortDescription>
    <LongDescription>在一个已知为null的值在{1}中被检查是否是{2}的一个实例。</LongDescription>
    <Details>
<![CDATA[<p>这个 `instanceof` 测试总是会返回假，因为检查的值肯定为null。虽然这是安全的，但请确保这不是某种误解或逻辑错误的指示。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_NULL_INSTANCEOF" deprecated="true"> <!-- deprecated in favor of NP_NULL_INSTANCEOF -->
    <ShortDescription>已知的空值检查是否是某个类型的实例。  A known null value is checked to see if it is an instance of a type</ShortDescription>
    <LongDescription>在{1}中，已知的空值被检查是否是{2}的实例。</LongDescription>
    <Details>
<![CDATA[<p>这个 instanceof 测试总是会返回 false，因为被检查的值肯定为 null。虽然这是安全的，但请确保这不是某种误解或逻辑错误的迹象。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_IMPOSSIBLE_INSTANCEOF">
    <ShortDescription>instanceof 总是会返回false  instanceof will always return false</ShortDescription>
    <LongDescription>在{1}中，`instanceof`将始终返回false，因为一个{2}不能是一个{3}。</LongDescription>
    <Details>
<![CDATA[<p> 这个 instanceof 测试总是会返回 false。虽然这是安全的，但请确保这并不是某种误解或其他逻辑错误的迹象。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_VACUOUS_INSTANCEOF">
    <ShortDescription>instanceof 总是会返回 true  instanceof will always return true</ShortDescription>
    <LongDescription>在{1}中，`instanceof`将对于所有非空值始终返回true，因为所有的{2}都是{3}的实例。</LongDescription>
    <Details>
<![CDATA[<p>这种 `instanceof` 测试总是会返回 true（除非被测试的值为 null）。虽然这是安全的，但请确保这不是某种误解或逻辑错误的迹象。如果你确实想测试该值是否为 null，也许进行一个 null 检测而不是 `instanceof` 检测会更清晰。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_UNCONFIRMED_CAST">
    <ShortDescription>未检查/未确认的类型转换  Unchecked/unconfirmed cast</ShortDescription>
    <LongDescription>从{2}到{3}的未检查/未确认类型转换在{1}中出现</LongDescription>
    <Details>
<![CDATA[<p>该类型转换未进行检查，且并非所有转换来源的实例都能成功转换为目标类型。请确保程序逻辑能保证这种转换不会失败。</p>]]>
    </Details>
  </BugPattern>
   <BugPattern type="BC_UNCONFIRMED_CAST_OF_RETURN_VALUE">
    <ShortDescription>方法返回值未经检查/未确认的类型转换  Unchecked/unconfirmed cast of return value from method</ShortDescription>
    <LongDescription>从 {2} 到 {3} 的未检查/未确认的类型转换来自 {1} 方法的返回值</LongDescription>
    <Details>
<![CDATA[<p>该代码对方法返回值进行了未检查的类型转换。虽然代码可能以某种方式调用该方法，从而使转换变得安全，但 SpotBugs 无法验证此转换是否安全。请确保你的程序逻辑保证此类转换不会失败。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_BAD_CAST_TO_CONCRETE_COLLECTION">
    <ShortDescription>对具体集合进行了可疑的类型转换  Questionable cast to concrete collection</ShortDescription>
    <LongDescription>在 {1} 中从 {2} 到 {3} 的可疑类型转换</LongDescription>
    <Details>
<![CDATA[<p>这段代码将一个抽象集合（如Collection、List或Set）强制转换为具体的实现类（如ArrayList或HashSet）。这可能是不正确的，可能会使你的代码变得脆弱，因为将来切换到其他具体实现类会更加困难。除非有特别的理由这样做，否则最好使用抽象集合类。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RE_POSSIBLE_UNINTENDED_PATTERN">
    <ShortDescription>"." 或 "|" 用于正则表达式  "." or "|" used for regular expression</ShortDescription>
    <LongDescription>在{1}中使用“.”或“|”进行正则表达式匹配</LongDescription>
    <Details>
<![CDATA[<p>正在调用一个String方法，并将 "." 或 "|" 作为参数传递给接受正则表达式的参数。这是否是你想要的效果？例如：</p>
<ul>
<li>`s.replaceAll(".", "/")` 将返回一个每个字符都被替换为 `'/'` 的字符串。</li>
<li>`s.split(".")` 总是返回一个空的字符串数组。</li>
<li>`"ab|cd".replaceAll("|", "/")` 将返回 `"/a/b/|/c/d/"`。</li>
<li>`"ab|cd".split("|")` 将返回包含六个元素 (!) 的数组：[, a, b, |, c, d]。</li>
</ul>
<p>考虑使用 `<code>s.replace(".", "/")</code>` 或 <code>s.split("\\.")</code> 代替。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION">
    <ShortDescription>无效的正则表达式语法  Invalid syntax for regular expression</ShortDescription>
    <LongDescription>在 {1} 中的正则表达式语法无效</LongDescription>
    <Details>
<![CDATA[这里使用的正则表达式不符合正则表达式的语法规范，当执行该语句时将会抛出PatternSyntaxException异常。]]>
    </Details>
  </BugPattern>
  <BugPattern type="RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION">
    <ShortDescription>使用 File.separator 进行正则表达式匹配  File.separator used for regular expression</ShortDescription>
    <LongDescription>在 `{1}` 中使用了 File.separator 进行正则表达式匹配。</LongDescription>
    <Details>
<![CDATA[这里使用的代码使用了 `<code>File.separator</code>`，但在正则表达式中需要的是普通字符。在Windows平台上，`<code>File.separator</code>` 是反斜杠，而在正则表达式中反斜杠会被解释为转义字符，这会导致失败。除了其他选项外，你可以使用 `<code>File.separatorChar=='\\' ? "\\\\" : File.separator</code>` 替代 `<code>File.separator</code>`。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DLS_OVERWRITTEN_INCREMENT">
    <ShortDescription>重写的增量  Overwritten increment</ShortDescription>
    <LongDescription>在 {1} 中重写了递增操作</LongDescription>
    <Details>
<![CDATA[<p>代码执行了递增/递减操作（例如，<code>i++</code> / <code>i--</code>），然后立即覆盖该值。例如，<code>i = i++</code> / <code>i = i--</code>会立即将递增/递减后的值覆盖为原始值。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT">
    <ShortDescription>将无符号右移转换为short/byte类型  Unsigned right shift cast to short/byte</ShortDescription>
    <LongDescription>在{1}中将无符号右移转换为short/byte类型</LongDescription>
    <Details>
<![CDATA[<p>该代码执行无符号右移操作，然后将结果转换为short或byte类型，这会丢弃结果的高位。由于高位被丢弃，无符号右移和有符号右移的结果可能没有区别（具体取决于位移量的大小）。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BSHIFT_WRONG_ADD_PRIORITY">
    <ShortDescription>可能的位移操作解析错误  Possible bad parsing of shift operation</ShortDescription>
    <LongDescription>在 `{1}` 中可能存在位移操作的不良解析。</LongDescription>
    <Details>
<![CDATA[<p>代码执行的操作类似于 (x << 8 + y)。虽然这可能是正确的，但很可能本意是进行 (x << 8) + y 的操作，但由于位移运算符的优先级较低，实际上会被解析为 x << (8 + y)。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_BAD_SHIFT_AMOUNT">
    <ShortDescription>将32位int类型向左或向右移动超出-31到31的范围。  32 bit int shifted by an amount not in the range -31..31</ShortDescription>
    <LongDescription>32位整数向右移动{2}位在{1}中</LongDescription>
    <Details>
<![CDATA[<p>该代码对一个32位int进行常量偏移，但偏移量超出范围-31..31。这会导致使用整数值的较低5位来决定具体的偏移量（例如，偏移40位等同于偏移8位，而偏移32位则等同于不偏移）。这可能不是预期的行为，并且至少会让人困惑。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IM_MULTIPLYING_RESULT_OF_IREM">
    <ShortDescription>整数余数的整数乘积  Integer multiply of result of integer remainder</ShortDescription>
    <LongDescription>在{1}中的整数余数的整数倍数</LongDescription>
    <Details>
<![CDATA[<p>该代码将一个整数余运算的结果乘以一个整数常量。请确保不要混淆了运算符的优先级。例如，i % 60 * 1000 应该是 (i % 60) * 1000，而不是 i % (60 * 1000)。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_INVOKING_HASHCODE_ON_ARRAY">
    <ShortDescription>对数组调用hashCode方法  Invocation of hashCode on an array</ShortDescription>
    <LongDescription>在{1}中对数组调用了hashCode方法</LongDescription>
    <Details>
<![CDATA[<p>该代码对数组调用了hashCode方法。调用数组的hashCode方法返回的是System.identityHashCode的值，会忽略数组的内容和长度。如果你需要一个依赖于数组<a>内容的hashCode，请使用<code>java.util.Arrays.hashCode(a)</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_INVOKING_TOSTRING_ON_ARRAY">
    <ShortDescription>对数组调用toString方法  Invocation of toString on an array</ShortDescription>
    <LongDescription>在 `{1}` 中对 `{2.givenClass}` 调用了 `toString` 方法。</LongDescription>
    <Details>
<![CDATA[<p>该代码对数组调用了toString方法，这会产生一个相当无用的结果，例如[C@16f0472。建议使用Arrays.toString将数组转换为可读的字符串，以显示数组的内容。参见《编程趣题》，第3章，第12题。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_INVOKING_TOSTRING_ON_ANONYMOUS_ARRAY">
    <ShortDescription>对未命名数组调用toString方法  Invocation of toString on an unnamed array</ShortDescription>
    <LongDescription>在{1}中对未命名数组调用toString方法</LongDescription>
    <Details>
<![CDATA[<p>代码对一个（匿名）数组调用了toString方法。调用数组的toString方法会产生类似[C@16f0472这样的无用结果。考虑使用Arrays.toString将数组转换为包含数组内容的可读字符串。详见《编程趣题》，第3章，第12个谜题。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IM_AVERAGE_COMPUTATION_COULD_OVERFLOW">
    <ShortDescription>计算平均值时可能会发生溢出  Computation of average could overflow</ShortDescription>
    <LongDescription>在 {1} 中，计算平均值可能导致溢出。</LongDescription>
    <Details>
<![CDATA[<p>该代码使用除法或带符号右移来计算两个整数的平均值，然后将结果用作数组的索引。如果被平均的数值非常大，这可能会导致溢出（从而计算出一个负的平均值）。假设结果应该是非负的，你可以使用无符号右移而不是使用 <code>(low+high)/2</code>，即应该使用 <code>(low+high) &gt;&gt;&gt; 1</code>。</p>
<p>这个错误存在于许多早期实现的二分查找和归并排序中。Martin Buchholz 在 JDK 库中 <a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6412541">发现并修复了这个问题</a>，而 Joshua Bloch 则在 <a href="http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html">广泛宣传了这种错误模式</a>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IM_BAD_CHECK_FOR_ODD">
    <ShortDescription>检查奇偶性判断不能处理负数的情况  Check for oddness that won't work for negative numbers</ShortDescription>
    <LongDescription>检查在{1}中不会对负数生效的奇偶性判断。</LongDescription>
    <Details>
<![CDATA[<p>该代码使用 x % 2 == 1 来检查一个值是否为奇数，但这对于负数无效（例如，(-5) % 2 == -1）。如果代码的意图是检查奇偶性，可以考虑使用 (x & 1) == 1 或 x % 2 != 0。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_HARDCODED_ABSOLUTE_FILENAME">
    <ShortDescription>代码中包含对绝对路径名的硬编码引用  Code contains a hard coded reference to an absolute pathname</ShortDescription>
    <LongDescription>在 `{1}` 中硬编码了绝对路径引用</LongDescription>
    <Details>
<![CDATA[<p>这段代码使用硬编码的绝对路径构造了一个File对象（例如，<code>new File("/home/dannyc/workspace/j2ee/src/share/com/sun/enterprise/deployment");</code>）</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_BAD_MONTH">
    <ShortDescription>无效的月份常量值  Bad constant value for month</ShortDescription>
    <LongDescription>在{1}中传递给{3}的{2}月份值无效</LongDescription>
    <Details>
<![CDATA[<p>此代码将一个超出预期范围（0..11）的常量月份值传递给方法。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_USELESS_SUBSTRING">
    <ShortDescription>对 `substring(0)` 的调用，返回的是原始值。  Invocation of substring(0), which returns the original value</ShortDescription>
    <LongDescription>{1} 调用了 `substring(0)`，这将返回原始值。</LongDescription>
    <Details>
<![CDATA[<p>该代码对一个字符串调用了 substring(0) 方法，这会返回原来的值。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_CALLING_NEXT_FROM_HASNEXT">
    <ShortDescription>`hasNext` 方法调用了 `next` 方法  hasNext method invokes next</ShortDescription>
    <LongDescription>{1} 调用 {2.givenClass}</LongDescription>
    <Details>
<![CDATA[<p>hasNext() 方法调用了 next() 方法。这几乎肯定不对，因为 hasNext() 方法不应该改变迭代器的状态，而 next 方法应该改变迭代器的状态。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SWL_SLEEP_WITH_LOCK_HELD">
    <ShortDescription>在持有锁的情况下调用了Thread.sleep()方法  Method calls Thread.sleep() with a lock held</ShortDescription>
    <LongDescription>{1} 在持锁状态下调用了Thread.sleep()方法</LongDescription>
    <Details>
      <![CDATA[<p>该方法在持有锁的情况下调用了Thread.sleep()。这可能会导致非常差的性能和可扩展性，甚至可能造成死锁，因为其他线程可能正在等待获取该锁。更好的做法是调用wait()来释放锁并允许其他线程运行。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="DB_DUPLICATE_BRANCHES">
    <ShortDescription>方法的两个分支使用了相同的代码  Method uses the same code for two branches</ShortDescription>
    <LongDescription>{1} 使用了两个分支中的相同代码</LongDescription>
    <Details>
      <![CDATA[<p>此方法使用相同的代码实现条件分支的两个分支。确保这不是一个编码错误。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="DB_DUPLICATE_SWITCH_CLAUSES">
    <ShortDescription>方法在同一段代码中为两个 switch 语句块使用了相同的代码。  Method uses the same code for two switch clauses</ShortDescription>
    <LongDescription>{1} 使用相同的代码片段为两个 switch 子句</LongDescription>
    <Details>
      <![CDATA[<p>该方法使用相同的代码实现switch语句的两个分支。这可能是重复代码，但也可能表明存在编码错误。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="IMA_INEFFICIENT_MEMBER_ACCESS">
    <ShortDescription>方法访问了所属类的私有成员变量  Method accesses a private member variable of owning class</ShortDescription>
    <LongDescription>访问所属类的私有成员变量</LongDescription>
    <Details>
      <![CDATA[<p>这个内部类的方法读取或写入了拥有者类的私有成员变量，或者调用了拥有者类的私有方法。编译器必须生成一个特殊的方法来访问这个私有成员，这会导致效率降低。放松对该成员变量或方法的保护级别可以让编译器将其视为正常的访问。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="XFB_XML_FACTORY_BYPASS">
    <ShortDescription>方法直接分配了具体的XML接口实现  Method directly allocates a specific implementation of xml interfaces</ShortDescription>
    <LongDescription>{1} 直接分配了具体的XML接口实现</LongDescription>
    <Details>
      <![CDATA[<p>此方法分配了特定的XML接口实现。建议使用提供的工厂类来创建这些对象，以便在运行时可以更改实现。请参阅：</p>
<ul>
    <li>javax.xml.parsers.DocumentBuilderFactory</li>
    <li>javax.xml.parsers.SAXParserFactory</li>
    <li>javax.xml.transform.TransformerFactory</li>
    <li>org.w3c.dom.Document.create<i>XXXX</i></li>
</ul>
<p>以获取详细信息。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="USM_USELESS_SUBCLASS_METHOD">
    <ShortDescription>方法无必要地委托给父类的方法  Method superfluously delegates to parent class method</ShortDescription>
    <LongDescription>{1} 无必要地委托给父类方法</LongDescription>
    <Details>
      <![CDATA[<p>这个派生方法仅仅传递接收到的相同参数调用超类的方法。该方法可以移除，因为它没有提供额外的价值。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="USM_USELESS_ABSTRACT_METHOD">
    <ShortDescription>已在一个实现的接口中定义了抽象方法  Abstract Method is already defined in implemented interface</ShortDescription>
    <LongDescription>抽象方法 `{1}` 已经在实现的接口中定义。</LongDescription>
    <Details>
      <![CDATA[<p>这个抽象方法已经在由该抽象类实现的接口中定义。由于它不提供额外的价值，因此可以移除该方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CI_CONFUSED_INHERITANCE">
    <ShortDescription>类是最终类但声明了受保护的字段  Class is final but declares protected field</ShortDescription>
    <LongDescription>类 {0} 是最终类但声明了受保护的字段 {1}</LongDescription>
    <Details>
      <![CDATA[<p>该类被声明为最终类，但声明了受保护的字段。由于类是最终类，无法派生，使用受保护的访问修饰符令人困惑。应将字段的访问修饰符更改为private或public以正确表示字段的实际用途。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="QBA_QUESTIONABLE_BOOLEAN_ASSIGNMENT">
    <ShortDescription>方法在布尔表达式中赋值布尔字面量  Method assigns boolean literal in boolean expression</ShortDescription>
    <LongDescription>{1} 在布尔表达式中赋值布尔常量</LongDescription>
    <Details>
      <![CDATA[<p>此方法在一个 if 或 while 表达式中为布尔变量赋了一个字面量的布尔值（true 或 false）。大多数情况下，这应该是使用 == 进行布尔比较，而不是使用 = 进行赋值。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="VR_UNRESOLVABLE_REFERENCE">
    <ShortDescription>类引用未解析的类或方法  Class makes reference to unresolvable class or method</ShortDescription>
    <LongDescription>{0} 对 {1} 的引用无法解析</LongDescription>
    <Details>
      <![CDATA[<p>该类引用了一个在分析其所依赖的库中无法Resolve的类或方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="GC_UNCHECKED_TYPE_IN_GENERIC_CALL">
    <ShortDescription>泛型调用中的未检查类型  Unchecked type in generic call</ShortDescription>
    <LongDescription>在 `{1}` 中提供了类型为 `Object` 的未检查参数，而预期的类型应为 `{3.givenClass}`。</LongDescription>
    <Details>
     <![CDATA[<p>这个对泛型集合方法的调用传递了一个类型为 Object 的参数，而期望的是特定类型的泛型类型参数。因此， neither 标准 Java 类型系统 nor 静态分析 无法提供有用的信息来确定传递的对象是否是适当类型的。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="GC_UNRELATED_TYPES">
    <ShortDescription>泛型参数与方法参数之间没有关系  No relationship between generic parameter and method argument</ShortDescription>
    <LongDescription>{2.givenClass} 与预期的参数类型 {3.givenClass} 在 {1} 中不兼容</LongDescription>
    <Details>
     <![CDATA[<p>此对泛型集合方法的调用包含一个与集合参数类型不兼容的参数（即，参数的类型既不是对应泛型类型参数的超类型也不是子类型）。因此，很可能该集合中没有任何对象与这里使用的方法参数相等。最有可能的情况是向方法传递了错误的值。</p>  
<p>通常情况下，两个无关类的实例不相等。例如，如果`Foo`和`Bar`类之间不存在 subtype 关系，则`Foo`类的一个实例不应等于`Bar`类的一个实例。这还会导致一些问题，比如可能会得到一个不对称的 equals 方法。例如，如果您定义了`Foo`类使得`Foo`可以等于`String`类，那么您的 equals 方法将不再是对称的，因为`String`只能等于另一个`String`。</p>  
<p>在极少数情况下，人们确实会定义非对称的 equals 方法并仍然使代码正常工作。虽然 API 中没有记录或保证这一点，但通常情况下，如果您检查一个`Collection<String>`是否包含`Foo`对象，那么进行相等性检查时使用的等于方法（例如`Foo`类中的 equals 方法）会被使用。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_COLLECTIONS_SHOULD_NOT_CONTAIN_THEMSELVES">
    <ShortDescription>集合不应包含自身  Collections should not contain themselves</ShortDescription>
    <LongDescription>在调用{2.givenClass}时，集合不应该包含自身。</LongDescription>
    <Details>
     <![CDATA[<p>这种对泛型集合方法的调用只有在集合中包含自身的情况下才有意义（例如，如果 <code>s.contains(s)</code> 为真）。这种情况发生的可能性不大，并且如果确实发生会导致问题（比如计算哈希码会导致无限递归）。很可能传递给参数的值是错误的。     </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_VACUOUS_SELF_COLLECTION_CALL">
    <ShortDescription>空洞的集合调用  Vacuous call to collections</ShortDescription>
    <LongDescription>对于任何集合 c，调用 c.{2.name}(c) 没有意义。</LongDescription>
    <Details>
     <![CDATA[<p>这个调用没有意义。对于任何集合<c>，调用<c>.containsAll(c) 应该总是返回 true，并且<c>.retainAll(c) 应该没有任何效果。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="PZ_DONT_REUSE_ENTRY_OBJECTS_IN_ITERATORS">
    <ShortDescription>不要在迭代器中重用entry对象  Don't reuse entry objects in iterators</ShortDescription>
    <LongDescription>{0}既是Iterator也是一个Map.Entry</LongDescription>
    <Details>
     <![CDATA[<p>`entrySet()` 方法允许返回一个视图，其中包含 Iterator 和 Map.Entry。这个聪明的想法被几个 Map 实现所采用，但引入了潜在的编程错误可能性。如果一个 map <code>m</code> 通过 `entrySet` 返回这样的迭代器，那么 <code>c.addAll(m.entrySet())</code> 将会出错。OpenJDK 7 中的所有 Map 实现都已被重写以避免这个问题，你也应该这样做。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_ENTRY_SETS_MAY_REUSE_ENTRY_OBJECTS">
    <ShortDescription>由于可能重用Entry对象，向entry集添加元素可能会失败。  Adding elements of an entry set may fail due to reuse of Entry objects</ShortDescription>
    <LongDescription>在{1}中可能会因为重复使用{2.simpleClass}.Entry对象而导致向entry集添加元素失败。</LongDescription>
    <Details>
     <![CDATA[<p>`entrySet()` 方法允许返回一个视图，其中在迭代过程中会重复使用同一个 Entry 对象。截至 Java 6，`IdentityHashMap` 和 `EnumMap` 都是如此操作的。当你遍历这样的 Map 时，在迭代到下一个条目之前，Entry 的值是有效的。例如，如果你尝试将这样的 `entrySet` 传递给一个 `addAll` 方法，将会出现严重的问题。</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="DMI_USING_REMOVEALL_TO_CLEAR_COLLECTION">
    <ShortDescription>不要使用removeAll来清空集合  Don't use removeAll to clear a collection</ShortDescription>
    <LongDescription>在{1}中，`removeAll` 用于清空集合。</LongDescription>
    <Details>
     <![CDATA[<p>如果你想从集合<c>中移除所有元素，应使用<c>.clear>，而不是<c>.removeAll(c)>. 调用<c>.removeAll(c)>来清空集合不够明确，容易因打字错误而出错，并且效率较低，对于某些集合来说，还可能会抛出<code>ConcurrentModificationException</code>. </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="STCAL_STATIC_CALENDAR_INSTANCE">
    <ShortDescription>静态日历字段  Static Calendar field</ShortDescription>
    <LongDescription>{1} 是类型为 java.util.Calendar 的静态字段，且不是线程安全的。</LongDescription>
    <Details>
<![CDATA[<p>尽管JavaDoc中没有提及，但Calendar类本质上不适合多线程使用。在未经适当同步的情况下，在线程边界共享单个实例会导致应用程序出现异常行为。在1.4版本中，这些问题似乎不如在Java 5中频繁地显现，但在Java 5中，你可能会看到随机的ArrayIndexOutOfBoundsException或IndexOutOfBoundsException，这些错误发生在sun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate()方法中。</p>
<p>你可能还会遇到序列化问题。</p>
<p>建议使用实例字段。</p>
<p>有关更多信息，请参阅<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6231579">JDK Bug #6231579</a>和<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6178997">JDK Bug #6178997</a>。</p>]]>
</Details>
  </BugPattern>
  <BugPattern type="STCAL_INVOKE_ON_STATIC_CALENDAR_INSTANCE">
    <ShortDescription>调用静态Calendar方法  Call to static Calendar</ShortDescription>
    <LongDescription>在 `{1}` 中对 `static java.util.Calendar` 的方法进行了调用</LongDescription>
    <Details>
<![CDATA[<p>尽管JavaDoc没有提供这方面的提示，但Calendar对象本质上不适合用于多线程环境。检测器发现了一个通过静态字段获取的Calendar实例的调用，这看起来有些可疑。</p>
<p>有关更多信息，请参见<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6231579">JDK Bug #6231579</a>和<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6178997">JDK Bug #6178997</a>。</p>]]>
</Details>
  </BugPattern>
  <BugPattern type="STCAL_STATIC_SIMPLE_DATE_FORMAT_INSTANCE">
    <ShortDescription>静态的 `DateFormat`  Static DateFormat</ShortDescription>
    <LongDescription>{1} 是一个静态字段，类型为 java.text.DateFormat，并且不是线程安全的。</LongDescription>
    <Details>
<![CDATA[<p>正如JavaDoc所述，DateFormats本质上不适合多线程使用。如果不加适当同步而在线程边界共享单个实例，会导致应用程序行为异常。</p>
<p>您还可能会遇到序列化问题。</p>
<p>建议使用实例字段。</p>
<p>有关更多信息，请参见<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6231579">JDK Bug #6231579</a>和<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6178997">JDK Bug #6178997</a>。</p>]]>
</Details>
  </BugPattern>
  <BugPattern type="STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE">
    <ShortDescription>调用静态的DateFormat方法  Call to static DateFormat</ShortDescription>
    <LongDescription>在 `{1}` 中调用了静态方法 `java.text.DateFormat` 的方法。</LongDescription>
    <Details>
<![CDATA[<p>如JavaDoc所述，DateFormats在多线程环境中是不安全的。检测器发现有对通过静态字段获取的DateFormat实例的调用，这看起来可疑。</p>
<p>有关更多信息，请参见<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6231579">JDK Bug #6231579</a>和<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6178997">JDK Bug #6178997</a>。</p>]]>
</Details>
  </BugPattern>
  <BugPattern type="TQ_COMPARING_VALUES_WITH_INCOMPATIBLE_TYPE_QUALIFIERS">
    <ShortDescription>使用不兼容类型限定词比较值  Comparing values with incompatible type qualifiers</ShortDescription>
    <LongDescription>被标注为具有类型限定符{2.simpleName}的值与从未具有该限定符的值进行相等性比较。</LongDescription>
    <Details>
      <![CDATA[<p>一个带有类型修饰注解的值与从不带该修饰符的值进行比较。</p>
<p>具体来说，一个用类型修饰注解标记为 when=ALWAYS 的值会与同一个类型修饰注解标记为 when=NEVER 的值进行比较。</p>
<p>例如，假设 @NonNegative 是 @Negative(when=When.NEVER) 的别名。以下代码将生成此警告，因为返回语句需要一个 @NonNegative 值，但接收的是标记为 @Negative 的值。</p>
<pre><code>public boolean example(@Negative Integer value1, @NonNegative Integer value2) {     return value1.equals(value2); } </code></pre>]]>
    </Details>
  </BugPattern>


  <BugPattern type="TQ_ALWAYS_VALUE_USED_WHERE_NEVER_REQUIRED">
    <ShortDescription>标注了类型限定符的值用于需要不携带该限定符的值的位置  Value annotated as carrying a type qualifier used where a value that must not carry that qualifier is required</ShortDescription>
    <LongDescription>标记为携带类型修饰符 {2.simpleName} 的值用于必须不携带该修饰符的地方</LongDescription>
    <Details>
      <![CDATA[<p>指定带有类型限定注解的值在需要该值不带此注解的位置被消费。</p>
<p>更精确地说，带有type=ALWAYS指定的类型限定注解的值保证会到达使用相同类型限定注解且type=NEVER指定的位置。</p>
<p>例如，假设@NonNegative是@Negative(when=When.NEVER)的一个别名。以下代码将生成此警告，因为返回语句需要一个@NonNegative值，但收到的是一个标记为@Negative的值。</p>
<pre><code>public @NonNegative Integer example(@Negative Integer value) {     return value; } </code></pre>]]>
    </Details>
  </BugPattern>


  <BugPattern type="TQ_UNKNOWN_VALUE_USED_WHERE_ALWAYS_STRICTLY_REQUIRED">
    <ShortDescription>在需要使用类型修饰符的值处使用了未带类型修饰符的值  Value without a type qualifier used where a value is required to have that qualifier</ShortDescription>
    <LongDescription>在需要一个 `{2.simpleName}` 注解的地方使用了未带类型限定符的值</LongDescription>
    <Details>
      <![CDATA[<p>   该值的使用方式要求对该值进行类型注解。     由于类型注解是严格的，因此工具会拒绝任何未带有适当注解的值。   </p>    <p>   要将一个值转换为具有严格注解的值，可以定义一个返回值带有严格注解的身份函数。     这是唯一能够将非注解值转换为具有严格类型注解值的方法。   </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="TQ_NEVER_VALUE_USED_WHERE_ALWAYS_REQUIRED">
    <ShortDescription>标注为从未携带类型限定符的值在需要携带该限定符的地方被使用  Value annotated as never carrying a type qualifier used where value carrying that qualifier is required</ShortDescription>
    <LongDescription>值被注释为从不携带类型限定符{2.simpleName}，但在需要携带该限定符的地方使用了它。</LongDescription>
    <Details>
      <![CDATA[<p>   指定为不携带类型限定注解的值保证会在需要该注解的位置或多个位置被消费。   </p>    <p>   更精确地说，带有指定 when=NEVER 的类型限定注解的值保证会到达一个或多个使用位置，在这些位置上相同的类型限定注解指定为 when=ALWAYS。   </p>    <p>   TODO: 示例   </p>]]>
    </Details>
  </BugPattern>




  <BugPattern type="TQ_MAYBE_SOURCE_VALUE_REACHES_ALWAYS_SINK">
    <ShortDescription>可能没有类型限定符的值总是以需要该类型限定符的方式使用  Value that might not carry a type qualifier is always used in a way requires that type qualifier</ShortDescription>
    <LongDescription>可能没有携带{2.simpleName}注解的值总是以需要该类型提示的方式使用。</LongDescription>
    <Details>
      <![CDATA[<p>一个被注解为可能不是由类型限定词表示的值，但该值保证将以需要使用由该类型限定词表示的值的方式被使用。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="TQ_MAYBE_SOURCE_VALUE_REACHES_NEVER_SINK">
    <ShortDescription>可能携带类型限定符的值总是以禁止其具有该类型限定符的方式使用  Value that might carry a type qualifier is always used in a way prohibits it from having that type qualifier</ShortDescription>
    <LongDescription>带有{2.simpleName}注解的值总是被用于禁止其具有该类型提示的方式。</LongDescription>
    <Details>
      <![CDATA[<p>一个被注解为可能是一个由类型限定符表示的值的实例，并且该值保证将以禁止使用由该类型限定符表示的值的方式被使用。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_NEVER_SINK">
    <ShortDescription>需要值没有类型限定符，但标记为未知  Value required to not have type qualifier, but marked as unknown</ShortDescription>
    <LongDescription>值要求不能是 {2.simpleName}，但被明确注解为与 {2.simpleName} 无关。</LongDescription>
    <Details>
      <![CDATA[<p>某个值的使用方式要求该值不能带有类型限定符，但存在明确注解表明不知晓为何该值禁止有该类型限定符。要么是值的使用方式不正确，要么是注解信息不准确。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_ALWAYS_SINK">
    <ShortDescription>需要类型限定符的值却被标记为未知  Value required to have type qualifier, but marked as unknown</ShortDescription>
    <LongDescription>值必须始终为 `{2.simpleName}`，但与此相反，该值被明确注解为未知的 `{2.simpleName}`。</LongDescription>
    <Details>
      <![CDATA[<p>该值被使用的方式要求它总是带有类型限定符，但存在一个明确的注解表明不知道该值在何处需要有这个类型限定符。要么是该值的使用方式不正确，要么是注解不正确。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IO_APPENDING_TO_OBJECT_OUTPUT_STREAM">
    <ShortDescription>试图向对象输出流追加内容的 doomed 尝试  Doomed attempt to append to an object output stream</ShortDescription>
    <LongDescription>在 `{1}` 中尝试向对象输出流追加操作是徒劳的。</LongDescription>
    <Details>
      <![CDATA[<p>      这段代码以追加模式打开一个文件，然后将结果包装在对象输出流中，如下所示： </p> <pre><code>OutputStream out = new FileOutputStream(anyFile, true);      new ObjectOutputStream(out);</code></pre> <p>      这样做无法让你追加到已存于文件中的对象输出流。如果你想能够追加到对象输出流，需要保持对象输出流的打开状态。 </p> <p>唯一可以使在追加模式下打开文件并写入对象输出流起作用的情况是，在读取文件时计划以随机访问模式打开文件，并定位到追加操作开始的位置字节偏移量。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="WL_USING_GETCLASS_RATHER_THAN_CLASS_LITERAL">
    <ShortDescription>而不是使用类字面量，同步getClass()调用  Synchronization on getClass rather than class literal</ShortDescription>
    <LongDescription>在{1}处使用getClass而非类字面量的同步</LongDescription>
    <Details>
      <![CDATA[<p>      这个实例方法对 <code>this.getClass()</code> 进行了同步。如果该类被子类化，子类将对子类的类对象进行同步，这很可能不是预期的行为。例如，考虑以下来自 java.awt.Label 的代码：</p>
<pre><code>private static final String base = "label"; private static int nameCounter = 0;  String constructComponentName() {     synchronized (getClass()) {   return base + nameCounter++;     } } </code></pre>
<p>Label 的子类不会对同一个类对象进行同步，从而引发数据竞争。相反，这段代码应该对 <code>Label.class</code> 进行同步。</p>
<pre><code>private static final String base = "label"; private static int nameCounter = 0;  String constructComponentName() {     synchronized (Label.class) {   return base + nameCounter++;     } } </code></pre>
<p>错误模式由 Jason Mehrens 提供。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="OBL_UNSATISFIED_OBLIGATION">
    <ShortDescription>方法可能无法正确清理流或资源  Method may fail to clean up stream or resource</ShortDescription>
    <LongDescription>{1} 可能无法清理掉 {2}</LongDescription>
    <Details>
          <![CDATA[<p>     此方法可能无法正确清理（关闭、处理）流、数据库对象或其他需要显式清理操作的资源。     </p>      <p>     通常，如果一个方法打开了一个流或其它资源，该方法应该使用 try/finally 块来确保在方法返回之前已经进行了清理操作。     </p>      <p>     此错误模式实质上与 OS_OPEN_STREAM 和 ODR_OPEN_DATABASE_RESOURCE 错误模式相同，但基于不同的（并且希望是更好的）静态分析技术。我们对这个错误模式的有用性很感兴趣。对于反馈，请参阅：     </p>     <ul> <li><a href="https://github.com/spotbugs/spotbugs/blob/master/.github/CONTRIBUTING.md">贡献指南</a></li> <li><a href="https://github.com/spotbugs/discuss/issues?q=">邮件列表</a></li>     </ul>      <p>     特别是，     对于此错误模式的假阳性抑制启发式尚未进行广泛调整，因此关于假阳性的报告对我们非常有帮助。     </p>      <p>     有关此分析技术的描述，请参见 Weimer 和 Necula 的论文《寻找和预防运行时错误处理错误》（<a href="https://people.eecs.berkeley.edu/~necula/Papers/rte_oopsla04.pdf">PDF</a>）。     </p>]]>
      </Details>
  </BugPattern>




  <BugPattern type="OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE">
    <ShortDescription>方法可能在处理checked异常时未能清理流或资源  Method may fail to clean up stream or resource on checked exception</ShortDescription>
    <LongDescription>在处理已检查异常时，{1} 可能无法清理 {2}。</LongDescription>
    <Details>
          <![CDATA[<p>此方法可能无法清理（关闭、处理）流、数据库对象或其他需要显式清理操作的资源。</p>
<p>一般来说，如果一个方法打开了一个流或其它资源，该方法应使用 try/finally 块来确保在方法返回之前对流或资源进行清理。</p>
<p>此错误模式实质上与 OS_OPEN_STREAM 和 ODR_OPEN_DATABASE_RESOURCE 错误模式相同，但基于不同的（希望是更好的）静态分析技术。我们对该错误模式的有用性很感兴趣。有关反馈，请参阅：</p>
<ul>
<li><a href="https://github.com/spotbugs/spotbugs/blob/master/.github/CONTRIBUTING.md">贡献指南</a></li>
<li><a href="https://github.com/spotbugs/discuss/issues?q=">邮件列表</a></li>
</ul>
<p>特别是，此错误模式的假阳性抑制启发式尚未广泛调优，因此关于假阳性的报告对我们很有帮助。</p>
<p>有关分析技术的描述，请参阅 Weimer 和 Necula 的论文 <i>Finding and Preventing Run-Time Error Handling Mistakes</i>（<a href="https://people.eecs.berkeley.edu/~necula/Papers/rte_oopsla04.pdf">PDF</a>）。</p>]]>
      </Details>
  </BugPattern>















  <BugPattern type="FB_UNEXPECTED_WARNING">
    <ShortDescription>来自SpotBugs的意外/不必要的警告  Unexpected/undesired warning from SpotBugs</ShortDescription>
    <LongDescription>在{1}中发现不必要的/{2}SpotBugs 警告</LongDescription>
    <Details>
          <![CDATA[<p>SpotBugs生成了一个警告，根据<code>@NoWarning</code>注解，这个警告是意外的或不需要的。</p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="FB_MISSING_EXPECTED_WARNING">
    <ShortDescription>SpotBugs缺少预期或所需的警告提示  Missing expected or desired warning from SpotBugs</ShortDescription>
    <LongDescription>在{1}中缺少预期或所需的第{2}个SpotBugs警告</LongDescription>
    <Details>
          <![CDATA[<p>SpotBugs 没有生成根据 <code>@ExpectedWarning</code> 注解预期或希望产生的警告。</p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="RV_RETURN_VALUE_OF_PUTIFABSENT_IGNORED">
    <ShortDescription>`putIfAbsent` 的返回值被忽略，传递给 `putIfAbsent` 的值被重复使用  Return value of putIfAbsent ignored, value passed to putIfAbsent reused</ShortDescription>
    <LongDescription>putIfAbsent的返回值被忽略，但{4}在{1}中重复使用了。</LongDescription>
    <Details>
          <![CDATA[`putIfAbsent` 方法通常用于确保给定的键与单一值相关联（首次调用 put if absent 成功时）。如果你忽略返回值并保留传入值的引用，你可能会保留与该键在映射中关联的不是同一个值。如果使用时不存储在映射中的那个值，你的程序将会表现出错误的行为。]]>
      </Details>
  </BugPattern>
  <BugPattern type="LG_LOST_LOGGER_DUE_TO_WEAK_REFERENCE">
    <ShortDescription>由于弱引用在OpenJDK中的使用可能导致潜在的日志记录器丢失更改。  Potential lost logger changes due to weak reference in OpenJDK</ShortDescription>
    <LongDescription>在{1}中对日志器的更改可能会丢失。</LongDescription>
    <Details>
          <![CDATA[<p>OpenJDK 引入了潜在的不兼容性。特别是，java.util.logging.Logger 的行为发生了变化。它现在内部使用弱引用而不是强引用。这是一个合理的改变，但不幸的是，某些代码依赖于旧的行为——在更改日志器配置时，它会简单地丢弃日志器引用。这意味着垃圾收集器可以自由回收这部分内存，从而导致日志器配置丢失。例如考虑以下代码：</p>
<pre><code>public static void initLogging() throws Exception {     Logger logger = Logger.getLogger("edu.umd.cs");     logger.addHandler(new FileHandler()); // 调用更改日志器配置     logger.setUseParentHandlers(false); // 另一个更改日志器配置的调用 } </code></pre>
<p>在方法结束时丢失了日志器引用（它没有从方法中逃逸），因此，如果在 initLogging 调用之后正好发生垃圾收集周期，则会丢失日志器配置（因为 Logger 仅保留弱引用）。</p>
<pre><code>public static void main(String[] args) throws Exception {     initLogging(); // 向日志器添加一个文件处理器     System.gc(); // 日志器配置丢失     Logger.getLogger("edu.umd.cs").info("Some message"); // 这个消息不会按预期记录到文件中 } </code></pre>
<p><em>Ulf Ochsenfahrt 和 Eric Fellheimer</em></p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="AT_OPERATION_SEQUENCE_ON_CONCURRENT_ABSTRACTION">
    <ShortDescription>对并发抽象的连续调用可能不是原子操作  Sequence of calls to concurrent abstraction may not be atomic</ShortDescription>
    <LongDescription>在 `{1}` 中，对 `{2}` 的连续调用可能不是原子操作。</LongDescription>
    <Details>
          <![CDATA[这段代码包含对并发抽象（如并发哈希映射）的一系列调用。这些调用不会原子性地执行。]]>
      </Details>
  </BugPattern>
  <BugPattern type="DM_DEFAULT_ENCODING">
    <ShortDescription>依赖默认编码  Reliance on default encoding</ShortDescription>
    <LongDescription>在 {1} 中发现依赖默认编码：{2}</LongDescription>
    <Details>
<![CDATA[<p>发现了一次调用，该方法将执行字节到字符串（或字符串到字节）的转换，并假设默认平台编码是合适的。这会导致应用程序的行为在不同平台上有所不同。请使用替代API，并显式指定字符集名称或字符集对象。</p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="NP_METHOD_PARAMETER_RELAXING_ANNOTATION">
    <ShortDescription>方法紧化了参数的空值注解  Method tightens nullness annotation on parameter</ShortDescription>
    <LongDescription>方法 `{1}` 覆写了空值注解，从而放松了其上级方法对参数的要求。</LongDescription>
    <Details>
        <![CDATA[<p>   一个方法在覆盖父类的方法时，应该始终实现该方法的合同。因此，如果一个方法接受了一个标记为 @Nullable 的参数，你不应在子类中用一个该参数标记为 @Nonnull 的方法来覆盖它。这样做会违反该方法处理空参数的合同。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_METHOD_PARAMETER_TIGHTENS_ANNOTATION">
    <ShortDescription>方法收紧了参数的空值注解  Method tightens nullness annotation on parameter</ShortDescription>
    <LongDescription>方法 `{1}` 以不兼容的方式 overriding 参数 `{2}` 的非空性注解</LongDescription>
    <Details>
        <![CDATA[<p>   一个方法在覆盖父类的方法时，应该始终实现该方法的契约。因此，如果一个方法接受一个标记为 @Nullable 的参数，你不应该在一个子类中用一个将该参数标记为 @Nonnull 的方法来覆盖它。这样做违反了该方法应处理空参数的契约。</p>]]>
      </Details>
  </BugPattern>

  <BugPattern type="NP_METHOD_RETURN_RELAXING_ANNOTATION">
    <ShortDescription>方法放松了返回值的非空注解  Method relaxes nullness annotation on return value</ShortDescription>
    <LongDescription>方法 `{1}` 以不兼容的方式覆盖了返回值的空值注解。</LongDescription>
    <Details>
        <![CDATA[<p>一个方法应该始终实现它所重写的 方法的合约。因此，如果一个方法被注解为返回@Nonnull 值，你不应在子类中用一个被注解为返回@Nullable 或 @CheckForNull 值的方法来覆盖该方法。这样做违反了该方法不应返回 null 的合约。</p>]]>
      </Details>
  </BugPattern>

  <BugPattern type="EOS_BAD_END_OF_STREAM_CHECK">
    <ShortDescription>数据读取在比较之前被转换为-1  Data read is converted before comparison to -1</ShortDescription>
    <LongDescription>在方法 {1} 中，{2} 的返回值在与 {4} 进行比较之前被转换为 {3}。</LongDescription>
    <Details>
      <![CDATA[<p>Java.io.FileInputStream.read() 方法返回一个 int。如果将这个 int 转换为 byte，则 -1（表示 EOF）和字节 0xFF 就无法区分，将 (转换后的) 结果与 -1 进行比较会导致在遇到字符 0xFF 时循环过早结束。同样地，Java.io.FileReader.read() 方法也返回一个 int。如果将其转换为 char，则 -1 变为 0xFFFF，即 Character.MAX_VALUE。将结果与 -1 进行比较是没有意义的，因为在 Java 中字符是无符号的。如果 EOF 的检测是循环的条件，则该循环将是无限的。</p>
<p>详见 SEI CERT 规则 <a href="https://wiki.sei.cmu.edu/confluence/display/java/FIO08-J.+Distinguish+between+characters+or+bytes+read+from+a+stream+and+-1">FIO08-J. 区分从流中读取的字符或字节与 -1</a>。</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="REFLC_REFLECTION_MAY_INCREASE_ACCESSIBILITY_OF_CLASS">
    <ShortDescription>公有方法使用反射在其参数中获取的类创建一个实例，这可能会增加任何类的可访问性。  Public method uses reflection to create a class it gets in its parameter which could increase the accessibility of any class</ShortDescription>
    <LongDescription>公共方法 `{1}` 使用反射在其参数中获取的类创建一个实例，这可能会增加任何类的可访问性。</LongDescription>
    <Details>
      <![CDATA[<p>SEI CERT SEC05-J 规则禁止使用反射来增加类、方法或字段的访问性。如果一个包中的类提供了一个接受 java.lang.Class 实例作为参数的公共方法，并且调用了其 newInstance() 方法，那么这将不通过公共构造函数增加同一包中类的可访问性。攻击者代码可以调用此方法并将此类传递给它以创建该类的一个实例。为了避免这种情况，可以通过使该方法非公共或检查包访问权限来实现；第三个解决方案是使用 java.beans.Beans.instantiate() 方法而不是 java.lang.Class.newInstance()，后者会检查正在接收的 Class 对象是否有任何公共构造函数。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="REFLF_REFLECTION_MAY_INCREASE_ACCESSIBILITY_OF_FIELD">
    <ShortDescription>公共方法使用反射修改其参数中获取的字段，这可能会增加任何类的可访问性。  Public method uses reflection to modify a field it gets in its parameter which could increase the accessibility of any class</ShortDescription>
    <LongDescription>公共方法 {1} 使用反射修改其参数中获取到的字段，这可能会增加任何类的可访问性。</LongDescription>
    <Details>
      <![CDATA[<p>SEI CERT SEC05-J 规则禁止使用反射来增加类、方法或字段的可访问性。如果一个包中的类提供了一个接受 java.lang.reflect.Field 实例作为参数并调用 setter（或 setAccessible()）方法的公共方法，那么这将增加该包中私有、保护或包内可见字段的可访问性。攻击者代码可以调用此方法并将此类字段传递给它以进行更改。应通过使该方法非公共或将包访问权限检查作为防护措施来避免这种情况。</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="MC_OVERRIDABLE_METHOD_CALL_IN_CONSTRUCTOR">
    <ShortDescription>构造函数中调用了可被重写的方法  An overridable method is called from a constructor</ShortDescription>
    <LongDescription>可重写方法 `{2}` 在构造函数 `{1}` 中被调用。</LongDescription>
    <Details>
      <![CDATA[在构造函数中调用可覆盖的方法可能会导致使用未初始化的数据。还可能泄漏部分构建对象的 this 引用。仅应从构造函数中调用静态、最终或私有方法。

请参阅 SEI CERT 规则 <a href="https://wiki.sei.cmu.edu/confluence/display/java/MET05-J.+Ensure+that+constructors+do+not+call+overridable+methods">MET05-J. 确保构造函数不调用可覆盖的方法</a>。]]>
    </Details>
  </BugPattern>

  <BugPattern type="MC_OVERRIDABLE_METHOD_CALL_IN_CLONE">
    <ShortDescription>@Override方法从clone()方法中被调用。  An overridable method is called from the clone() method.</ShortDescription>
    <LongDescription>可被覆盖的方法 {2} 被类 {0} 的方法 clone() 调用。</LongDescription>
    <Details>
      <![CDATA[<p>从<code>clone()</code>方法中调用可覆盖的方法是不安全的，因为子类可以覆盖该方法，从而影响<code>clone()</code>的行为。此外，这也可能使方法观察或修改处于部分初始化状态的克隆对象。只能调用静态、最终或私有方法从<code>clone()</code>方法中。</p>

<p>请参阅SEI CERT规则 <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88487921">MET06-J. 不要在<code>clone()</code>中调用可覆盖的方法</a>。</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="SSD_DO_NOT_USE_INSTANCE_LOCK_ON_SHARED_STATIC_DATA">
    <ShortDescription>在共享静态数据上使用了实例级锁。  Instance level lock was used on a shared static data</ShortDescription>
    <LongDescription>静态字段"{2}"被实例级别的{3}修改。</LongDescription>
    <Details>
      <![CDATA[<p>如果锁或同步方法不是静态的，并且修改了静态字段，这可能会导致共享静态数据在并发访问时受到保护不足。这种情况可以通过两种方式发生：如果同步方法使用了一个非静态锁对象，或者同步方法声明为非静态。这两种情况都无效。最佳解决方案是使用一个私有的静态 final 锁对象来保护共享的静态数据。</p>
<p>参见 SEI CERT 规则 <a href="https://wiki.sei.cmu.edu/confluence/display/java/LCK06-J.+Do+not+use+an+instance+lock+to+protect+shared+static+data">LCK06-J. 不要用实例锁来保护共享静态数据</a>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FL_FLOATS_AS_LOOP_COUNTERS">
    <ShortDescription>不要将浮点变量用作循环计数器  Do not use floating-point variables as loop counters</ShortDescription>
    <LongDescription>使用浮点数作为循环计数器可能导致意外的行为。</LongDescription>
    <Details>
      <![CDATA[<p>不应使用浮点变量作为循环计数器，因为它们不够精确，可能会导致循环不正确。循环计数器是在每次迭代中都会改变并控制何时终止循环的变量。它会在每次迭代中以固定量减少或增加。</p>
<p>请参阅规则 <a href="https://wiki.sei.cmu.edu/confluence/display/java/NUM09-J.+Do+not+use+floating-point+variables+as+loop+counters">NUM09-J</a>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="THROWS_METHOD_THROWS_RUNTIMEEXCEPTION">
    <ShortDescription>方法故意抛出 `RuntimeException`。  Method intentionally throws RuntimeException.</ShortDescription>
    <LongDescription>方法故意抛出 `RuntimeException`。</LongDescription>
    <Details>
      <![CDATA[<p>   方法故意抛出 RuntimeException。<br>   根据 <a href="https://wiki.sei.cmu.edu/confluence/display/java/ERR07-J.+Do+not+throw+RuntimeException%2C+Exception%2C+or+Throwable">SEI CERT ERR07-J 规则</a>，抛出 RuntimeException 可能会导致错误，比如调用者无法检查异常因此不能适当恢复。<br>   此外，抛出 RuntimeException 会强制调用者捕获 RuntimeException，从而违反 <a href="https://wiki.sei.cmu.edu/confluence/display/java/ERR08-J.+Do+not+catch+NullPointerException+or+any+of+its+ancestors">SEI CERT ERR08-J 规则</a>。<br>   请注意，您可以从 Exception 或 RuntimeException 继承并抛出该异常的新实例。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="THROWS_METHOD_THROWS_CLAUSE_BASIC_EXCEPTION">
    <ShortDescription>方法在其throws语句中列出了Exception。  Method lists Exception in its throws clause.</ShortDescription>
    <LongDescription>方法在其抛出条款中列出了Exception。</LongDescription>
    <Details>
      <![CDATA[<p>   方法在 throws 子句中列出了 Exception。<br>     在声明方法时，throws 子句中的异常类型应尽可能具体。因此，在 throws 子句中使用 Exception 会强制调用者要么在其自身的 throws 子句中使用它，要么在一个 try-catch 块中处理它（但不一定包含关于抛出异常的有意义的信息)。<br><br>      如需更多信息，请参阅 <a href="https://wiki.sei.cmu.edu/confluence/display/java/ERR07-J.+Do+not+throw+RuntimeException%2C+Exception%2C+or+Throwable">SEI CERT ERR07-J 规则</a>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="THROWS_METHOD_THROWS_CLAUSE_THROWABLE">
    <ShortDescription>方法在其throws子句中列出了Throwable。  Method lists Throwable in its throws clause.</ShortDescription>
    <LongDescription>方法在其抛出异常声明中列出了Throwable。</LongDescription>
    <Details>
      <![CDATA[<p>
   方法在其 throws 子句中列出了 Throwable。<br>
   在声明方法时，throws 子句中的异常类型应该是尽可能具体的。因此，在 throws 子句中使用 Throwable 会迫使调用者要么在自己的 throws 子句中使用它，要么在 try-catch 块中使用它（但这种情况下不一定包含关于抛出的异常的任何有意义的信息）。<br>
   此外，如此使用 Throwable 在语义上是不良做法，因为 Throwables 包括 Error 类型，而 Error 通常是不可恢复的情况。<br><br>

   更多信息，请参见 <a href="https://wiki.sei.cmu.edu/confluence/display/java/ERR07-J.+Do+not+throw+RuntimeException%2C+Exception%2C+or+Throwable">SEI CERT ERR07-J 规则</a>。
</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="PERM_SUPER_NOT_CALLED_IN_GETPERMISSIONS">
    <ShortDescription>自定义类加载器未调用其超类的getPermissions()方法  Custom class loader does not call its superclass's getPermissions()</ShortDescription>
    <LongDescription>自定义类加载器 {1} 没有调用其超类的 getPermissions() 方法</LongDescription>
    <Details>
      <![CDATA[<p><a href="https://wiki.sei.cmu.edu/confluence/display/java/SEC07-J.+Call+the+superclass%27s+getPermissions%28%29+method+when+writing+a+custom+class+loader">SEI CERT规则SEC07-J</a>要求自定义类加载器在其自身的getPermissions()方法中必须总是调用其超类的getPermissions()方法来初始化他们返回的对象。忽略这一点意味着使用此类自定义类加载器定义的类具有与系统范围的策略文件中指定的权限完全独立的权限，实际上这些类的权限覆盖了它们。</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="USC_POTENTIAL_SECURITY_CHECK_BASED_ON_UNTRUSTED_SOURCE">
    <ShortDescription>基于不受信任来源的潜在安全检查。  Potential security check based on untrusted source.</ShortDescription>
    <LongDescription>在公共方法 `{1}` 中，在进入 `doPrivileged` 块之前调用了非最终方法 `{4}`，并在块内部于位置 `{6}` 也对类实例 `{3}` 的非最终类实例进行了相同调用，该实例位于位置 `{5}`。如果此调用是在进入 `doPrivileged()` 块之前的检查，则可能会不可靠，因为该方法可能接收到恶意派生类的一个实例，而这个派生类重写了此方法以表现出与预期不同的行为。</LongDescription>
    <Details>
      <![CDATA[<p>公共类中的公共方法可能从包外部被调用，这意味着可能会传递未信任的数据。在调用方法之前先进行 doPrivileged 检查其返回值，然后在类内部再次调用同一方法是危险的，如果该方法或其所在的类不是最终类。攻击者可以传入恶意类的实例而不是预期的实例，在这种情况下，这个方法可能会被重写以在不同调用中返回不同的值。例如，一个返回文件路径的方法可能在进入 doPrivileged 块之前返回一个无害的路径进行检查，然后在 doPrivileged 块内部的调用时返回敏感文件。为了避免这种情况，防御性地复制接收到的对象参数，例如使用与形参类型相同的类的拷贝构造函数。这可以确保方法的行为完全符合预期。<p>
<p>请参考 SEI CERT 规则 <a href="https://wiki.sei.cmu.edu/confluence/display/java/SEC02-J.+Do+not+base+security+checks+on+untrusted+sources">SEC02-J. 不要基于未信任的来源进行安全性检查</a>。 </p>]]>
    </Details>
  </BugPattern>
  <!--
  **********************************************************************
   BugCodes
  **********************************************************************
   -->
  <BugCode abbrev="FS">格式字符串问题  Format string problem</BugCode>
  <BugCode abbrev="SKIPPED">分析跳过  Analysis skipped</BugCode>
  <BugCode abbrev="IL">无限循环  Infinite Loop</BugCode>
  <BugCode abbrev="VO">volatile 的使用  Use of volatile</BugCode>
  <BugCode abbrev="UI">不安全的继承  Unsafe inheritance</BugCode>
  <BugCode abbrev="FL">浮点精度的使用  Use of floating point precision</BugCode>
  <BugCode abbrev="TEST">测试原型和未完成的错误模式  Testing prototype and incomplete bug pattern</BugCode>
  <BugCode abbrev="IMSE">可疑的捕获IllegalMonitorStateException异常  Dubious catching of IllegalMonitorStateException</BugCode>
  <BugCode abbrev="CN">克隆模式的不良实现  Bad implementation of cloneable idiom</BugCode>
  <BugCode abbrev="CAA">协变数组赋值  Covariant array assignment</BugCode>
  <BugCode abbrev="AT">可能的原子性违规  Possible atomicity violation</BugCode>
  <BugCode abbrev="FI">不正确地使用终结器  Incorrect use of finalizers</BugCode>
  <BugCode abbrev="ES">使用 == 或 != 检查 String 的相等性  Checking String equality using == or !=</BugCode>
  <BugCode abbrev="ML">更新字段上的同步（可变锁）  Synchronization on updated field (Mutable Lock)</BugCode>
  <BugCode abbrev="UG">未同步的 get 方法，同步的 set 方法  Unsynchronized get method, synchronized set method</BugCode>
  <BugCode abbrev="IO">输入/输出问题  Input/Output problem</BugCode>
  <BugCode abbrev="IC">初始化循环性  Initialization circularity</BugCode>
  <BugCode abbrev="SI">可疑的静态初始化器  Suspicious static initializer</BugCode>
  <BugCode abbrev="MSF">可变的Servlet字段  Mutable servlet field</BugCode>
  <BugCode abbrev="IS">不一致的同步  Inconsistent synchronization</BugCode>
  <BugCode abbrev="Eq">equals() 方法的实现问题  Problems with implementation of equals()</BugCode>
  <BugCode abbrev="Co">`compareTo()`方法的实现问题  Problems with implementation of compareTo()</BugCode>
  <BugCode abbrev="HE">相等的对象必须具有相同的哈希码  Equal objects must have equal hashcodes</BugCode>
  <BugCode abbrev="AM">API滥用  API misuse</BugCode>
  <BugCode abbrev="Dm">可疑的方法使用  Dubious method used</BugCode>
  <BugCode abbrev="Bx">原始值的可疑封装  Questionable Boxing of primitive value</BugCode>
  <BugCode abbrev="UR">在构造函数中未初始化的字段读取  Uninitialized read of field in constructor</BugCode>
  <BugCode abbrev="RR"> Method 忽略了 InputStream.read() 的结果  Method ignores results of InputStream.read()</BugCode>
  <BugCode abbrev="NN">裸露的通知  Naked notify</BugCode>
  <BugCode abbrev="UW">无条件等待  Unconditional wait</BugCode>
  <BugCode abbrev="SP">方法依赖于字段的旋转  Method spins on field</BugCode>
  <BugCode abbrev="DC">双重检查模式  Double-check pattern</BugCode>
  <BugCode abbrev="Wa">不在循环中等待  Wait not in loop</BugCode>
  <BugCode abbrev="No">使用notify()而不是notifyAll()  Using notify() rather than notifyAll()</BugCode>
  <BugCode abbrev="DE">丢弃或忽略了异常  Dropped or ignored exception</BugCode>
  <BugCode abbrev="Ru">方法调用run()  Method invokes run()</BugCode>
  <BugCode abbrev="It">迭代器的定义不正确  Incorrect definition of Iterator</BugCode>
  <BugCode abbrev="SnVI">序列化类缺少版本标识ID  Serializable class with no Version ID</BugCode>
  <BugCode abbrev="Se">Serializable类的定义不正确  Incorrect definition of Serializable class</BugCode>
  <BugCode abbrev="WS">类的 `writeObject()` 方法是同步的，但其他部分不是。  Class's writeObject() method is synchronized but nothing else is</BugCode>
  <BugCode abbrev="RS">类的readObject()方法是同步的  Class's readObject() method is synchronized</BugCode>
  <BugCode abbrev="SC">构造函数调用了Thread.start()  Constructor invokes Thread.start()</BugCode>
  <BugCode abbrev="MS">可变的静态字段  Mutable static field</BugCode>
  <BugCode abbrev="ME">可变枚举字段  Mutable enum field</BugCode>
  <BugCode abbrev="EI">返回数组的方法可能会暴露内部表示。  Method returning array may expose internal representation</BugCode>
  <BugCode abbrev="Nm">混淆的方法名称  Confusing method name</BugCode>
  <BugCode abbrev="SS">未读字段应当是静态的  Unread field should be static</BugCode>
  <BugCode abbrev="UuF">未使用的字段  Unused field</BugCode>
  <BugCode abbrev="UrF">未读字段  Unread field</BugCode>
  <BugCode abbrev="UwF">未定义的字段  Unwritten field</BugCode>
  <BugCode abbrev="SIC">内部类可以改为静态类  Inner class could be made static</BugCode>
  <BugCode abbrev="TLW">等待时持有两个锁  Wait with two locks held</BugCode>
  <BugCode abbrev="RANGE">范围检查  Range checks</BugCode>
  <BugCode abbrev="RV">方法返回值的不良使用  Bad use of return value from method</BugCode>
  <BugCode abbrev="LG">日志问题  Logger problem</BugCode>
  <BugCode abbrev="IA">含糊的调用  Ambiguous invocation</BugCode>
  <BugCode abbrev="HSC">巨大的字符串常量  Huge String constants</BugCode>
  <BugCode abbrev="HRS">HTTP 响应拆分漏洞  HTTP Response splitting vulnerability</BugCode>
  <BugCode abbrev="PT">路径遍历  Path traversal</BugCode>
  <BugCode abbrev="XSS">跨站脚本漏洞  Cross site scripting vulnerability</BugCode>
  <BugCode abbrev="NP">空指针解引用  Null pointer dereference</BugCode>
  <BugCode abbrev="NOISE">无效的随机警告  Bogus random warning</BugCode>
  <BugCode abbrev="RpC">重复的条件判断  Repeated conditional test</BugCode>
  <BugCode abbrev="OS">在所有路径上未关闭流  Stream not closed on all paths</BugCode>
  <BugCode abbrev="PZLA">prefer 零长度数组而非 null 表示没有结果  Prefer zero length arrays to null to indicate no results</BugCode>
  <BugCode abbrev="UCF">无用的控制流  Useless control flow</BugCode>
  <BugCode abbrev="RCN">对空值的冗余比较  Redundant comparison to null</BugCode>
  <BugCode abbrev="UL">锁在所有路径上未释放  Lock not released on all paths</BugCode>
  <BugCode abbrev="RC">质疑使用引用等价性而非调用equals方法  Questionable use of reference equality rather than calling equals</BugCode>
  <BugCode abbrev="EC">比较不兼容的类型进行相等性判断  Comparing incompatible types for equality</BugCode>
  <BugCode abbrev="MWN">匹配错误的wait()或notify()  Mismatched wait() or notify()</BugCode>
  <BugCode abbrev="SA">无用的自我操作  Useless self-operation</BugCode>
  <BugCode abbrev="INT">可疑的整数表达式  Suspicious integer expression</BugCode>
  <BugCode abbrev="BIT">可疑的位逻辑表达式  Suspicious bitwise logical expression</BugCode>
  <BugCode abbrev="LI">未同步的懒初始化  Unsynchronized Lazy Initialization</BugCode>
  <BugCode abbrev="JLM">同步对 java.util.concurrent 中的对象  Synchronization on java.util.concurrent objects</BugCode>
  <BugCode abbrev="UPM">私有方法从不被调用  Private method is never called</BugCode>
  <BugCode abbrev="UMAC">匿名类中的不可调用方法  Uncallable method of anonymous class</BugCode>
  <BugCode abbrev="EI2">存储对可变对象的引用  Storing reference to mutable object</BugCode>
  <BugCode abbrev="NS">非短路布尔运算符的可疑使用  Suspicious use of non-short-circuit boolean operator</BugCode>
  <BugCode abbrev="ODR">在所有路径中未关闭数据库资源  Database resource not closed on all paths</BugCode>
  <BugCode abbrev="SBSC">在循环中使用+操作符进行字符串连接  String concatenation in loop using + operator</BugCode>
  <BugCode abbrev="IIL">可以在循环外部移动的效率低下的代码  Inefficient code which can be moved outside of the loop</BugCode>
  <BugCode abbrev="IIO">不高效地使用 `String.indexOf(String)` 或 `String.lastIndexOf(String)` 方法  Inefficient use of String.indexOf(String) or String.lastIndexOf(String)</BugCode>
  <BugCode abbrev="ITA">使用collection.toArray(new Foo[0])不够高效  Inefficient use of collection.toArray(new Foo[0])</BugCode>
  <BugCode abbrev="SW"> Swing编码规范  Swing coding rules</BugCode>
  <BugCode abbrev="IJU">未正确实现的JUnit测试案例  Improperly implemented JUnit TestCase</BugCode>
  <BugCode abbrev="BOA">错误覆盖适配器  Badly Overridden Adapter</BugCode>
  <BugCode abbrev="SF">switch-case 会默认向下执行（即发生falls through）  Switch case falls through</BugCode>
  <BugCode abbrev="SIO">多余的instanceof判断  Superfluous instanceof</BugCode>
  <BugCode abbrev="BAC">不良的Applet构造函数  Bad Applet Constructor</BugCode>
  <BugCode abbrev="UOE">使用对象的 equals 方法  Use Object Equals</BugCode>
  <BugCode abbrev="STI">可疑的线程中断  Suspicious Thread Interrupted</BugCode>
  <BugCode abbrev="DLS">死掉的局部变量存储  Dead local store</BugCode>
  <BugCode abbrev="IP">被忽略的参数  Ignored parameter</BugCode>
  <BugCode abbrev="MF">遮罩字段  Masked Field</BugCode>
  <BugCode abbrev="WMI">不高效的Map迭代器使用  Inefficient Map Iterator</BugCode>
  <BugCode abbrev="ISC">静态类实例化  Instantiated Static Class</BugCode>
  <BugCode abbrev="DCN">不要捕获空指针异常  Don't Catch NullPointer Exception</BugCode>
  <BugCode abbrev="REC">异常运行时捕获  RuntimeException capture</BugCode>
  <BugCode abbrev="FE">测试浮点数相等性  Test for floating point equality</BugCode>
  <BugCode abbrev="UM">不必要的数学运算常量上  Unnecessary Math on constants</BugCode>
  <BugCode abbrev="UC">无用的代码  Useless code</BugCode>
  <BugCode abbrev="CNT">已知常量的粗略值  Rough value of known constant</BugCode>
  <BugCode abbrev="CD">循环依赖  Circular Dependencies</BugCode>
  <BugCode abbrev="RI">冗余接口  Redundant Interfaces</BugCode>
  <BugCode abbrev="MTIA">多线程实例访问  Multithreaded Instance Access</BugCode>
  <BugCode abbrev="PS">公共信号量  Public Semaphores</BugCode>
  <BugCode abbrev="BSHIFT">不良的位移操作  Bad shift</BugCode>
  <BugCode abbrev="ICAST">整数值的强制转换  Casting from integer values</BugCode>
  <BugCode abbrev="RE">正则表达式  Regular expressions</BugCode>
  <BugCode abbrev="SQL">潜在的SQL问题  Potential SQL Problem</BugCode>
  <BugCode abbrev="WL">可能在错误的对象上进行加锁  Possible locking on wrong object</BugCode>
  <BugCode abbrev="ESync">空的同步块  Empty Synchronized blocks</BugCode>
  <BugCode abbrev="QF">可疑的for循环  Questionable for loops</BugCode>
  <BugCode abbrev="VA">参数变量问题  Vararg problems</BugCode>
  <BugCode abbrev="BC">对象引用的不良类型转换  Bad casts of object references</BugCode>
  <BugCode abbrev="IM">可疑的整数运算  Questionable integer math</BugCode>
  <BugCode abbrev="ST">静态字段的误用  Misuse of static fields</BugCode>
  <BugCode abbrev="JCIP">违反net.jcip注解规定  Violation of net.jcip annotations</BugCode>
  <BugCode abbrev="USELESS_STRING">生成的字符串无用/不具信息性  Useless/non-informative string generated</BugCode>
  <BugCode abbrev="DMI">可疑的方法调用  Dubious method invocation</BugCode>
  <BugCode abbrev="PZ">受Joshua Bloch和Neal Gafter的Programming Puzzlers启发的警告  Warning inspired by Joshua Bloch's and Neal Gafter's Programming Puzzlers</BugCode>
  <BugCode abbrev="SWL">持有锁后睡眠  Sleep with lock held</BugCode>
  <BugCode abbrev="J2EE">Java 2 Enterprise Edition 错误  J2EE error</BugCode>
  <BugCode abbrev="DB">重复分支  Duplicate Branches</BugCode>
  <BugCode abbrev="IMA">无效的成员访问  Inefficient Member Access</BugCode>
  <BugCode abbrev="XFB">XML工厂绕过  XML Factory Bypass</BugCode>
  <BugCode abbrev="USM">无用的子类方法  Useless Subclass Method</BugCode>
  <BugCode abbrev="CI">混淆的继承  Confused Inheritance</BugCode>
  <BugCode abbrev="QBA">可疑的布尔赋值  Questionable Boolean Assignment</BugCode>
  <BugCode abbrev="VR">版本兼容性问题  Version compatibility issue</BugCode>
  <BugCode abbrev="DP">使用doPrivileged方法  Use doPrivileged</BugCode>
  <BugCode abbrev="GC">对泛型集合方法的可疑调用  Suspicious calls to generic collection methods</BugCode>
  <BugCode abbrev="STCAL">静态使用类型 Calendar 或 DateFormat  Static use of type Calendar or DateFormat</BugCode>
  <BugCode abbrev="TQ">类型资格注解使用不一致  Inconsistent use of type qualifier annotations</BugCode>
  <BugCode abbrev="OBL">未履行清理流或资源的义务  Unsatisfied obligation to clean up stream or resource</BugCode>
  <BugCode abbrev="FB">SpotBugs 在一个方法上没有产生预期的警告  SpotBugs did not produce the expected warnings on a method</BugCode>
  <BugCode abbrev="DL">由于在共享对象上进行锁定而导致未意向的争用或可能的死锁  Unintended contention or possible deadlock due to locking on shared objects</BugCode>
  <BugCode abbrev="JUA">JUnit断言中的问题  Problems in JUnit Assertions</BugCode>
  <BugCode abbrev="EOS">未到达流末尾检查  Bad End of Stream check</BugCode>
  <BugCode abbrev="REFLC">反射增强了类的访问性  Reflection increasing accessibility of classes</BugCode>
  <BugCode abbrev="REFLF">反射增强了字段的可访问性  Reflection increasing accessibility of fields</BugCode>
  <BugCode abbrev="MC">可重写方法的调用可能存在风险  Dangerous call to overridable method</BugCode>
  <BugCode abbrev="SSD">不要使用实例锁来保护共享静态数据  Do not use an instance lock to protect shared static data</BugCode>
  <BugCode abbrev="THROWS">异常抛出相关问题  Exception throwing related problems</BugCode>
  <BugCode abbrev="PERM">自定义类加载器未调用其超类的getPermissions()方法。  Custom class loader does not call its superclass's getPermissions()</BugCode>
  <BugCode abbrev="USC">基于不受信任源的潜在安全检查  Potential security check based on untrusted source</BugCode>
</MessageCollection>
