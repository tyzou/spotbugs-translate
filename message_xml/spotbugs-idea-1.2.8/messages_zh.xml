<?xml version="1.0" encoding="UTF-8"?>
<MessageCollection xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="messagecollection.xsd">
  <!--
  **********************************************************************
  Plugin information
  **********************************************************************
  -->
  <Plugin>
    <ShortDescription>Core SpotBugs plugin</ShortDescription>
    <Details>
<![CDATA[
<p>
This plugin contains all of the standard SpotBugs detectors.
</p>
]]>
    </Details>
    <BugsUrl>https://spotbugs.readthedocs.io/en/latest/bugDescriptions.html</BugsUrl>
    <AllBugsUrl>https://spotbugs.readthedocs.io/en/latest/bugDescriptions.html</AllBugsUrl>
  </Plugin>
  <FindBugsMain cmd="addMessages" class="edu.umd.cs.findbugs.AddMessages">
    <Description>将错误的文本描述（例如，漏洞的文字说明）添加到分析结果中  Add msgs (e.g., textual descriptions of bugs) to analysis results</Description>
  </FindBugsMain>
  <FindBugsMain cmd="analyze" class="edu.umd.cs.findbugs.FindBugs2">
    <Description>执行SpotBugs分析  Perform SpotBugs Analysis</Description>
  </FindBugsMain>
  <FindBugsMain cmd="gui" class="edu.umd.cs.findbugs.gui2.Driver">
    <Description>启动SpotBugs图形界面  Launch SpotBugs GUI</Description>
  </FindBugsMain>
  <FindBugsMain cmd="list" class="edu.umd.cs.findbugs.PrintingBugReporter">
    <Description>将分析结果转换为文本形式  Convert analysis results to textual form</Description>
  </FindBugsMain>
  <FindBugsMain cmd="help" class="edu.umd.cs.findbugs.ShowHelp">
    <Description>提供命令帮助  Provide help for commands</Description>
  </FindBugsMain>
  <FindBugsMain cmd="version" class="edu.umd.cs.findbugs.Version">
    <Description>列出SpotBugs版本信息  List SpotBugs version</Description>
  </FindBugsMain>
  <FindBugsMain cmd="filter" class="edu.umd.cs.findbugs.workflow.Filter">
    <Description>过滤分析结果  Filter analysis results</Description>
  </FindBugsMain>
  <FindBugsMain cmd="set" class="edu.umd.cs.findbugs.workflow.SetBugDatabaseInfo">
    <Description>设置项目配置/选项  Set project configuration/options</Description>
  </FindBugsMain>
  <FindBugsMain cmd="history" class="edu.umd.cs.findbugs.workflow.MineBugHistory">
    <Description>多版本分析结果中的详细信息  List details from multi-version analysis results</Description>
  </FindBugsMain>
  <FindBugsMain cmd="union" class="edu.umd.cs.findbugs.workflow.UnionResults">
    <Description>合并来自不相交组件的分析结果  Merge analysis results from disjoint components</Description>
  </FindBugsMain>
  <FindBugsMain cmd="merge" class="edu.umd.cs.findbugs.workflow.Update">
    <Description>将不同版本软件的分析结果结合起来，生成多版本分析结果。  Combine analysis results from different versions of software to produce multi-version analysis results</Description>
  </FindBugsMain>

  <FindBugsMain cmd="dis" class="edu.umd.cs.findbugs.workflow.PrintClass">
    <Description>反编译类文件  Disassemble a class file</Description>
  </FindBugsMain>
  <FindBugsMain cmd="errors" class="edu.umd.cs.findbugs.workflowListErrors">
    <Description>将结果文件中的列表分析错误存储起来  List analysis errors stored in results file</Description>
  </FindBugsMain>

  <!-- On changing this, please also update default cloud id in FindbugsPlugin -->
  <Cloud id="edu.umd.cs.findbugs.cloud.doNothingCloud">
    <Description>(cloud disabled)</Description>
    <Details>Bug reviews are disabled when using this plugin.</Details>
  </Cloud>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.SuppressMultithreaded">
    <Description>抑制多线程正确性问题  Suppress multithreaded correctness issues</Description>
    <Details>抑制所有多线程正确性问题  Suppress all multithreaded correctness issues</Details>
  </PluginComponent>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.SuppressI18N">
    <Description>抑制国际化问题  Suppress internationalization issues</Description>
    <Details>屏蔽所有国际化问题  Suppress all internationalization issues</Details>
  </PluginComponent>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.SelectivelySuppressI18N">
    <Description>在所有但选定的包中抑制国际化问题  Suppress internationalization issues in all but selected packages</Description>
    <Details>除了i18n.properties资源中指定的之外，抑制所有国际化问题。  Suppress all internationalization issues except those specified in the i18n.properties resource</Details>
  </PluginComponent>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.MaxRank14">
    <Description>抑制优先级高于14的所有问题  Suppress all issues with rank higher than 14</Description>
    <Details>抑制优先级高于14的所有问题  Suppress all issues with rank higher than 14</Details>
  </PluginComponent>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.SuppressMalicious">
    <Description>抑制关于恶意代码漏洞的警告  Suppress warnings about vulnerabilities to malicious code</Description>
    <Details>抑制关于恶意代码漏洞的警告  Suppress warnings about vulnerabilities to malicious code</Details>
  </PluginComponent>
  <!--
  **********************************************************************
  Categories (replacing the BugCategoryDescriptions.properties file)
  **********************************************************************
   -->
  <BugCategory category="CORRECTNESS">
    <Description>正确性  Correctness</Description>
    <Abbreviation>C</Abbreviation>
    <Details>可能存在的bug——似乎是编码错误，导致代码很可能不是开发者原本想要的效果。我们力求将误报率保持在较低水平。  Probable bug - an apparent coding mistake resulting in code that was probably not what the developer intended. We strive for a low false positive rate.</Details>
  </BugCategory>
  <BugCategory category="NOISE">
    <Description>无效的随机噪声  Bogus random noise</Description>
    <Abbreviation>N</Abbreviation>
    <Details>无效的随机噪音：旨在在数据挖掘实验中作为控制变量使用，而不是用于查找软件中的实际 bug。  Bogus random noise: intended to be useful     as a control in data mining experiments, not in finding actual bugs in software</Details>
  </BugCategory>
  <BugCategory category="SECURITY">
    <Description>安全性  Security</Description>
    <Abbreviation>S</Abbreviation>
    <Details>以未信任输入的方式使用，这可能会创建一个可远程利用的安全漏洞。  A use of untrusted input in a way that could create a remotely exploitable security vulnerability.</Details>
  </BugCategory>
  <BugCategory category="BAD_PRACTICE">
    <Description>不良实践  Bad practice</Description>
    <Abbreviation>B</Abbreviation>
    <Details>违反推荐和必要的编码实践。例如，哈希码和equals问题、cloneable模式、遗漏的异常、Serializable问题以及滥用finalize方法。我们力求使这种分析准确，尽管某些团队可能并不关心其中的一些不良实践。  Violations of recommended and essential coding practice. Examples include hash code and equals problems, cloneable idiom, dropped exceptions, Serializable problems, and misuse of finalize. We strive to make this analysis accurate, although some groups may not care about some of the bad practices.</Details>
  </BugCategory>
  <BugCategory category="STYLE">
    <Description> dodgy code 检查工具  Dodgy code</Description>
    <Abbreviation>D</Abbreviation>
    <Details>代码混乱、异常或容易导致错误的编写方式。例如，死掉的局部变量存储、switch语句的自动向下传递、未经确认的类型转换以及对已知为null的值进行冗余的非空检查。接受更多的假阳性结果。在SpotBugs的以前版本中，这一类别被称为Style。  Code that is confusing, anomalous, or written in a way that leads itself to errors. Examples include dead local stores, switch fall through, unconfirmed casts, and redundant null check of value known to be null. More false positives accepted. In previous versions of SpotBugs, this category was known as Style.</Details>
  </BugCategory>
  <BugCategory category="PERFORMANCE">
    <Description>性能  Performance</Description>
    <Abbreviation>P</Abbreviation>
    <Details>代码可能不是不正确，但可能是低效的  Code that is not necessarily incorrect but may be inefficient</Details>
  </BugCategory>
  <BugCategory category="MALICIOUS_CODE">
    <Description>恶意代码漏洞  Malicious code vulnerability</Description>
    <Abbreviation>V</Abbreviation>
    <Details>来自不受信任代码的攻击易受攻击的代码  Code that is vulnerable to attacks from untrusted code</Details>
  </BugCategory>
  <BugCategory category="MT_CORRECTNESS">
    <Description>多线程正确性  Multithreaded correctness</Description>
    <Abbreviation>M</Abbreviation>
    <Details>与线程、锁和volatile相关的代码缺陷  Code flaws having to do with threads, locks, and volatiles</Details>
  </BugCategory>
  <BugCategory category="I18N">
    <Description>国际化  Internationalization</Description>
    <Abbreviation>I</Abbreviation>
    <Details>与国际化和区域设置相关的代码缺陷  Code flaws having to do with internationalization and locale</Details>
  </BugCategory>
  <BugCategory category="EXPERIMENTAL">
    <Description>实验性的  Experimental</Description>
    <Abbreviation>X</Abbreviation>
    <Details>实验性的且尚未完全验证的错误模式  Experimental and not fully vetted bug patterns</Details>
  </BugCategory>

  <!--
  **********************************************************************
  Detectors
  **********************************************************************
   -->
  <Detector class="edu.umd.cs.findbugs.detect.ConstructorThrow">
    <Details>
<![CDATA[<p>查找抛出异常的构造函数。 </p>  <p> Finds constructors that throw exceptions. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.OverridingMethodsMustInvokeSuperDetector">
    <Details>
<![CDATA[<p>查找必须调用super的方法覆盖检查。 </p>  <p> Finds overriding methods that must call super. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindRoughConstants">
    <Details>
<![CDATA[<p>查找大约（但不精确）等于已知值（如Math.PI）的常量。 </p>  <p> Finds constants which roughly (but not precisely) equal to known values like Math.PI. </p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InitializeNonnullFieldsInConstructor">
    <Details>
<![CDATA[<p>在构造函数中未写入的非空字段。 </p>  <p> Finds non-null fields that are not written to in constructors. </p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.IntCast2LongAsInstant">
    <Details>
<![CDATA[<p>查找表示自纪元以来的毫秒值的32位整数用法。 </p>  <p> Finds uses of 32-bit values to describe milliseconds since the epoch. </p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainLongInstantfParams">
    <Details>
<![CDATA[<p>构建一个数据库，记录所有以64位值表示自纪元以来的毫秒数的参数。</p>  <p> Builds database of parameters that take a 64 bit value describing milliseconds since the epoch.</p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InconsistentAnnotations">
    <Details>
<![CDATA[<p>此检测器查找直接应用于方法参数的类型限定符与这些方法参数的使用之间的不一致性。 </p>  <p> This detector finds inconsistencies between type qualifiers directly applied to method parameters and uses of those method parameters. </p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.AtomicityProblem">
    <Details>
<![CDATA[<p>查找会对并发抽象进行非原子执行的操作序列（例如，get/put 等）。 </p>  <p> Finds sequences of operations (e.g., get/put) on a concurrent abstraction     that will not be executed atomically.     </p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SynchronizationOnSharedBuiltinConstant">
    <Details>
<![CDATA[<p>此检测器寻找对共享内置常量（如字符串）的同步。</p>  <p> This detector looks for synchronization on a shared built-in constant (such as a String).</p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SynchronizeAndNullCheckField">
    <Details>
<![CDATA[<p>此检测器查找一个在同步操作中作为锁的对象并在后续被空检査的字段。</p>  <p> This detector looks for a field that is synchronized on and then null checked.</p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckImmutableAnnotation">
    <Details>
<![CDATA[<p>查找被标记为net.jcip.annotations.Immutable或javax.annotation.concurrentImmutable的类违反规则的情况。</p>  <p> Looks for violations of the rules for classes annotated as net.jcip.annotations.Immutable or javax.annotation.concurrent.Immutable.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.VarArgsProblems">
    <Details>
<![CDATA[<p>查找来自Java 5可变参数的方法实现中的问题。</p>  <p> Looks for problems with arising from Java 5 varargs.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteJCIPAnnotation">
    <Details>
<![CDATA[<p>记录来自net.jcip.annotations包的注解。</p>  <p> Record annotations from the net.jcip.annotations package.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteDirectlyRelevantTypeQualifiers">
    <Details>
<![CDATA[<p>注意与分析方法相关的类型限定符。</p>  <p> Note the type qualifiers relevant to analyzing a method.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BuildInterproceduralCallGraph">
    <Details>
      <![CDATA[<p>构建调用图。</p>  <p>Builds the interprocedural call graph.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BuildObligationPolicyDatabase">
    <Details>
          <![CDATA[构建FindUnsatisfiedObligation检测器使用的义务类型和方法的数据库。  <p>Builds the database of obligation types and methods used by the FindUnsatisfiedObligation detector.]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteSuppressedWarnings">
    <Details>
<![CDATA[<p>根据使用 edu.umd.cs.findbugs.annotations.NoteSuppressWarnings 注解来抑制警告。</p>  <p> Suppresses warnings based on use of the edu.umd.cs.findbugs.annotations.NoteSuppressWarnings annotation.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteAnnotationRetention">
    <Details>
<![CDATA[<p>记录注解保留策略。</p>  <p> Records annotation retention.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteSyntheticElements">
    <Details>
      <![CDATA[<p>记录合成类、方法、字段等。</p>  <p>Records synthetic classes, methods, fields, etc.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.Methods">
    <Details>
<![CDATA[<p>构建所有分析类中定义的方法的数据库，供其他检测器使用。</p>  <p> Builds a database of all methods defined in analyzed classes, for use by other detectors.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ReflectiveClasses">
    <Details>
<![CDATA[<p>尝试确定哪些类包含对其 .class 对象的常量引用。 </p>  <p> Try to determine which classes have constant references to their .class objects.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CalledMethods">
    <Details>
<![CDATA[<p>为其他检测器构建一个所有调用的方法的数据库。</p>  <p> Builds a database of all methods invoked in analyzed classes, for use by other detectors.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNoSideEffectMethods">
    <Details>
<![CDATA[<p>查找没有副作用，仅仅返回一些值的方法。</p>  <p> Looks for the methods which have no side effect, just return some value.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BuildStringPassthruGraph">
    <Details>
<![CDATA[<p>构建数据库，记录从一个方法传递到另一个方法未发生变化的字符串参数。</p>  <p> Builds the database of string parameters passed from method to method unchanged.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FunctionsThatMightBeMistakenForProcedures">
    <Details>
<![CDATA[<p>查找那些返回该类新实例的方法的不可变类，以防止人们误以为这些方法会修改调用它的那个实例。 </p>  <p> Looks for immutable classes with methods that return new instances of that class, where people might accidentally think those methods mutate the instance they are invoked on. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ConfusionBetweenInheritedAndOuterMethod">
    <Details>
<![CDATA[<p>查找可能混淆的继承方法和外部方法。</p>  <p> Looks for potential confusion between inherited and outer methods.</p>]]>
    </Details>
  </Detector>
    <Detector class="edu.umd.cs.findbugs.detect.NoteCheckReturnValueAnnotations">
    <Details>
<![CDATA[<p>查找注解以检查方法的返回值。 </p>  <p> Looks for annotations to check return values of a method. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SynchronizeOnClassLiteralNotGetClass">
    <Details>
      <![CDATA[<p>查找使用getClass的结果进行同步而不是使用类字面量的代码。 </p>  <p> Looks for code that synchronizes on the results of getClass rather than on class literals. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FieldItemSummary">
    <Details>
      <![CDATA[<p>     该检测器生成关于存储到字段中的信息的汇总。</p>  <p>     This detector produces summary information for what is stored     into fields. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteNonNullAnnotations">
    <Details>
      <![CDATA[<p>查找方法、字段和参数上的 @Nonnull 注解。这些注解可以被 FindNullDeref 检测器用于生成警告，当可能为 null 的值在只应使用非 null 值的上下文中使用时。</p>  <p> Looks for @Nonnull annotations on methods, fields, and parameters. These can be used by the FindNullDeref detector to generate warnings when a possibly-null value is used in a context where only non-null values should be used. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteUnconditionalParamDerefs">
    <Details>
      <![CDATA[<p>分析应用程序中的所有方法，确定哪些方法无条件地解引用参数。这些信息用于后续的分析过程，以找到可能传递空值给这些方法的调用点。</p>
<p>这是一个较慢的检测器。</p>  <p> Analyze all methods in the application to determine which dereference parameters unconditionally.  This information is used in a later analysis pass to find call sites where null values may be passed to those methods. </p> <p> This is a slow detector. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteNonnullReturnValues">
    <Details>
      <![CDATA[<p>分析应用程序中的所有方法以确定哪些方法始终返回非空值。 </p>  <p> Analyze all methods in the application to determine which     methods always return non-null values. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BooleanReturnNull">
    <Details>
<![CDATA[<p>查找返回布尔类型但明确返回null值的方法。</p>  <p> Looks for methods with Boolean return type that return explicit null values.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.OptionalReturnNull">
    <Details>
<![CDATA[<p>查找返回类型为Optional的方法，并检查其是否显式返回null值。</p>  <p> Looks for methods with Optional return type that return explicit null values.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUselessObjects">
    <Details>
<![CDATA[<p>查找无用的对象。</p>  <p> Looks for useless objects.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MutableEnum">
    <Details>
          <![CDATA[<p>检查并警告关于可变枚举字段。</p>  <p> Looks and warns about mutable enum fields.</p>]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BadUseOfReturnValue">
    <Details>
<![CDATA[<p>查找函数返回值在被检查是否非空之后就被丢弃的情况。  </p>  <p> Looks for cases where the return value of a function is discarded after being checked for non-null.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InheritanceUnsafeGetResource">
    <Details>
<![CDATA[<p>查找对 `this.getClass().getResource(...)` 的使用，如果该类被另一个包中的类扩展，则可能会导致意外的结果。 </p>  <p> Looks for uses of this.getClass().getResource(...), which can give unexpected results if the class is extended by a class in another package. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InfiniteRecursiveLoop">
    <Details>
<![CDATA[查找无限递归循环。  <p> Looks for an infinite recursive loop. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InfiniteLoop">
    <Details>
<![CDATA[<p>查找无限循环。</p>  <p> Looks for an infinite loop. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.VolatileUsage">
    <Details>
<![CDATA[<p>查找对 volatile 字段使用的错误模式。 </p>  <p> Looks for bug patterns in the usage of volatile fields. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.EmptyZipFileEntry">
    <Details>
<![CDATA[<p>此检查寻找创建空ZIP文件条目的情况。它是一个较快的检测器。</p>  <p> This looks for creation of empty ZIP file entries. It is a moderately fast detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.UncallableMethodOfAnonymousClass">
    <Details>
<![CDATA[<p>该检测器查找定义了本应但未在超类中重写的方法的匿名内部类。 </p>  <p> This detector looks for anonymous inner classes that define methods that are probably intended to but do not override methods in a superclass. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DontUseEnum">
    <Details>
<![CDATA[<p>检查字段和方法不要使用assert或enum作为名称，因为它们是Java 5中的关键字。</p>  <p>Checks that fields and methods don't use the name assert or enum as they are keywords in Java 5.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.URLProblems">
    <Details>
<![CDATA[<p>在<code>java.net.URL</code>上的equals和hashCode方法会解析域名。因此，这些操作可能会非常昂贵，这个检测器会寻找那些可能调用这些方法的地方。 </p>  <p> The equals and hashCode method on <code>java.net.URL</code> resolve the domain name. As a result, these operations can be very expensive, and this detector looks for places where those methods might be invoked. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FinalizerNullsFields">
    <Details>
<![CDATA[<p>该检测器查找对类的字段进行置空操作的最终化程序。这种做法对垃圾回收器没有任何帮助，置空字段也不会产生任何效果。</p>  <p> This detector looks for finalizers that null out fields of a class. This does not help the garbage collector in any way, the nulling out of fields has no effect. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CrossSiteScripting">
    <Details>
<![CDATA[<p>此检测器寻找明显的跨站脚本漏洞。</p>  <p> This detector looks for obvious/blatant cases of cross site scripting vulnerabilities.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.RepeatedConditionals">
    <Details>
<![CDATA[这个检测器寻找包含重复条件检查的代码，例如 `(x == 5 || x == 5)`。  <p> This detector looks for code containing repeated conditional tests, such as (x == 5 || x == 5).]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.RedundantConditions">
    <Details>
<![CDATA[这个检测器寻找包含无用条件的代码，比如这个表达式中的第二个条件：(x >= 10 && x >= 5)。  <p> This detector looks for code containing useless conditions like the second condition in this expression: (x >= 10 && x >= 5).]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CallToUnsupportedMethod">
    <Details>
<![CDATA[此检测器会查找对不支持方法的调用。  <p> This detector looks for calls to methods that are unsupported.]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FormatStringChecker">
    <Details>
<![CDATA[<p>检查错误的格式字符串。</p>  <p> Checks for incorrect format strings. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.EqualsOperandShouldHaveClassCompatibleWithThis">
    <Details>
<![CDATA[<p>检查equals方法是否检查其操作数是否为一个不是定义equals方法的类兼容的类。 </p>  <p> Checks for equals methods that check for their operand being an instance of a class that is not compatible with the class defining the equals method. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestingGround">
    <Details>
<![CDATA[<p>这个检测器只是一个用于测试新检测器的钩子。通常情况下，这个检测器什么也不做。</p>  <p> This detector is just a hook for testing new detectors. Normally, this detector does nothing.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestingGround2">
    <Details>
<![CDATA[<p>这个检测器只是一个用于测试新检测器的钩子。通常情况下，这个检测器什么都不会做。</p>  <p> This detector is just a hook for testing new detectors. Normally, this detector does nothing.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.LostLoggerDueToWeakReference">
    <Details>
<![CDATA[<p>该检测器查找在使用弱引用持有日志记录器的情况下，代码在OpenJDK 6下行为不同的情况。</p>  <p> This detector finds code that behaves differently under OpenJDK 6, where weak references are used to hold onto Loggers. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestingGround2">
    <Details>
<![CDATA[<p>这个检测器只是一个用于测试新检测器的挂钩。通常情况下，这个检测器什么也不做。</p>  <p> This detector is just a hook for testing new detectors. Normally, this detector does nothing.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.Noise">
    <Details>
<![CDATA[<p>这个检测器生成一个随机信号：基于方法执行的操作的哈希值产生的警告。这些警告是虚假的随机噪声，旨在作为数据挖掘实验中的控制变量，而不是用于查找软件中的实际bug。通常情况下，这个检测器没有任何作用，只是一个测试新检测器的挂钩。</p>  <p> This detector generates a random signal: warnings that are just based on hash values of the operations performed by methods. These warnings are bogus random noise, intended to be useful   as a control in data mining experiments, not in finding actual bugs in software.   This detector is just a hook for testing new detectors. Normally, this detector does nothing.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoiseNullDeref">
    <Details>
<![CDATA[<p>用于检测空指针引用的嘈杂探测器。旨在作为关于警告的有效性或预测能力的实验中的控制使用，而非查找代码中问题的方式。</p>  <p> Noisy detector for null dereferences. Intended to be used as a control in experiments about the validity or predictive ability of warnings, not as a way to find problems in code. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.HugeSharedStringConstants">
    <Details>
<![CDATA[<p>这个检测器查找跨多个类文件中重复的字符串常量。 </p>  <p> This detector looks for string constants that are duplicated across multiple classfiles. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DoInsideDoPrivileged">
    <Details>
<![CDATA[<p>查找应在doPrivileged块中执行的代码。</p>  <p> Looks for code that should be executed inside doPrivileged blocks.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ResolveAllReferences">
    <Details>
<![CDATA[<p>检查所有引用是否可以解析。  </p>  <p> Checks that all references call be resolved.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SwitchFallthrough">
    <Details>
<![CDATA[<p>该检测器查找包含 fall through 的 switch 语句。</p>  <p> This detector looks for switch statements containing fall through. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindFieldSelfAssignment">
    <Details>
<![CDATA[<p>该检测器寻找字段赋值时读取同一字段值的情况。 </p>  <p> This detector looks for places where a field is assigned by reading the value of the same field.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSelfComparison">
    <Details>
<![CDATA[<p>这个检测器查找将值与其自身进行比较的地方。</p>  <p> This detector looks for places where a value is compared with itself.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSelfComparison2">
    <Details>
<![CDATA[<p>该检测器寻找将值与其自身进行比较的地方。</p>  <p> This detector looks for places where a value is compared with itself.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNonShortCircuit">
    <Details>
<![CDATA[<p>此检测器查找可疑的非短路布尔运算符（使用 <code>|</code> 和 <code>&amp;</code> 而不是 <code>||</code> 和 <code>&&amp;&amp;</code>）的用法。</p>  <p> This detector looks for suspicious uses of non-short-circuiting boolean operators (<code>|</code> and <code>&amp;</code> instead of <code>||</code> and <code>&amp;&amp;</code>).</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DontCatchIllegalMonitorStateException">
    <Details>
<![CDATA[<p>此检测器用于查找捕获IllegalMonitorStateException的try-catch块。</p>  <p> This detector looks for try-catch blocks that catch an IllegalMonitorStateException.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindFloatMath">
    <Details>
<![CDATA[<p>该检测器用于查找使用浮点数学运算的情况。它是一个中等速度的检测器。</p>  <p> This detector looks for uses of floating point math. It is a moderately fast detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CloneIdiom">
    <Details>
<![CDATA[<p>该检测器查找违反可克隆类编写惯用法的违规情况。 </p>  <p> This detector looks for violations of the idioms for writing cloneable classes. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MultipleInstantiationsOfSingletons">
    <Details>
<![CDATA[<p>此检测器查找使用单例设计模式编写类时违反惯用法的违规行为。 </p>  <p> This detector looks for violations of the idioms for writing classes using singleton design pattern. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ThrowingExceptions">
    <Details>
<![CDATA[<p>该检测器查找抛出RuntimeException的方法以及在其throws子句中包含Exception或Throwable的方法。 </p>  <p> This detector looks for methods throwing RuntimeException and methods  that have Exception or Throwable in their throws clause. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ComparatorIdiom">
    <Details>
<![CDATA[<p>这个检测器用于查找实现<code>Comparator</code>接口的类编写不符合约定的违规情况。 </p>  <p> This detector looks for violations of the idioms for writing classes that implement <code>Comparator</code>. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DroppedException">
    <Details>
<![CDATA[<p>该检测器查找捕获异常但未对异常进行处理的代码。</p>  <p> This detector looks for code where an exception is caught, but nothing is done to handle the exception.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.LoadOfKnownNullValue">
    <Details>
<![CDATA[<p>查找许多已知为null的值。 </p>  <p> Looks for loads of values known to be null. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DumbMethodInvocations">
    <Details>
<![CDATA[<p>该检测器查找传递给方法的不良参数（例如，substring(0)）。 </p>  <p> This detector looks for bad arguments being passed to methods (e.g., substring(0)). </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DumbMethods">
    <Details>
<![CDATA[<p>该检测器查找无意义方法的调用，例如无参的String构造函数。</p>  <p> This detector looks for calls to pointless methods, such as the no-argument String constructor. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CovariantArrayAssignment">
    <Details>
<![CDATA[<p>该检测器查找类似于 `Object[] array = new String[10]` 的协变数组赋值，可能会在运行时导致 `ArrayStoreException`。 </p>  <p> This detector looks for covariant array assignments like Object[] array = new String[10] which may cause ArrayStoreException at runtime. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NumberConstructor">
    <Details>
<![CDATA[<p>查找对 Number 构造函数带有原始类型参数的调用。 </p>  <p> Looks for calls to Number constructors with primitive arguments. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindDoubleCheck">
    <Details>
<![CDATA[<p>该检测器查找双重锁定实例。 </p>  <p> This detector looks for instances of double-checked locking. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindFinalizeInvocations">
    <Details>
<![CDATA[<p>该检测器寻找对 finalize() 的调用以及其他与最终化相关的问题。  </p>  <p> This detector looks for calls to finalize() and other finalizer-related issues.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindHEmismatch">
    <Details>
<![CDATA[<p>此检测器用于查找 `hashCode()` 和 `equals()` 方法定义中的问题。 </p>  <p> This detector looks for problems in the definition of the hashCode() and equals() methods.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.OverridingEqualsNotSymmetrical">
    <Details>
<![CDATA[<p>查找重写超类中的equals方法，但其中的等价关系可能不是对称的。 </p>  <p> Looks for equals methods that override equals methods in a superclass where the equivalence relationship might not be symmetrical. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNakedNotify">
    <Details>
<![CDATA[<p>该检测器寻找看起来不会修改可变对象状态的对notify()的方法调用。 </p>  <p> This detector looks for calls to notify() that don't seem to modify mutable object state.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindReturnRef">
    <Details>
<![CDATA[<p>此检测器寻找返回可变静态数据的方法。 </p>  <p> This detector looks for methods that return mutable static data. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindRunInvocations">
    <Details>
<![CDATA[<p>此检测器查找对 Thread.run() 的调用。它是一个快速的检测器。</p>  <p> This detector looks for calls to Thread.run().  It is a fast detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSpinLoop">
    <Details>
<![CDATA[<p>该检测器寻找从字段读取循环的循环。</p>  <p> This detector looks for loops that spin reading from a field. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindTwoLockWait">
    <Details>
<![CDATA[<p>此检测器会查找持有两个（或多个）锁后调用wait()的情况。这是一个较慢的检测器。</p>  <p> This detector looks for calls to wait() with two (or more) locks held. It is a slow detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnconditionalWait">
    <Details>
<![CDATA[<p>该检测器查找不在条件语句或循环中的wait()调用。</p>  <p> This detector looks for calls to wait() not in a conditional or loop. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUninitializedGet">
    <Details>
<![CDATA[<p>该检测器查找构造函数中读取未初始化字段的情况。</p>  <p> This detector looks for reads of uninitialized fields in constructors. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnsyncGet">
    <Details>
<![CDATA[<p>该检测器查找获取方法（get）未同步而设置方法（set）已同步的情况。</p>  <p> This detector looks for get and set methods where the get is unsynchronized while the set is synchronized.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InitializationChain">
    <Details>
<![CDATA[<p>该检测器用于查找可能存在循环类初始化依赖关系。</p>  <p> This detector looks for potentially circular class initialization dependencies.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.IteratorIdioms">
    <Details>
<![CDATA[<p>该检测器查找Iterator类定义中存在的问题。</p>  <p> This detector looks for problems in how Iterator classes are defined. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.LockedFields">
    <Details>
<![CDATA[<p>该检测器查找以不一致的锁定方式访问字段的情况。</p>  <p> This detector looks for fields that are accessed in an inconsistent manner with respect to locking.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.EqStringTest">
    <Details>
<![CDATA[<p>此检测器查找使用 == 或 != 运算符比较 String 对象的情况。</p>  <p> This detector looks for comparisons of String objects using the == or != operators.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MutableLock">
    <Details>
<![CDATA[<p>此检测器寻找对从修改字段读取的对象进行同步的操作。  </p>  <p> This detector looks for synchronization on objects read from modified fields.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SynchronizingOnContentsOfFieldToProtectField">
    <Details>
<![CDATA[<p>该检测器寻找对某个字段进行同步以保护对该字段的更新的代码。</p>  <p> This detector looks for code that seems to be synchronizing on a field in order to guard updates of that field. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MutableStaticFields">
    <Details>
<![CDATA[<p>此检测器用于查找可能被恶意代码修改的静态字段。 </p>  <p> This detector looks for static fields that may be modified by malicious code.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.Naming">
    <Details>
<![CDATA[<p>该检测器查找命名可疑的方法。 </p>  <p> This detector looks for suspiciously-named methods.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ReadReturnShouldBeChecked">
    <Details>
<![CDATA[<p>该检测器查找对InputStream.read()或InputStream.skip()的调用，其中返回值被忽略。</p>  <p> This detector looks for calls to InputStream.read() or InputStream.skip() where the return value is ignored.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SerializableIdiom">
    <Details>
<![CDATA[<p>该检测器用于查找实现Serializable接口时可能存在的问题。  </p>  <p> This detector looks for potential problems in the implementation of Serializable classes.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.StartInConstructor">
    <Details>
<![CDATA[<p>这个检测器寻找开始线程的构造函数。  </p>  <p> This detector looks for constructors that start threads.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindBadForLoop">
    <Details>
<![CDATA[<p>此检测器用于查找错误的 for 循环。 </p>  <p> This detector looks for incorrect for loops. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ExplicitSerialization">
    <Details>
<![CDATA[<p>查找显式的序列化，通过readObject和writeObject方法作为证据确认该类确实进行了序列化。 </p>  <p> Looks for explicit serialization via readObject and     writeObject as evidence that this class is, indeed, serialized. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.UnreadFields">
    <Details>
<![CDATA[<p>此检测器查找其值从未被读取的字段。 </p>  <p> This detector looks for fields whose value is never read.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.WaitInLoop">
    <Details>
<![CDATA[<p>该检测器查找不在循环中的wait()调用。</p>  <p> This detector looks for calls to wait() that are not in a loop. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BCPMethodReturnCheck">
    <Details>
<![CDATA[<p>此检测器会查找调用方法但对其返回值可疑地忽略的情况。它是一个较慢的检测器。</p>  <p> This detector looks for calls to methods where the return value is suspiciously ignored.  It is a slow detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindComparatorProblems">
    <Details>
<![CDATA[<p>该检测器用于查找Comparator.compare或Comparable.compareTo实现中的问题。</p>  <p> This detector looks for problems in Comparator.compare or Comparable.compareTo implementation.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNullDeref">
    <Details>
<![CDATA[<p>该检测器寻找可能导致空指针异常的地方，同时也查找对引用值与null的冗余比较。这是一个运行较慢的检测器。</p>  <p> This detector looks for places where a null pointer exception might occur.  It also looks for redundant comparisons of reference values against null.  It is a slow detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNullDerefsInvolvingNonShortCircuitEvaluation">
    <Details>
<![CDATA[<p>这个检测器查找可能会发生空指针异常的地方，并且使用非短路评估会导致常规技术失效。</p>  <p> This detector looks for places where a null pointer exception might occur, and the use of non-short-circuit evaluation causes the usual techniques to fail. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindOpenStream">
    <Details>
<![CDATA[<p>该检测器查找不会从方法中逸出且似乎在所有方法退出路径中都没有被关闭的IO流对象。这是一个较慢的检测器。</p>  <p> This detector looks for IO stream objects which do not escape the method and do not appear to be closed on all paths out of the method. It is a slow detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.PreferZeroLengthArrays">
    <Details>
<![CDATA[<p>该检测器查找返回数组或明确的空引用的方法。在这种情况下，返回空数组通常比返回空引用更可取。</p>  <p> This detector looks for methods that return either arrays or an explicit null reference. Returning a zero length array is generally preferred in this context to returning a null reference. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUselessControlFlow">
    <Details>
<![CDATA[<p>该检测器寻找没有任何效果的控制流语句。</p>  <p> This detector looks for control flow statements which have no effect. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnreleasedLock">
    <Details>
<![CDATA[<p>该检测器查找在方法中获取但未在所有路径上释放的 JSR-166（<code>java.util.concurrent</code>）锁。这是一个较快的检测器。请注意，为了使用此检测器，您需要将 <code>java.util.concurrent</code> 包添加到辅助类路径中（或者分析该包本身）。 </p>  <p> This detector looks for JSR-166 (<code>java.util.concurrent</code>) locks which are acquired, but not released on all paths out of the method.&nbsp; It is a moderately fast detector.&nbsp; Note that in order to use this detector, you need to have the <code>java.util.concurrent</code> package in the auxiliary classpath (or be analyzing the package itself).</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindRefComparison">
    <Details>
<![CDATA[<p>这个检测器会查找使用 == 或 != 操作符比较两个引用值的地方，而类是某种类型（例如 <code>java.lang.String</code>）的情况下，比较引用值通常是一个错误。这是一个运行较慢的检测器。</p>  <p> This detector looks for places where two reference values are compared with the == or != operator, and the class is of a type (such as <code>java.lang.String</code>) where comparing reference values is generally an error.  It is a slow detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindMismatchedWaitOrNotify">
    <Details>
<![CDATA[<p>此检测器会查找未在当前锁定的对象上调用 wait()、notify() 或 notifyAll() 的情况。这是一个较快的检测器。<b>由于该检测器仍在开发中，会产生太多误报，因此已禁用。</b></p>  <p> This detector looks for calls to wait(), notify(), or notifyAll() which do not appear to be made on an object which is currently locked.&nbsp; It is a moderately fast detector.&nbsp; <b>This detector is disabled because it is still under development, and produces too many false positives.</b></p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindEmptySynchronizedBlock">
    <Details>
<![CDATA[<p>该检测器查找空的同步块。</p>  <p> This detector looks for empty synchronized blocks.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindInconsistentSync2">
    <Details>
<![CDATA[<p>此检测器会查找以不一致方式访问的字段，特别是与加锁相关的访问。它是一个较慢的检测器。</p>  <p> This detector looks for fields that are accessed in an inconsistent manner with respect to locking.  It is a slow detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindLocalSelfAssignment2">
    <Details>
<![CDATA[<p>该检测器查找局部变量的自赋值。 </p>  <p> This detector looks for self assignments of local variables. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.IncompatMask">
    <Details>
<![CDATA[<p>此检测器查找可疑的位逻辑表达式。</p>  <p> This detector looks for suspicious bitwise logical expressions. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.LazyInit">
    <Details>
<![CDATA[<p>该检测器用于查找非易失性字段的懒初始化情况。它是一个相对较快的检测器。</p>  <p> This detector looks for lazy field initialization where the field is not volatile.  It is a moderately fast detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindJSR166LockMonitorenter">
    <Details>
<![CDATA[<p>该检测器会查找对JSR166锁进行的普通同步操作。它是一个较快的检测器。</p>  <p> This detector looks for ordinary synchronization performed on JSR166 locks.  It is a moderately fast detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUncalledPrivateMethods">
    <Details>
<![CDATA[<p>该检测器查找从未被调用的私有方法。</p>  <p> This detector looks for private methods that are never called. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.StringConcatenation">
    <Details>
<![CDATA[<p>该检测器查找循环中使用 + 进行字符串连接的情况。</p>  <p> This detector looks for String concatenation in loops using +. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InefficientInitializationInsideLoop">
    <Details>
<![CDATA[<p>该检测器寻找在循环中初始化的对象，可以将其移到循环外部以获得更好的性能。</p>  <p> This detector looks for objects initialized within loop which can be moved outside for better performance. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InefficientIndexOf">
    <Details>
<![CDATA[<p>该检测器查找使用 `String.indexOf(String)` 或 `String.lastIndexOf(String)` 并传递长度为1的常量字符串的代码。建议使用更高效的整数实现方式。这是一个快速检测器。 </p>  <p> This detector looks for code that uses String.indexOf(String) or String.lastIndexOf(String), passing a constant string of length 1. It is recommended to use the more efficient integer implementations. A fast detector. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InefficientToArray">
    <Details>
<![CDATA[<p>该检测器查找使用 toArray() 方法将集合转换为数组但传递了一个零长度数组原型的情况。</p>  <p> This detector looks for code that converts Collections to arrays using the toArray() method that takes a prototype array, passing an array argument which is zero-length. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InvalidJUnitTest">
    <Details>
<![CDATA[<p>该检测器用于查找格式错误的JUnit测试。</p>  <p> This detector looks for JUnit tests that are malformed. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BadlyOverriddenAdapter">
    <Details>
<![CDATA[<p>此检测器查找扩展了Adapter类并用错误的签名重写了Listener方法的代码。 </p>  <p> This detector looks for code that extends an Adapter class and overrides a Listener method with the wrong signature. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BadResultSetAccess">
    <Details>
<![CDATA[<p>此检测器查找对结果集的getXXX或setXXX方法的调用，其中字段索引为0。由于结果集的字段从索引1开始，这总是错误的。 </p>  <p> This detector looks for calls to getXXX or setXXX methods of a result set where the field index is 0. As ResultSet fields start at index 1, this is always a mistake. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SuperfluousInstanceOf">
    <Details>
<![CDATA[<p>该检测器查找使用 instanceof 运算符进行类型检查的情况，而这些判断可以通过静态分析来确定。 </p>  <p> This detector looks for type checks using the instanceof operator where the determination can be done statically. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BadAppletConstructor">
    <Details>
<![CDATA[<p>此检测器查找调用父Applet中依赖于Applet Stub的方法的Applet构造函数。由于Stub直到init方法执行前不久才会初始化，因此这些方法在构造函数中会失败。</p>  <p> This detector looks for Applet constructors that call methods in the parent Applet that rely on the Applet stub. Since this stub isn't initialized until just before the init() method, these methods will fail in the constructor. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SuspiciousThreadInterrupted">
    <Details>
<![CDATA[<p>该检测器会查找从非静态上下文中对 `Thread.interrupted()` 的调用。如果调用的是 `Thread.currentThread().interrupted()`，那么这只是一个无用的操作，直接使用 `Thread.interrupted()` 即可。但是，如果对任意线程对象进行调用，则很可能是一个错误，因为 `interrupted()` 总是针对当前线程调用的。 </p>  <p> This detector looks for calls to Thread.interrupted() from a non-static context. If it is called from Thread.currentThread().interrupted(), then it is just a useless exercise, just use Thread.interrupted(). However if it is called on an arbitrary thread object, it is most probably an error, as interrupted() is always called on the current thread. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSqlInjection">
    <Details>
<![CDATA[<p>该检测器使用数据流分析来查找在SQL语句中用非常量字符串作为参数调用execute方法的情况。</p>  <p> This detector uses data flow analysis to look for invocations of execute methods on SQL statements in which something other than a constant string is passed as an argument. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindDeadLocalStores">
    <Details>
<![CDATA[<p>此检测器查找从未后续读取的局部变量的赋值。它是一个较快的检测器。</p>  <p> This detector looks for assignments to local variables that are never subsequently read. It is a moderately fast detector. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindMaskedFields">
    <Details>
<![CDATA[<p>此检测器用于查找被方法内定义的局部字段屏蔽掉的类级字段。</p>  <p> This detector looks for class level fields that are masked by local fields defined in methods. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.WrongMapIterator">
    <Details>
<![CDATA[<p>该检测器查找使用由 keySet 迭代器检索出的键来访问 Map 入口值的情况。</p>  <p> This detector looks for accessing the value of a Map entry, using a key that was retrieved from a keySet iterator. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InstantiateStaticClass">
    <Details>
<![CDATA[<p>该检测器查找基于仅定义静态方法的类创建对象的代码。</p>  <p> This detector looks for code that creates objects based on classes that only define static methods. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.RuntimeExceptionCapture">
    <Details>
<![CDATA[<p>该检测器查找那些捕获Exception异常，但块中并未抛出Exception异常的catch子句。</p>  <p> This detector looks for catch clauses that catch Exception, when no code in the block throws Exception. </p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DontCatchNullPointerException">
    <Details>
<![CDATA[<p>不应该捕获空指针异常。</p>  <p>Nullpointer exceptions should not be caught.</p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindFloatEquality">
    <Details>
<![CDATA[<p>查找浮点数相等表达式。一个快速检测器。</p>  <p> Looks for floating point equality expressions. A fast detector. </p>]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnsatisfiedObligation">
    <Details>
<![CDATA[<p>此检测器会在方法的所有退出路径中查找未清理的I/O流和数据库资源。这是一个运行较慢的检测器。</p>  <p>This detector looks for I/O streams and database resources that are not cleaned up on all paths out of a method.  This is a slow detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.UnnecessaryMath">
    <Details>
<![CDATA[<p>此检测器查找调用 java.lang.Math 静态方法针对常量值的代码，其中结果值是静态已知的常量。直接使用常量而不是调用方法往往更快，并且有时更准确。</p>  <p>This detector looks for code that calls java.lang.Math static methods on constant values, where the resultant value is a statically known constant. It is faster, and sometimes more accurate, to use the constant instead.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindCircularDependencies">
    <Details>
<![CDATA[<p>此检测器用于查找类之间的循环依赖关系。</p>  <p>This detector looks for circular dependencies among classes. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.RedundantInterfaces">
    <Details>
<![CDATA[<p>此检测器查找声明实现与其超类相同接口的类。如果超类实现了某个接口，那么子类也会自动实现该接口，这是多余的。</p>  <p>This detector looks for classes that declare they implement the same interface as a super class. This is redundant, if a superclass implements an interface, so does the subclass.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MultithreadedInstanceAccess">
    <Details>
<![CDATA[<p>此检测器查找实现Struts框架时可能存在的问题。 </p>  <p>This detector looks for potential problems in implementing the Struts framework. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.PublicSemaphores">
    <Details>
<![CDATA[<p>此检测器会查找公开类，这些类进行了同步操作，并在 <b>this</b> 上使用了 wait()、notify() 或 notifyAll()。这将同步实现暴露为类的公共构件。类的客户端可能会使用该类的一个实例作为其自己的同步对象，从而破坏基础实现。</p>  <p>This detector looks for public classes that synchronize and use wait(), notify() or notifyAll() on <b>this</b>. This exposes a synchronization implementation as a public artifact of the class. Clients of the class may use an instance of the class as its own synchronizing object, and cause havoc to the base implementation. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MethodReturnCheck">
    <Details>
<![CDATA[<p>此检测器会查找调用方法但对其返回值可疑地忽略不使用的代码。 </p>  <p> This detector looks for calls to methods where the return value is suspiciously ignored.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.IDivResultCastToDouble">
    <Details>
<![CDATA[<p>该检测器寻找将整数除法的结果强制转换为double的情况。通常，本意是将整数运算量强制转换为double类型后再进行除法运算。</p>  <p> This detector looks for places where the result of integer division is cast to double. Often, what was meant was to cast the integer operands to double and then perform the division. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindBadCast2">
    <Details>
<![CDATA[<p>该检测器通过数据流分析查找对象引用的不良转换。 </p>  <p> This detector looks for bad casts of object references using data flow analysis. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNonSerializableStoreIntoSession">
    <Details>
<![CDATA[<p>此检测器查找将非序列化对象存储到HTTP会话中的情况。 </p>  <p> This detector looks for stores of non Serializable objects into HTTP sessions. </p>]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindUseOfNonSerializableValue">
    <Details>
<![CDATA[<p>该检测器查找在需要实现序列化的情况下使用非Serializable对象的情况。</p>  <p> This detector looks for uses of non Serializable objects in contexts that require them to be serializable. </p>]]>
    </Details>
  </Detector>


  <Detector class="edu.umd.cs.findbugs.detect.FindNonSerializableValuePassedToWriteObject">
    <Details>
<![CDATA[<p>该检测器会查找传递给ObjectOutput的writeObject方法的非Serializable对象。</p>  <p> This detector looks for non Serializable objects passed to the writeObject method of an ObjectOutput. </p>]]>
    </Details>
  </Detector>



  <Detector class="edu.umd.cs.findbugs.detect.BadSyntaxForRegularExpression">
    <Details>
<![CDATA[<p>此检测器查找无效语法的正则表达式。 </p>  <p> This detector looks for regular expressions that have invalid syntax.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindPuzzlers">
    <Details>
<![CDATA[<p>这个检测器会查找由Joshua Bloch和Neal Gafter在其《Programming Puzzlers》工作中提到的各类小错误。  </p>  <p> This detector looks for miscellaneous small errors mentioned by Joshua Bloch and Neal Gafter in their work on Programming Puzzlers.   </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSleepWithLockHeld">
    <Details>
      <![CDATA[<p>    这个检测器会查找在持有锁的情况下调用Thread.sleep()的情况。它是一个较慢的检测器。</p>  <p>    This detector looks for calls to Thread.sleep() made with    a lock held.  It is a slow detector. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DuplicateBranches">
    <Details>
<![CDATA[这个检测器会查找具有两个分支且代码相同的 if/else 或 switch 语句，从而使测试变得毫无意义。这种情况通常是由复制粘贴两个分支引起的，导致一个分支的逻辑不正确。  <p> This detector looks for if/else or switch statements that have the same code for two branches, thus rendering the test useless. This often is caused by copying and pasting the two branches, causing incorrect logic for the one branch.</p><p></p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InefficientMemberAccess">
    <Details>
<![CDATA[<p>该检测器查找内部类写入拥有类的私有成员变量的情况。在这种情况下，需要使用特殊编译生成的访问者方法来写入此变量。将可见性放宽为受保护将允许直接写入字段。</p>  <p> This detector looks for internal classes that write to member variables of the owning class, when that member variable is private. In this case, a special compiler generated accessor method needs to be used to write to this variable. Relaxing the visibility to protected will allow the field to be directly written.</p> <p></p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.XMLFactoryBypass">
    <Details>
<![CDATA[<p>该检测器寻找直接分配XML接口实现的实例。这将代码绑定到特定的实现，而不是使用提供的工厂模式来创建这些对象。</p>  <p> This detector looks for direct allocations of implementations of XML interfaces. This ties the code to a specific implementation, rather than using the supplied factory pattern to create these objects.</p> <p></p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.UselessSubclassMethod">
    <Details>
      <![CDATA[<p>这个检测器查找子类中实现由超类定义的方法，这些方法仅将参数原封不动地传递给父类的方法。这些方法可以直接删除。</p>  <p> This detector looks for subclasses that implement methods defined in the super class, that only pass the parameters untouched to the parent class method. These methods can just be removed. </p> <p></p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ConfusedInheritance">
    <Details>
      <![CDATA[<p>此检测器会查找声明了 protected 成员的 final 类。由于此类无法派生，成员使用 protected 访问级别是不正确的。应将访问级别改为 public 或 private，以正确表示该字段的意图。这可能是由于未完全将类转变为新的范式而仅改变了类的用途所导致的问题。</p> <p></p>  <p> This detector looks for final classes that declare protected members. As this class cannot be derived from, the use of protected access for members is incorrect. The access should be changed to public or private to represent the correct intention of the field. This was probably caused by a change in use for this class, without completely changing all of the class to the new paradigm. </p> <p></p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.QuestionableBooleanAssignment">
    <Details>
      <![CDATA[<p>该检测器查找将字面量布尔值简单赋值给变量以用于条件表达式的情况。</p>  <p> This detector looks for simple assignments of literal boolean values to variables in conditional expressions. </p> <p></p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainNullReturnValues">
    <Details>
      <![CDATA[<p> TrainNullReturnValues 确定哪些方法可能返回 null，并将这些方法保存到一个文件中。生成的文件可以在后续处理中使用，以提高空指针检测器的精确度。由于这只是训练过程，因此不会报告任何警告。 </p>
<p> 这是一个较慢的检测器。 </p>  <p> TrainNullReturnValues determines which methods may return null and saves them to a file.  The resulting file may be used in a subsequent pass to improve the precision of the null-dereference detector. Since this is just a training pass, no warnings are reported. </p> <p> This is a slow detector. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainUnconditionalDerefParams">
    <Details>
      <![CDATA[<p> TrainUnconditionalParamDerefs 确定哪些方法可能会无条件地反引参参数，并将这些信息保存到一个文件中。生成的文件可以在后续处理中使用，以提高空指针检测的精度。由于这只是训练过程，因此不会报告任何警告。</p>
<p> 这是一个运行较慢的检测器。 </p>  <p> TrainUnconditionalParamDerefs determines which methods may unconditionally dereference parameters and saves them to a file. The resulting file may be used in a subsequent pass to improve the precision of the null-dereference detector. Since this is just a training pass, no warnings are reported. </p> <p> This is a slow detector. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainFieldStoreTypes">
    <Details>
      <![CDATA[<p>TrainFieldStoreTypes分析存储在字段中的类型，并将这些类型存储到数据库中。稍后可以使用该数据库进行更精确的类型分析。</p>
<p>这是一个较慢的检测器。</p>  <p> TrainFieldStoreTypes analyzes the types stored into fields and stores them to a database.  The database may be used in a later pass to make type analysis more precise. </p> <p> This is a slow detector. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainNonNullAnnotations">
    <Details>
      <![CDATA[<p>TrainNonNullAnnotations 收集 @Nonnull 和 @PossiblyNull 注释，并将其存储到数据库文件中。这是一个快速检测器。</p>  <p> TrainNonNullAnnotations collects @Nonnull and @PossiblyNull annotations and stores them to database files.  This is a fast detector. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckCalls">
    <Details>
      <![CDATA[<p>这个检测器仅用于在SpotBugs中调试方法调用解析。不要启用它。</p>  <p>This detector is just for debugging method call resolution in SpotBugs. Don't enable it.</p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindBugsSummaryStats">
    <Details>
<![CDATA[<p>该检测器仅收集分析过程的汇总统计信息。 </p>  <p> This detector just collects summary statistics information about the analysis process. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestASM">
    <Details>
    <![CDATA[<p>     这个检测器是一个示例代码，展示了如何使用ASM字节码分析框架编写SpotBugs检测器。     </p>  <p>     This detector is a code example showing how to write a SpotBugs     detector using the ASM bytecode analysis framework.     </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ViewCFG">
    <Details>
      <![CDATA[<p>从控制流程图（CFG）生成DOT文件。 </p>  <p> Generate DOT files from the CFGs. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnrelatedTypesInGenericContainer">
    <Details>
    <![CDATA[<p>这个检测器会检查传递给接收 <code>java.lang.Object</code> 的泛型集合方法的参数类型，看其是否与集合的参数相关。如果参数的类类型与其相关，则该参数永远不会在集合中出现。例如，如果 `foo` 是一个 `List<String>` 而 `bar` 是一个 `StringBuffer`，那么调用 `foo.contains(bar)` 始终会返回 false。这是一个快速检测器。</p>  <p> This detector looks at the arguments of calls to generic     collection methods that receive a <code>java.lang.Object</code>     to see if the argument's type is related to the collection's     parameter. Arguments with unrelated class types are never going     to be in the collection. For example, if <code>foo</code> is a     <code>List&lt;String&gt;</code> and <code>bar</code> is a     <code>StringBuffer</code>, the call <code>foo.contains(bar)</code>     will always return false. This is a fast detector.     </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.StaticCalendarDetector">
    <Details>
<![CDATA[<p>此检测器会警告关于类型为 java.util.Calendar 或 java.text.DateFormat（及其子类）的静态字段，因为 Calendar 在多线程使用时是不安全的。</p>  <p>This detector warns about static fields of type java.util.Calendar or java.text.DateFormat (and subclasses) because  Calendars are inherently unsafe for multithreaded use. </p>]]>
</Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestDataflowAnalysis">
    <Details>
      <![CDATA[这是一款仅用于测试数据流分析的内部检测器。默认情况下不会启用此功能。  <p>This is an internal detector used only for testing dataflow analyses.     It is not enabled by default.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckTypeQualifiers">
    <Details>
      <![CDATA[<p>检查由JSR-305类型注解指定的属性违规情况。</p>  <p>Check for violations of properties specified by JSR-305   type qualifier annotations.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.AppendingToAnObjectOutputStream">
    <Details>
      <![CDATA[<p>查找向对象输出流追加的尝试。</p>  <p>Looks for an attempt to append to an object output stream.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckExpectedWarnings">
    <Details>
          <![CDATA[<p>检查@ExpectedWarning和@NoWarning注解。此检测器仅用于测试SpotBugs。</p>  <p>Checks @ExpectedWarning and @NoWarning annotations.     This detector is used only for testing SpotBugs.</p>]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DontIgnoreResultOfPutIfAbsent">
    <Details>
          <![CDATA[<p>检查如果忽略了putIfAbsent的方法返回结果，则第二个参数传递的值不应被重复使用。</p>  <p>Checks that if the result of putIfAbsent is ignored, the value passed as the second argument is not reused. </p>]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ReadOfInstanceFieldInMethodInvokedByConstructorInSuperclass">
    <Details>
          <![CDATA[<p>检查从构造方法调用的 superclass 方法。  </p>  <p>Checks for methods invoked from constructors for superclasses.  </p>]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DefaultEncodingDetector">
    <Details>
<![CDATA[<p>检查对使用用户默认平台编码进行字节到字符串（或字符串到字节）转换的方法调用。这可能会导致应用程序的行为在不同平台上有所不同。</p>  <p> Checks for calls to methods which perform a byte to String (or String to byte) conversion using the user's default  platform encoding. This can cause the application behavior to vary between platforms.  </p>]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckRelaxingNullnessAnnotation">
    <Details>
      <![CDATA[<p>检查重写的方法不会放松@Nonnull（变为@CheckForNull）的返回值或@CheckForNull（变为@Nonnull）的参数。</p>  <p>Checks that overriding methods do not relax @Nonnull (made @CheckForNull) on return values   or @CheckForNull (made @Nonnull) on parameters.</p>]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DontAssertInstanceofInTests">
    <Details>
      <![CDATA[<p>JUnit测试中的模式检测器，其中对象的类型通过assertInstanceof操作符进行断言。</p>
<p>应避免使用这种方式，因为不当转换可能导致ClassCastException，其提供的错误原因信息可能比assertInstanceof操作符结果产生的“false is not true”消息更为有用。</p>
<p>这是一个快速的检测器。</p>  <p>Detector for patterns in JUnit tests where the type of an object    is checked by asserting the instanceof operator.</p> <p>    This should be avoided as the ClassCastException that would result    from an improper cast may provide more information regarding the    cause of the error than a "false is not true" message which would    result from asserting the result of the instanceof operator. </p>    <p>It is a fast detector</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindBadEndOfStreamCheck">
    <Details>
      <![CDATA[<p>检测将 java.io.FileInputStream.read() 或 java.io.FileReader.read() 的返回值在与 -1 比较之前进行转换的模式。</p>
<p>    这两个方法都返回 int 类型。如果将 int 转换为 byte（在处理 FileInputStream.read() 时），那么 -1 和字节 0xFF 将变得无法区分。如果将其转换为 char（在处理 FileReader.read() 时），-1 将变为 0xFFFF，而在 Java 中字符是无符号的，因此等于 Character.MAX_VALUE。</p>  <p>Detector for patterns where the return value of java.io.FileInputStream.read() or    java.io.FileReader.read() is converted before checking against -1.</p> <p>    Both methods return an int. If this int is converted to byte (in the case of    FileInputStream.read()) then -1 and the byte 0xFF become indistinguishable.    If it is converted to char (in the case of FileReader.read()) then -1 becomes    0xFFFF which is Character.MAX_VALUE since characters are unsigned in Java. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ReflectionIncreaseAccessibility">
    <Details>
      <![CDATA[<p>检测公共方法在其参数中实例化类的情况。</p>
<p>攻击者可能使用没有公有构造函数的类调用此方法。</p>  <p>Detector for public methods instantiating a class they get in their parameter.</p>    <p> An attacker may invoke this method with a class that has no public constructor.    </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindOverridableMethodCall">
    <Details>
      <![CDATA[<p>检测从构造函数、clone() 方法或 readObject() 方法调用可覆写方法的模式。</p> <p>从构造函数调用可覆写方法可能会导致使用未初始化的数据。从 clone() 或 readObject() 方法调用此类方法是不安全的。</p>  <p>    Detector for patterns where a constructor, a clone(), or a readObject() method    calls an overridable method. </p> <p>    Calling an overridable method from a constructor may result in the use of    uninitialized data. Calling such method from a clone(), or readObject() method    is insecure. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindInstanceLockOnSharedStaticData">
    <Details>
      <![CDATA[<p>检测共享静态数据被实例级别非静态同步方法修改，或者在使用非静态锁对象的同步块中修改的模式。</p>
<p>程序不得使用实例锁来保护静态共享数据，因为当类创建了两个或多个实例时，实例锁是无效的。因此，如果不使用静态锁对象，共享状态将无法得到并发访问的安全保护。</p>  <p>   Detector for patterns where a shared static data is modified by either an instance level non-static synchronized   method, or inside a synchronized block, which used a non-static lock object. </p> <p>    Programs must not use instance locks to protect static shared data because instance locks are ineffective    when two or more instances of the class are created.    Consequently, failure to use a static lock object leaves the shared state unprotected against concurrent access. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DontUseFloatsAsLoopCounters">
    <Details>
      <![CDATA[<p>检查循环计数器中是否使用了浮点数。</p>  <p>Checks for floats in loop counters.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.PermissionsSuper">
    <Details>
      <![CDATA[<p>检查实现接口 java.security.SecureClassLoader 的类中的 getPermissions() 方法。这些方法必须始终调用 super.getPermissions() 来获取对象的初始值，这是它们在末尾返回的对象值。 </p>  <p>Checks method getPermissions() of classes implementing interface    java.security.SecureClassLoader. The methods must always call    super.getPermissions() to get the initial value of the object    which they return at the end.   </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindPotentialSecurityCheckBasedOnUntrustedSource">
    <Details>
      <![CDATA[<p>在进入doPrivileged块之前查找对不可信源的安全检查。</p>  <p>Looks for potential security checks on an untrusted source before entering a    doPrivileged block.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindAssertionsWithSideEffects">
    <Details>
      <![CDATA[查找具有副作用的断言。  <p>Finds assertions with side effects.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindPublicAttributes">
    <Details>
      <![CDATA[<p>此检测器查找公开属性，同时该类的方法也写了这些属性。</p>  <p>This detector looks for public attributes that are also written by the methods of the class.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindVulnerableSecurityCheckMethods">
    <Details>
      <![CDATA[<p>执行安全检查的方法不应被覆盖，因此这些方法必须声明为private或final。否则，恶意子类可以覆盖这些方法并省略检查，从而破坏它们的安全性。</p>  <p>   Methods that perform security checks should be prevented from being overridden, so they must be declared as   private or final. Otherwise, these methods can be compromised when a malicious subclass overrides them   and omits the checks.   </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindArgumentAssertions">
    <Details>
      <![CDATA[<p>查找验证公共方法参数的断言。</p>  <p>Finds assertions that validate public method arguments.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DontReusePublicIdentifiers">
    <Details>
      <![CDATA[检查是否在Java标准库中重复使用了公共标识符、公共实用类、接口或包。  <p>Checks for reuse of public identifiers, public utility classes, interfaces, or  packages in the Java Standard Library.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.UnnecessaryEnvUsage">
    <Details>
      <![CDATA[<p>检查对 System.getenv() 的调用，其中变量也有一个等效的 Java 属性。 </p>  <p>Checks for calls of System.getenv(), where the variable has an equivalent   Java property too. </p>]]>
    </Details>
  </Detector>
  <!--
  **********************************************************************
  BugPatterns
  **********************************************************************
   -->
  <BugPattern type="CT_CONSTRUCTOR_THROW">
    <ShortDescription>避免让构造函数抛出异常。  Be wary of letting constructors throw exceptions.</ShortDescription>
    <LongDescription>在类 {0} 的 {1} 位置抛出异常将离开构造函数。正在构建的对象仍处于部分初始化状态，可能面临最终化器攻击的风险。</LongDescription>
    <Details>
      <![CDATA[<p>在构造函数中抛出异常的类容易受到最终化器攻击。</p>
<p>可以通过声明类为最终类、使用一个声明为最终的空最终化器，或者巧妙地使用私有构造函数来防止最终化器攻击。</p>
<p>更多信息，请参阅 <a href="https://wiki.sei.cmu.edu/confluence/display/java/OBJ11-J.+Be+wary+of+letting+constructors+throw+exceptions"><code>SEI CERT规则 OBJ-11</code></a>。</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="JUA_DONT_ASSERT_INSTANCEOF_IN_TESTS">
    <ShortDescription>在测试中使用 `instanceof` 检查值是不推荐的。  Asserting value of instanceof in tests is not recommended.</ShortDescription>
    <LongDescription>在{3}处的类型{0}断言可能隐藏了有关为何一次转换可能会失败的有用信息。</LongDescription>
    <Details>
      <![CDATA[<p>在测试中进行类型断言并不推荐，因为类转换异常的信息可能比使用 instanceof 断言提供的信息更清楚，能够更好地指示为何使用了错误类型的实例。</p>
<p>当调试由于不良转换而失败的测试时，观察 ClassCastException 的输出可能会更有用，因为它可以提供实际遇到类型的更多信息。在断言类型之前进行转换会导致更不informative 的“false is not true”消息。</p>
<p>如果使用JUnit和hamcrest，可以考虑使用hamcrest中的<a href="https://junit.org/junit4/javadoc/latest/index.html?org/hamcrest/core/IsInstanceOf.html"><code>IsInstanceOf</code></a>类代替。</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="OVERRIDING_METHODS_MUST_INVOKE_SUPER">
    <ShortDescription>使用了@OverridingMethodsMustInvokeSuper注解的方法，但覆盖方法并没有调用超类方法。  Super method is annotated with @OverridingMethodsMustInvokeSuper, but the overriding method isn't calling the super method.</ShortDescription>
    <LongDescription>super方法被标注了@OverridingMethodsMustInvokeSuper注解，但{1}并没有调用超类方法。</LongDescription>
    <Details>
      <![CDATA[<p>@OverridingMethodsMustInvokeSuper 注解了超方法，但覆盖方法并未调用超方法。</p>]]>
    </Details>  </BugPattern>
  <BugPattern type="CNT_ROUGH_CONSTANT_VALUE">
    <ShortDescription>已知常量的近似值被发现  Rough value of known constant found</ShortDescription>
    <LongDescription>找到的近似值为 {3}：{2}</LongDescription>
    <Details>
      <![CDATA[<p>建议使用预定义的库常量以提高代码清晰度和精度。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SKIPPED_CLASS_TOO_BIG">
    <ShortDescription>分析的类太大了。  Class too big for analysis</ShortDescription>
    <LongDescription>{0} 对分析来说太大了。</LongDescription>
    <Details>
      <![CDATA[<p>这个类的大小超过了可以有效处理的范围，并且没有进行全面的错误分析。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NOISE_NULL_DEREFERENCE">
    <ShortDescription>关于空指针解引用的虚假警告  Bogus warning about a null pointer dereference</ShortDescription>
    <LongDescription>在{1}处有关空指针解引用的虚假警告</LongDescription>
    <Details>
      <![CDATA[<p>无效警告。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NOISE_METHOD_CALL">
    <ShortDescription>关于方法调用的虚假警告  Bogus warning about a method call</ShortDescription>
    <LongDescription>在{1}中关于方法调用{2}的虚假警告</LongDescription>
    <Details>
      <![CDATA[<p>无效警告。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NOISE_FIELD_REFERENCE">
    <ShortDescription>关于字段引用的虚假警告  Bogus warning about a field reference</ShortDescription>
    <LongDescription>关于在{1}中引用{2}的无效警告</LongDescription>
    <Details>
      <![CDATA[<p>虚假警告。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NOISE_OPERATION">
    <ShortDescription>关于操作的虚假警告  Bogus warning about an operation</ShortDescription>
    <LongDescription>关于操作 {1} 的虚假警告</LongDescription>
    <Details>
      <![CDATA[<p>虚假警告。</p>]]>
    </Details>
  </BugPattern>
    <BugPattern type="DMI_BIGDECIMAL_CONSTRUCTED_FROM_DOUBLE">
        <ShortDescription>从不是精确表示的double构建的BigDecimal  BigDecimal constructed from double that isn't represented precisely</ShortDescription>
        <LongDescription>从 `{1}` 构造了 `BigDecimal` 对象 `{4}`</LongDescription>
        <Details>
      <![CDATA[<p>这段代码从一个double值创建了一个BigDecimal，但这个转换并不适用于十进制数。例如，有人可能会认为在Java中编写new BigDecimal(0.1)会生成一个等于0.1的BigDecimal（无标度值为1，标度为1），但实际上它等于0.1000000000000000055511151231257827021181583404541015625。你可能应该使用BigDecimal.valueOf(double d)方法，该方法使用double的字符串表示来创建BigDecimal（例如，BigDecimal.valueOf(0.1)生成的是0.1）。 </p>]]>
    </Details>
    </BugPattern>

    <BugPattern type="DMI_DOH">
        <ShortDescription>啊哈！一个毫无意义的方法调用  D'oh! A nonsensical method invocation</ShortDescription>
        <LongDescription>啊哈哈！在{1}中非理性地调用了{2.nameAndSignature}。</LongDescription>
        <Details>
      <![CDATA[<p>这种方法调用没有意义，原因通过检查就能明显看出。 </p>]]>
    </Details>
    </BugPattern>

  <BugPattern type="DMI_VACUOUS_CALL_TO_EASYMOCK_METHOD">
    <ShortDescription>对EasyMock方法的无用/冗余调用  Useless/vacuous call to EasyMock method</ShortDescription>
    <LongDescription>在{1}中对{2}进行了多余/空洞的调用</LongDescription>
    <Details>
      <![CDATA[<p>这个调用没有向EasyMock方法传递任何对象，所以这个调用没有任何效果。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_SCHEDULED_THREAD_POOL_EXECUTOR_WITH_ZERO_CORE_THREADS">
    <ShortDescription>使用零核心线程创建ScheduledThreadPoolExecutor  Creation of ScheduledThreadPoolExecutor with zero core threads</ShortDescription>
    <LongDescription>在{1}中创建核心线程数为零的ScheduledThreadPoolExecutor</LongDescription>
    <Details>
      <![CDATA[<p>(<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html#ScheduledThreadPoolExecutor-int-">Javadoc</a>) 一个核心线程数为零的 ScheduledThreadPoolExecutor 将不会执行任何任务；对最大线程池大小的更改将被忽略。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_FUTILE_ATTEMPT_TO_CHANGE_MAXPOOL_SIZE_OF_SCHEDULED_THREAD_POOL_EXECUTOR">
    <ShortDescription>尝试更改ScheduledThreadPoolExecutor的最大池大小无济于事  Futile attempt to change max pool size of ScheduledThreadPoolExecutor</ShortDescription>
    <LongDescription>在 {1} 中尝试更改 ScheduledThreadPoolExecutor 的最大线程池大小无济于事</LongDescription>
    <Details>
      <![CDATA[<p>(<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html">Javadoc</a>) 尽管 ScheduledThreadPoolExecutor 继承自 ThreadPoolExecutor，但其中一些继承来的调优方法对其并无用处。特别是，因为它作为一个固定大小的线程池使用 corePoolSize 个线程和一个无界队列工作，因此对 maximumPoolSize 的调整没有任何实际效果。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_UNSUPPORTED_METHOD">
    <ShortDescription>调用不支持的方法  Call to unsupported method</ShortDescription>
    <LongDescription>在{1}中调用了不支持的方法{2}</LongDescription>
    <Details>
      <![CDATA[<p>此方法调用的所有目标都会抛出 UnsupportedOperationException。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_EMPTY_DB_PASSWORD">
    <ShortDescription>空数据库密码  Empty database password</ShortDescription>
    <LongDescription>在 {1} 中空数据库密码</LongDescription>
    <Details>
      <![CDATA[<p>此代码使用空密码创建数据库连接，这表明该数据库未受密码保护。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_CONSTANT_DB_PASSWORD">
    <ShortDescription>硬编码的数据库密码  Hardcoded constant database password</ShortDescription>
    <LongDescription>在 {1} 中硬编码了数据库密码常量</LongDescription>
    <Details>
      <![CDATA[<p>这段代码使用硬编码的常量密码建立数据库连接。任何能够访问源代码或编译后代码的人都可以轻松得知密码。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="HRS_REQUEST_PARAMETER_TO_COOKIE">
    <ShortDescription>来自不可信输入的HTTP_cookie  HTTP cookie formed from untrusted input</ShortDescription>
    <LongDescription>来自不可信输入{1}的HTTP_cookie</LongDescription>
    <Details>
      <![CDATA[<p>此代码使用不信任的HTTP参数构建HTTP Cookie。如果将该Cookie添加到HTTP响应中，将会导致HTTP响应拆分漏洞。更多详情请参见 <a href="http://en.wikipedia.org/wiki/HTTP_response_splitting">http://en.wikipedia.org/wiki/HTTP_response_splitting</a>。</p>
<p>SpotBugs 只查找HTTP响应拆分的最明显的情况。如果 SpotBugs 发现了任何此类情况，你很可能还有其他未被报告的漏洞。如果你担心HTTP响应拆分问题，你应该考虑使用商业静态分析或渗透测试工具进行更详细的检查。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="HRS_REQUEST_PARAMETER_TO_HTTP_HEADER">
    <ShortDescription>HTTP 响应拆分漏洞  HTTP Response splitting vulnerability</ShortDescription>
    <LongDescription>在{1}中，直接将HTTP参数写入HTTP头部输出。</LongDescription>
    <Details>
            <![CDATA[<p>此代码直接将HTTP参数写入HTTP标头，这允许发生HTTP响应拆分漏洞。有关更多信息，请参见 <a href="http://en.wikipedia.org/wiki/HTTP_response_splitting">http://en.wikipedia.org/wiki/HTTP_response_splitting</a>。</p>
<p>SpotBugs 只寻找最明显的HTTP响应拆分漏洞。如果 SpotBugs 发现了任何这类问题，你很可能还有其他 SpotBugs 没有报告的漏洞。如果你担心 HTTP 响应拆分问题，你应该认真考虑使用商业静态分析或渗透测试工具。</p>]]>
        </Details>
  </BugPattern>



  <BugPattern type="PT_RELATIVE_PATH_TRAVERSAL">
    <ShortDescription>相对路径遍历在Servlet中的使用  Relative path traversal in servlet</ShortDescription>
    <LongDescription>在{1}中存在相对路径遍历漏洞</LongDescription>
    <Details>
<![CDATA[<p>该软件使用HTTP请求参数构建路径名，并且应该限制在某个受限目录内，但是它未能妥善中和诸如 ".." 这样的序列，这些序列可能会解析为超出该目录的位置。有关更多信息，请参阅 <a href="http://cwe.mitre.org/data/definitions/23.html">http://cwe.mitre.org/data/definitions/23.html</a>。</p>
<p>SpotBugs 只查找最明显的相对路径遍历案例。如果 SpotBugs 发现了任何这类问题，你很可能还有其他未被报告的漏洞。如果你担心相对路径遍历的问题，你应该认真考虑使用商业静态分析或渗透测试工具。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="PT_ABSOLUTE_PATH_TRAVERSAL">
    <ShortDescription>在Servlet中使用绝对路径遍历  Absolute path traversal in servlet</ShortDescription>
    <LongDescription>在{1}中使用了绝对路径遍历</LongDescription>
    <Details>
<![CDATA[<p>该软件使用HTTP请求参数构建文件路径，并且应该限制在某个受限目录内，但并未妥善中和如“/abs/path”这样的绝对路径序列，这些序列可能会解析到超出那个目录的位置。有关更多信息，请参阅 <a href="http://cwe.mitre.org/data/definitions/36.html">http://cwe.mitre.org/data/definitions/36.html</a>。</p>
<p>SpotBugs 只查找最明显的绝对路径遍历漏洞。如果 SpotBugs 发现了任何这类问题，那么你很可能还有其他未被报告的漏洞。如果你关心绝对路径遍历问题，你应该考虑使用商业静态分析或渗透测试工具。</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER">
    <ShortDescription>反射型跨站脚本漏洞  Servlet reflected cross site scripting vulnerability</ShortDescription>
    <LongDescription>在{1}中将HTTP参数写入Servlet输出中。</LongDescription>
    <Details>
<![CDATA[<p>这段代码直接将HTTP参数写入Servlet输出，这允许发生反射型跨站脚本漏洞。更多详细信息请参阅 <a href="http://en.wikipedia.org/wiki/Cross-site_scripting">http://en.wikipedia.org/wiki/Cross-site_scripting</a>。</p>
<p>SpotBugs 只查找最明显的跨站脚本漏洞情况。如果 SpotBugs 发现了任何这样的情况，你几乎肯定还有其他未被报告的跨站脚本漏洞。如果你担心跨站脚本问题，你应该认真考虑使用商业静态分析或渗透测试工具。</p>]]>
    </Details>
  </BugPattern>


  <BugPattern type="XSS_REQUEST_PARAMETER_TO_SEND_ERROR">
    <ShortDescription>错误页面中反射式的跨站脚本漏洞  Servlet reflected cross site scripting vulnerability in error page</ShortDescription>
    <LongDescription>在{1}中，HTTP参数被写入Servlet错误页面。</LongDescription>
    <Details>
<![CDATA[<p>此代码直接将HTTP参数写入服务器错误页面（使用HttpServletResponse.sendError）。回显这种未信任的输入可能会导致反射型跨站脚本漏洞。更多信息请参见<a href="http://en.wikipedia.org/wiki/Cross-site_scripting">http://en.wikipedia.org/wiki/Cross-site_scripting</a>。</p>
<p>SpotBugs 只会寻找最明显的跨站脚本漏洞情况。如果 SpotBugs 发现了任何此类问题，你很可能还有其他 SpotBugs 没有报告的跨站脚本漏洞。如果你担心跨站脚本的问题，你应该考虑使用商业静态分析或渗透测试工具进行更详细的检查。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="XSS_REQUEST_PARAMETER_TO_JSP_WRITER">
    <ShortDescription>反射型跨站脚本漏洞  JSP reflected cross site scripting vulnerability</ShortDescription>
    <LongDescription>直接将HTTP参数写入JSP输出中，在{1.class}中给出了反射型XSS漏洞。</LongDescription>
    <Details>
<![CDATA[<p>此代码直接将HTTP参数写入JSP输出，这允许发生跨站脚本漏洞。有关更多信息，请参阅 <a href="http://en.wikipedia.org/wiki/Cross-site_scripting">http://en.wikipedia.org/wiki/Cross-site_scripting</a>。</p>
<p>SpotBugs 只查找最明显的跨站脚本漏洞案例。如果 SpotBugs 发现了任何此类情况，你几乎肯定还有其他 SpotBugs 没有报告的跨站脚本漏洞。如果你担心跨站脚本问题，你应该认真考虑使用商业静态分析或渗透测试工具。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SW_SWING_METHODS_INVOKED_IN_SWING_THREAD">
    <ShortDescription>某些Swing方法需要在Swing线程中调用  Certain swing methods need to be invoked in Swing thread</ShortDescription>
    <LongDescription>在 `{1}` 中对 swing 方法的调用需要在 Swing 事件线程中执行</LongDescription>
    <Details>
<![CDATA[<p>(来自JDC技术提示): Swing 的 show()、setVisible() 和 pack() 方法会为框架创建相应的 peer。随着 peer 的创建，系统会创建事件分派线程。这使得事情变得复杂，因为事件分派线程可能会在 pack 和 validate 仍在处理时通知监听者。这种情况可能导致两个线程同时遍历基于 Swing 组件的 GUI——这是一个严重的缺陷，可能会导致死锁或其他相关线程问题。pack 调用会使组件被实现。当它们正在被实现（即不一定可见）时，可能会触发事件分派线程上的监听器通知。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IL_INFINITE_LOOP">
    <ShortDescription>一个明显的无限循环  An apparent infinite loop</ShortDescription>
    <LongDescription>在 {1} 中存在明显的无限循环。</LongDescription>
    <Details>
<![CDATA[<p>这个循环似乎没有终止的方式（除了可能抛出异常）。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IL_INFINITE_RECURSIVE_LOOP">
    <ShortDescription>一个明显的无限递归循环  An apparent infinite recursive loop</ShortDescription>
    <LongDescription>在{1}中存在明显的无限递归循环。</LongDescription>
    <Details>
<![CDATA[<p>该方法无条件地调用自身。这似乎表明存在一个无限递归循环，最终会导致栈溢出。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IL_CONTAINER_ADDED_TO_ITSELF">
    <ShortDescription>一个集合将其自身添加到集合中。  A collection is added to itself</ShortDescription>
    <LongDescription>在一个集合中将自己添加了 {1}次</LongDescription>
    <Details>
<![CDATA[<p>集合被添加到它自己中。结果，在计算这个集合的hashCode时会抛出StackOverflowException异常。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="VO_VOLATILE_REFERENCE_TO_ARRAY">
    <ShortDescription>一个volatile引用的数组不会将数组元素视为volatile。  A volatile reference to an array doesn't treat the array elements as volatile</ShortDescription>
    <LongDescription>{1} 是一个易失性引用指向的数组；数组元素是非易失性的。</LongDescription>
    <Details>
<![CDATA[<p>这声明了一个对数组的volatile引用，这可能不是你想要的效果。带有volatile引用的数组，对其引用的读写会以volatile方式处理，但数组元素本身是非volatile的。如果你想让数组元素也成为volatile的，需要使用java.util.concurrent中的原子数组类（从Java 5.0开始提供）。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="VO_VOLATILE_INCREMENT">
    <ShortDescription>对volatile字段的增量操作不是原子性的。  An increment to a volatile field isn't atomic</ShortDescription>
    <LongDescription>在 {1} 中对易变字段 {2} 进行增量操作</LongDescription>
    <Details>
<![CDATA[<p>这段代码会增加或减少一个volatile字段。volatile字段的增加/减少操作不是原子性的。如果多个线程同时对字段进行增加/减少操作，可能会导致某些增加/减少操作丢失。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UI_INHERITANCE_UNSAFE_GETRESOURCE">
    <ShortDescription>如果类被扩展，使用GetResource可能不安全。  Usage of GetResource may be unsafe if class is extended</ShortDescription>
    <LongDescription>在{1}中使用GetResource可能不安全，因为类可能会被扩展。</LongDescription>
    <Details>
<![CDATA[<p>如果此类被另一个包中的类扩展，那么调用 <code>this.getClass().getResource(...)</code> 可能不会得到预期的结果。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_BOOLEAN_RETURN_NULL">
    <ShortDescription>布尔返回类型的方法明确返回了null  Method with Boolean return type returns explicit null</ShortDescription>
    <LongDescription>{1} 返回布尔类型，并显式返回了 null</LongDescription>
    <Details>
       <![CDATA[<p>返回 Boolean.TRUE、Boolean.FALSE 或 null 的方法是一个潜在的问题。此方法可能会像返回 boolean 类型的值一样被调用，并且编译器会自动将 Boolean 值进行拆箱处理。如果返回 null 值，这将会导致 NullPointerException。</p>]]>
       </Details>
  </BugPattern>
  <BugPattern type="NP_OPTIONAL_RETURN_NULL">
    <ShortDescription>带有Optional返回类型的方法显式返回null  Method with Optional return type returns explicit null</ShortDescription>
    <LongDescription>{1}具有Optional返回类型，并显式返回null。</LongDescription>
    <Details>
       <![CDATA[<p>     使用 `Optional` 返回类型（`java.util.Optional` 或 `com.google.common.base.Optional`）始终意味着设计上不希望返回空值。在这种情况下返回 null 将违反合约，并且很可能会破坏客户端代码。</p>]]>
       </Details>
  </BugPattern>
  <BugPattern type="NP_NONNULL_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR">
    <ShortDescription>非空字段未初始化  Non-null field is not initialized</ShortDescription>
    <LongDescription>非空字段 {2.name} 在 {1} 中未被初始化</LongDescription>
    <Details>
       <![CDATA[<p>该字段被标记为非空，但构造函数并未对其进行初始化。该字段可能在构造函数的其他地方进行了初始化，或者总是会在使用前进行初始化。</p>]]>
       </Details>
  </BugPattern>
  <BugPattern type="NP_SYNC_AND_NULL_CHECK_FIELD">
    <ShortDescription>在同一字段上进行同步和空值检查。  Synchronize and null check on the same field.</ShortDescription>
    <LongDescription>在 {1} 中，字段 {2.givenClass} 被同步并检查是否为空。</LongDescription>
    <Details>
<![CDATA[<p>由于该字段进行了同步操作，似乎不太可能为空。如果为空然后进行同步操作将会抛出NullPointerException，并且这种检查就变得毫无意义。最好同步另一个字段。</p>]]>
     </Details>
  </BugPattern>
  <BugPattern type="RpC_REPEATED_CONDITIONAL_TEST">
    <ShortDescription>重复的条件判断  Repeated conditional tests</ShortDescription>
    <LongDescription>在 {1} 中重复了条件测试</LongDescription>
    <Details>
<![CDATA[<p>代码中包含一个条件测试连续进行了两次（例如，<code>x == 0 || x == 0</code>)。也许第二次出现的条件应该是其他东西（例如，<code>x == 0 || y == 0</code>)。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="TESTING">
    <ShortDescription>测试  Testing</ShortDescription>
    <LongDescription>在{1}生成警告信息</LongDescription>
    <Details>
<![CDATA[<p>此错误模式仅由新的、尚未完全实现的错误检测器生成。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="TESTING1">
    <ShortDescription>测试 1  Testing 1</ShortDescription>
    <LongDescription>在 {1} 生成了警告 1</LongDescription>
    <Details>
<![CDATA[<p>这个错误模式仅由新开发的、不完全实现的bug检测器生成。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="TESTING2">
    <ShortDescription>测试 2  Testing 2</ShortDescription>
    <LongDescription>在 {1} 生成了测试警告 2</LongDescription>
    <Details>
<![CDATA[<p>此错误模式仅由新开发、不完全实现的错误检测器生成。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="TESTING3">
    <ShortDescription>测试 3  Testing 3</ShortDescription>
    <LongDescription>在{1}生成了测试警告3</LongDescription>
    <Details>
<![CDATA[<p>这个错误模式仅由新开发的、尚未完全实现的错误检测器生成。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UNKNOWN">
    <ShortDescription>未知的错误模式  Unknown bug pattern</ShortDescription>
    <LongDescription>未知错误模式 BUG_PATTERN 在 {1} 中</LongDescription>
    <Details>
<![CDATA[<p>记录了一个警告，但SpotBugs无法找到该错误模式的描述因此无法对其进行说明。这种情况仅应在SpotBugs或其配置存在bug、或者分析是通过未当前加载的插件生成的情况下发生。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="AM_CREATES_EMPTY_ZIP_FILE_ENTRY">
    <ShortDescription>创建一个空的zip文件条目  Creates an empty zip file entry</ShortDescription>
    <LongDescription>在 {1} 中创建了空的 ZIP 文件条目</LongDescription>
    <Details>
<![CDATA[<p>代码调用了<code>putNextEntry()</code>，紧接着立即调用了<code>closeEntry()</code>。这会导致一个空的Zip文件条目。条目的内容应该在调用<code>putNextEntry()</code>和<code>closeEntry()</code>之间写入到Zip文件中。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="AM_CREATES_EMPTY_JAR_FILE_ENTRY">
    <ShortDescription>创建一个空的jar文件条目  Creates an empty jar file entry</ShortDescription>
    <LongDescription>在 {1} 中创建了空的 jar 文件条目</LongDescription>
    <Details>
<![CDATA[<p>代码调用了<code>putNextEntry()</code>，紧接着立即调用了<code>closeEntry()</code>。这会导致一个空的Jar文件条目。应在调用<code>putNextEntry()</code>和<code>closeEntry()</code>之间向Jar文件写入条目的内容。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IMSE_DONT_CATCH_IMSE">
    <ShortDescription>可疑的捕获IllegalMonitorStateException异常  Dubious catching of IllegalMonitorStateException</ShortDescription>
    <LongDescription>在{1}中可疑地捕获了IllegalMonitorStateException</LongDescription>
    <Details>
<![CDATA[<p>IllegalMonitorStateException 通常仅在您的代码设计存在缺陷时（例如，在不持有对象锁的情况下调用wait或notify）抛出。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FL_MATH_USING_FLOAT_PRECISION">
    <ShortDescription>方法使用浮点精度进行数学运算  Method performs math using floating point precision</ShortDescription>
    <LongDescription>{1} 使用浮点精度进行数学运算</LongDescription>
    <Details>
<![CDATA[<p>该方法使用浮点精度进行数学运算。浮点精度非常不精确。例如，16777216.0f + 1.0f = 16777216.0f。考虑改为使用双精度数学运算。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CAA_COVARIANT_ARRAY_FIELD">
    <ShortDescription>对字段进行协变数组赋值  Covariant array assignment to a field</ShortDescription>
    <LongDescription>类型为{2}的数组被分配给了类型为{3}的字段</LongDescription>
    <Details>
<![CDATA[<p>协变类型数组被分配给一个字段。这可能会导致混淆，并且如果以后该数组中存储了其他类型的引用（如下所示的代码），则可能在运行时引发ArrayStoreException： </p>
<pre><code>Number[] arr = new Integer[10]; arr[0] = 1.0; </code></pre>
<p>考虑更改创建的数组类型或字段类型。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CAA_COVARIANT_ARRAY_LOCAL">
    <ShortDescription>局部变量中的协变数组赋值  Covariant array assignment to a local variable</ShortDescription>
    <LongDescription>类型为 {2} 的数组被赋值给类型为 {3} 的变量</LongDescription>
    <Details>
<![CDATA[<p>协变类型数组被赋值给一个局部变量。这可能会导致混淆，并且如果稍后在该数组中存储其他类型的引用（如以下代码所示），可能会在运行时引发ArrayStoreException：</p>
<pre><code>Number[] arr = new Integer[10]; arr[0] = 1.0; </code></pre>
<p>考虑更改创建的数组类型或局部变量的类型。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CAA_COVARIANT_ARRAY_RETURN">
    <ShortDescription>方法返回了协变数组  Covariant array is returned from the method</ShortDescription>
    <LongDescription>返回类型为{3}的方法返回了类型为{2}的数组。</LongDescription>
    <Details>
<![CDATA[<p>方法返回了协变类型数组。这可能会导致混淆，并且如果调用代码尝试将其他类型的引用存储到返回的数组中，可能会在运行时引发ArrayStoreException。</p>
<p>考虑更改创建的数组类型或方法的返回类型。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CAA_COVARIANT_ARRAY_ELEMENT_STORE">
    <ShortDescription>协变数组中存储了可能不兼容的元素  Possibly incompatible element is stored in covariant array</ShortDescription>
    <LongDescription>类型为 {2} 的值被存储到了元素类型为 {3} 的数组中</LongDescription>
    <Details>
<![CDATA[<p>将值存储到数组中，但该值的类型与数组类型不符。分析显示实际数组类型的范围窄于其变量或字段声明的类型，并且此赋值不满足原始数组类型。这种赋值可能会在运行时导致ArrayStoreException。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CN_IDIOM">
    <ShortDescription>该类实现了Cloneable接口，但未定义或使用clone方法。  Class implements Cloneable but does not define or use clone method</ShortDescription>
    <LongDescription>类 {0} 实现了 Cloneable 但未定义或使用 clone 方法</LongDescription>
    <Details>
<![CDATA[<p>    该类实现了Cloneable接口，但未定义或使用clone方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE">
    <ShortDescription>类定义了clone()但未实现Cloneable接口  Class defines clone() but doesn't implement Cloneable</ShortDescription>
    <LongDescription>{0} 定义了 clone() 但未实现 Cloneable 接口</LongDescription>
    <Details>
<![CDATA[<p>该类定义了clone()方法，但该类并未实现Cloneable。在某些情况下这样做是可以的（例如，您希望控制子类如何进行克隆），但在实施之前请确保这是您的意图。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CN_IDIOM_NO_SUPER_CALL">
    <ShortDescription>克隆方法没有调用super.clone()  clone method does not call super.clone()</ShortDescription>
    <LongDescription>{1} 没有调用 super.clone()</LongDescription>
    <Details>
<![CDATA[<p>这个非最终类定义了一个clone()方法，该方法没有调用super.clone()。如果此类（<i>A</i>）被子类（<i>B</i>）扩展，并且子类<i>B</i>调用了super.clone()，那么<i>B</i>的clone()方法很可能返回一个类型为<i>A</i>的对象，这违反了clone()的标准契约。</p>
<p>如果所有clone()方法都调用super.clone()，则它们可以确保使用Object.clone()，而Object.clone()总是会返回正确类型的对象。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_FUTURE_KEYWORD_USED_AS_IDENTIFIER">
    <ShortDescription>在较新的Java版本中使用关键字作为标识符  Use of identifier that is a keyword in later versions of Java</ShortDescription>
    <LongDescription>{1} 使用了 {2} 作为变量名，在较新的Java版本中这是一个关键字。</LongDescription>
    <Details>
<![CDATA[<p>标识符是预留词汇，在后续版本的Java中被用作关键字，因此您需要更改代码以在后续版本的Java中编译。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_FUTURE_KEYWORD_USED_AS_MEMBER_IDENTIFIER">
    <ShortDescription>在较新的Java版本中使用关键字作为标识符  Use of identifier that is a keyword in later versions of Java</ShortDescription>
    <LongDescription>{1} 与较新版本Java中的关键字冲突</LongDescription>
    <Details>
<![CDATA[<p>这个标识符在较新的Java版本中被用作关键字。此代码以及引用该API的任何代码都需要进行修改，以便在较新的Java版本中编译。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DE_MIGHT_DROP">
    <ShortDescription>方法可能会抛出异常  Method might drop exception</ShortDescription>
    <LongDescription>{1}可能会丢失{2}</LongDescription>
    <Details>
<![CDATA[<p>此方法可能会抛出异常。通常，异常应该以某种方式处理或报告，或者从方法中抛出。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DE_MIGHT_IGNORE">
    <ShortDescription>方法可能忽略异常处理  Method might ignore exception</ShortDescription>
    <LongDescription>{1} 可能会忽略 {2}</LongDescription>
    <Details>
<![CDATA[<p>该方法可能会忽略一个异常。通常，异常应该以某种方式处理或报告，或者从方法中抛出。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DP_DO_INSIDE_DO_PRIVILEGED">
    <ShortDescription>应在 `doPrivileged` 块内调用的方法在此处被调用  Method invoked that should be only be invoked inside a doPrivileged block</ShortDescription>
    <LongDescription>在{1}中调用了{2}，而该方法应该在一个doPrivileged块内被调用。</LongDescription>
    <Details>
<![CDATA[<p>此代码调用了一个需要进行安全权限检查的方法。如果此代码将被授予安全权限，但可能由未获得安全权限的代码来调用，则该调用需要发生在doPrivileged块中。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DP_DO_INSIDE_DO_PRIVILEDGED"> <!-- misspelled for backward compatibility -->
    <ShortDescription>应在doPrivileged块内部调用的方法在此处被调用  Method invoked that should be only be invoked inside a doPrivileged block</ShortDescription>
    <LongDescription>在{1}中调用了{2}，而该方法本应位于doPrivileged块内被调用。</LongDescription>
    <Details>
<![CDATA[<p>该代码调用了需要进行安全权限检查的方法。如果该代码将被授予安全权限，但可能会由未获得安全权限的代码调用，则此调用需要放在一个doPrivileged块中。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED">
    <ShortDescription>类加载器应该仅在 doPrivileged 块内创建  Classloaders should only be created inside doPrivileged block</ShortDescription>
    <LongDescription>{1} 创建了一个 {2} 类加载器，这应该在 doPrivileged 块中执行。</LongDescription>
    <Details>
<![CDATA[<p>这段代码创建了一个类加载器，如果安装了安全管理器，则需要相应的权限。如果该代码可能由没有安全权限的代码调用，那么类加载器的创建需要发生在doPrivileged块内。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="JCIP_FIELD_ISNT_FINAL_IN_IMMUTABLE_CLASS">
    <ShortDescription>不可变类的字段应为 final  Fields of immutable classes should be final</ShortDescription>
    <LongDescription>由于{0}被标记为Immutable，因此{1.givenClass}应该是final的。</LongDescription>
    <Details>
<![CDATA[该类被标注为 `net.jcip.annotationsImmutable` 或 `javax.annotation.concurrent.Immutable`，并且这些注解的要求是所有字段必须是最终变量（final）。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_THREAD_PASSED_WHERE_RUNNABLE_EXPECTED">
    <ShortDescription>线程参数预期为Runnable接口实例  Thread passed where Runnable expected</ShortDescription>
    <LongDescription>在{1}处使用了Thread，预期为Runnable。</LongDescription>
    <Details>
<![CDATA[<p>将一个 Thread 对象作为参数传递给期望接收 Runnable 的方法。这相当不寻常，可能会指示逻辑错误或导致意外行为。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_COLLECTION_OF_URLS">
    <ShortDescription>映射和集合中的URL可能会成为性能瓶颈  Maps and sets of URLs can be performance hogs</ShortDescription>
    <LongDescription>{1} 使用或包含了一组URL的映射或集合，这可能会成为性能瓶颈。</LongDescription>
    <Details>
<![CDATA[<p>该方法或字段使用了URL的Map或Set。由于URL的equals和hashCode方法会执行域名解析，这可能会导致性能下降。更多信息请参阅<a href="http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html">http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html</a>。考虑使用<code>java.net.URI</code>替代。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_BLOCKING_METHODS_ON_URL">
    <ShortDescription>URL的equals和hashCode方法是存在问题的。  The equals and hashCode methods of URL are blocking</ShortDescription>
    <LongDescription>在{1}中调用了{2}，该方法会阻塞以进行域名解析。</LongDescription>
    <Details>
<![CDATA[<p>URL的equals和hashCode方法会执行域名解析，这可能会造成性能上的巨大损失。更多信息请参见<a href="http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html">http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html</a>。考虑使用<code>java.net.URI</code>替代。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION">
    <ShortDescription>无法在没有运行时保留的情况下使用反射检查注解是否存在  Cannot use reflection to check for presence of annotation without runtime retention</ShortDescription>
    <LongDescription>使用反射检查{1}中是否存在没有运行时保留的注解{3}。</LongDescription>
    <Details>
<![CDATA[<p>除非注解本身被标注了 @Retention(RetentionPolicy.RUNTIME) 注解，否则无法通过反射（例如，使用 isAnnotationPresent 方法）来观察该注解。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_EXIT">
    <ShortDescription>方法调用了System.exit(...)  Method invokes System.exit(...)</ShortDescription>
    <LongDescription>{1} 调用了 System.exit(...)，这会关闭整个虚拟机。</LongDescription>
    <Details>
<![CDATA[<p>调用System.exit会关闭整个Java虚拟机。只有在适当的情况下才应该这样做。这样的调用会使你的代码难以被其他代码调用。考虑抛出一个RuntimeException代替。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_RUN_FINALIZERS_ON_EXIT">
    <ShortDescription>方法调用了危险的方法runFinalizersOnExit  Method invokes dangerous method runFinalizersOnExit</ShortDescription>
    <LongDescription>{1} 调用了危险的方法 runFinalizersOnExit</LongDescription>
    <Details>
<![CDATA[<p> <em>绝不要为了任何原因调用System.runFinalizersOnExit或Runtime.runFinalizersOnExit：它们是Java库中最危险的方法之一。——约书亚·布洛赫</em></p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_STRING_CTOR">
    <ShortDescription>方法调用了效率低的 `new String(String)` 构造函数  Method invokes inefficient new String(String) constructor</ShortDescription>
    <LongDescription>{1} 调用了低效的 new String(String) 构造函数</LongDescription>
    <Details>
<![CDATA[<p>使用<code>java.lang.String(String)</code>构造函数会浪费内存，因为这样构造的对象将与作为参数传递的<code>String</code>功能上无法区分。可以直接使用参数<code>String</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_STRING_VOID_CTOR">
    <ShortDescription>方法调用了效率低的 `new String()` 构造函数  Method invokes inefficient new String() constructor</ShortDescription>
    <LongDescription>{1} 调用了不高效的 `new String()` 构造函数</LongDescription>
    <Details>
<![CDATA[<p>使用无参构造函数创建一个新的<code>java.lang.String</code>对象会浪费内存，因为这样创建的对象将与空字符串常量<code>""</code>功能上无法区分。Java保证相同的字符串常量将由同一个<code>String</code>对象表示。因此，你应该直接使用空字符串常量。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_STRING_TOSTRING">
    <ShortDescription>方法在调用String对象的toString()方法。  Method invokes toString() method on a String</ShortDescription>
    <LongDescription>{1} 对字符串调用 `toString()` 方法。</LongDescription>
    <Details>
<![CDATA[调用 `String.toString()` 是多余的。直接使用字符串即可。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_GC">
    <ShortDescription>显式的垃圾回收；除非在基准代码中，否则极其可疑。  Explicit garbage collection; extremely dubious except in benchmarking code</ShortDescription>
    <LongDescription>强制进行垃圾回收；除了基准测试代码之外，在其他情况下都是极其可疑的。</LongDescription>
    <Details>
<![CDATA[<p>代码明确调用了垃圾回收。除了特定的基准测试用途外，这通常是不明智的。</p>
<p>过去，在关闭或 finalize 方法中显式调用垃圾收集器的情况导致了巨大的性能瓶颈。垃圾收集可能非常昂贵。任何会导致成百上千次垃圾收集的情况都会使机器变得非常缓慢。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_BOOLEAN_CTOR">
    <ShortDescription>方法调用了无效的Boolean构造函数；请使用Boolean.valueOf(...)代替。  Method invokes inefficient Boolean constructor; use Boolean.valueOf(...) instead</ShortDescription>
    <LongDescription>{1} 调用了低效的 `Boolean` 构造函数；请使用 `Boolean.valueOf(...)` 代替。</LongDescription>
    <Details>
<![CDATA[<p>创建新的<code>java.lang.Boolean</code>实例会浪费内存，因为<code>Boolean</code>对象是不可变的，并且这种类型只有两个有用的价值。请使用<code>Boolean.valueOf()</code>方法（或Java 5的自动装箱）来替代创建<code>Boolean</code>对象。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_NUMBER_CTOR">
    <ShortDescription>方法调用了效率低的 `Number` 构造函数；改为使用静态的 `valueOf` 方法。  Method invokes inefficient Number constructor; use static valueOf instead</ShortDescription>
    <LongDescription>{1} 调用了低效的 {2} 构造函数；请使用 {3} 代替。</LongDescription>
    <Details>
      <![CDATA[<p>使用 <code>new Integer(int)</code> 确保每次都创建新的对象，而 <code>Integer.valueOf(int)</code> 则允许编译器、类库或 JVM 进行值缓存。使用缓存的值可以避免对象分配，代码运行更快。</p>
<p>-128 和 127 之间的值都有对应的缓存实例，使用 <code>valueOf</code> 比构造函数大约快 3.5 倍。对于常量范围之外的值，两种风格的性能相同。</p>
<p>除非类必须与 Java 5 之前的 JVM 兼容，否则在创建 <code>Long</code>、<code>Integer</code>、<code>Short</code>、<code>Character</code> 和 <code>Byte</code> 的实例时，请使用自动装箱或 <code>valueOf()</code> 方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_FP_NUMBER_CTOR">
    <ShortDescription>方法调用了效率低的浮点Number构造函数；请使用static valueOf代替。  Method invokes inefficient floating-point Number constructor; use static valueOf instead</ShortDescription>
    <LongDescription>{1} 调用了低效的 {2} 构造函数；请使用 {3} 代替。</LongDescription>
    <Details>
      <![CDATA[<p>使用<code>new Double(double)</code>可以确保总是创建新的对象，而<code>Double.valueOf(double)</code>则可以让编译器、类库或JVM进行值缓存。使用缓存的值可以避免对象分配，从而使代码更快。</p>
<p>除非类必须与早于Java 5的JVM兼容，否则在创建<code>Double</code>和<code>Float</code>实例时，请使用自动装箱或<code>valueOf()</code>方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_CONVERT_CASE">
    <ShortDescription>考虑使用带Locale参数的版本调用方法  Consider using Locale parameterized version of invoked method</ShortDescription>
    <LongDescription>在 {1} 中使用未本地化的 String.toUpperCase() 或 String.toLowerCase() 方法</LongDescription>
    <Details>
<![CDATA[<p>正在使用平台默认编码将 String 转换为大写或小写。这在使用国际字符时可能会导致不正确的转换。请改用以下版本：</p>
<ul>
    <li>`String.toUpperCase(Locale l)`</li>
    <li>`String.toLowerCase(Locale l)`</li>
</ul>
<p>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR">
    <ShortDescription>原始值在三元运算符中被拆箱并强制转换  Primitive value is unboxed and coerced for ternary operator</ShortDescription>
    <LongDescription>原始值在{1}中的三元操作符中进行了拆箱和隐式类型转换。</LongDescription>
    <Details>
<![CDATA[<p>在条件三元运算符（`b ? e1 : e2`）的评估过程中，包裹型原始值会进行拆箱并转换为另一种原始类型。根据Java的语言规范，如果`e1`和`e2`是包装数值类型，在执行此操作时，这些值会被拆箱并转换/强制转换为其公共类型（例如，如果`e1`的类型是`Integer`而`e2`的类型是`Float`，那么`e1`将被拆箱，转换为浮点型，并重新封装。参见JLS第15.25节）。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BX_BOXING_IMMEDIATELY_UNBOXED">
    <ShortDescription>原始值被装箱然后立即拆箱  Primitive value is boxed and then immediately unboxed</ShortDescription>
    <LongDescription>原始值被装箱然后立即拆箱在{1}中</LongDescription>
    <Details>
<![CDATA[<p>一个原始类型被装箱，然后立即拆箱。这很可能是因为在一个需要未装箱值的地方手动进行了装箱操作，从而迫使编译器立即撤销了装箱的工作。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BX_UNBOXING_IMMEDIATELY_REBOXED">
    <ShortDescription>装箱值随即拆箱然后重新装箱  Boxed value is unboxed and then immediately reboxed</ShortDescription>
    <LongDescription>在 `{1}` 中，已装箱的值立即进行了拆箱然后重新装箱。</LongDescription>
    <Details>
<![CDATA[<p>一个装箱值被拆箱然后立即重新装箱。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION">
    <ShortDescription>原始值被装箱然后拆箱以执行原始类型转换  Primitive value is boxed then unboxed to perform primitive coercion</ShortDescription>
    <LongDescription>原始值被装箱然后拆箱以在{1}中执行原始类型转换</LongDescription>
    <Details>
<![CDATA[<p>构造了一个原始类型的装箱值，然后立即转换为不同的原始类型（例如：<code>new Double(d).intValue()</code>）。直接进行原始类型的转换即可（例如：<code>(int) d</code>)。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_BOXED_PRIMITIVE_TOSTRING">
    <ShortDescription>方法分配了一个装箱原始类型，仅仅是为了调用toString方法。  Method allocates a boxed primitive just to call toString</ShortDescription>
    <LongDescription>只为了调用toString方法而将原生类型进行装箱在{1}处</LongDescription>
    <Details>
<![CDATA[<p>为了调用toString()方法而对原始类型进行装箱是不必要的，直接使用接受原始值的静态toString形式更为有效。因此，请将：</p>
<table>
<tr><th>替换...</th><th>改用这个...</th></tr>
<tr><td>new Integer(1).toString()</td><td>Integer.toString(1)</td></tr>
<tr><td>new Long(1).toString()</td><td>Long.toString(1)</td></tr>
<tr><td>new Float(1.0).toString()</td><td>Float.toString(1.0)</td></tr>
<tr><td>new Double(1.0).toString()</td><td>Double.toString(1.0)</td></tr>
<tr><td>new Byte(1).toString()</td><td>Byte.toString(1)</td></tr>
<tr><td>new Short(1).toString()</td><td>Short.toString(1)</td></tr>
<tr><td>new Boolean(true).toString()</td><td>Boolean.toString(true)</td></tr>
</table>]]>
    </Details>
  </BugPattern>
    <BugPattern type="DM_BOXED_PRIMITIVE_FOR_PARSING">
    <ShortDescription>使用装箱/拆箱解析原始类型  Boxing/unboxing to parse a primitive</ShortDescription>
    <LongDescription>将原始类型进行装箱/拆箱以解析 {1}</LongDescription>
    <Details>
<![CDATA[<p>从字符串创建一个装箱原始值，仅仅是为了提取未装箱的原始值。直接调用静态parseXXX方法更高效。</p>]]>
    </Details>
  </BugPattern>
    <BugPattern type="DM_BOXED_PRIMITIVE_FOR_COMPARE">
    <ShortDescription>将原始类型装箱以便比较  Boxing a primitive to compare</ShortDescription>
    <LongDescription>原始类型被包装以调用 {2}：请使用 {3} 替代。</LongDescription>
    <Details>
<![CDATA[<p>只是为了调用<code>compareTo()</code>方法而创建了一个装箱原始类型。从Java 1.4起可以使用静态compare方法（对于double和float类型），从Java 7起可以用于其他原始类型，直接在原始类型上工作更高效。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_NEW_FOR_GETCLASS">
    <ShortDescription>方法分配了一个对象，只是为了获取类对象  Method allocates an object, only to get the class object</ShortDescription>
    <LongDescription>{1} 分配了一个对象，只是为了获取类对象</LongDescription>
    <Details>
<![CDATA[<p>此方法只是为了调用其上的getClass()而分配了一个对象，以便获取该对象的Class对象。直接访问类的.class属性更为简单。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_MONITOR_WAIT_ON_CONDITION">
    <ShortDescription>在Condition上调用了wait()方法  Monitor wait() called on Condition</ShortDescription>
    <LongDescription>在{1}中调用了Condition的wait()方法</LongDescription>
    <Details>
      <![CDATA[<p>该方法在<code>java.util.concurrent.locks.Condition</code>对象上调用了<code>wait()</code>。使用<code>Condition</code>接口定义的<code>await()</code>方法之一来等待<code>Condition</code>更为合适。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="RV_01_TO_INT">
    <ShortDescription>随机值在0到1之间会被强制转换为整数0  Random value from 0 to 1 is coerced to the integer 0</ShortDescription>
    <LongDescription>{1} 使用生成一个介于 0 和 1 之间的随机值，然后将该值强制转换为整数 0。</LongDescription>
    <Details>
<![CDATA[<p>一个介于0到1之间的随机值被强制转换为整数值0。你可能希望在将其强制转换为整数之前将随机值乘以其他某个值，或者使用<code>Random.nextInt(n)</code>方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_INVALID_MIN_MAX">
    <ShortDescription>Math.max 和 Math.min 的不当组合使用  Incorrect combination of Math.max and Math.min</ShortDescription>
    <LongDescription>使用 `Math.max` 和 `Math.min` 的错误组合：此代码总是返回 `{2}`</LongDescription>
    <Details>
<![CDATA[<p>这段代码尝试使用类似 `Math.min(0, Math.max(100, value))` 的构造来限制值的范围。然而，这里的常量顺序不正确：应该为 `Math.min(100, Math.max(0, value))`。因此，这段代码始终会产生相同的结果（或者如果值是 NaN，则产生 NaN）。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_NEXTINT_VIA_NEXTDOUBLE">
    <ShortDescription>使用 `Random` 的 `nextInt` 方法而不是 `nextDouble` 来生成随机整数。  Use the nextInt method of Random rather than nextDouble to generate a random integer</ShortDescription>
    <LongDescription>{1} 使用 Random 的 nextDouble 方法生成随机整数；使用 nextInt 更高效。</LongDescription>
    <Details>
<![CDATA[如果 `r` 是一个 `java.util.Random`，你可以使用 `r.nextInt(n)` 来生成从 `0` 到 `n-1` 的随机数，而不是使用 `(int)(r.nextDouble() * n)`。  
nextInt 方法的参数必须为正数。例如，如果你想生成从 -99 到 0 的随机值，可以使用 `-r.nextInt(100)`。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE">
    <ShortDescription>在SQL语句的execute或addBatch方法中传递了非常量字符串  Nonconstant string passed to execute or addBatch method on an SQL statement</ShortDescription>
    <LongDescription>{1} 将非常量的 String 传递给 SQL 语句的 execute 或 addBatch 方法</LongDescription>
    <Details>
<![CDATA[<p>该方法对一个看起来像是动态生成的字符串调用了SQL语句的execute或addBatch方法。建议改为使用预编译语句。这样更高效，并且安全性更高，能减少SQL注入攻击的风险。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING">
    <ShortDescription>一个预编译语句是从一个非常量字符串生成的。  A prepared statement is generated from a nonconstant String</ShortDescription>
    <LongDescription>从非常量字符串{1}生成了预处理语句。</LongDescription>
    <Details>
<![CDATA[<p>该代码从一个非常量字符串创建SQL预处理语句。如果不进行检查，用户提供的污染数据可能会被用于构建这个字符串，从而可能导致预处理语句执行意外且不希望的操作，甚至引发SQL注入攻击。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_USELESS_THREAD">
    <ShortDescription>使用默认的空run方法创建了线程  A thread was created using the default empty run method</ShortDescription>
    <LongDescription>{1} 使用默认的空run方法创建线程</LongDescription>
    <Details>
<![CDATA[<p>此方法创建线程时未指定运行方法，既没有从Thread类派生，也没有传递Runnable对象。这样创建的线程只会浪费时间。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DC_DOUBLECHECK">
    <ShortDescription>可能的字段双重检查  Possible double-check of field</ShortDescription>
    <LongDescription>在 {1} 中可能对 {2} 进行了双重检查。</LongDescription>
    <Details>
<![CDATA[<p>该方法可能包含双检锁的实例。根据Java内存模型的语义，这种模式是不正确的。更多信息，请参阅网页 <a href="http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html">http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html</a>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DC_PARTIALLY_CONSTRUCTED">
    <ShortDescription>部分初始化的对象可能存在问题  Possible exposure of partially initialized object</ShortDescription>
    <LongDescription>在 `{1}` 中可能存在部分初始化的对象暴露问题。</LongDescription>
    <Details>
<![CDATA[<p>看起来这个方法使用了双重检查锁定的懒初始化。虽然字段被正确声明为volatile，但在字段赋值之后，对象的内部结构可能会发生变化，从而另一个线程可能看到一个部分初始化的对象。</p>
<p>要解决这个问题，请考虑首先将对象存储到局部变量中，并在对象完全构造后再将其保存到volatile字段中。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_FINALIZER_NULLS_FIELDS">
    <ShortDescription>最终化器使字段为空  Finalizer nulls fields</ShortDescription>
    <LongDescription>在 `{1.class}` 类的 `finalize` 方法中将 `{3}` 设置为 `null`。</LongDescription>
    <Details>
<![CDATA[<p>此终结器将字段置为空。这通常是一个错误，因为它无助于垃圾回收，而且对象本身很快也会被垃圾回收。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_FINALIZER_ONLY_NULLS_FIELDS">
    <ShortDescription>仅将字段置为null  Finalizer only nulls fields</ShortDescription>
    <LongDescription>{1} 只检查空字段</LongDescription>
    <Details>
<![CDATA[<p>这个finalize方法除了使字段变为null之外没有任何作用。这完全是多余的，并且需要对象先被垃圾回收，然后进行finalize处理，最后再被垃圾回收一次。你应该直接移除finalize方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_PUBLIC_SHOULD_BE_PROTECTED">
    <ShortDescription>最终化器应该声明为受保护的，而不是公共的  Finalizer should be protected, not public</ShortDescription>
    <LongDescription>{1} 是公共的；应为受保护的</LongDescription>
    <Details>
<![CDATA[<p>一个类的 `finalize()` 方法应该具有保护访问权限，而不是公共访问权限。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_EMPTY">
    <ShortDescription>空的finalize方法应该被删除  Empty finalizer should be deleted</ShortDescription>
    <LongDescription>{1} 是空的，应该被删除。</LongDescription>
    <Details>
<![CDATA[<p>空的<code>finalize()</code>方法是没有用的，因此应该删除它们。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_NULLIFY_SUPER">
    <ShortDescription>最终化器取消了超类的最终化器  Finalizer nullifies superclass finalizer</ShortDescription>
    <LongDescription>{1} 使 {2}.finalize() 失效。这是有意为之吗？</LongDescription>
    <Details>
<![CDATA[<p>这个空的<code>finalize()</code>方法明确抵消了其超类定义的任何终结器的效果。除非有特殊需要，否则不会执行超类定义的任何终结器操作，请删除此方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_USELESS">
    <ShortDescription>最终化器除了调用父类的最终化器之外不做其他事情。  Finalizer does nothing but call superclass finalizer</ShortDescription>
    <LongDescription>{1} 除了调用super.finalize()外不做任何事情；删除它。</LongDescription>
    <Details>
<![CDATA[<p>这个 `finalize()` 方法唯一做的事情就是调用超类的 `finalize()` 方法，因此它是多余的。请删除它。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_MISSING_SUPER_CALL">
    <ShortDescription>最终化器未调用超类的最终化器  Finalizer does not call superclass finalizer</ShortDescription>
    <LongDescription>{1} 缺少对 super.finalize() 的调用，因此 {2}.finalize() 也不会被调用。</LongDescription>
    <Details>
<![CDATA[<p>这个 `finalize()` 方法没有调用其父类的 `finalize()` 方法。因此，父类中定义的任何终结器动作将不会被执行。请添加对 `super.finalize()` 的调用。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_EXPLICIT_INVOCATION">
    <ShortDescription>显式调用最终化方法  Explicit invocation of finalizer</ShortDescription>
    <LongDescription>在{1}中显式调用{2}</LongDescription>
    <Details>
<![CDATA[<p>此方法显式调用了对象的 <code>finalize()</code> 方法。因为最终化方法应该只由 VM 一次执行，所以这样做是不好的。</p>
<p>如果一组相关对象开始进行最终化处理，那么 VM 将会同时在不同的线程中对所有可最终化的对象调用 finalize 方法。因此，在类 X 的 finalize 方法中调用 X 所引用的对象的 finalize 方法是一个特别糟糕的想法，因为这些对象可能已经在其他线程中被进行最终化处理了。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS">
    <ShortDescription>等于检查不兼容的操作数  Equals checks for incompatible operand</ShortDescription>
    <LongDescription>{1} 检查操作数是否为 {2.givenClass}</LongDescription>
    <Details>
<![CDATA[<p>此 equals 方法用于检查参数是否为不兼容类型（即既不是定义 equals 方法的类的超类也不是子类的类）。例如，Foo 类的 equals 方法可能看起来像这样：</p>
<pre><code>public boolean equals(Object o) {     if (o instanceof Foo)   return name.equals(((Foo)o).name);     else if (o instanceof String)   return name.equals(o);     else return false; } </code></pre>
<p>这被认为是不良做法，因为它使得实现对称性和传递性的 equals 方法变得非常困难。缺乏这些属性可能会导致一些意想不到的行为。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_DONT_DEFINE_EQUALS_FOR_ENUM">
    <ShortDescription>枚举中定义了协变equals()方法  Covariant equals() method defined for enum</ShortDescription>
    <LongDescription>枚举 {0} 定义了 equals({0.givenClass})</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个枚举，并且枚举的相等性是基于对象身份来定义的。为枚举值定义协变的equals方法是一种极其不良的做法，因为这可能会导致使用协变枚举方法有两个不同的枚举值比较为相等，而在正常情况下比较却不相等。不要这样做。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_SELF_USE_OBJECT">
    <ShortDescription>定义了协变的equals()方法，继承自Object.equals(Object)  Covariant equals() method defined, Object.equals(Object) inherited</ShortDescription>
    <LongDescription>{0} 定义了 equals({0.givenClass}) 方法，并使用了 Object.equals(Object) 方法。</LongDescription>
    <Details>
<![CDATA[<p>该类定义了一个协变版本的<code>equals()</code>方法，但继承了基类<code>java.lang.Object</code>中定义的正常<code>equals(Object)</code>方法。类应该可能定义一个<code>boolean equals(Object)</code>方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_OTHER_USE_OBJECT">
    <ShortDescription>定义了 equals() 方法但未重写 Object 的 equals(Object) 方法  equals() method defined that doesn't override Object.equals(Object)</ShortDescription>
    <LongDescription>{0} 定义了 {1.givenClass} 方法，并使用了 Object.equals(Object) 方法</LongDescription>
    <Details>
<![CDATA[<p>该类定义了一个<code>equals()</code>方法，这个方法没有覆盖基类<code>java.lang.Object</code>中定义的正常<code>equals(Object)</code>方法。类应该 probably 定义一个<code>boolean equals(Object)</code>方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_OTHER_NO_OBJECT">
    <ShortDescription>定义了等于方法（equals()），但未重写 Object 类的 equals(Object) 方法。  equals() method defined that doesn't override equals(Object)</ShortDescription>
    <LongDescription>{0} 定义了 {1.givenClass} 方法，但未重写 equals(Object) 方法</LongDescription>
    <Details>
<![CDATA[<p>这个类定义了一个<code>equals()</code>方法，该方法没有重写基础的<code>java.lang.Object</code>类中定义的<code>equals(Object)</code>方法。相反，它继承了从一个超类继承来的<code>equals(Object)</code>方法。该类应该可能定义一个<code>boolean equals(Object)</code>方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_DOESNT_OVERRIDE_EQUALS">
    <ShortDescription>类没有在超类中重写 equals 方法  Class doesn't override equals in superclass</ShortDescription>
    <LongDescription>{0} 没有覆盖 {2.givenClass}</LongDescription>
    <Details>
<![CDATA[<p>该类继承了一个定义了 equals 方法的类，并添加了字段，但自己并没有定义 equals 方法。因此，此类实例之间的相等性将忽略子类的身份以及附加的字段。请确保这是预期的行为，并且你不需要覆盖 equals 方法。即使你不需要覆盖 equals 方法，也考虑覆写它以说明子类的 equals 方法只是返回调用 super.equals(o) 的结果。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_SELF_NO_OBJECT">
    <ShortDescription>协变定义的 equals() 方法  Covariant equals() method defined</ShortDescription>
    <LongDescription>{0} 定义了 equals({0.givenClass}) 方法，但未定义 equals(Object) 方法。</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个协变版本的<code>equals()</code>方法。为了正确重写<code>java.lang.Object</code>中的<code>equals()</code>方法，<code>equals()</code>的方法参数必须是<code>java.lang.Object</code>类型。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_OVERRIDING_EQUALS_NOT_SYMMETRIC">
    <ShortDescription>`equals` 方法重写了超类中的 `equals`，并且可能不是对称的。  equals method overrides equals in superclass and may not be symmetric</ShortDescription>
    <LongDescription>在 `{2.class.givenClass}` 中，`{1.class}` 重写了 `equals` 方法，并且可能不具备对称性。</LongDescription>
    <Details>
<![CDATA[<p>该类定义了一个equals方法，它覆盖了超类中的equals方法。两个equals方法都在判断两个对象是否相等时使用了<code>instanceof</code>。这存在很大的风险，因为equals方法的对称性非常重要（换句话说，<code>a.equals(b) == b.equals(a)</code>)。如果B是A的子类型，并且A的equals方法检查参数是否为A的实例，而B的equals方法检查参数是否为B的实例，则这些方法定义的等价关系很可能不是对称的。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_GETCLASS_AND_CLASS_CONSTANT">
    <ShortDescription>equal方法在子类型中会失败  equals method fails for subtypes</ShortDescription>
    <LongDescription>{1} 不适用于子类型</LongDescription>
    <Details>
<![CDATA[<p>该类具有一个equals方法，如果被子类继承，则此方法可能会失效。它通过将类字面量与参数的类进行比较来工作（例如，在`Foo`类中，它可能检查`Foo.class == o.getClass()`）。最好检查`this.getClass() == o.getClass()`。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_UNUSUAL">
    <ShortDescription>异常的 equals 方法  Unusual equals method</ShortDescription>
    <LongDescription>{1}是不常见的</LongDescription>
    <Details>
<![CDATA[<p>这个类并没有使用我们识别的任何模式来检查参数类型与*this*对象类型的兼容性。这段代码可能没有问题，但值得进行一下审查。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_COMPARING_CLASS_NAMES">
    <ShortDescription>equals方法比较类名而不是类对象  equals method compares class names rather than class objects</ShortDescription>
    <LongDescription>{1} 比较类名称而不是类对象</LongDescription>
    <Details>
<![CDATA[<p>该类定义了一个equals方法，通过检查两个对象的类名是否相同来判断这两个对象是否为同一类。如果由不同的类加载器加载了同名的类，则会是不同类。只需检查类对象是否相同即可。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_ALWAYS_TRUE">
    <ShortDescription>equals方法总是返回true  equals method always returns true</ShortDescription>
    <LongDescription>始终返回true</LongDescription>
    <Details>
<![CDATA[<p>该类定义了一个总是返回true的equals方法。这很富有想象力，但并不明智。此外，这意味着equals方法不是对称的。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_ALWAYS_FALSE">
    <ShortDescription>equals方法始终返回false  equals method always returns false</ShortDescription>
    <LongDescription>总是返回 false</LongDescription>
    <Details>
<![CDATA[<p>这个类定义了一个总是返回 false 的 equals 方法。这意味着对象不等于自身，并且无法创建此类的对象有用的 Maps 或 Sets。从根本上说，这意味 equals 不具备反射性，这是 equals 方法的要求之一。</p>
<p>期望的语义是对象身份：一个对象等于自身。这是从类 <code>Object</code> 继承的行为。如果你需要覆盖从其他超类继承的 equals 方法，可以使用：</p>
<pre><code>public boolean equals(Object o) {     return this == o; } </code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="HSC_HUGE_SHARED_STRING_CONSTANT">
    <ShortDescription>巨大的字符串常量在多个类文件中被重复使用  Huge string constants is duplicated across multiple class files</ShortDescription>
    <LongDescription>{1} 被初始化为一个长度为 {2} 的字符串常量，并且在其他 {3} 个类文件中也被重复声明。</LongDescription>
    <Details>
      <![CDATA[<p>在一个大的字符串常量被跨多个类文件重复使用。这很可能是因为一个final字段初始化为一个字符串常量，而Java语言规定其他类中对该final字段的所有引用必须被内联到该类文件中。参见<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6447475">JDK Bug 6447475</a>，了解此问题在JDK中的一个实例以及解决它如何减少了JDK的大小达1兆字节。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_ARGUMENT_MIGHT_BE_NULL">
    <ShortDescription>方法未检查传入的参数是否为null  Method does not check for null argument</ShortDescription>
    <LongDescription>{1} 不检查空参数</LongDescription>
    <Details>
      <![CDATA[<p>     该方法的某个参数已被识别为应始终检查是否为空（null），但该参数在未进行前置空检的情况下被解引用。 </p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT">
    <ShortDescription>`equals()` 方法未检查空参数  equals() method does not check for null argument</ShortDescription>
    <LongDescription>{1} 不检查空参数</LongDescription>
    <Details>
      <![CDATA[<p>此实现中的equals(Object)违反了java.lang.Object.equals()定义的合同，因为它没有检查传递的参数是否为null。所有的equals()方法如果传入null值都应该返回false。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="RV_NEGATING_RESULT_OF_COMPARETO">
    <ShortDescription>对compareTo()/compare()方法的结果取反  Negating the result of compareTo()/compare()</ShortDescription>
    <LongDescription>{1} 反转了 {2} 的返回值。</LongDescription>
    <Details>
<![CDATA[<p>该代码对 compareTo 或 compare 方法的返回值进行了取反操作。这是一种值得怀疑或不良的编程实践，因为如果返回值是 Integer.MIN_VALUE，取反操作将不会改变结果的符号。你可以通过反转操作数的顺序而不是取反结果来实现相同的目的。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CO_COMPARETO_RESULTS_MIN_VALUE">
    <ShortDescription>`compareTo()`/`compare()` 方法返回 `Integer.MIN_VALUE`  compareTo()/compare() returns Integer.MIN_VALUE</ShortDescription>
    <LongDescription>{1}返回Integer.MIN_VALUE，无法对其进行取反操作。</LongDescription>
    <Details>
<![CDATA[在某些情况下，这个 `compareTo` 或者 `compare` 方法返回常量 `Integer.MIN_VALUE`，这是一种非常糟糕的实践。比较方法返回值唯一关心的是结果的符号。但是人们有时会取 `compareTo` 返回值的相反数，期望这样可以改变结果的符号。然而，这仅在返回值不是 `Integer.MIN_VALUE` 时才有效。因此，直接返回 -1 而不是 `Integer.MIN_VALUE`。]]>
    </Details>
  </BugPattern>
  <BugPattern type="CO_COMPARETO_INCORRECT_FLOATING">
    <ShortDescription>`compareTo()`/`compare()` 不正确地处理浮点值（如float或double）  compareTo()/compare() incorrectly handles float or double value</ShortDescription>
    <LongDescription>{1} 不正确地处理了 {2} 值</LongDescription>
    <Details>
<![CDATA[<p>该方法使用类似于以下模式比较双精度或浮点值：val1 > val2 ? 1 : val1 < val2 ? -1 : 0。这种模式在处理 -0.0 和 NaN 值时会出错，可能导致排序结果不正确或集合损坏（如果将比较值用作键）。考虑使用 Double.compare 或 Float.compare 静态方法，这些方法可以正确处理所有特殊情况。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CO_SELF_NO_OBJECT">
    <ShortDescription>可变的compareTo()方法定义  Covariant compareTo() method defined</ShortDescription>
    <LongDescription>{0} 定义了 compareTo({0.givenClass}) 方法，但未定义 compareTo(Object) 方法。</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个协变版本的 `compareTo()` 方法。为了正确重写 `Comparable` 接口中的 `compareTo()` 方法，`compareTo()` 的参数必须是 `java.lang.Object` 类型。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_SIGNATURE_DECLARES_HASHING_OF_UNHASHABLE_CLASS">
    <ShortDescription>签名声明了在哈希构造中使用不可哈希的类。  Signature declares use of unhashable class in hashed construct</ShortDescription>
    <LongDescription>在 `{1}` 中，`{2}` 没有定义 `hashCode()` 方法，但被用于哈希上下文中。</LongDescription>
    <Details>
<![CDATA[<p>在一个泛型签名中声明的方法、字段或类使用了非哈希类，而在需要哈希类的上下文中却要求使用哈希类。一个声明了 equals 方法但继承了 Object 类中的 hashCode() 方法的类是不可哈希的，因为等价的对象必须具有相同的哈希码。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_USE_OF_UNHASHABLE_CLASS">
    <ShortDescription>在散列数据结构中未使用带有 `hashCode()` 方法的类  Use of class without a hashCode() method in a hashed data structure</ShortDescription>
    <LongDescription>在 `{1}` 中，`{2}` 没有定义 `hashCode()` 方法，但被用于哈希数据结构中。</LongDescription>
    <Details>
<![CDATA[<p>一个类定义了equals(Object)方法但没有定义hashCode()方法，因此没有满足相等对象拥有相同hashCode的要求。如果该类的实例被用于哈希数据结构中，则修复此问题变得最为重要。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_HASHCODE_USE_OBJECT_EQUALS">
    <ShortDescription>类定义了hashCode()方法并且使用了Object的equals()方法。  Class defines hashCode() and uses Object.equals()</ShortDescription>
    <LongDescription>{0} 定义了 hashCode 并使用了 Object.equals() 方法</LongDescription>
    <Details>
<![CDATA[<p>此类定义了<code>hashCode()</code>方法，但其<code>equals()</code>方法继承自<code>java.lang.Object</code>(该类通过比较对象引用定义了相等性)。尽管这可能会满足相等对象必须具有相同哈希码的合同，但这可能不是覆盖<code>hashCode()</code>方法所期望的结果。(覆盖<code>hashCode()</code>意味着对象的身份基于比简单的引用相等更复杂的条件。)</p>
<p>如果认为此类的实例不会插入到HashMap/HashTable中，则推荐使用的<code>hashCode</code>实现是：</p>
<pre><code>public int hashCode() {     assert false : "hashCode not designed";     return 42; // 任何任意常量都可以 </code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_COMPARETO_USE_OBJECT_EQUALS">
    <ShortDescription>类定义了`compareTo(...)`方法，并使用了`Object.equals()`。  Class defines compareTo(...) and uses Object.equals()</ShortDescription>
    <LongDescription>{0} 定义了 {1.givenClass} 并使用了 Object.equals() 方法</LongDescription>
    <Details>
<![CDATA[<p>此类定义了 <code>compareTo(...)</code> 方法，但继承了 <code>java.lang.Object</code> 的 <code>equals()</code> 方法。通常情况下，<code>compareTo</code> 返回零当且仅当 <code>equals</code> 返回真。如果违反这一规则，在如 PriorityQueue 等类中会出现奇怪和不可预测的失败情况。在 Java 5 中，<code>PriorityQueue.remove</code> 方法使用的是 <code>compareTo</code> 方法，而在 Java 6 中则使用了 <code>equals</code> 方法。</p>

<p>从 Comparable 接口中的 compareTo 方法的 Javadoc： <blockquote>强烈建议（但不是严格要求）<code>(x.compareTo(y)==0) == (x.equals(y))</code>。通常来说，任何实现了 Comparable 接口并且违反这一条件的类都应该明确指出这一点。推荐的语言是“注意：此类的自然排序与 equals 不一致。” </blockquote></p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_HASHCODE_NO_EQUALS">
    <ShortDescription>类定义了hashCode()方法但未定义equals()方法  Class defines hashCode() but not equals()</ShortDescription>
    <LongDescription>{0} 定义了 `hashCode` 但没有定义 `equals`</LongDescription>
    <Details>
<![CDATA[<p>该类定义了<code>hashCode()</code>方法但未定义<code>equals()</code>方法。因此，该类可能会违反相等对象必须具有相同哈希码的不变量。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_EQUALS_USE_HASHCODE">
    <ShortDescription>类定义了 equals() 方法并且使用了 Object.hashCode() 方法  Class defines equals() and uses Object.hashCode()</ShortDescription>
    <LongDescription>{0} 定义了 `equals` 方法并使用了 `Object.hashCode()`。</LongDescription>
    <Details>
<![CDATA[<p>此类重写了<code>equals(Object)</code>，但没有重写<code>hashCode()</code>方法，并继承了<code>java.lang.Object</code>的<code>hashCode()</code>实现（返回的是对象的身份哈希码，由VM随机分配的一个值）。因此，该类很可能违反相等对象必须具有相同哈希码的不变量。</p>
<p>如果认为此类的实例不会插入到HashMap/HashTable中，则推荐使用的<code>hashCode</code>实现是：</p>
<pre><code>public int hashCode() {     assert false : "hashCode not designed";     return 42; // 任何任意常量都行 } </code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_INHERITS_EQUALS_USE_HASHCODE">
    <ShortDescription>类继承了equals()方法并使用了Object.hashCode()方法  Class inherits equals() and uses Object.hashCode()</ShortDescription>
    <LongDescription>{0} 继承了 equals 并使用了 Object.hashCode() 方法</LongDescription>
    <Details>
<![CDATA[<p>该类从抽象超类继承了<code>equals(Object)</code>方法，并从<code>java.lang.Object</code>继承了<code>hashCode()</code>方法（返回的是身份哈希码，由VM分配的任意值）。因此，该类很可能违反相等对象必须具有相同哈希码的不变量。</p>
<p>如果您不希望定义<code>hashCode</code>方法，或者认为该对象永远不会被放入HashMap/Hashtable中，则可以将<code>hashCode()</code>方法定义为抛出<code>UnsupportedOperationException</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_EQUALS_NO_HASHCODE">
    <ShortDescription>类定义了equals()方法但未定义hashCode()方法  Class defines equals() but not hashCode()</ShortDescription>
    <LongDescription>{0} 定义了 equals 但未定义 hashCode</LongDescription>
    <Details>
<![CDATA[<p>该类重写了<code>equals(Object)</code>，但未重写<code>hashCode()</code>。因此，该类可能会违反相等对象必须具有相同哈希码的不变量。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_ABSTRACT_SELF">
    <ShortDescription>抽象类定义了协变的equals()方法  Abstract class defines covariant equals() method</ShortDescription>
    <LongDescription>抽象类 {0} 定义了 equals({0.givenClass}) 方法</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个协变版本的 `equals()`。为了正确重写 `java.lang.Object` 中的 `equals()` 方法，`equals()` 的参数必须具有类型 `java.lang.Object`。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ES_COMPARING_STRINGS_WITH_EQ">
    <ShortDescription>使用 `==` 或 `!=` 比较 String 对象  Comparison of String objects using == or !=</ShortDescription>
    <LongDescription>在{1}中使用==或!=比较String对象</LongDescription>
    <Details>
<![CDATA[<p>此代码使用 == 或 != 运算符比较 <code>java.lang.String</code> 对象的引用等性。除非两个字符串都是源文件中的常量，或者已经通过 <code>String.intern()</code> 方法进行了intern化处理，否则相同的字符串值可能由两个不同的 String 对象表示。建议使用 <code>equals(Object)</code> 方法代替。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ES_COMPARING_PARAMETER_STRING_WITH_EQ">
    <ShortDescription>使用 `==` 或 `!=` 比较 String 参数  Comparison of String parameter using == or !=</ShortDescription>
    <LongDescription>在{1}中使用==或!=比较String参数</LongDescription>
    <Details>
<![CDATA[<p>此代码使用==或!=操作符比较<code>java.lang.String</code>参数的引用等价性。要求调用者仅传递字符串常量或 interned 字符串给方法是不必要的脆弱，并且很少能带来可测量的性能提升。考虑改用<code>equals(Object)</code>方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CO_ABSTRACT_SELF">
    <ShortDescription>抽象类定义了协变的compareTo()方法  Abstract class defines covariant compareTo() method</ShortDescription>
    <LongDescription>抽象类 {0} 定义了compareTo({0.givenClass}) 方法</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个协变版本的 `compareTo()`。要正确覆盖 `Comparable` 接口中的 `compareTo()` 方法，`compareTo()` 的参数必须具有类型 `java.lang.Object`。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IS_FIELD_NOT_GUARDED">
    <ShortDescription>字段未受到并发访问保护  Field not guarded against concurrent access</ShortDescription>
    <LongDescription>{1.givenClass} 未保护免于并发访问；有 {2}% 的时间被锁定</LongDescription>
    <Details>
<![CDATA[<p>该字段使用了net.jcip.annotations.GuardedBy或javax.annotation.concurrent.GuardedBy进行注解，但似乎以违反这些注解的方式被访问。</p>]]>
</Details>
  </BugPattern>
  <BugPattern type="MSF_MUTABLE_SERVLET_FIELD">
    <ShortDescription>可变的Servlet字段  Mutable servlet field</ShortDescription>
    <LongDescription>{1} 是一个可变的Servlet字段</LongDescription>
    <Details>
<![CDATA[<p>通常，web服务器只会创建一个Servlet或JSP类的实例（即，将该类视为单例），并将多个线程调用该实例的方法以处理多个同时请求。因此，拥有可变的实例字段通常会产生竞态条件。]]>
    </Details>
  </BugPattern>
  <BugPattern type="IS2_INCONSISTENT_SYNC">
    <ShortDescription>不一致的同步  Inconsistent synchronization</ShortDescription>
    <LongDescription>{1}的一致同步性不足；锁住了{2}%的时间</LongDescription>
    <Details>
<![CDATA[<p>该类的字段似乎在同步方面存在不一致的访问情况。此错误报告表明，错误模式检测器判断以下几点：</p>
<ul>
<li>该类包含锁定和未锁定访问的混合,</li>
<li>该类没有标注为 <b>javax.annotation.concurrent.NotThreadSafe</b>,</li>
<li>至少有一个锁定访问是由该类自己的方法执行的,</li>
<li>未同步字段访问（读取和写入）的数量不超过所有访问的三分之一，写入的权重是读取的两倍。</li>
</ul>
<p>符合这种错误模式的一个典型问题是忘记在一个打算线程安全的类中对一个方法进行同步。</p>
<p>你可以选择标记为“未同步访问”的节点以显示检测器认为未同步访问字段的代码位置。</p>
<p>请注意，此检测器存在各种不准确之处；例如，它无法静态检测所有持有锁的情况。即使检测器在区分锁定和未锁定访问方面是准确的，所涉及的代码也可能是正确的。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NN_NAKED_NOTIFY">
    <ShortDescription>裸露的通知  Naked notify</ShortDescription>
    <LongDescription>在{1}中使用了裸notify()</LongDescription>
    <Details>
<![CDATA[<p>调用了<code>notify()</code> 或 <code>notifyAll()</code>，但没有伴随任何（明显的）对可变对象状态的修改。通常，在监视器上调用通知方法是因为某些条件已经变为真，而其他线程正在等待这个条件。然而，为了使这个条件有意义，它必须涉及到两个线程都能看到的堆栈中的对象。</p>
<p>此错误不一定表示存在错误，因为可变对象状态的变化可能在调用了通知的方法之前的一个方法中发生。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_EXPOSE_REP">
    <ShortDescription>公共静态方法可能通过返回可变对象或数组暴露内部表示。  Public static method may expose internal representation by returning a mutable object or array</ShortDescription>
    <LongDescription>公共静态块 `{1}` 可能会通过返回 `{2.givenClass}` � Expose 内部表示。</LongDescription>
    <Details>
<![CDATA[<p>一个公共静态方法返回了一个可变对象或数组的引用，而该对象或数组是类的静态状态的一部分。任何调用此方法的代码都可以自由修改底层数组。一种修复方法是返回数组的副本。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_REP">
    <ShortDescription>可能通过返回可变对象的引用暴露内部表示。  May expose internal representation by returning reference to mutable object</ShortDescription>
    <LongDescription>{1} 可能会通过返回 {2.givenClass} 暴露内部表示。</LongDescription>
    <Details>
<![CDATA[<p>返回存储在对象某个字段中的可变对象引用会暴露该对象的内部表示形式。如果这些实例被不可信的代码访问，并且对可变对象的未检查更改会危及安全或其他重要属性，您就需要采取不同的措施。在许多情况下，返回对象的新副本是更好的方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_REP2">
    <ShortDescription>可能通过包含对可变对象的引用暴露内部表示形式  May expose internal representation by incorporating reference to mutable object</ShortDescription>
    <LongDescription>将可外部修改的对象存储到{2.givenClass}中可能会暴露内部表示。</LongDescription>
    <Details>
<![CDATA[<p>这段代码将对外可变的对象引用存储到了对象的内部表示中。如果实例被不可信的代码访问，并且对可变对象的未检查更改会威胁到安全或其他重要属性，那么你需要采取不同的措施。在许多情况下，存储对象的副本是更好的方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_STATIC_REP2">
    <ShortDescription>可能会暴露内部静态状态，因为将一个可变对象存储到了静态字段中。  May expose internal static state by storing a mutable object into a static field</ShortDescription>
    <LongDescription>{1} 可能会通过将可变对象存储到静态字段中而暴露内部的静态状态 {2}</LongDescription>
    <Details>
<![CDATA[<p>这段代码将对外部可变对象的引用存储在静态字段中。如果未检查对该可变对象的修改会损害安全或其他重要属性，你需要采取不同的措施。在许多情况下，存储对象的副本是更好的做法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_EXPOSE_BUF">
    <ShortDescription>可能通过返回共享非公共数据的缓冲区暴露内部表示。  May expose internal representation by returning a buffer sharing non-public data</ShortDescription>
    <LongDescription>{1} 可能会通过返回 {2.givenClass} 暴露内部表示。</LongDescription>
    <Details>
<![CDATA[<p>A公共静态方法要么返回一个缓冲区（java.nio.*Buffer），该缓冲区通过仅引用类的部分静态状态中的数组来包裹一个数组，要么返回一个浅拷贝的缓冲区，该缓冲区与原始缓冲区共享对同一数组的引用。调用此方法的任何代码都可以自由修改底层数组。一种修复方法是返回一个只读缓冲区或一个新的包含数组副本的缓冲区。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_BUF">
    <ShortDescription>可能通过返回共享非公开数据的缓冲区暴露内部表示方式  May expose internal representation by returning a buffer sharing non-public data</ShortDescription>
    <LongDescription>{1} 可能会通过返回 {2.givenClass} 暴露内部表示。</LongDescription>
    <Details>
<![CDATA[<p>返回一个缓冲区（java.nio.*Buffer）对象，该对象封装了存储在对象某个字段中的数组，会暴露数组元素的内部表示，因为缓冲区只存储对数组的引用而不是复制其内容。同样地，通过使用其duplicate()方法返回此类缓冲区的一个浅拷贝并将其存储在对象的某个字段中也会暴露缓冲区的内部表示。<br>
如果实例被不受信任的代码访问，并且未受检查地修改数组会危及安全或其他重要属性，则您需要采取不同的措施。在这种情况下，使用其asReadOnly()方法返回一个只读缓冲区或使用其put()方法将数组复制到新缓冲区通常是一个更好的选择。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_BUF2">
    <ShortDescription>可能通过创建包含数组引用的缓冲区来暴露内部表示。  May expose internal representation by creating a buffer which incorporates reference to array</ShortDescription>
    <LongDescription>{1} 可能通过创建包含外部数组的缓冲区来暴露内部表示，并将其纳入 {2.givenClass}</LongDescription>
    <Details>
<![CDATA[<p>这段代码创建了一个缓冲区，其中存储了对外部数组或外部缓冲区的引用，并将其转换为对象内部表示。如果这些实例被不可信的代码访问，并且对数组的未检查更改会危及安全或其他重要属性，您需要采取不同的措施。在许多情况下，复制数组是一个更好的方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_STATIC_BUF2">
    <ShortDescription>可能通过将外部数组存储到静态字段中而暴露内部静态状态  May expose internal static state by creating a buffer which stores an external array into a static field</ShortDescription>
    <LongDescription>{1} 可能通过将外部数组存储到静态字段中来暴露内部静态状态 {2}</LongDescription>
    <Details>
<![CDATA[<p>此代码创建一个缓冲区，该缓冲区存储对外部数组的引用或外部缓冲区的数组。如果对外部数组进行未检查的修改会威胁到安全或其他重要属性，那么您需要采取不同的措施。在许多情况下，复制数组并存储副本是一个更好的方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RU_INVOKE_RUN">
    <ShortDescription>在单独的线程上调用了run（您是不是应该使用start代替？）  Invokes run on a thread (did you mean to start it instead?)</ShortDescription>
    <LongDescription>{1} 显式地对线程调用了run方法（您本意是要启动它吗？）</LongDescription>
    <Details>
<![CDATA[<p>该方法显式地在一个对象上调用了<code>run()</code>&nbsp;。通常情况下，类实现<code>Runnable</code>接口是因为它们的<code>run()</code>方法将在新的线程中被调用，此时应该使用<code>Thread.start()</code>来调用。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SP_SPIN_ON_FIELD">
    <ShortDescription>方法在字段上旋转  Method spins on field</ShortDescription>
    <LongDescription>在{1}中围绕{2.givenClass}旋转</LongDescription>
    <Details>
<![CDATA[<p>该方法在一个循环中读取一个字段。编译器可以合法地将读操作移出循环，从而使代码变为无限循环。应该更改类以使用适当的同步（包括wait和notify调用）。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NS_DANGEROUS_NON_SHORT_CIRCUIT">
    <ShortDescription>潜在的危险使用非短路逻辑  Potentially dangerous use of non-short-circuit logic</ShortDescription>
    <LongDescription>在{1}中潜在危险地使用了非短路逻辑</LongDescription>
    <Details>
<![CDATA[<p>这段代码似乎使用了非短路逻辑（例如，& 或 |）而不是短路逻辑（&& 或 ||）。此外，根据左操作数的值，在某些情况下你可能不希望评估右操作数（因为这可能会引起副作用、导致异常或非常昂贵）。</p>
<p>非短路逻辑会导致表达式的两边即使结果可以从左操作数推断出来也要被评估。这可能会降低效率，并且如果左操作数用于排除在评估右操作数时会产生错误的情况，那么可能会导致错误。</p>
<p>请参阅 <a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.22.2">Java 语言规范</a> 获取详细信息。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NS_NON_SHORT_CIRCUIT">
    <ShortDescription>非短路逻辑的可疑使用  Questionable use of non-short-circuit logic</ShortDescription>
    <LongDescription>在{1}中使用了可疑的非短路逻辑</LongDescription>
    <Details>
<![CDATA[<p>这段代码似乎使用了非短路逻辑（例如，& 或 |），而不是短路逻辑（&& 或 ||）。非短路逻辑会导致表达式的两边即使可以根据左边的值推断结果也会被评估。这可能会降低效率，并且如果左边的条件防止右边的评估产生错误，则可能导致错误。</p>
<p>详细内容请参见 <a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.22.2">Java 语言规范</a>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="TLW_TWO_LOCK_WAIT">
    <ShortDescription>等待时持有两个锁  Wait with two locks held</ShortDescription>
    <LongDescription>在 {1} 中持有了两个锁后调用 wait() 方法。</LongDescription>
    <Details>
<![CDATA[在持有两个锁的情况下进行等待可能会导致死锁。仅当执行等待时会释放所等待的对象的锁，并不会释放其他任何锁。这不一定是一个bug，但值得仔细检查。]]>
    </Details>
  </BugPattern>
  <BugPattern type="TLW_TWO_LOCK_NOTIFY" deprecated="true"> <!-- never generated -->
    <ShortDescription>持有两个锁进行通知  Notify with two locks held</ShortDescription>
    <LongDescription>在{1}中持有了两个锁的情况下使用notify()或notifyAll*()方法</LongDescription>
    <Details>
<![CDATA[<p>代码在持有两个锁的情况下调用了notify()或notifyAll()。如果这种通知旨在唤醒一个同样持有着这两个锁的wait()，可能会导致死锁，因为wait()只会放弃一个锁，而notify()将无法获取到所有两个锁，因此通知不会成功。如果有关于双锁等待的警告，存在 bug 的概率相当高。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UW_UNCOND_WAIT">
    <ShortDescription>无条件等待  Unconditional wait</ShortDescription>
    <LongDescription>在{1}中无条件等待</LongDescription>
    <Details>
<![CDATA[<p>该方法包含对 `java.lang.Object.wait()` 的调用，但没有用条件控制流加以保护。代码应在调用 wait 之前验证其期望等待的条件是否已满足；否则，任何先前的通知将被忽略。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UR_UNINIT_READ">
    <ShortDescription>在构造函数中对未初始化的字段进行读取  Uninitialized read of field in constructor</ShortDescription>
    <LongDescription>在{1}中未初始化读取{2.name}</LongDescription>
    <Details>
<![CDATA[<p>该构造函数读取了一个尚未被赋值的字段。这通常是由程序员误将字段当作构造函数的一个参数来使用所导致的。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UR_UNINIT_READ_CALLED_FROM_SUPER_CONSTRUCTOR">
    <ShortDescription>从超类构造函数中调用未初始化的字段方法  Uninitialized read of field method called from constructor of superclass</ShortDescription>
    <LongDescription>在从超类构造函数调用时，{1}.{2.name} 没有被初始化。</LongDescription>
    <Details>
<![CDATA[<p>该方法在超类的构造函数中被调用。此时，类的字段尚未初始化。</p>
<p>为了使这一点更加明确，请考虑以下类：</p>
<pre><code>abstract class A {     int hashCode;     abstract Object getValue();      A() {   hashCode = getValue().hashCode();     } }  class B extends A {     Object value;      B(Object v) {   this.value = v;     }      Object getValue() {   return value;     } } </code></pre>
<p>当构造一个 <code>B</code> 对象时，会在设置 <code>value</code> 之前调用 <code>A</code> 的构造函数。因此，在 <code>A</code> 构造函数中调用 <code>getValue</code> 时会读取未初始化的 <code>value</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UG_SYNC_SET_UNSYNC_GET">
    <ShortDescription>未同步的get方法，同步的set方法  Unsynchronized get method, synchronized set method</ShortDescription>
    <LongDescription>{1} 是未同步的，{2} 是同步的</LongDescription>
    <Details>
<![CDATA[<p>该类包含同名的方法，其中 set 方法是同步的而 get 方法不是。这可能导致运行时出现错误行为，因为调用 get 方法的代码可能不会看到对象的一致状态。get 方法应该也设置为同步。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IC_INIT_CIRCULARITY">
    <ShortDescription>初始化循环依赖  Initialization circularity</ShortDescription>
    <LongDescription>{0} 和 {1} 之间的初始化循环依赖</LongDescription>
    <Details>
<![CDATA[<p>在两个引用了错误实例的类的静态初始化器中检测到了循环依赖。此类循环可能导致许多不可预期的行为。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION">
    <ShortDescription>在初始化过程中， superclass 使用了subclass。  Superclass uses subclass during initialization</ShortDescription>
    <LongDescription>初始化{0}访问了类{2}，但该类尚未初始化。</LongDescription>
    <Details>
<![CDATA[在类的初始化过程中，该类主动使用了一个子类。此时子类尚未被初始化。例如，在以下代码中，`foo` 将会是 `null`。

```java
public class CircularClassInitialization {     
    static class InnerClassSingleton extends CircularClassInitialization {   
        static InnerClassSingleton singleton = new InnerClassSingleton();     
    }     
    
    static CircularClassInitialization foo = InnerClassSingleton.singleton; 
}
```]]>
    </Details>
  </BugPattern>
  <BugPattern type="IT_NO_SUCH_ELEMENT">
    <ShortDescription>`Iterator next()` 方法不能抛出 `NoSuchElementException`。  Iterator next() method cannot throw NoSuchElementException</ShortDescription>
    <LongDescription>{1} 不能抛出 NoSuchElementException 异常。</LongDescription>
    <Details>
<![CDATA[<p>该类实现了<code>java.util.Iterator</code>接口。然而，其<code>next()</code>方法不能抛出<code>java.util.NoSuchElementException</code>。应将<code>next()</code>方法修改为，在没有更多元素可返回时调用此方法时抛出<code>NoSuchElementException</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DL_SYNCHRONIZATION_ON_SHARED_CONSTANT">
    <ShortDescription>对字符串字面量进行同步  Synchronization on String literal</ShortDescription>
    <LongDescription>在 {1} 中对字符串字面量进行同步</LongDescription>
    <Details>
<![CDATA[<p>代码使用字符串常量进行同步。</p>
<pre><code>private static String LOCK = "LOCK"; ... synchronized(LOCK) {     ... } ... </code></pre>
<p>常量字符串会在JVM加载的所有其他类中共享。因此，这段代码是在锁定其他代码也可能锁定的东西上。这可能导致非常奇怪且难以诊断的阻塞和死锁行为。请参阅<a href="http://www.javalobby.org/java/forums/t96352.html">http://www.javalobby.org/java/forums/t96352.html</a> 和 <a href="http://jira.codehaus.org/browse/JETTY-352">http://jira.codehaus.org/browse/JETTY-352</a>。</p>
<p>请参阅CERT <a href="https://wiki.sei.cmu.edu/confluence/display/java/LCK01-J.+Do+not+synchronize+on+objects+that+may+be+reused">LCK01-J. 不要对可能被重用的对象进行同步</a> 以获取更多信息。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DL_SYNCHRONIZATION_ON_INTERNED_STRING">
    <ShortDescription>同步操作在interned字符串上  Synchronization on interned String</ShortDescription>
    <LongDescription>在 `{1}` 中对interned String进行同步</LongDescription>
    <Details>
<![CDATA[<p>代码使用 interned 的 String 进行同步。</p>
<pre><code>private static String LOCK = new String("LOCK").intern(); ... synchronized(LOCK) {     ... } ... </code></pre>
<p>常量字符串会被 intern 并在 JVM 加载的所有其他类之间共享。因此，这段代码是在锁定其他代码也可能锁定的对象上。这可能会导致非常奇怪且难以诊断的阻塞和死锁行为。请参阅 <a href="http://www.javalobby.org/java/forums/t96352.html">http://www.javalobby.org/java/forums/t96352.html</a> 和 <a href="http://jira.codehaus.org/browse/JETTY-352">http://jira.codehaus.org/browse/JETTY-352</a>。</p>
<p>请参阅 CERT <a href="https://wiki.sei.cmu.edu/confluence/display/java/LCK01-J.+Do+not+synchronize+on+objects+that+may+be+reused">LCK01-J. Do not synchronize on objects that may be reused</a> 以获取更多信息。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DL_SYNCHRONIZATION_ON_BOOLEAN">
    <ShortDescription>同步布尔值  Synchronization on Boolean</ShortDescription>
    <LongDescription>在 {1} 中对布尔值进行同步</LongDescription>
    <Details>
      <![CDATA[<p>代码对一个装箱原始常量进行同步，例如一个 Boolean。</p>
<pre><code>private static Boolean inited = Boolean.FALSE; ...
synchronized(inited) {     if (!inited) {   init();   inited = Boolean.TRUE;     } }
...</code></pre>
<p>由于通常只存在两个 Boolean 对象，这段代码可能会与其他无关的代码同步同一个对象，导致响应性下降甚至可能引起死锁。</p>
<p>更多详情请参考 CERT <a href="https://wiki.sei.cmu.edu/confluence/display/java/LCK01-J.+Do+not+synchronize+on+objects+that+may+be+reused">LCK01-J. 不要对可能会被重用的对象进行同步</a>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DL_SYNCHRONIZATION_ON_UNSHARED_BOXED_PRIMITIVE">
    <ShortDescription>同步于装箱原始值  Synchronization on boxed primitive values</ShortDescription>
    <LongDescription>在 {1} 中对 {2} 进行同步</LongDescription>
    <Details>
      <![CDATA[<p>代码对一个显式未共享的装箱原始类型进行了同步，例如一个Integer。</p>
<pre><code>private static final Integer fileLock = new Integer(1); ... synchronized(fileLock) {     .. 做某事 .. } ... </code></pre>
<p>在这种情况下，最好重新声明fileLock为</p>
<pre><code>private static final Object fileLock = new Object(); </code></pre>
<p>现有代码可能没有问题，但这样会让人感到困惑，并且未来可能会进行“移除装箱”重构（如在IntelliJ中），这将用一个在整个JVM中共享的interned Integer对象替换它，从而导致非常混淆的行为以及潜在的死锁。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DL_SYNCHRONIZATION_ON_BOXED_PRIMITIVE">
    <ShortDescription>同步于装箱原始类型  Synchronization on boxed primitive</ShortDescription>
    <LongDescription>在{1}中对{2}进行同步</LongDescription>
    <Details>
      <![CDATA[<p>代码使用了一个装箱原始常量（例如，Integer）进行同步。</p>
<pre><code>private static Integer count = 0; ... synchronized(count) {     count++; } ... </code></pre>
<p>由于Integer对象可以被缓存并共享，在其他无关代码中可能会同步相同的对象，这会导致响应性差甚至可能引发死锁。</p>
<p>有关更多信息，请参阅CERT <a href="https://wiki.sei.cmu.edu/confluence/display/java/LCK01-J.+Do+not+synchronize+on+objects+that+may+be+reused">LCK01-J. 不要在可能会被重用的对象上进行同步</a>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ESync_EMPTY_SYNC">
    <ShortDescription>空的同步块  Empty synchronized block</ShortDescription>
    <LongDescription>在 `{1}` 中存在空的同步块</LongDescription>
    <Details>
<![CDATA[<p>代码中包含一个空的同步块：</p>
<pre><code>synchronized() { }
</code></pre>
<p>空的同步块比大多数人认识到的还要微妙且更难正确使用，几乎从来没有比其他更简洁的解决方案更好的情况。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IS_INCONSISTENT_SYNC">
    <ShortDescription>不一致的同步  Inconsistent synchronization</ShortDescription>
    <LongDescription>在不一致的同步中，{1} 有时被锁定；实际锁定比例为 {2}%。</LongDescription>
    <Details>
<![CDATA[<p>此类的字段似乎在同步方面存在不一致的访问情况。此错误报告指出，错误模式检测器判断出以下几点：</p>
<ul>
<li>该类中混有锁定和未锁定的访问,</li>
<li>至少有一个锁定访问是由该类自己的方法执行的,</li>
<li>未同步字段访问（读取和写入）的数量不超过所有访问的一三分之一，且写入的操作被赋予了两倍的权重</li>
</ul>
<p>符合这种错误模式的一个典型错误是忘记在打算线程安全的类中的一个方法上进行同步。</p>
<p>请注意，此检测器存在各种准确性问题；例如，检测器无法静态检测所有持有锁的情况。即使检测器能够准确地区分锁定和未锁定的访问，所涉及的代码仍可能是正确的。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ML_SYNC_ON_FIELD_TO_GUARD_CHANGING_THAT_FIELD">
    <ShortDescription>在尝试保护字段时对字段进行同步，但这是徒劳的  Synchronization on field in futile attempt to guard that field</ShortDescription>
    <LongDescription>在{2.givenClass}上进行同步，这是一种徒劳的尝试，试图保护它。</LongDescription>
    <Details>
<![CDATA[<p>该方法使用一个字段进行同步，似乎是为了防止对该字段的同时更新。但是，保护字段实际上是对引用对象加锁，而不是对字段本身加锁。这可能无法提供你需要的互斥性，并且其他线程可能会对引用的对象（用于其他目的）加锁。这种模式的一个例子如下：</p>
<pre><code>private Long myNtfSeqNbrCounter = new Long(0);
private Long getNotificationSequenceNumber() {
    Long result = null;
    synchronized(myNtfSeqNbrCounter) {
        result = new Long(myNtfSeqNbrCounter.longValue() + 1);
        myNtfSeqNbrCounter = new Long(result.longValue());
    }
    return result;
}
</code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ML_SYNC_ON_UPDATED_FIELD">
    <ShortDescription>方法在更新后的字段上进行同步  Method synchronizes on an updated field</ShortDescription>
    <LongDescription>{1} 在更新的字段 {2.givenClass} 上进行同步</LongDescription>
    <Details>
<![CDATA[<p>该方法对一个来自可变字段引用的对象进行同步。由于不同的线程可能在不同对象上进行同步，这很可能没有有用的语义。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_OOI_PKGPROTECT">
    <ShortDescription>字段应从接口中移动出来，并改为包私有访问修饰符  Field should be moved out of an interface and made package protected</ShortDescription>
    <LongDescription>`{1}` 应该从接口中移出，并改为包私有访问级别</LongDescription>
    <Details>
<![CDATA[<p>接口中定义的一个final static字段引用了一个可变对象（如数组或哈希表）。这个可变对象可能会被恶意代码或其它包中的意外操作修改。为了解决这个问题，需要将该字段移动到一个类中，并将其改为包保护级，以避免这种漏洞。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_FINAL_PKGPROTECT">
    <ShortDescription>字段应当既为 final 类型，又具有包私有访问级别  Field should be both final and package protected</ShortDescription>
    <LongDescription>{1} 应该同时是 final 和包私有访问级别</LongDescription>
    <Details>
<![CDATA[<p>    可变的静态字段可能会被恶意代码或其它包中的意外代码更改。可以将该字段改为包私有和/或将之设为final以避免此漏洞。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_SHOULD_BE_REFACTORED_TO_BE_FINAL">
    <ShortDescription>字段不是最终的，但应 refactor 为最终的  Field isn't final but should be refactored to be so</ShortDescription>
    <LongDescription>{1} 不是最终变量，但应重新分解为最终变量。</LongDescription>
    <Details>
<![CDATA[<p>这个 <code>public static</code> 或 <code>protected static</code> 字段不是最终化字段，可能会被恶意代码或不小心从另一个包中更改。可以将该字段设置为最终化以避免此漏洞，但静态初始化器对字段进行了多次写入操作，因此需要进行一些重构。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_SHOULD_BE_FINAL">
    <ShortDescription>字段不是最终的但应该设置为最终的  Field isn't final but should be</ShortDescription>
    <LongDescription>{1} 不是最终变量但应该被声明为最终变量</LongDescription>
    <Details>
<![CDATA[<p>这个公共静态或保护静态字段不是最终变量，可能会被恶意代码或意外地从另一个包中更改。可以将该字段设为最终变量以避免此漏洞。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_PKGPROTECT">
    <ShortDescription>字段应为包私有  Field should be package protected</ShortDescription>
    <LongDescription>{1} 应该是包私有访问级别</LongDescription>
    <Details>
<![CDATA[<p>可变的静态字段可能会被恶意代码或意外更改。可以将该字段改为包保护级以避免这种漏洞。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_MUTABLE_HASHTABLE">
    <ShortDescription>字段是一个可变的Hashtable。  Field is a mutable Hashtable</ShortDescription>
    <LongDescription>{1} 是一个可变的Hashtable。</LongDescription>
    <Details>
<![CDATA[<p>一个最终静态字段引用了一个Hashtable，并且可以从另一个包恶意代码或意外访问。这段代码可以自由地修改Hashtable的内容。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_MUTABLE_COLLECTION">
    <ShortDescription>字段是一个可变集合  Field is a mutable collection</ShortDescription>
    <LongDescription>{1} 是一个可变集合。</LongDescription>
    <Details>
<![CDATA[<p>将可变集合实例分配给一个最终静态字段，因此可能会被恶意代码或从另一个包中的意外操作修改。考虑使用Collections.unmodifiableSet/List/Map等方式来包装这个字段，以避免这种漏洞。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_MUTABLE_COLLECTION_PKGPROTECT">
    <ShortDescription>Field 是一个可变集合，应该声明为包私有。  Field is a mutable collection which should be package protected</ShortDescription>
    <LongDescription>{1} 是一个可变集合，应该声明为包私有。</LongDescription>
    <Details>
<![CDATA[<p>将可变集合实例分配给一个最终静态字段，因此可能会被恶意代码或另一个包中的意外操作修改。可以将该字段改为包保护级以避免此漏洞。或者，您可以使用 Collections.unmodifiableSet/List/Map 等方法对该字段进行包装，以避免此漏洞。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_MUTABLE_ARRAY">
    <ShortDescription>字段是一个可变数组  Field is a mutable array</ShortDescription>
    <LongDescription>{1} 是一个可变数组</LongDescription>
    <Details>
<![CDATA[<p>一个最终静态字段引用了一个数组，并且可以从另一个包中的恶意代码或误操作中访问。这段代码可以自由修改数组的内容。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_CANNOT_BE_FINAL">
    <ShortDescription>字段不是最终变量，无法防止恶意代码对其进行修改  Field isn't final and cannot be protected from malicious code</ShortDescription>
    <LongDescription>{1} 不是最终变量，无法防止恶意代码对其进行保护。</LongDescription>
    <Details>
<![CDATA[<p>可变的静态字段可能会被恶意代码或从另一个包中的意外操作改变。不幸的是，该字段的使用方式并不允许对此问题进行简单的修复。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ME_MUTABLE_ENUM_FIELD">
    <ShortDescription>枚举字段是公共可变的  Enum field is public and mutable</ShortDescription>
    <LongDescription>{1}字段是公共可变的</LongDescription>
    <Details>
<![CDATA[<p>在一个公共枚举内部定义了一个可变的公共字段，这样恶意代码或不小心从其他包中就可以改变这个字段。尽管可以在懒加载时使用可变的枚举字段，但将其暴露给外部世界是一个不良实践。考虑将此字段声明为 final 和/或 包私有。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ME_ENUM_FIELD_SETTER">
    <ShortDescription>公共枚举方法无条件地设置了其字段  Public enum method unconditionally sets its field</ShortDescription>
    <LongDescription>{1} 无条件地设置了字段 {2.name}</LongDescription>
    <Details>
<![CDATA[<p>此公有方法在公共枚举中无条件地设置了枚举字段，因此该字段可以被恶意代码或从另一个包中的意外操作更改。尽管可变的枚举字段可用于懒汉初始化，但将其暴露给外部世界是一个不良实践。考虑移除此方法或将该方法声明为包私有。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IA_AMBIGUOUS_INVOCATION_OF_INHERITED_OR_OUTER_METHOD">
    <ShortDescription>可能是二义性的方法调用，可能是继承来的或外部的方法。  Potentially ambiguous invocation of either an inherited or outer method</ShortDescription>
    <LongDescription>在{1}中可能存在二义性调用，可能是外部方法或继承的方法{2}</LongDescription>
    <Details>
<![CDATA[<p>一个内部类调用了既可以解析为继承来的方法也可以解析为外部类定义的方法。例如，你调用 <code>foo(17)</code>，这个方法既在超类中定义也在外部方法中定义。根据 Java 语义，它会被解析为调用继承来的方法，但这可能不是你的意图。</p>
<p>如果你确实想要调用继承来的那个方法，可以通过在 super 上调用该方法（例如调用 <code>super.foo(17)</code>）的方式来实现，这样其他阅读你代码的人和 SpotBugs 也能清楚地知道你是想调用继承来的那个方法，而不是外部类中的方法。</p>
<p>如果你调用了 <code>this.foo(17)</code>，那么会调用继承来的方法。但由于 SpotBugs 只分析 classfile，它无法区分 <code>this.foo(17)</code> 和 <code>foo(17)</code> 的区别，因此它仍然会报潜在的模糊方法调用警告。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_SAME_SIMPLE_NAME_AS_SUPERCLASS">
    <ShortDescription>类名不应屏蔽超类的简单名称  Class names shouldn't shadow simple name of superclass</ShortDescription>
    <LongDescription>类名 {0} � contrast 了超类的简单名称 {1}</LongDescription>
    <Details>
<![CDATA[<p>这个类的简单名称与其超类相同，只是其超类在不同的包中（例如，<code>alpha.Foo</code> 扩展自 <code>beta.Foo</code>）。这可能会造成极大的混淆，在很多情况下需要查看导入语句来解析引用，并且会有很多机会无意间定义不覆盖超类方法的方法。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_SAME_SIMPLE_NAME_AS_INTERFACE">
    <ShortDescription>类名不应该遮蔽实现接口的简单名称  Class names shouldn't shadow simple name of implemented interface</ShortDescription>
    <LongDescription>类名 {0} � contrasted 界面 实现的简单名称 {1}</LongDescription>
    <Details>
<![CDATA[<p>这个类/接口的简单名称与实现/扩展的接口的名称相同，仅包装空间不同（例如，<code>alpha.Foo</code> 扩展了 <code>beta.Foo</code>）。这可能会导致极度混乱，在很多情况下你需要查看导入语句来解析引用，并且会有很多机会不小心定义的方法并不覆盖超类中的方法。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_CLASS_NAMING_CONVENTION">
    <ShortDescription>类名应以大写字母开头  Class names should start with an upper case letter</ShortDescription>
    <LongDescription>类名 {0} 没有以大写字母开头</LongDescription>
    <Details>
<![CDATA[<p>类名应为名词，采用驼峰命名法，每个内部单词的首字母大写。尽量使类名简单且具有描述性。使用完整的词语，避免使用缩写和简称（除非该缩写比长名称更为广泛使用，例如URL或HTML）。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_METHOD_NAMING_CONVENTION">
    <ShortDescription>方法名应以小写字母开头  Method names should start with a lower case letter</ShortDescription>
    <LongDescription>方法名 {1} 不以小写字母开头</LongDescription>
    <Details>
<![CDATA[<p>方法应使用动词，并采用混合大小写的形式，首字母小写，内部单词的首字母大写。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_FIELD_NAMING_CONVENTION">
    <ShortDescription>非最终字段名称应以小写字母开头，最终字段应使用大写并用下划线分隔单词。  Non-final field names should start with a lower case letter, final fields should be uppercase with words separated by underscores</ShortDescription>
    <LongDescription>字段名 {1} 不符合命名规范。如果是final修饰的，应使用全部大写ALL_CAPS格式，否则应使用下划线隔符小驼峰格式(lowerCamelCase)。</LongDescription>
    <Details>
<![CDATA[<p>非最终字段的名称应使用混合大小写，首字母小写且后续单词的首字母大写。最终字段的名称应全部大写，并用下划线（_）分隔单词。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_VERY_CONFUSING">
    <ShortDescription>非常混淆的方法名称  Very confusing method names</ShortDescription>
    <LongDescription>在方法 {1} 和方法 {3} 之间切换非常混乱。</LongDescription>
    <Details>
<![CDATA[<p>引用的方法名称仅通过大小写不同。这非常容易引起混淆，因为如果大小写完全相同，则一个方法会覆盖另一个方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_VERY_CONFUSING_INTENTIONAL">
    <ShortDescription>方法名称非常迷惑（但也许是有意而为）  Very confusing method names (but perhaps intentional)</ShortDescription>
    <LongDescription>方法 {1} 和 {3} 很让人困惑（也许故意这样做的）。</LongDescription>
    <Details>
<![CDATA[<p>引用的方法名称仅在大小写上有所不同。这种情况非常令人困惑，因为如果大小写完全一致，则其中一个方法会覆盖另一个方法。根据其他方法的存在，似乎这两个方法并存是有意的，但确实让人感到困惑。你应该尽量消除其中一个方法，除非由于冻结的API不得不保留两者。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_WRONG_PACKAGE">
    <ShortDescription>方法未正确覆盖超类中的方法，因为参数的包不同。  Method doesn't override method in superclass due to wrong package for parameter</ShortDescription>
    <LongDescription>由于参数类型 {4} 与超类的参数类型 {5} 不匹配，因此方法 {1} 没有覆盖超类中的方法。</LongDescription>
    <Details>
<![CDATA[<p>子类中的方法并未覆盖 superclass 中相似的方法，因为参数的类型与 superclass 中对应参数的类型不完全匹配。例如，如果有以下代码：</p>
<pre><code>import alpha.Foo;  
public class A {     
    public int f(Foo x) { return 17; } 
} ---- import beta.Foo;  
public class B extends A {     
    public int f(Foo x) { return 42; } 
}</code></pre>
<p>类 <code>B</code> 中定义的 <code>f(Foo)</code> 方法并未覆盖类 <code>A</code> 中定义的 <code>f(Foo)</code> 方法，因为参数类型来自不同的包。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_WRONG_PACKAGE_INTENTIONAL">
    <ShortDescription>方法由于参数的包错误而不覆盖超类中的方法。  Method doesn't override method in superclass due to wrong package for parameter</ShortDescription>
    <LongDescription>因为参数类型{4}与超类的参数类型{5}不匹配，所以{1}没有重写超类的方法。</LongDescription>
    <Details>
<![CDATA[<p>子类中的方法并没有覆盖超类中相似的方法，因为参数的类型与超类中对应参数的类型不完全匹配。例如，假设你有以下代码：</p>
<pre><code>import alpha.Foo;  
public class A {     
    public int f(Foo x) { return 17; } 
} ---- import beta.Foo;  

public class B extends A {     
    public int f(Foo x) { return 42; }     
    public int f(alpha.Foo x) { return 27; } 
}</code></pre>
<p>类B中的<code>f(Foo)</code>方法并没有覆盖类A中的<code>f(Foo)</code>方法，因为参数类型是来自不同包的<code>Foo</code>。</p>
<p>在这种情况下，子类确实定义了一个与超类中方法签名完全相同的的方法，所以这种理解显然是正确的。然而，这样的方法会非常令人困惑。你应该强烈考虑移除或弃用具有相似但不相同签名的方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_CONFUSING">
    <ShortDescription>混淆的方法名称  Confusing method names</ShortDescription>
    <LongDescription>方法 {1} 和 {3} 令人困惑</LongDescription>
    <Details>
<![CDATA[<p>引用的方法名称仅通过大小写不同。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_METHOD_CONSTRUCTOR_CONFUSION">
    <ShortDescription>明显的方法/构造函数混淆  Apparent method/constructor confusion</ShortDescription>
    <LongDescription>{1} 可能应该被定义为构造函数。</LongDescription>
    <Details>
<![CDATA[<p>这个常规方法的名称与定义它的类相同。这很可能是指定为构造函数的情况。如果确实是想定义一个构造函数，应该移除返回类型为 void 的声明。如果你不小心定义了此方法并意识到错误，后来又定义了一个正确的构造函数但因向后兼容性无法删除该方法，则可以对该方法进行弃用。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_LCASE_HASHCODE">
    <ShortDescription>类中定义了hashcode()方法，应该写成hashCode()？  Class defines hashcode(); should it be hashCode()?</ShortDescription>
    <LongDescription>类 {0} 中定义了 `hashcode()`；应该写成 `hashCode()` 吗？</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个名为<code>hashcode()</code>的方法。该方法并未重写来自<code>java.lang.Object</code>的<code>hashCode()</code>方法，这可能不是本来的意图。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_LCASE_TOSTRING">
    <ShortDescription>类定义了tostring()；应该写成toString()？  Class defines tostring(); should it be toString()?</ShortDescription>
    <LongDescription>类 {0} 定义了 tostring()；应该使用 toString() 吗？</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个名为<code>tostring()</code>的方法。该方法并未重写自<code>java.lang.Object</code>中的<code>toString()</code>方法，这可能是意图之外的。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_BAD_EQUAL">
    <ShortDescription>Class 定义了 equal(Object)；应该使用 equals(Object) 吗？  Class defines equal(Object); should it be equals(Object)?</ShortDescription>
    <LongDescription>类 {0} 定义了 `equal(Object)`，应该改为 `equals(Object)` 吗？</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个方法 <code>equal(Object)</code>。该方法没有重写来自 <code>java.lang.Object</code> 的 <code>equals(Object)</code> 方法，这可能是作者的本意。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_CLASS_NOT_EXCEPTION">
    <ShortDescription>类虽然名为异常类，但并未继承自Exception。  Class is not derived from an Exception, even though it is named as such</ShortDescription>
    <LongDescription>类 {0} 没有继承自 Exception，尽管它的命名暗示它应该是这样的。</LongDescription>
    <Details>
<![CDATA[<p>该类没有继承其他异常，但却以 'Exception' 结尾。这会给使用此类的用户带来 confusion。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RR_NOT_CHECKED">
    <ShortDescription>方法忽略了InputStream.read()的方法结果。  Method ignores results of InputStream.read()</ShortDescription>
    <LongDescription>忽略 {2} 的结果 {1}</LongDescription>
    <Details>
<![CDATA[<p>此方法忽略了<code>java.io.InputStream.read()</code>的一种变体的返回值，该变体可以返回多个字节。如果不检查返回值，调用者将无法正确处理实际读取的字节数少于请求字节数的情况。这是一种特别隐蔽的bug，因为在许多程序中，从输入流中读取通常会读取完整的数据量，导致程序仅在偶尔情况下失败。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SR_NOT_CHECKED">
    <ShortDescription>方法忽略了 `InputStream.skip()` 的结果。  Method ignores results of InputStream.skip()</ShortDescription>
    <LongDescription>{1} 忽略了 {2} 的结果</LongDescription>
    <Details>
<![CDATA[<p>此方法忽略了 <code>java.io.InputStream.skip()</code> 的返回值，该方法可以跳过多个字节。如果不检查返回值，在调用者请求跳过的字节数少于实际跳过的字节数时将无法正确处理这种情况。这是一种特别危险的bug，因为在许多程序中，从输入流中的跳过操作通常确实会跳过所请求的全部数据，导致程序只会在偶尔情况下失败。然而对于缓冲流来说，<code>skip()</code> 只会在缓冲区内跳过数据，并且经常不能跳过请求的数量。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_READ_RESOLVE_IS_STATIC">
    <ShortDescription>readResolve 方法不得声明为静态方法。  The readResolve method must not be declared as a static method.</ShortDescription>
    <LongDescription>{1} 应该声明为实例方法而不是静态方法。</LongDescription>
    <Details>
<![CDATA[为了使 readResolve 方法被序列化机制识别，它不能声明为静态方法。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_PRIVATE_READ_RESOLVE_NOT_INHERITED">
    <ShortDescription>私有readResolve方法不会被子类继承  Private readResolve method not inherited by subclasses</ShortDescription>
    <LongDescription>在{0}中定义的私有readResolve方法未被子类继承。</LongDescription>
    <Details>
<![CDATA[<p>该类定义了一个私有readResolve方法。由于是私有的，因此不会被子类继承。这可能是有意为之且可以接受的，但应进行审查以确保这是预期的行为。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_READ_RESOLVE_MUST_RETURN_OBJECT">
    <ShortDescription>readResolve 方法必须声明为返回类型为 Object。  The readResolve method must be declared with a return type of Object.</ShortDescription>
    <LongDescription>方法 `{1}` 必须声明为返回 `Object` 类型，而不是 `{1.returnType}`。</LongDescription>
    <Details>
<![CDATA[<p>为了使 readResolve 方法被序列化机制识别，必须将其声明为返回类型为 Object。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_TRANSIENT_FIELD_OF_NONSERIALIZABLE_CLASS">
    <ShortDescription>类中的瞬态字段不是可序列化的。  Transient field of class that isn't Serializable.</ShortDescription>
    <LongDescription>`{1.givenClass}` 是 transient 的，但 `{0}` 没有实现 Serializable 接口。</LongDescription>
    <Details>
<![CDATA[<p>该字段被标记为 transient，但类并未实现 Serializable 接口，因此对该字段进行 transient 标记实际上没有任何效果。这可能是之前版本的代码中该类实现了 Serializable 接口后留下的痕迹，或者表明对序列化机制的理解有误。</p>
<p><em>仅在启用了特殊选项 <tt>reportTransientFieldOfNonSerializableClass</tt> 时报告此错误。</em></p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_TRANSIENT_FIELD_NOT_RESTORED">
    <ShortDescription>反序列化时未被设置的瞬态字段。  Transient field that isn't set by deserialization.</ShortDescription>
    <LongDescription>字段 {1} 是 transient 的，但在反序列化时并未被设置。</LongDescription>
    <Details>
<![CDATA[<p>该类包含一个字段，在类的多个地方都会更新这个字段，因此它似乎构成了类的状态的一部分。然而，由于该字段被标记为 transient 并且不在 readObject 或 readResolve 中设置，默认情况下任何反序列化的类实例都将包含该字段的默认值。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_PREVENT_EXT_OBJ_OVERWRITE">
    <ShortDescription>防止覆盖可序列化的对象  Prevent overwriting of externalizable objects</ShortDescription>
    <LongDescription>任何调用者都可以通过使用readExternal()方法来重置对象的值。</LongDescription>
    <Details>
      <![CDATA[<p><code>readExternal()</code> 方法必须声明为 public，且不受恶意调用者的保护，因此代码允许任何调用者在任意时间重置对象的值。</p>
<p>为了防止外部化对象被覆盖，可以使用一个 Boolean 标志，在实例字段填充完毕后设置该标志。此外，通过同步在一个私有锁对象上也可以防止竞态条件的发生。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_METHOD_MUST_BE_PRIVATE">
    <ShortDescription>为了使序列化能够正常工作，该方法必须是私有的。  Method must be private in order for serialization to work</ShortDescription>
    <LongDescription>方法 `{1.givenClass}` 必须是私有（private）的，才能在 `{0}` 的序列化/反序列化过程中被调用。</LongDescription>
    <Details>
<![CDATA[<p>该类实现了<code>Serializable</code>接口，并定义了一个自定义的序列化/反序列化方法。但由于该方法没有声明为私有，因此它会被序列化/反序列化API默默地忽略。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION">
    <ShortDescription>类实现了Externalizable接口，但没有定义一个无参构造函数。  Class is Externalizable but doesn't define a void constructor</ShortDescription>
    <LongDescription>{0} 实现了 Externalizable 接口，但没有定义无参构造函数</LongDescription>
    <Details>
<![CDATA[<p>该类实现了<code>Externalizable</code>接口，但没有定义公共无参构造函数。当反序列化Externalizable对象时，它们首先需要通过调用公共无参构造函数来构建。由于此类没有这样的构造函数，在运行时进行序列化和反序列化将会失败。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NO_SUITABLE_CONSTRUCTOR">
    <ShortDescription>类实现了Serializable接口，但其超类没有定义一个无参构造函数。  Class is Serializable but its superclass doesn't define a void constructor</ShortDescription>
    <LongDescription>{0}实现了Serializable接口，但其超类并未定义可访问的无参构造函数。</LongDescription>
    <Details>
<![CDATA[<p>此类实现了 <code>Serializable</code> 接口，而其超类未实现。当此类的对象进行反序列化时，需要通过调用超类的无参构造函数来初始化超类的字段。由于超类没有提供无参构造函数，因此在运行时会因为序列化和反序列化失败。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NO_SERIALVERSIONID">
    <ShortDescription>类是可序列化的，但没有定义serialVersionUID  Class is Serializable, but doesn't define serialVersionUID</ShortDescription>
    <LongDescription>{0} 实现了Serializable接口；考虑声明一个serialVersionUID。</LongDescription>
    <Details>
<![CDATA[<p>此类实现了 <code>Serializable</code> 接口，但没有定义 <code>serialVersionUID</code> 字段。简单的更改（如添加一个 .class 对象的引用）将向类中添加合成字段，这会不幸地改变隐式的 <code>serialVersionUID</code>（例如，添加对 <code>String.class</code> 的引用会产生静态字段 <code>class$java$lang$String</code>)。此外，不同的源代码到字节码编译器可能会使用不同的命名约定来生成用于类对象或内部类的引用的合成变量名称。为了确保不同版本之间的可互操作性，请考虑添加一个显式的 <code>serialVersionUID</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_COMPARATOR_SHOULD_BE_SERIALIZABLE">
    <ShortDescription>Comparator 没有实现 Serializable 接口  Comparator doesn't implement Serializable</ShortDescription>
    <LongDescription>{0} 实现了 Comparator 但未实现 Serializable</LongDescription>
    <Details>
<![CDATA[<p>该类实现了<code>Comparator</code>接口。你应该考虑一下它是否也应该实现<code>Serializable</code>接口。如果使用比较器来构造有序集合（例如<code>TreeMap</code>），那么只有当比较器也是可序列化的时候，<code>TreeMap</code>才会是可序列化的。由于大多数比较器几乎没有或根本没有状态，因此使其成为可序列化的通常是容易且有利于防御性编程的做法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SF_SWITCH_FALLTHROUGH">
    <ShortDescription>在 switch 语句中发现一个 case 没有显式返回或 break，而是直接跳转到下一个 case 中。  Switch statement found where one case falls through to the next case</ShortDescription>
    <LongDescription>在 {1} 中发现了 switch 语句，其中某个 case 意外地转移到了下一个 case。</LongDescription>
    <Details>
<![CDATA[<p>该方法包含一个 switch 语句，其中一种情况分支会延续到下一个情况。通常你需要在这种情况结尾处加上 break 或 return。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SF_SWITCH_NO_DEFAULT">
    <ShortDescription>在缺少默认情况"default case"的switch语句中发现了switch语句。  Switch statement found where default case is missing</ShortDescription>
    <LongDescription>在{1}中发现了switch语句且缺少default情况处理。</LongDescription>
    <Details>
<![CDATA[<p>此方法包含一个缺少默认情况"default case"的switch语句。通常需要提供默认情况。</p>
<p>由于分析仅检查生成的字节码，因此如果default case 在switch 语句末尾且该switch 语句没有其他case 的break 语句，则可能会错误触发此警告。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH">
    <ShortDescription>由于开关语句穿透导致的死存储  Dead store due to switch statement fall through</ShortDescription>
    <LongDescription>在此处由于switch语句的fall through，{2.givenClass}从上一个测试案例中的值被覆盖了。</LongDescription>
    <Details>
<![CDATA[在这里由于开关语句穿透（fall through），之前switch case中的值被覆盖了。很可能你在前一个case的末尾忘记了添加break或return语句。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH_TO_THROW">
    <ShortDescription>由于switch语句跳过导致的死存储  Dead store due to switch statement fall through to throw</ShortDescription>
    <LongDescription>在switch语句导致抛出异常的流程中，上一个case中的{2.givenClass}值在这里丢失了。</LongDescription>
    <Details>
<![CDATA[在此处，由于switch语句穿透到抛出异常的地方，之前switch case中存储的值被忽略了。这可能是你忘记在前一个case的末尾添加break或return。]]>
    </Details>
  </BugPattern>
  <BugPattern type="WS_WRITEOBJECT_SYNC">
    <ShortDescription>类的 `writeObject()` 方法是同步的，但没有其他内容是同步的。  Class's writeObject() method is synchronized but nothing else is</ShortDescription>
    <LongDescription>{0} 的 `writeObject` 方法是同步的，但其他部分却没有同步。</LongDescription>
    <Details>
<![CDATA[<p>此类具有一个使用了同步机制的 <code>writeObject()</code> 方法，但类中的其他方法都没有使用同步机制。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RS_READOBJECT_SYNC">
    <ShortDescription>类的readObject()方法是同步的  Class's readObject() method is synchronized</ShortDescription>
    <LongDescription>{0} 的 readObject 方法是同步的</LongDescription>
    <Details>
<![CDATA[<p>此可序列化的类定义了一个同步的 `readObject()` 方法。根据定义，通过反序列化创建的对象只能被一个线程访问，因此 `readObject()` 无需进行同步操作。如果 `readObject()` 方法本身导致对象变得可见给另一个线程，则这属于非常可疑的编码风格。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NONSTATIC_SERIALVERSIONID">
    <ShortDescription>serialVersionUID 不是静态的  serialVersionUID isn't static</ShortDescription>
    <LongDescription>"{1} 不是静态的"</LongDescription>
    <Details>
<![CDATA[<p>该类定义了一个非静态的 <code>serialVersionUID</code> 字段。如果该字段用于指定序列化的目的版本UID，应将其声明为静态。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NONFINAL_SERIALVERSIONID">
    <ShortDescription>serialVersionUID 不是 final 常量  serialVersionUID isn't final</ShortDescription>
    <LongDescription>{1} 不是最终的</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个非最终的 `serialVersionUID` 字段。如果打算为此字段指定序列化版本UID，则应将其声明为最终（final）。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NONLONG_SERIALVERSIONID">
    <ShortDescription>serialVersionUID 不是 long 类型  serialVersionUID isn't long</ShortDescription>
    <LongDescription>"{1} 不长"</LongDescription>
    <Details>
<![CDATA[<p>该类定义了一个不是长整型的 `serialVersionUID` 字段。如果打算为了序列化目的指定版本UID，应该将此字段改为长整型。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_BAD_FIELD">
    <ShortDescription>可序列化的类中包含非瞬态非序列化实例字段  Non-transient non-serializable instance field in serializable class</ShortDescription>
    <LongDescription>类 {0} 定义了非暂存且不可序列化的实例字段 {1.name}</LongDescription>
    <Details>
<![CDATA[<p>该可序列化类定义了一个非原始实例字段，该字段既不是临时的、可序列化的，也不是 <code>java.lang.Object</code>，并且没有实现 <code>Externalizable</code> 接口或 <code>readObject()</code> 和 <code>writeObject()</code> 方法。如果此字段中存储了非可序列化对象，则该类的对象在反序列化时不会被正确处理。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_BAD_FIELD_INNER_CLASS">
    <ShortDescription>非序列化类包含一个可序列化的内部类  Non-serializable class has a serializable inner class</ShortDescription>
    <LongDescription>{0}是可以序列化，但也是非序列化类的内部类。</LongDescription>
    <Details>
<![CDATA[<p>这个可序列化的类是一个非可序列化类的内部类。因此，尝试序列化它时也会试图将与其关联的外部类实例一起关联起来，从而导致运行时错误。</p>
<p>如果可能的话，将内部类改为静态内部类可以解决这个问题。使外部类成为可序列化的也可能奏效，但这意味着序列化内部类的实例时总是会同时序列化外部类的实例，而这通常不是你真正想要的结果。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_INNER_CLASS">
    <ShortDescription>可序列化的内部类  Serializable inner class</ShortDescription>
    <LongDescription>{0} 是可序列化的内部类</LongDescription>
    <Details>
<![CDATA[<p>这个可序列化的类是内部类。尝试序列化它时也会序列化相关的外部实例。由于外部实例是可序列化的，所以这不会失败，但可能会序列化比预期更多的数据。如果可能的话，将内部类改为静态内部类（也称为嵌套类）应该可以解决问题。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_BAD_FIELD_STORE">
    <ShortDescription>序列化类的实例字段中存储了非序列化值  Non-serializable value stored into instance field of a serializable class</ShortDescription>
    <LongDescription>存储到非暂存字段 {1.givenClass} 中</LongDescription>
    <Details>
<![CDATA[<p>可序列化的类中存储了一个非序列化值到一个非瞬态字段中。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SC_START_IN_CTOR">
    <ShortDescription>构造函数调用了Thread.start()方法  Constructor invokes Thread.start()</ShortDescription>
    <LongDescription>{1} 调用了 {2}</LongDescription>
    <Details>
<![CDATA[<p>构造函数启动了一个线程。如果该类以后被扩展/子类化，这可能是错误的，因为线程将在子类构造函数启动之前启动。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SS_SHOULD_BE_STATIC">
    <ShortDescription>未读字段：这个字段应该声明为静态的吗？  Unread field: should this field be static?</ShortDescription>
    <LongDescription>未读字段：{1}；该字段应该声明为静态吗？</LongDescription>
    <Details>
<![CDATA[<p>该类包含一个实例最终字段，该字段初始化为编译时静态值。考虑将该字段声明为静态。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UUF_UNUSED_FIELD">
    <ShortDescription>未使用的字段  Unused field</ShortDescription>
    <LongDescription>未使用字段：{1}</LongDescription>
    <Details>
<![CDATA[<p>该字段从未使用过。考虑从类中移除它。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="URF_UNREAD_FIELD">
    <ShortDescription>未读字段  Unread field</ShortDescription>
    <LongDescription>未读字段：{1}</LongDescription>
    <Details>
<![CDATA[<p>此字段从未被读取。考虑从类中移除它。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD">
    <ShortDescription>未使用的公共或保护字段  Unused public or protected field</ShortDescription>
    <LongDescription>未使用的公共或保护字段：{1}</LongDescription>
    <Details>
<![CDATA[<p>此字段从未被使用。该字段是公有的或保护的，也许它是打算与其他未纳入分析的类一起使用的。如果不是这种情况，请考虑从类中移除它。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD">
    <ShortDescription>未读取的公共/受保护字段  Unread public/protected field</ShortDescription>
    <LongDescription>未读取的公共/受保护字段：{1}</LongDescription>
    <Details>
<![CDATA[<p>此字段从未被读取。该字段是公有的或受保护的，也许它是打算与其他分析中未见类一起使用。如果不打算这样使用，请考虑从类中移除它。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="QF_QUESTIONABLE_FOR_LOOP">
    <ShortDescription>复杂的、微妙的或错误的for循环中的增量操作  Complicated, subtle or wrong increment in for-loop</ShortDescription>
    <LongDescription>for循环中的复杂、微妙或错误的增量{1}</LongDescription>
    <Details>
<![CDATA[<p>您确定这个for循环是正确地增加/减少了变量吗？看起来另一个变量是由for循环初始化和检查的。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UWF_NULL_FIELD">
    <ShortDescription>字段仅被设置为null  Field only ever set to null</ShortDescription>
    <LongDescription>字段仅被设置为null：{1}</LongDescription>
    <Details>
<![CDATA[<p>此字段的所有写入都是常量值null，因此所有对该字段的读取都将返回null。检查是否有错误，如果无用则可以移除。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD">
    <ShortDescription>未定义的公共或受保护字段  Unwritten public or protected field</ShortDescription>
    <LongDescription>未定义的公共或保护字段：{1}</LongDescription>
    <Details>
<![CDATA[<p>未对该公共/受保护字段进行写操作。所有读取操作都将返回默认值。检查是否应该对其进行初始化，或者如果它没有用处则可以删除该字段。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UWF_UNWRITTEN_FIELD">
    <ShortDescription>未定义字段  Unwritten field</ShortDescription>
    <LongDescription>未定义字段：{1}</LongDescription>
    <Details>
<![CDATA[<p>此字段从未被写入。所有对该字段的读取都将返回默认值。检查是否存在错误（是否应该进行初始化？），或者如果该字段是无用的，则可以将其删除。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD">
    <ShortDescription>从实例方法写入静态字段  Write to static field from instance method</ShortDescription>
    <LongDescription>从实例方法 {1} 向静态字段 {2} 写入</LongDescription>
    <Details>
<![CDATA[<p>该实例方法写入了一个静态字段。如果同时操作多个实例，这可能会很难正确实现，并且通常被认为是不良做法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_LOAD_OF_KNOWN_NULL_VALUE">
    <ShortDescription>已知为空值的加载  Load of known null value</ShortDescription>
    <LongDescription>在{1}处加载已知的空值</LongDescription>
    <Details>
<![CDATA[<p>在此点引用的变量已知为null，因为之前进行了对null的检查。虽然这是有效的，但这可能是一个错误（也许您本来打算引用的是另一个变量，或者之前的检查应该是非null的检查）。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_DEREFERENCE_OF_READLINE_VALUE">
    <ShortDescription>对 `readLine()` 的结果进行解引用而未进行空检查  Dereference of the result of readLine() without nullcheck</ShortDescription>
    <LongDescription>在第{1}行没有对readLine()的结果进行空检查后直接解引用。</LongDescription>
    <Details>
<![CDATA[<p>调用 readline() 后其结果未检查是否为 null 就进行了解引用。如果已无更多文本行可供读取，readline() 将返回 null，并对 null 进行解引用会导致空指针异常。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_IMMEDIATE_DEREFERENCE_OF_READLINE">
    <ShortDescription>直接解引用 `readLine()` 的结果  Immediate dereference of the result of readLine()</ShortDescription>
    <LongDescription>在 `{1}` 中立即解引用 `readLine()` 的结果。</LongDescription>
    <Details>
<![CDATA[<p>调用readLine()的结果立即被解引用。如果没有更多的文本行可读取，readLine()将返回null，并对它的解引用会产生空指针异常。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_UNWRITTEN_FIELD">
    <ShortDescription>未写入字段的读取  Read of unwritten field</ShortDescription>
    <LongDescription>在 {1} 中读取未写入的字段 {2.name}</LongDescription>
    <Details>
<![CDATA[<p>该程序正在解引用一个似乎从未被写入非空值的字段。除非该字段是通过分析未看到的某种机制初始化的，否则解引用这个值将会生成空指针异常。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD">
    <ShortDescription>读取未声明的公共或受保护字段  Read of unwritten public or protected field</ShortDescription>
    <LongDescription>在 {1} 中读取未写入的公共或受保护字段 {2.name}</LongDescription>
    <Details>
<![CDATA[程序正在引用一个公共或保护类型的字段，而该字段似乎从未被写入过非空值。除非该字段是通过分析未看到的某种机制初始化的，否则引用这个值将会生成空指针异常。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIC_THREADLOCAL_DEADLY_EMBRACE">
    <ShortDescription>非静态内部类和线程局部变量的致命拥抱  Deadly embrace of non-static inner class and thread local</ShortDescription>
    <LongDescription>{0} 需要声明为 _static_ 以避免与 {1} 的致命拥抱</LongDescription>
    <Details>
<![CDATA[<p>这个类是一个内部类，但很可能应该定义为静态内部类。由于它不是静态的，内部类保留对外部类的引用。如果线程局部变量包含对内部类实例的引用，则内外部对象都将是可达的，并且不具备被垃圾回收的资格。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIC_INNER_SHOULD_BE_STATIC">
    <ShortDescription>应该是静态内部类  Should be a static inner class</ShortDescription>
    <LongDescription>{0}应该是一个静态内部类 _static_ 内部类？</LongDescription>
    <Details>
<![CDATA[<p>该类是内部类，但并未使用其对创建它的对象的引用。此引用会使该类的实例变大，并可能导致保留对创建者对象的引用时间比必要的时间长。如果可能，应将该类设为静态。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR">
    <ShortDescription>在构造函数中未初始化的字段但在后续代码中进行了非空检查和引用。  Field not initialized in constructor but dereferenced without null check</ShortDescription>
    <LongDescription>在构造函数中未初始化 `{1.givenClass}`，并在 `{2}` 中进行了引用。</LongDescription>
    <Details>
<![CDATA[<p>该字段在任何构造函数中都没有被初始化，因此对象构建后可能会为空。在其他地方，它被加载并在未进行空检查的情况下反引用。这可能是错误或值得怀疑的设计，因为它意味着如果在字段被初始化之前对其进行反引用来获取引用时会产生空指针异常。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIC_INNER_SHOULD_BE_STATIC_ANON">
    <ShortDescription>可以重构为命名的静态内部类  Could be refactored into a named static inner class</ShortDescription>
    <LongDescription>类 {0} 可以重构为一个名为的静态内部类 _static_ 内部类</LongDescription>
    <Details>
<![CDATA[<p>这个类是一个内部类，但并不使用它对创建它的对象的引用。这个引用会使该类实例变大，并可能使对创建者对象的引用保持存活时间比必要的时间更长。如果可能的话，应该将这个类声明为<em>静态</em>内部类。由于匿名内部类不能标记为静态，因此需要重构内部类使其成为命名的内部类。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS">
    <ShortDescription>可以重构为静态内部类  Could be refactored into a static inner class</ShortDescription>
    <LongDescription>类 {0} 可以重构为一个 _静态_ 内部类</LongDescription>
    <Details>
<![CDATA[<p>这个内类是一个嵌套类，但除了在构造内对象时之外，并未使用创建它的对象的引用。该引用会使此类实例变大，并可能使对外部对象的引用保持活跃的时间比必要的时间更长。如果可能，应该将此类改为<em>静态</em>内部类。由于在构造内实例时需要对外部对象的引用，因此内类需要重新设计以将外部实例的引用传递给内类的构造函数。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="WA_NOT_IN_LOOP">
    <ShortDescription>不在循环中等待  Wait not in loop</ShortDescription>
    <LongDescription>在{1}中不要等待循环中。</LongDescription>
    <Details>
<![CDATA[<p>该方法包含对<code>java.lang.Object.wait()</code>的调用，并且不在循环中。如果锁用于多种条件，则调用者希望等待的情况可能并不是实际发生的情况。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="WA_AWAIT_NOT_IN_LOOP">
    <ShortDescription>Condition.await() 不应在循环中使用  Condition.await() not in loop</ShortDescription>
    <LongDescription>在{1}中，`Condition.await()` 不应在循环外使用。</LongDescription>
    <Details>
<![CDATA[<p>该方法中包含对 <code>java.util.concurrent.await()</code>（或变体）的调用，并且不在循环中。如果对象用于多个条件，则调用者 intend 等待的条件可能并不是实际发生的情况。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NO_NOTIFY_NOT_NOTIFYALL">
    <ShortDescription>使用notify()而非notifyAll()  Using notify() rather than notifyAll()</ShortDescription>
    <LongDescription>在{1}中使用notify而不是notifyAll</LongDescription>
    <Details>
<![CDATA[<p>该方法调用了<code>notify()</code> 而不是<code>notifyAll()</code>。Java 监视器通常用于处理多种条件。调用<code>notify()</code> 只会唤醒一个线程，这意味着被唤醒的线程可能并不是等待某个条件满足的那个线程。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UC_USELESS_VOID_METHOD">
    <ShortDescription>无用的非空void方法  Useless non-empty void method</ShortDescription>
    <LongDescription>方法 {1} 看起来是无用的</LongDescription>
    <Details>
<![CDATA[<p>我们的分析显示，这个非空的void方法实际上并没有执行任何有用的工作。请检查一下：可能是其代码中出现了错误，或者其内容可以完全移除。</p>
<p>我们尽量减少误报的情况，但在某些情况下，此警告可能是错误的。常见的误报情况包括：</p>
<ul>
<li>该方法旨在触发一些类的加载，这可能会产生副作用。</li>
<li>该方法旨在隐式抛出某种不显而见的异常。</li>
</ul>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UC_USELESS_CONDITION">
    <ShortDescription>条件没有效果  Condition has no effect</ShortDescription>
    <LongDescription>无用的条件：在此状态下已知{2}</LongDescription>
    <Details>
<![CDATA[<p>此条件总是产生与之前窄化变量值相同的结果。可能原本的意思不同，或者可以移除此条件。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UC_USELESS_CONDITION_TYPE">
    <ShortDescription>条件表达式由于变量类型的原因无效。  Condition has no effect due to the variable type</ShortDescription>
    <LongDescription>无用的条件：因为变量类型为{3}，所以总是{2}</LongDescription>
    <Details>
<![CDATA[<p>由于涉及变量的类型范围，此条件总是产生相同的结果。可能是另有他意，或者该条件可以被移除。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UC_USELESS_OBJECT">
    <ShortDescription>创建了不必要的对象  Useless object created</ShortDescription>
    <LongDescription>在方法 {1} 中存储于变量 {2} 的对象是无用的</LongDescription>
    <Details>
<![CDATA[<p>我们的分析显示，该对象是无用的。它被创建并修改，但其值从未超出方法范围或产生任何副作用。要么存在错误，该对象原本打算使用，要么可以移除。</p>
<p>这种分析很少产生误报。常见的误报情况包括：</p>
<ul>
    <li>- 该对象用于隐式抛出某些难以察觉的异常。</li>
    <li>- 该对象作为占位符以通用化代码。</li>
    <li>- 该对象用于持有对弱引用/软引用对象的强引用。</li>
</ul>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UC_USELESS_OBJECT_STACK">
    <ShortDescription>在栈上创建了不必要的对象  Useless object created on stack</ShortDescription>
    <LongDescription>在方法 `{1}` 中创建了不必要的对象</LongDescription>
    <Details>
<![CDATA[<p>这个对象仅用于执行一些没有副作用的修改。可能原本有其他意图，或者这个对象可以被移除。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RANGE_ARRAY_INDEX">
    <ShortDescription>数组索引越界  Array index is out of bounds</ShortDescription>
    <LongDescription>数组索引超出范围：{3}</LongDescription>
    <Details>
<![CDATA[<p>进行了数组操作，但数组索引越界，这将在运行时导致ArrayIndexOutOfBoundsException。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RANGE_ARRAY_OFFSET">
    <ShortDescription>数组越界  Array offset is out of bounds</ShortDescription>
    <LongDescription>数组越界：{3}</LongDescription>
    <Details>
<![CDATA[<p>方法使用了数组参数和偏移量参数，但偏移量超出范围。这将在运行时导致 IndexOutOfBoundsException。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RANGE_ARRAY_LENGTH">
    <ShortDescription>数组长度越界  Array length is out of bounds</ShortDescription>
    <LongDescription>数组长度超出范围：{3}</LongDescription>
    <Details>
<![CDATA[<p>方法使用了数组参数和长度参数调用，但长度超出了界限。这将在运行时导致索引越界异常（IndexOutOfBoundsException）。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RANGE_STRING_INDEX">
    <ShortDescription>字符串索引超出范围  String index is out of bounds</ShortDescription>
    <LongDescription>在调用 `{5}` 时，字符串索引越界：{3}</LongDescription>
    <Details>
<![CDATA[<p>调用了String的某个方法，并指定了一个越界的字符串索引。这将在运行时导致StringIndexOutOfBoundsException异常。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_CHECK_FOR_POSITIVE_INDEXOF">
    <ShortDescription>方法检查 `String.indexOf` 的结果是否为正数  Method checks to see if result of String.indexOf is positive</ShortDescription>
    <LongDescription>{1} 检查 `String.indexOf` 的结果是否为正数</LongDescription>
    <Details>
<![CDATA[<p>该方法调用 String.indexOf 并检查结果是否为正数或非正数。通常的做法是检查结果是否为负数或非负数。只有当要查找的子字符串出现在字符串的起始位置之外时，结果才是正数。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_DONT_JUST_NULL_CHECK_READLINE">
    <ShortDescription>在检查 `readLine` 返回值是否非空后，方法忽略了对其返回值的处理  Method discards result of readLine after checking if it is non-null</ShortDescription>
    <LongDescription>{1} 在检查 `readLine` 返回值是否非空后，丢弃了其返回结果</LongDescription>
    <Details>
<![CDATA[<p>在检查 readLine 返回值是否非空后，返回的值被丢弃。几乎在所有情况下，如果结果是非空的，您将希望使用这个非空值。再次调用 readLine 将会给出不同的行。</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="RV_RETURN_VALUE_IGNORED_INFERRED">
    <ShortDescription>方法忽略了返回值，这样可以吗？  Method ignores return value, is this OK?</ShortDescription>
    <LongDescription>{2.给定类}的返回值被忽略，在{1}中这样做可以接受吗？</LongDescription>
    <Details>
<![CDATA[<p>该代码调用了一个方法并忽略了返回值。返回值与调用的方法类型相同，从我们的分析来看，返回值可能是重要的（例如，类似于忽略<code>String.toLowerCase()</code>的返回值）。仅仅通过对方法体的简单分析，我们猜测忽略返回值可能不是一个好主意。你可以使用@CheckReturnValue注解来指示SpotBugs你是否认为忽略此方法的返回值是重要或可接受的。</p>
<p>请仔细调查以决定是否可以忽略返回值。</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT">
    <ShortDescription>方法无副作用的返回值被忽略  Return value of method without side effect is ignored</ShortDescription>
    <LongDescription>{2.givenClass} 方法的返回值被忽略，但该方法没有副作用。</LongDescription>
    <Details>
<![CDATA[<p>该代码调用了一个方法并忽略了其返回值。然而，我们的分析显示，该方法（包括任何子类的实现）除了返回值外没有任何其他效果。因此，可以移除此调用。</p>
<p>我们尽力减少误报的数量，但在某些情况下这种警告可能是错误的。常见的误报情况包括：</p>
<p>- 该方法设计用于被重写并在其他项目中产生副作用，而这些项目不在分析范围之外。</p>
<p>- 调用该方法是为了触发类加载，可能会产生副作用。</p>
<p>- 调用该方法只是为了获取某些异常。</p>
<p>如果你认为我们的假设是错误的，可以使用@CheckReturnValue 注解来指示 SpotBugs 忽略对该方法返回值的忽略是可以接受的。</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="RV_RETURN_VALUE_IGNORED">
    <ShortDescription>方法忽略了返回值  Method ignores return value</ShortDescription>
    <LongDescription>在 `{1}` 中忽略了 `{2.givenClass}` 的返回值。</LongDescription>
    <Details>
<![CDATA[<p>此方法的返回值应进行检查。这种警告的一个常见原因是，调用不可变对象的方法时，误以为该方法会更新对象。例如，在下面的代码片段中：</p>
<pre><code>String dateString = getHeaderField(name); dateString.trim(); </code></pre>
<p>程序员似乎认为 trim() 方法会更新由 dateString 引用的 String 对象。但由于 String 是不可变的，trim() 函数返回一个新的 String 值，并且在这里被忽略了。代码应更正为：</p>
<pre><code>String dateString = getHeaderField(name); dateString = dateString.trim(); </code></pre>]]>
    </Details>
  </BugPattern>


  <BugPattern type="RV_RETURN_VALUE_IGNORED_BAD_PRACTICE">
    <ShortDescription>方法忽略了异常返回值的处理  Method ignores exceptional return value</ShortDescription>
    <LongDescription>在{1}中忽略了{2}的异常返回值</LongDescription>
    <Details>
<![CDATA[<p>该方法返回一个值但未进行检查。返回值应该被检查，因为这可以指示函数执行的不寻常或意外情况。例如，<code>File.delete()</code> 方法在文件未能成功删除时会返回 false（而不是抛出异常）。如果不检查结果，你就无法注意到方法调用通过返回非典型值信号了不寻常的行为。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_CHECK_COMPARETO_FOR_SPECIFIC_RETURN_VALUE">
    <ShortDescription>代码检查特定值的返回情况，这些值由compareTo方法返回。  Code checks for specific values returned by compareTo</ShortDescription>
    <LongDescription>检查 {2.givenClass} 的返回值是否等于 {3}</LongDescription>
    <Details>
<![CDATA[这段代码调用了 `compareTo` 或 `compare` 方法，并检查返回值是否为特定值，如 1 或 -1。在调用这些方法时，你应该只检查结果的符号，而不是特定的非零值。虽然许多或大多数 `compareTo` 和 `compare` 方法仅返回 -1、0 或 1，但有些方法会返回其他值。]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_EXCEPTION_NOT_THROWN">
    <ShortDescription>异常创建但未抛出而是被丢弃  Exception created and dropped rather than thrown</ShortDescription>
    <LongDescription>在 `{1}` 中没有抛出 `{2.givenClass}`。</LongDescription>
    <Details>
<![CDATA[这段代码创建了一个异常（或错误）对象，但并没有做任何处理。例如：

```java
if (x < 0) {
    new IllegalArgumentException("x必须是非负数");
}
```

程序员本意可能是要抛出这个创建的异常：

```java
if (x < 0) {
    throw new IllegalArgumentException("x必须是非负数");
}
```]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_ALWAYS_NULL">
    <ShortDescription>空指针解引用  Null pointer dereference</ShortDescription>
    <LongDescription>在 {1} 中对 {2.givenClass} 的空指针解引用</LongDescription>
    <Details>
<![CDATA[<p>这里解引用了一个空指针。当代码执行时，这将导致一个<code>NullPointerException</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_CLOSING_NULL">
    <ShortDescription>在调用 `close()` 时，其作用于总是为 `null` 的值。  close() invoked on a value that is always null</ShortDescription>
    <LongDescription>在 {1} 中，{2.givenClass} 始终为 null，因此无法关闭它。</LongDescription>
    <Details>
<![CDATA[`close()` 方法被调用在一个始终为 null 的值上。如果执行此语句，将会发生空指针异常。但更大的风险是你关闭了一个本不应关闭的东西。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_STORE_INTO_NONNULL_FIELD">
    <ShortDescription>将空值存储到标记了@Nonnull注解的字段中  Store of null value into field annotated @Nonnull</ShortDescription>
    <LongDescription>在{1}中将空值存储到由@Nonnull注解的字段{2.givenClass}中</LongDescription>
    <Details>
      <![CDATA[<p>将可能为null的值存储到了已被标注为@Nonnull的字段中。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_ALWAYS_NULL_EXCEPTION">
    <ShortDescription>在异常路径中对空指针进行解引用  Null pointer dereference in method on exception path</ShortDescription>
    <LongDescription>在异常路径中，{1} 中的 {2.givenClass} 发生空指针解引用错误。</LongDescription>
    <Details>
<![CDATA[<p>在异常路径中，一个为 null 的指针在此处被间接引用。这将在代码执行时导致 <code>NullPointerException</code>。请注意，由于 SpotBugs 目前不会修剪不可行的异常路径，因此这可能是一个假警报。</p>
<p>另外，请注意，SpotBugs 认为 switch 语句中的默认情况也是异常路径，因为默认情况往往不可行。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE">
    <ShortDescription>参数必须是非空的，但被标记为可为空。  Parameter must be non-null but is marked as nullable</ShortDescription>
    <LongDescription>{2} 必须为非空但被标记为可为空</LongDescription>
    <Details>
<![CDATA[<p>这个参数总是被用于非空的要求中，但该参数明确注解为可为空。要么参数的使用方式有误，要么注解不正确。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_ON_SOME_PATH">
    <ShortDescription>可能的空指针脱引用  Possible null pointer dereference</ShortDescription>
    <LongDescription>在 `{1}` 中可能对 `{2.givenClass}` 进行了空指针解引用。</LongDescription>
    <Details>
<![CDATA[<p>存在一个分支语句，如果执行的话，会保证出现空值引用的情况，从而在代码运行时生成 <code>NullPointerException</code>。当然，问题可能是该分支或语句是不可达的，空指针异常实际上永远不会发生；这种判断超出了 SpotBugs 的能力范围。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_ON_SOME_PATH_MIGHT_BE_INFEASIBLE">
    <ShortDescription>在可能不可行的分支上对空指针进行解引用  Possible null pointer dereference on branch that might be infeasible</ShortDescription>
    <LongDescription>在{1}中，可能存在从不可能执行的分支上对{2.givenClass}进行空指针解引用的风险。</LongDescription>
    <Details>
<![CDATA[<p>存在一个分支语句，<em>如果执行</em>，将会保证出现空指针引用，并在代码执行时生成 <code>NullPointerException</code>。当然，问题可能是该分支或语句是不可行的，空指针异常实际上永远不会发生；SpotBugs 无法判断这种情况。由于该值之前已经被测试过是否为空，因此这种可能性确实存在。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_ON_SOME_PATH_EXCEPTION">
    <ShortDescription>在异常路径上可能存在空指针脱引用问题  Possible null pointer dereference in method on exception path</ShortDescription>
    <LongDescription>在异常路径上，{1} 中对 {2.givenClass} 的可能为空指针解引用。</LongDescription>
    <Details>
<![CDATA[<p>在某些异常控制路径上，参考值为 null，这里却进行了解引用操作。这可能会导致在代码执行时出现 <code>NullPointerException</code>。请注意，由于 SpotBugs 目前不修剪不可能的异常路径，因此这可能是一个假警告。</p>  
<p>另外，请注意，SpotBugs 认为 switch 语句的默认情况是异常路径，因为默认情况通常不可行。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE">
    <ShortDescription>由于调用方法的返回值可能为空，可能导致空指针解引用  Possible null pointer dereference due to return value of called method</ShortDescription>
    <LongDescription>调用方法返回值可能导致在 {1} 处发生空指针解引用。</LongDescription>
    <Details>
      <![CDATA[<p>方法的返回值在未进行空检查的情况下被解引用，而该方法的返回值通常是应该进行空检查的。这可能会导致代码执行时出现 <code>NullPointerException</code>。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_PARAM_DEREF_NONVIRTUAL">
    <ShortDescription>非虚拟方法调用传递了非null参数为null  Non-virtual method call passes null for non-null parameter</ShortDescription>
    <LongDescription>在 `{1}` 中对非虚拟方法调用传递了 `{2.givenClass}` 的非空参数为 `null`</LongDescription>
    <Details>
      <![CDATA[<p>一个可能为null的值被传递给了一个非null的方法参数。要么该参数被注解为始终不应为null，要么分析表明它总是会被引用。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS">
    <ShortDescription>方法调用传递了空值给非空参数  Method call passes null for non-null parameter</ShortDescription>
    <LongDescription>在 `{1}` 中，传递了空值给 `{2.givenClass}` 的非空参数。</LongDescription>
    <Details>
      <![CDATA[在一个调用点传递了一个可能为null的值，而所有已知的目标方法都需要该参数为非null。要么该参数被标注为始终不应为null的参数，要么分析已经表明它将总是会被解引用。]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_PARAM_DEREF">
    <ShortDescription>方法调用传入了非空参数的空值  Method call passes null for non-null parameter</ShortDescription>
    <LongDescription>在{1}中，为{2.givenClass}的非空参数传递了null。</LongDescription>
    <Details>
      <![CDATA[<p>该方法调用为非空方法参数传递了 null 值。要么该参数被注解为总是非空的，要么分析表明它始终会被解引用。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_NONNULL_PARAM_VIOLATION">
    <ShortDescription>方法调用向非空参数传递了null值  Method call passes null to a non-null parameter</ShortDescription>
    <LongDescription>在 {1} 中，传递了空值给非空参数 {2.givenClass}。</LongDescription>
    <Details>
      <![CDATA[<p>该方法将一个空值作为参数传递给必须为非空的方法。要么这个参数已经被显式地标记为@Nonnull，要么分析已确定该参数总是会被解引用。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_NONNULL_RETURN_VIOLATION">
    <ShortDescription>方法可能会返回空值，但声明为@Nonnull  Method may return null, but is declared @Nonnull</ShortDescription>
    <LongDescription>{1} 可能返回 null，但声明为 @Nonnull</LongDescription>
    <Details>
      <![CDATA[<p>该方法可能会返回一个空值，但该方法（或其覆盖的超类方法）被声明为返回@Nonnull。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_CLONE_COULD_RETURN_NULL">
    <ShortDescription>克隆方法可能会返回null  Clone method may return null</ShortDescription>
    <LongDescription>{1} 可能返回null</LongDescription>
    <Details>
      <![CDATA[<p>     这个克隆方法在某些情况下似乎会返回 null，但克隆操作从未允许返回 null 值。如果你认为这条路径是不可达的，请抛出一个 AssertionError 代替。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_TOSTRING_COULD_RETURN_NULL">
    <ShortDescription>`toString` 方法可能返回 `null`  toString method may return null</ShortDescription>
    <LongDescription>{1} 可能返回 null</LongDescription>
    <Details>
      <![CDATA[<p>    这个 `toString` 方法在某些情况下似乎会返回 `null`。规范可能允许这种情况，但这是一个坏主意，可能会导致其他代码出错。应该返回空字符串或其他合适的字符串而不是 `null`。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_GUARANTEED_DEREF">
    <ShortDescription>空值保证会被解引用  Null value is guaranteed to be dereferenced</ShortDescription>
    <LongDescription>在 `{1}` 中，`{2.givenClass}` 可能为 null 并且保证会被解引用。</LongDescription>
    <Details>
          <![CDATA[<p>存在一个语句或分支，如果执行了该语句或分支，在此点上可以保证某个值为null，并且除了涉及运行时异常的向前路径外，该值将被去引用。</p>
<p>请注意，类似于<code>if (x == null) throw new NullPointerException();</code>的检查也被视为对<x>的去引用。</p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH">
    <ShortDescription>值为null，并且在异常路径上保证会被解引用。  Value is null and guaranteed to be dereferenced on exception path</ShortDescription>
    <LongDescription>在异常路径上，{1} 中保证了对 {2.name} 进行了解引用操作。</LongDescription>
    <Details>
          <![CDATA[<p>在异常路径上存在一条语句或分支，如果执行该语句会在该点确保一个值为null，并且该值将在后续代码中被解引用（除了涉及运行时异常的前向路径）。 </p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="SI_INSTANCE_BEFORE_FINALS_ASSIGNED">
    <ShortDescription>静态初始化器在所有静态final字段被赋值之前创建实例  Static initializer creates instance before all static final fields assigned</ShortDescription>
    <LongDescription>{0}的静态初始化器在所有static final字段被赋值之前创建实例</LongDescription>
    <Details>
<![CDATA[<p>该类的静态初始化器在所有静态最终字段被赋值之前创建了类的一个实例。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="OS_OPEN_STREAM">
    <ShortDescription>方法可能无法关闭流  Method may fail to close stream</ShortDescription>
    <LongDescription>{1} 可能无法关闭流</LongDescription>
    <Details>
<![CDATA[<p>该方法创建了一个IO流对象，但没有将其赋值给任何字段，也没有将其传递给其他可能关闭它的方法，也没有返回它，并且在方法的所有路径结束时都没有显式关闭流。这可能会导致文件描述符泄漏。通常建议使用<code>finally</code>块来确保流被正确关闭。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="OS_OPEN_STREAM_EXCEPTION_PATH">
    <ShortDescription>方法可能在异常情况下无法关闭流  Method may fail to close stream on exception</ShortDescription>
    <LongDescription>{1} 在异常情况下可能未能关闭流</LongDescription>
    <Details>
<![CDATA[<p>该方法创建了一个IO流对象，但未将其分配给任何字段、传递给其他方法或返回它，并且在所有可能的异常路径中都没有出现关闭它的代码。这可能会导致文件描述符泄漏。通常建议使用<code>finally</code>块来确保流被正确关闭。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="PZLA_PREFER_ZERO_LENGTH_ARRAYS">
    <ShortDescription>考虑返回一个空数组而不是null  Consider returning a zero length array rather than null</ShortDescription>
    <LongDescription>{1}应该返回一个空数组而不是null吗？</LongDescription>
    <Details>
<![CDATA[<p>通常，返回长度为零的数组而不是空引用以表示没有结果（即结果为空列表）是一种更好的设计。这样客户端方法就不需要进行空指针检查了。</p>
<p>另一方面，使用空引用表示“对这个问题没有答案”可能是适当的。例如，<code>File.listFiles()</code> 如果给定的是一个不包含文件的目录，则返回一个空列表；如果该文件不是目录，则返回 null。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UCF_USELESS_CONTROL_FLOW">
    <ShortDescription>无用的控制流  Useless control flow</ShortDescription>
    <LongDescription>在 `{1}` 中存在无用的控制流</LongDescription>
    <Details>
<![CDATA[<p>该方法包含一个无用的控制流语句，无论条件分支是否被选择，控制流都会继续前往同一个位置。例如，这可能是由于在一个 `if` 语句中有一个空语句块导致的：</p>
<pre><code>if (argv.length == 0) {     // TODO: 处理这种情况
}</code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UCF_USELESS_CONTROL_FLOW_NEXT_LINE">
    <ShortDescription>无用的控制流跳转到下一行  Useless control flow to next line</ShortDescription>
    <LongDescription>在第{1}行使用了不必要的控制流转移到下一行。</LongDescription>
    <Details>
<![CDATA[<p>该方法包含一个无用的控制流语句，在这种情况下，无论分支是否被执行，控制流都会继续流向同一行或后续行。这通常是无意中将空语句作为 <code>if</code> 语句的主体导致的，例如：</p>
<pre><code>if (argv.length == 1);     System.out.println("Hello, " + argv[0]); </code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE">
    <ShortDescription>先前解引用过的值的空检查  Nullcheck of value previously dereferenced</ShortDescription>
    <LongDescription>在第{4#lineNumber}行的{2#givenClass}中的空值检查，在{1}中之前已经对该值进行了解引用。</LongDescription>
    <Details>
<![CDATA[<p>在这里检查一个值是否为空，但该值不可能为空，因为它之前已被去引用，在早期的去引用操作中如果它为空，则会抛出空指针异常。本质上，这段代码与之前的去引用操作关于该值是否允许为空的观点是矛盾的。要么这个检查是多余的，要么之前的去引用操作有误。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE">
    <ShortDescription>对已知为null的值进行冗余空指针检查  Redundant nullcheck of value known to be null</ShortDescription>
    <LongDescription>在{1}中已知{2}为null的情况下，对其进行冗余的空检查</LongDescription>
    <Details>
<![CDATA[<p>该方法对已知为 null 的值进行了冗余的 null 常量检查。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE">
    <ShortDescription>对已知非空值进行多余的空检查  Redundant nullcheck of value known to be non-null</ShortDescription>
    <LongDescription>在{1}中，{2}已知为非空，因此对其进行冗余的空值检查。</LongDescription>
    <Details>
<![CDATA[<p>该方法中对已知非空值进行了多余的null常量检查。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES">
    <ShortDescription>两个null值的冗余比较  Redundant comparison of two null values</ShortDescription>
    <LongDescription>在 {1} 中对两个空值进行了冗余比较。</LongDescription>
    <Details>
<![CDATA[<p>该方法中包含了两个已知为必定为空的引用之间的冗余比较。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE">
    <ShortDescription>对非空值进行与空值的冗余比较  Redundant comparison of non-null value to null</ShortDescription>
    <LongDescription>在 {1} 中对非空值进行了与 null 的冗余比较</LongDescription>
    <Details>
<![CDATA[<p>该方法中包含一个已知非空的引用和另一个已知为空的引用。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_CHECKED_NULL_COMPARISON" deprecated="true"> <!-- deprecated in favor of two separate RCN_ patterns -->
    <ShortDescription>之前已检查过的值与null的冗余比较  Redundant comparison to null of previously checked value</ShortDescription>
    <LongDescription>在{1}中，对之前已检查过的{2}进行了多余的null比较。</LongDescription>
    <Details>
<![CDATA[<p>该方法中包含对引用值与null的冗余比较。报告了两种类型的冗余比较：</p>
<ul>
<li>两个比较的值都肯定是null</li>
<li>一个值肯定是null，另一个值肯定是不为null</li>
</ul>
<p>这种警告通常表明对已知不会为null的值进行了与null的检查。虽然这个检查是不必要的，但它可能是出于防御性编程的原因。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UL_UNRELEASED_LOCK">
    <ShortDescription>方法在所有路径上都没有释放锁  Method does not release lock on all paths</ShortDescription>
    <LongDescription>{1} 在所有路径上都没有释放锁。</LongDescription>
    <Details>
<![CDATA[<p>该方法获取了一个JSR-166（<code>java.util.concurrent</code>）锁，但在方法的所有出口路径上并未释放该锁。通常使用JSR-166锁的正确方式如下：</p>
<pre><code>Lock l = ...; 
l.lock(); 
try {     
    // 执行某些操作 
} finally {    
    l.unlock(); 
}</code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UL_UNRELEASED_LOCK_EXCEPTION_PATH">
    <ShortDescription>方法在所有异常路径中都没有释放锁  Method does not release lock on all exception paths</ShortDescription>
    <LongDescription>在所有异常路径中未释放锁。</LongDescription>
    <Details>
<![CDATA[<p>该方法获取了一个JSR-166（<code>java.util.concurrent</code>）锁，但在方法的所有异常退出路径中并未释放该锁。通常使用JSR-166锁的正确方式是：</p>
<pre><code>Lock l = ...; 
l.lock(); 
try {     
    // 执行某些操作
} finally {     
    l.unlock(); 
} </code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RC_REF_COMPARISON">
    <ShortDescription>可疑的引用比较  Suspicious reference comparison</ShortDescription>
    <LongDescription>在 {1} 中对 {2} 的引用进行了可疑比较。</LongDescription>
    <Details>
<![CDATA[<p>此方法使用 == 或 != 运算符比较两个引用值，而此类实例通常应使用 equals() 方法进行比较。可能创建相等但不是同一个对象的独立实例，在这种情况下，虽然它们相等但不会通过 == 比较出来。一般来说，不应按引用比较的类包括 java.lang.Integer、java.lang.Float 等。RC_REF_COMPARISON 只涵盖原始类型的包装类型。可以通過添加 frc.suspicious 系统属性来扩展可疑类型列表，该属性以逗号分隔的类形式列出：</p>
<pre><code>&lt;systemPropertyVariables&gt;
   &lt;frc.suspicious&gt;java.time.LocalDate,java.util.List&lt;/frc.suspicious&gt;
      &lt;/systemPropertyVariables&gt;
</code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RC_REF_COMPARISON_BAD_PRACTICE">
    <ShortDescription>将常量与可疑引用进行比较  Suspicious reference comparison to constant</ShortDescription>
    <LongDescription>在{1}中将{2}引用与常量进行可疑比较</LongDescription>
    <Details>
<![CDATA[<p>此方法使用 == 或 != 运算符将参考值与常量进行比较，而通常情况下，应使用 equals() 方法来比较此类实例。有可能创建出相等但不是同一个对象的不同实例。一般不应按引用比较的类示例包括 java.lang.Integer、java.lang.Float 等。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN">
    <ShortDescription>布尔值的可疑引用比较  Suspicious reference comparison of Boolean values</ShortDescription>
    <LongDescription>在{1}中进行了布尔引用的可疑比较。</LongDescription>
    <Details>
<![CDATA[<p>此方法使用 == 或 != 运算符比较两个布尔值。通常只有两种布尔值（Boolean.TRUE 和 Boolean.FALSE），但可以使用 <code>new Boolean(b)</code> 构造函数创建其他布尔对象。最好避免使用此类对象，但如果它们存在，则使用 == 或 != 检查布尔对象的相等性将得到与使用 <code>.equals(...)</code> 不同的结果。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_UNRELATED_TYPES_USING_POINTER_EQUALITY">
    <ShortDescription>使用指针等价性来比较不同类型的对象  Using pointer equality to compare different types</ShortDescription>
    <LongDescription>在{1}中使用指针相等性比较一个{2.givenClass}与一个{3.givenClass}。</LongDescription>
    <Details>
<![CDATA[<p>该方法使用指针相等性比较两个看似为不同类型的引用。这种比较的结果在运行时总是会返回false。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_UNRELATED_TYPES">
    <ShortDescription>对不同类型的调用equals()方法比较  Call to equals() comparing different types</ShortDescription>
    <LongDescription>在 {1} 中调用了 {3.simpleClass}.equals({2.simpleClass}) 方法</LongDescription>
    <Details>
<![CDATA[<p>该方法对两个不同类类型的引用调用了equals(Object)方法，并且分析表明在运行时它们将指向不同的类的对象。此外，检查即将被调用的equals方法表明，要么此调用始终返回false，要么equals方法不具备对称性（这是class Object中equals方法合同要求的一个属性）。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_UNRELATED_INTERFACES">
    <ShortDescription>在比较不同接口类型时调用了equals()方法  Call to equals() comparing different interface types</ShortDescription>
    <LongDescription>在 {1} 中调用了 {3.simpleClass}.equals({2.simpleClass}) 方法</LongDescription>
    <Details>
<![CDATA[<p>该方法对两个无关接口类型的引用调用了equals(Object)，且 neither 是另一个的子类型，同时也没有已知的具体类会实现这两个接口。因此，在运行时比较的对象很可能不属于同一类（除非某些应用类未被分析，或者可以在运行时动态加载类）。根据equals() 的合同，不同类的对象应该总是比较不相等；因此，根据 java.lang.Object.equals(Object) 定义的合同，在运行时该比较的结果将始终为 false。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_UNRELATED_CLASS_AND_INTERFACE">
    <ShortDescription>在调用equals()方法时比较了不相关的类和接口  Call to equals() comparing unrelated class and interface</ShortDescription>
    <LongDescription>在 {1} 中调用了 {3.simpleClass}.equals({2.simpleClass}) 方法</LongDescription>
    <Details>
      <![CDATA[<p>此方法在两个引用上调用了equals(Object)，其中一个是指定的类，另一个是接口。然而，该类及其非抽象子类均未实现该接口。因此，在运行时比较的对象很可能不属于同一类（除非某些应用类未被分析，或者可以在运行时进行动态类加载）。根据equals()的方法合同，不同类的对象应始终比较为不相等；因此，按照java.lang.Object.equals(Object)定义的合同，在运行时此比较的结果将总是为false。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="EC_NULL_ARG">
    <ShortDescription>对 null 调用 equals() 方法  Call to equals(null)</ShortDescription>
    <LongDescription>在{1}中调用了equals(null)方法</LongDescription>
    <Details>
<![CDATA[<p>此方法调用了 equals(Object) 方法，并将 null 作为参数传递。根据 equals() 方法的合同，此调用应始终返回 <code>false</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MWN_MISMATCHED_WAIT">
    <ShortDescription>不匹配的wait()  Mismatched wait()</ShortDescription>
    <LongDescription>在 {1} 中发现了不匹配的 wait() 方法调用</LongDescription>
    <Details>
<![CDATA[<p>此方法在明显未持有对象锁的情况下调用了Object.wait()。不在持有锁的情况下调用wait()将会抛出<code>IllegalMonitorStateException</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MWN_MISMATCHED_NOTIFY">
    <ShortDescription>不匹配的notify()  Mismatched notify()</ShortDescription>
    <LongDescription>在{1}中发现了不匹配的notify()调用。</LongDescription>
    <Details>
<![CDATA[<p>该方法在没有明显持有对象锁的情况下调用了Object.notify()或Object.notifyAll()。在未持有锁的情况下调用notify()或notifyAll()将导致抛出<code>IllegalMonitorStateException</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_LOCAL_SELF_ASSIGNMENT_INSTEAD_OF_FIELD">
    <ShortDescription>局部变量的自我赋值而不是字段赋值  Self assignment of local rather than assignment to field</ShortDescription>
    <LongDescription>在{1}中，{2}被自我赋值而不是分配给字段。</LongDescription>
    <Details>
<![CDATA[<p>该方法中局部变量进行了自我赋值，并且存在一个同名的字段，例如：</p>
<pre><code>int foo;
public void setFoo(int foo) {
    foo = foo;
}
</code></pre>
<p>这种赋值是多余的。您是不是应该将值赋给字段而不是局部变量？ </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_LOCAL_SELF_ASSIGNMENT">
    <ShortDescription>局部变量的自我赋值  Self assignment of local variable</ShortDescription>
    <LongDescription>在 {1} 中，{2} 发生了自我赋值。</LongDescription>
    <Details>
<![CDATA[<p>此方法中包含对局部变量的自我赋值；例如：</p>
<pre><code>public void foo() {     int x = 3;     x = x; }</code></pre>
<p>此类赋值是多余的，并且可能会指示逻辑错误或打字错误。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_FIELD_SELF_ASSIGNMENT">
    <ShortDescription>字段的自我赋值  Self assignment of field</ShortDescription>
    <LongDescription>在 `{1}` 中，字段 `{2.givenClass}` 进行了自我赋值。</LongDescription>
    <Details>
<![CDATA[<p>该方法中包含对字段的自我赋值；例如：</p>
<pre><code>int x;
public void foo() {
    x = x;
}
</code></pre>
<p>这样的赋值是无用的，并且可能会指示逻辑错误或打字错误。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_FIELD_DOUBLE_ASSIGNMENT">
    <ShortDescription>字段的双重赋值  Double assignment of field</ShortDescription>
    <LongDescription>在 {1} 中为字段 {2.givenClass} 进行了双赋值。</LongDescription>
    <Details>
<![CDATA[<p>该方法中对字段进行了双重赋值；例如：</p>
<pre><code>int x,y;
public void foo() {
    x = x = 17;
}</code></pre>
<p>对字段进行两次赋值是多余的，并且可能表示逻辑错误或打字误操作。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_LOCAL_DOUBLE_ASSIGNMENT">
    <ShortDescription>局部变量的双重赋值  Double assignment of local variable</ShortDescription>
    <LongDescription>在 {1} 中，{2} 被双赋值。</LongDescription>
    <Details>
<![CDATA[<p>该方法中存在局部变量的双赋值；例如： </p> <pre><code>public void foo() {     int x,y;     x = x = 17; } </code></pre> <p>两次给同一个变量赋相同的值是多余的，并且可能表示逻辑错误或打字误入。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_FIELD_SELF_COMPUTATION">
    <ShortDescription>涉及字段的无意义自我计算（例如，x &amp; x）  Nonsensical self computation involving a field (e.g., x &amp; x)</ShortDescription>
    <LongDescription>在{1}中，{2.givenClass}进行了自我计算，这似乎是不必要的。</LongDescription>
    <Details>
<![CDATA[<p>该方法对一个字段进行了与自身引用的非理性计算（例如，x&x 或 x-x）。由于计算的本质，这种操作似乎没有意义，并且可能表明存在 typos 或逻辑错误。请重新检查此计算。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_LOCAL_SELF_COMPUTATION">
    <ShortDescription>涉及变量的自运算（例如，x &amp; x）是无意义的计算  Nonsensical self computation involving a variable (e.g., x &amp; x)</ShortDescription>
    <LongDescription>在{1}中，{2}与自身进行了 nonsensical 的自我计算。</LongDescription>
    <Details>
<![CDATA[<p>该方法对一个局部变量与同一个变量的另一个引用进行一种无意义的计算（例如，x&x 或 x-x）。由于计算的本质，这种操作似乎没有意义，并且可能表示 Typo 错误或逻辑错误。请再次检查该计算。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_FIELD_SELF_COMPARISON">
    <ShortDescription>将自己的字段与自身进行比较  Self comparison of field with itself</ShortDescription>
    <LongDescription>{2.givenClass} 在 {1} 中与自身进行了自我比较。</LongDescription>
    <Details>
<![CDATA[<p>该方法将一个字段与其自身进行比较，可能会指示打字错误或逻辑错误。请确保您比较的是正确的项。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_LOCAL_SELF_COMPARISON">
    <ShortDescription>将自己的值与自身进行比较  Self comparison of value with itself</ShortDescription>
    <LongDescription>自我比较 {2} 与自身 {1}</LongDescription>
    <Details>
<![CDATA[<p>该方法将局部变量与其自身进行比较，可能指示打字错误或逻辑错误。请确保您比较的是正确的东西。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT">
    <ShortDescription>在该代码中，使用了`Double.longBitsToDouble`方法对一个int类型的值进行了操作。  Double.longBitsToDouble invoked on an int</ShortDescription>
    <LongDescription>在 `{1}` 中调用了 `Double.longBitsToDouble` 方法传入的是一个 `int`。</LongDescription>
    <Details>
<![CDATA[<p>调用了 Double.longBitsToDouble 方法，但传递的是一个 32 位 int 值。这几乎肯定不是预期的行为，并且不太可能得到预期的结果。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_ARGUMENTS_WRONG_ORDER">
    <ShortDescription>反转的方法参数  Reversed method arguments</ShortDescription>
    <LongDescription>在{1}中对{2.name}的调用参数顺序错误</LongDescription>
    <Details>
<![CDATA[<p>这个方法调用的参数顺序似乎不对。例如，调用<code>Preconditions.checkNotNull("message", message)</code>时，保留参数的位置错误：要检查的值应该是第一个参数。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_RANDOM_USED_ONLY_ONCE">
    <ShortDescription>随机对象仅创建并使用一次  Random object created and used only once</ShortDescription>
    <LongDescription>在{1}中，仅创建并使用一次随机对象。</LongDescription>
    <Details>
<![CDATA[<p>这段代码创建了一个 java.util.Random 对象，使用它生成一个随机数，然后丢弃该 Random 对象。这会产生质量一般的随机数并且是低效的。如果可能，请重写代码，使其只在初始化时创建一次 Random 对象并保存起来，在每次需要新随机数时调用现有 Random 对象的方法来获取。</p>
<p>如果生成的随机数不能被猜出至关重要，则<strong>必须</strong>不要为每个随机数都创建一个新的 Random；这样产生的值很容易被猜出。你应该强烈考虑使用 java.security.SecureRandom（并且避免为每次需要的新随机数分配一个新 SecureRandom 对象）。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_ABSOLUTE_VALUE_OF_RANDOM_INT">
    <ShortDescription>尝试计算有符号随机整数的绝对值是不良做法  Bad attempt to compute absolute value of signed random integer</ShortDescription>
    <LongDescription>在{1}中尝试计算有符号随机整数的绝对值是不良做法。</LongDescription>
    <Details>
<![CDATA[<p>这段代码生成一个随机的带符号整数，然后计算该随机整数的绝对值。如果随机数生成器返回的是 <code>Integer.MIN_VALUE</code>，那么结果也会是负数（因为 <code>Math.abs(Integer.MIN_VALUE) == Integer.MIN_VALUE</code>)。同样的问题也出现在 long 类型的值中。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_ABSOLUTE_VALUE_OF_HASHCODE">
    <ShortDescription>尝试计算有符号32位哈希码的绝对值是不良做法。  Bad attempt to compute absolute value of signed 32-bit hashcode</ShortDescription>
    <LongDescription>在{1}中尝试计算带有符号的32位哈希码的绝对值是一个糟糕的做法。</LongDescription>
    <Details>
<![CDATA[<p>这段代码生成一个哈希码，然后计算该哈希码的绝对值。如果哈希码是 <code>Integer.MIN_VALUE</code>，那么结果也将是负数（因为 <code>Math.abs(Integer.MIN_VALUE) == Integer.MIN_VALUE</code>)。</p>
<p>大约每2^32个字符串有一个哈希码为 Integer.MIN_VALUE，包括 "polygenelubricants"、"GydZG_" 和 ""DESIGNING WORKHOUSES""。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_REM_OF_RANDOM_INT">
    <ShortDescription>32位-signed随机整数的余数  Remainder of 32-bit signed random integer</ShortDescription>
    <LongDescription>在{1}中计算32位带符号随机整数的余数</LongDescription>
    <Details>
<![CDATA[<p>这段代码生成一个随机的带符号整数，然后计算该值除以另一个值后的余数。由于随机数可能是负数，因此余数操作的结果也可能为负数。请确保这是有意为之，并强烈考虑使用 Random.nextInt(int) 方法代替。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_REM_OF_HASHCODE">
    <ShortDescription>hashCode的余数可能是负数  Remainder of hashCode could be negative</ShortDescription>
    <LongDescription>在 `{1}` 中，`hashCode` 的余数可能是负数。</LongDescription>
    <Details>
<![CDATA[<p>该代码计算哈希码，然后将该值与另一个值进行取余运算。由于哈希码可以是负数，因此取余操作的结果也可能为负数。</p>
<p>假设你需要确保计算结果是非负的，则可能需要修改你的代码。如果知道除数是2的幂次，则可以使用位与运算符（即，而不是使用 <code>x.hashCode()%n</code>，可以使用 <code>x.hashCode()&(n-1)</code>）。这可能比计算余数要快一些。如果你不知道除数是否是2的幂次，则可以取余操作结果的绝对值（即，使用 <code>Math.abs(x.hashCode()%n)</code>）。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE">
    <ShortDescription>非负值与负常量或零进行不良比较  Bad comparison of nonnegative value with negative constant or zero</ShortDescription>
    <LongDescription>在{1}中，非负值与{2}进行了不良比较。</LongDescription>
    <Details>
<![CDATA[<p>该代码将一个保证非负的值与一个负常量或零进行比较。</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="INT_BAD_COMPARISON_WITH_SIGNED_BYTE">
    <ShortDescription>对有符号字节的不良比较  Bad comparison of signed byte</ShortDescription>
    <LongDescription>在{1}中，使用了对-signed byte-与{2}进行不良比较。</LongDescription>
    <Details>
<![CDATA[<p>有符号字节只能在 -128 到 127 的范围内取值。将有符号字节 <code>b</code> 与该范围之外的值进行比较是徒劳的，很可能是不正确的。要将有符号字节 <code>b</code> 转换为 0 到 255 范围内的无符号值，可以使用 <code>0xff &amp; b</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="INT_BAD_COMPARISON_WITH_INT_VALUE">
    <ShortDescription>将整数值与长常量进行不良比较  Bad comparison of int value with long constant</ShortDescription>
    <LongDescription>在{1}中，int与{2}进行了不良比较。</LongDescription>
    <Details>
<![CDATA[<p>这段代码将一个 int 值与一个超出 int 可表示值范围的 long 常量进行了比较。这种比较是空洞的，并且可能是不正确的。</p>]]>
    </Details>
  </BugPattern>


  <BugPattern type="INT_VACUOUS_BIT_OPERATION">
    <ShortDescription>对整数值进行虚幻位掩码操作  Vacuous bit mask operation on integer value</ShortDescription>
    <LongDescription>在{1}中对{3}进行了空操作{2}</LongDescription>
    <Details>
<![CDATA[<p>这是一些无用的整数位操作（如与、或、异或操作，例如 <code>v & 0xffffffff</code>）。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="INT_VACUOUS_COMPARISON">
    <ShortDescription>整数值的空洞比较  Vacuous comparison of integer value</ShortDescription>
    <LongDescription>整数值 {1} 的空洞比较</LongDescription>
    <Details>
<![CDATA[<p>存在一个整数比较总是返回相同值的情况（例如，x <= Integer.MAX_VALUE）。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="INT_BAD_REM_BY_1">
    <ShortDescription>整数对1取余  Integer remainder modulo 1</ShortDescription>
    <LongDescription>在{1}中计算了整数余模1。</LongDescription>
    <Details>
<![CDATA[<p>(exp % 1) 表达式总是返回零。您本应使用 (exp & 1) 或 (exp % 2) 吗？</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_IOR_OF_SIGNED_BYTE">
    <ShortDescription>有符号字节值的位或运算  Bitwise OR of signed byte value</ShortDescription>
    <LongDescription>在{1}中计算了带符号字节值的按位或运算</LongDescription>
    <Details>
<![CDATA[<p>加载一个字节值（例如，从字节数组中加载或由返回类型为 byte 的方法返回的值），并对其进行位与操作。在对值进行任何位运算之前，字节值会扩展到 32 位。因此，如果 `b[0]` 包含值 `0xff`，并且 `x` 初始为 0，则代码 `((x << 8) | b[0])` 将将 `0xff` 扩展为 `0xffffffff`，从而给出结果值 `0xffffffff`。</p>

<p>特别是以下用于将字节数组打包成 int 的代码是错误的：</p>
<pre><code>int result = 0;
for (int i = 0; i < 4; i++) {
    result = ((result << 8) | b[i]);
}
</code></pre>

<p>可以使用以下惯用法代替：</p>
<pre><code>int result = 0;
for (int i = 0; i < 4; i++) {
    result = ((result << 8) | (b[i] & 0xff));
}
</code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_ADD_OF_SIGNED_BYTE">
    <ShortDescription>有符号字节值的位运算加法  Bitwise add of signed byte value</ShortDescription>
    <LongDescription>在{1}中计算了带符号字节值的位运算加法</LongDescription>
    <Details>
<![CDATA[<p>将一个字节值与已知其最低8位为清零的值相加。从字节数组加载的值在进行任何位运算之前会扩展到32位。因此，如果`b[0]`包含值`0xff`，而`x`初始值为0，则代码`((x << 8) + b[0])` 将会将`0xff`扩展到`0xffffffff`，从而给出结果`0xffffffff`。</p>  
<p>特别是以下用于将字节数组打包成一个int的代码是错误的：</p>
```java
int result = 0;
for (int i = 0; i < 4; i++)
    result = ((result << 8) + b[i]);
```
<p>而使用下面的惯用法可以正确工作：</p>
```java
int result = 0;
for (int i = 0; i < 4; i++)
    result = ((result << 8) + (b[i] & 0xff));
```]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_AND">
    <ShortDescription>不兼容的位掩码  Incompatible bit masks</ShortDescription>
    <LongDescription>在(e &amp; {2} == {3})中使用不兼容的位掩码会在{1}处产生常量结果。</LongDescription>
    <Details>
<![CDATA[<p>该方法将表达式(e & C)与D进行比较，由于常量C和D的特定值，这始终会比较不相等。这可能表明存在逻辑错误或拼写错误。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_SIGNED_CHECK">
    <ShortDescription>检查位运算符号  Check for sign of bitwise operation</ShortDescription>
    <LongDescription>检查{1}中的位运算符号。</LongDescription>
    <Details>
<![CDATA[<p>该方法比较表达式如 <code>((event.detail &amp; SWT.SELECTED) &gt; 0)</code>。使用位算术然后与大于运算符进行比较可能会导致意外的结果（当然这取决于SWT.SELECTED的值）。如果SWT.SELECTED是负数，这是一个可能存在bug的候选情况。即使SWT.SELECTED不是负数，使用'!= 0'而不是'&gt; 0'似乎也是一种良好的实践。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_SIGNED_CHECK_HIGH_BIT">
    <ShortDescription>检查位运算涉及负数的符号  Check for sign of bitwise operation involving negative number</ShortDescription>
    <LongDescription>在{1}中检查涉及{2}的位运算符号。</LongDescription>
    <Details>
<![CDATA[<p>该方法比较位运算表达式，例如 <code>((val &amp; CONSTANT) > 0)</code>，其中CONSTANT是一个负数。使用位运算然后与大于操作符进行比较可能会导致意外的结果。这种比较很可能不会按预期工作。良好的实践是使用'!= 0'而不是'> 0'。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_AND_ZZ">
    <ShortDescription>检查是否 ((...) &amp; 0) == 0  Check to see if ((...) &amp; 0) == 0</ShortDescription>
    <LongDescription>检查在{1}中是否存在 ((...) &amp; 0) == 0 的情况。</LongDescription>
    <Details>
<![CDATA[<p>此方法将表达式 <code>(e & 0)</code> 与 0 进行比较，这始终会比较相等。这可能表示逻辑错误或打字误操作。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_IOR">
    <ShortDescription>不兼容的位掩码  Incompatible bit masks</ShortDescription>
    <LongDescription>在 `(e | 2 == 3)` 中使用不兼容的位掩码会导致在 `{1}` 中得到常量结果。</LongDescription>
    <Details>
<![CDATA[<p>该方法比较形如 <code>(e | C)</code> 的表达式与 D，由于常量 C 和 D 的特定值，这种比较总是不相等的。这可能表明存在逻辑错误或打字错误。</p>
<p>通常，这种bug是因为代码想要在一个位集合中进行成员测试，但却使用了按位或运算符（“|”）而不是按位与运算符（“&amp;”）。</p>
<p>此外，在表达式如 <code>(e &amp; A | B) == C</code> 中也可能出现此类bug，该表达式会被解析为 <code>((e &amp; A) | B) == C</code>，而本意应该是 <code>(e &amp; (A | B)) == C</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="LI_LAZY_INIT_INSTANCE" deprecated="true"> <!-- never generated? -->
    <ShortDescription>实例字段的懒初始化不正确  Incorrect lazy initialization of instance field</ShortDescription>
    <LongDescription>在{1}中，实例字段{2}的延迟初始化不正确。</LongDescription>
    <Details>
<![CDATA[<p>该方法包含一个非易失性字段的未同步懒初始化。由于编译器或处理器可能会重新排序指令，因此如果该方法可以由多个线程调用，则线程无法保证看到完全初始化的对象。你可以将字段声明为易失性（volatile）以解决此问题。更多信息，请参阅<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/">Java 内存模型网站</a>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="LI_LAZY_INIT_STATIC">
    <ShortDescription>静态字段的懒初始化不正确  Incorrect lazy initialization of static field</ShortDescription>
    <LongDescription>在 `{1}` 中，静态字段 `{2}` 的懒初始化不正确。</LongDescription>
    <Details>
<![CDATA[<p>此方法包含一个非volatile静态字段的懒初始化，并且未同步。由于编译器或处理器可能会重新排序指令，因此如果该方法可以被多个线程调用，则线程不能保证看到一个完全初始化的对象。你可以将字段声明为volatile以纠正这个问题。更多信息，请参见<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/">Java内存模型网站</a>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="LI_LAZY_INIT_UPDATE_STATIC">
    <ShortDescription>不正确的懒初始化和静态字段更新  Incorrect lazy initialization and update of static field</ShortDescription>
    <LongDescription>在{1}中，静态字段{2}的懒初始化和更新不正确</LongDescription>
    <Details>
<![CDATA[<p>该方法包含了一个未同步的懒加载静态字段初始化。一旦字段被设置，存储在该位置的对象将被进一步更新或访问。当字段被设置时，其设置值对其他线程是可见的。如果该方法中的后续访问用于初始化对象，则除非有其他机制确保任何其他线程在对象完全初始化之前无法访问存储的对象，否则这是一个非常严重的多线程错误。</p>
<p>即使你认为该方法从不会由多个线程同时调用，将静态字段留到其设置值被完整填充/初始化后再进行设置也可能是更好的选择。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="JLM_JSR166_LOCK_MONITORENTER">
    <ShortDescription>同步操作执行于Lock上  Synchronization performed on Lock</ShortDescription>
    <LongDescription>在 {1} 中对 {2} 进行了同步操作。</LongDescription>
    <Details>
<![CDATA[<p>此方法对实现了 java.util.concurrent.locks.Lock 接口的对象进行同步。此类对象通过使用 <code>acquire()</code>/<code>release()</code> 而不是使用 <code>synchronized (...)</code> 构造来进行加锁/解锁。</p>]]>
</Details>
  </BugPattern>
  <BugPattern type="JML_JSR166_CALLING_WAIT_RATHER_THAN_AWAIT">
    <ShortDescription>在util.concurrent抽象层上使用监视器风格的wait方法  Using monitor style wait methods on util.concurrent abstraction</ShortDescription>
    <LongDescription>在{1}中调用{2.name}而不是{3.name}</LongDescription>
    <Details>
<![CDATA[<p>该方法在一个同时提供了<code>await()</code>、<code>signal()</code>、<code>signalAll()</code>方法的对象上调用了<code>wait()</code>、<code>notify()</code>或<code>notifyAll()</code>。这很可能不是你想要的效果，即使你需要这样做，你也应该考虑改变你的设计，因为其他开发人员会发现这一点极其 confusing。</p>]]>
</Details>
  </BugPattern>
  <BugPattern type="JLM_JSR166_UTILCONCURRENT_MONITORENTER">
    <ShortDescription>同步操作执行于util.concurrent实例上  Synchronization performed on util.concurrent instance</ShortDescription>
    <LongDescription>在{1}中对{2}进行了同步处理</LongDescription>
    <Details>
<![CDATA[<p>此方法对一个实例来自 java.util.concurrent 包（或其子类）的类的对象进行同步。这些类的实例具有与 Java 关键字 <code>synchronized</code> 提供的同步机制相互独立的并发控制机制。例如，对一个 <code>AtomicBoolean</code> 进行同步并不会阻止其他线程修改这个 <code>AtomicBoolean</code>。</p>
<p>这样的代码可能是正确的，但在代码审查和文档记录时需要格外小心，并且可能会让以后维护代码的人感到困惑。</p>]]>
</Details>
  </BugPattern>
  <BugPattern type="UPM_UNCALLED_PRIVATE_METHOD">
    <ShortDescription>私有方法从不被调用  Private method is never called</ShortDescription>
    <LongDescription>私有方法 {1} 从未被调用</LongDescription>
    <Details>
<![CDATA[<p>这是一个私有方法从不被调用。尽管有可能通过反射来调用该方法，但更可能的是该方法从未使用，应当移除。</p>]]>
</Details>
  </BugPattern>
  <BugPattern type="UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS">
    <ShortDescription>匿名类中定义了无法调用的方法  Uncallable method defined in anonymous class</ShortDescription>
    <LongDescription>在匿名类中定义了无法调用的方法 {1}</LongDescription>
    <Details>
<![CDATA[<p>这个匿名类定义了一个不会直接被调用且不覆盖超类中方法的方法。由于其他类无法直接调用匿名类中声明的方法，似乎这个方法是不可调用的。该方法可能是多余的代码，但也有可能该方法原本打算覆盖超类中声明的方法，但由于 typo 或其他错误，实际上并未覆盖预期的方法。</p>]]>
</Details>
  </BugPattern>
  <BugPattern type="ODR_OPEN_DATABASE_RESOURCE">
    <ShortDescription>方法可能无法关闭数据库资源  Method may fail to close database resource</ShortDescription>
    <LongDescription>可能无法关闭 `{2.excludingPackage}`</LongDescription>
    <Details>
<![CDATA[<p>该方法创建了一个数据库资源（例如，数据库连接或行集），但未将其分配给任何字段、传递给其他方法或返回它，并且在所有从方法退出的路径中都没有关闭对象。如果不从所有方法路径正确关闭数据库资源，可能会导致性能不佳，并可能导致应用程序与数据库通信出现问题。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH">
    <ShortDescription>方法在异常情况下可能无法关闭数据库资源  Method may fail to close database resource on exception</ShortDescription>
    <LongDescription>{1} 在异常情况下可能无法关闭数据库资源。</LongDescription>
    <Details>
<![CDATA[<p>该方法创建了一个数据库资源（例如，数据库连接或行集），但并未将其分配给任何字段、传递给其他方法或返回它，并且在所有从方法退出的异常路径中都没有关闭对象。如果不通过所有路径都正确关闭数据库资源，可能会导致性能较差，并可能导致应用程序与数据库通信出现问题。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SBSC_USE_STRINGBUFFER_CONCATENATION">
    <ShortDescription>方法在循环中使用 + 连接字符串  Method concatenates strings using + in a loop</ShortDescription>
    <LongDescription>{1} 在循环中使用 "+" 连接字符串</LongDescription>
    <Details>
<![CDATA[<p>该方法似乎是在循环中使用连接操作构建字符串。在每次迭代中，字符串会被转换为 StringBuffer 或 StringBuilder 追加内容，然后再转换回字符串。这会导致每次迭代都需要复制增长中的字符串，从而导致成本呈迭代次数的平方级。</p>
<p>通过显式使用 StringBuffer（或 Java 5 中的 StringBuilder）可以获得更好的性能。</p>
<p>例如：</p>
<pre><code>// 这是不好的做法
String s = "";
for (int i = 0; i < field.length; ++i) {
    s = s + field[i];
}

// 这是更好的做法
StringBuffer buf = new StringBuffer();
for (int i = 0; i < field.length; ++i) {
    buf.append(field[i]);
}
String s = buf.toString();
</code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIL_PREPARE_STATEMENT_IN_LOOP">
    <ShortDescription>在循环中使用 prepareStatement 方法调用  Method calls prepareStatement in a loop</ShortDescription>
    <LongDescription>{1} 在循环中使用常量参数调用 `prepareStatement` 方法</LongDescription>
    <Details>
<![CDATA[<p>该方法在循环中调用了 Connection.prepareStatement，并传递了常量参数。如果PreparedStatement需要多次执行，就没有必要在每个循环迭代中重新创建它。将此调用移出循环。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIL_ELEMENTS_GET_LENGTH_IN_LOOP">
    <ShortDescription>在循环中调用了 NodeList.getLength() 方法  NodeList.getLength() called in a loop</ShortDescription>
    <LongDescription>{1} 在循环中调用 NodeList.getLength() 来获取 getElementsByTagName 返回的值</LongDescription>
    <Details>
<![CDATA[<p>该方法在循环中调用了NodeList.getLength()，而NodeList是通过getElementsByTagName调用生成的。这个NodeList没有存储其长度，而是每次都在不太理想的方式下重新计算它。可以在循环前将长度值存到一个变量中考虑一下。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIL_PATTERN_COMPILE_IN_LOOP">
    <ShortDescription>在循环中调用 `Pattern.compile` 方法  Method calls Pattern.compile in a loop</ShortDescription>
    <LongDescription>{1} 在循环中使用常量参数调用Pattern.compile()</LongDescription>
    <Details>
<![CDATA[<p>该代码在循环中调用 `Pattern.compile` 方法，并传递常量参数。如果 `Pattern` 在多次使用时，没有必要在每次循环迭代中进行编译。可以将此调用移出循环，甚至放入静态最终字段中。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIL_PATTERN_COMPILE_IN_LOOP_INDIRECT">
    <ShortDescription>方法在循环中编译正则表达式  Method compiles the regular expression in a loop</ShortDescription>
    <LongDescription>{1} 在循环中编译正则表达式</LongDescription>
    <Details>
<![CDATA[<p>该方法在循环中创建了相同的正则表达式，因此会在每次迭代时进行编译。最好是在循环外部使用Pattern.compile预编译这个正则表达式以提高效率。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIO_INEFFICIENT_INDEX_OF">
    <ShortDescription>对 `String.indexOf(String)` 的使用不够高效  Inefficient use of String.indexOf(String)</ShortDescription>
    <LongDescription>{1} 使用了 `String.indexOf(String)` 而不是 `String.indexOf(int)`。</LongDescription>
    <Details>
<![CDATA[<p>这段代码将一个长度为1的常量字符串传递给String.indexOf()方法。使用整数实现的String.indexOf()更为高效，例如可以调用<code>myString.indexOf('.')</code>代替<code>myString.indexOf(".")

</code></p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIO_INEFFICIENT_LAST_INDEX_OF">
    <ShortDescription>对 `String.lastIndexOf(String)` 的使用不够高效  Inefficient use of String.lastIndexOf(String)</ShortDescription>
    <LongDescription>{1} 使用 `String.lastIndexOf(String)` 代替 `String.lastIndexOf(int)`</LongDescription>
    <Details>
<![CDATA[<p>这段代码将长度为1的常量字符串传递给String.lastIndexOf()方法。使用整数版本的String.lastIndexOf()更为高效，例如调用<code>myString.lastIndexOf('.') </code>而不是<code>myString.lastIndexOf(".")</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ITA_INEFFICIENT_TO_ARRAY">
    <ShortDescription>方法使用了带有零长度数组参数的toArray()方法  Method uses toArray() with zero-length array argument</ShortDescription>
    <LongDescription>{1} 使用了 `Collection.toArray()` 并带有一个空数组作为参数。</LongDescription>
    <Details>
<![CDATA[<p>该方法使用了集合派生类的 toArray() 方法，并传递了一个零长度的原型数组参数。更高效的做法是使用 <code>myCollection.toArray(new Foo[myCollection.size()])</code>。如果传递的数组足够大以容纳集合中的所有元素，则可以直接填充并返回该数组，从而避免通过反射创建第二个数组来作为结果返回。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD">
    <ShortDescription>在 `run` 方法中使用的 JUnit 断言不会被 JUnit 检测到。  JUnit assertion in run method will not be noticed by JUnit</ShortDescription>
    <LongDescription>在 `{1}` 中的 JUnit 断言不会被 JUnit 检测到。</LongDescription>
    <Details>
<![CDATA[<p>在run方法中执行了一个JUnit断言。失败的JUnit断言只会抛出异常。因此，如果这个异常发生在调用测试方法的线程之外的线程中，将会终止该线程但不会导致测试失败。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IJU_SETUP_NO_SUPER">
    <ShortDescription>testCase定义了setUp方法，但没有调用super.setUp()方法。  TestCase defines setUp that doesn't call super.setUp()</ShortDescription>
    <LongDescription>测试用例 {0} 定义了 `setUp` 但没有调用 `super.setUp()` 方法。</LongDescription>
    <Details>
<![CDATA[<p>Class是一个JUnit测试案例，并实现了setUp方法。但是，setUp方法没有调用super.setUp()。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IJU_TEARDOWN_NO_SUPER">
    <ShortDescription>testCase定义了tearDown方法，但没有调用super.tearDown()  TestCase defines tearDown that doesn't call super.tearDown()</ShortDescription>
    <LongDescription>测试用例 {0} 定义了 `tearDown` 但没有调用 `super.tearDown()`</LongDescription>
    <Details>
<![CDATA[<p>Class 是一个 JUnit 测试案例，并实现了 tearDown 方法。tearDown 方法应该调用 super.tearDown()，但并未这样做。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IJU_SUITE_NOT_STATIC">
    <ShortDescription>testCase 实现了一个非静态套件方法  TestCase implements a non-static suite method</ShortDescription>
    <LongDescription>测试用例 {0} 实现了一个非静态套件方法</LongDescription>
    <Details>
<![CDATA[<p>Class 是一个 JUnit 测试案例，并实现了 suite() 方法。但 suite 方法没有被声明为静态。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IJU_BAD_SUITE_METHOD">
    <ShortDescription>测试用例声明了一个不良的套件方法  TestCase declares a bad suite method</ShortDescription>
    <LongDescription>在{0}中，套件方法的声明不正确。</LongDescription>
    <Details>
<![CDATA[<p>Class 是一个 JUnit TestCase，并定义了一个 suite() 方法。但是，suite 方法需要声明为以下之一：</p>
<pre><code>public static junit.framework.Test suite()</code></pre>
<p> 或者 </p>
<pre><code>public static junit.framework.TestSuite suite()</code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IJU_NO_TESTS">
    <ShortDescription>testCase 没有测试用例  TestCase has no tests</ShortDescription>
    <LongDescription>测试用例 {0} 没有包含任何测试。</LongDescription>
    <Details>
<![CDATA[<p>Class是一个JUnit测试案例，但没有实现任何测试方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BOA_BADLY_OVERRIDDEN_ADAPTER">
    <ShortDescription>类在适配器中错误地重写了超类中实现的方法  Class overrides a method implemented in super class Adapter wrongly</ShortDescription>
    <LongDescription>类 {0} 在重写来自适配器超类的方法 {1} 时存在错误。</LongDescription>
    <Details>
<![CDATA[<p>该方法重写了父类中的一个方法，而该父类是一个适配器，实现了定义在java.awt.event或javax.swing.event包中的监听器接口。因此，当事件发生时，该方法不会被调用。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BRSA_BAD_RESULTSET_ACCESS" deprecated="true"> <!-- deprecated in favor of SQL_BAD_RESULTSET_ACCESS -->
    <ShortDescription>方法尝试使用索引 0 访问结果集字段。  Method attempts to access a result set field with index 0</ShortDescription>
    <LongDescription>尝试使用索引0访问结果集字段</LongDescription>
    <Details>
<![CDATA[<p>在调用结果集的getXXX或updateXXX方法时，字段索引使用了0。由于结果集中的字段从索引1开始，这始终是一个错误。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SQL_BAD_RESULTSET_ACCESS">
    <ShortDescription>方法尝试使用索引 0 访问结果集字段  Method attempts to access a result set field with index 0</ShortDescription>
    <LongDescription>尝试使用索引0访问结果集字段</LongDescription>
    <Details>
<![CDATA[<p>在调用结果集的getXXX或updateXXX方法时，字段索引为0。由于ResultSet中的字段从索引1开始，因此这始终是一个错误。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SQL_BAD_PREPARED_STATEMENT_ACCESS">
    <ShortDescription>方法尝试使用索引 0 访问预编译语句参数。  Method attempts to access a prepared statement parameter with index 0</ShortDescription>
    <LongDescription>尝试使用索引 0 访问预编译语句参数。</LongDescription>
    <Details>
<![CDATA[<p>在调用预处理语句的setXXX方法时，参数索引为0。由于参数索引从1开始，这始终是一个错误。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIO_SUPERFLUOUS_INSTANCEOF">
    <ShortDescription>使用 `instanceof` 运算符进行的不必要的类型检查  Unnecessary type check done using instanceof operator</ShortDescription>
    <LongDescription>{1} 使用 `instanceof` 运算符进行不必要的类型检查，当可以通过静态分析确定时可以省略。</LongDescription>
    <Details>
<![CDATA[<p>使用 instanceof 运算符进行类型检查，可以在静态确定对象是否为所需类型时使用。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BAC_BAD_APPLET_CONSTRUCTOR">
    <ShortDescription>不良的Applet构造函数依赖于未初始化的AppletStub  Bad Applet Constructor relies on uninitialized AppletStub</ShortDescription>
    <LongDescription>不良的Applet构造函数依赖于未初始化的AppletStub</LongDescription>
    <Details>
<![CDATA[<p>这个构造函数调用了依赖于AppletStub的方法，而AppletStub只有在该applet的init()方法被调用后才会初始化。因此这些方法将无法正确运行。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_ARRAY_AND_NONARRAY">
    <ShortDescription>使用了 `equals()` 方法来比较数组和非数组。  equals() used to compare array and nonarray</ShortDescription>
    <LongDescription>在 {1} 中调用了 {3.simpleClass}.equals({2.simpleClass}) 方法。</LongDescription>
    <Details>
<![CDATA[<p>此方法使用 .equals(Object o) 来比较一个数组和看起来不是数组的引用。如果被比较的对象类型不同，它们肯定会不相等，这种比较几乎肯定是错误的。即使两者都是数组，数组的 <code>equals()</code> 方法只能确定两个数组是否为同一个对象。要比较数组的内容，请使用 <code>java.util.Arrays.equals(Object[], Object[])</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_BAD_ARRAY_COMPARE">
    <ShortDescription>对数组调用equals()方法，这等同于使用==进行比较。  Invocation of equals() on an array, which is equivalent to ==</ShortDescription>
    <LongDescription>在{1}中，使用.equals来比较两个{2.simpleClass}的实例（相当于==）。</LongDescription>
    <Details>
<![CDATA[<p>此方法调用了数组的 .equals(Object o) 方法。由于数组未覆盖 Object 的 equals 方法，因此调用数组的 equals 方法等同于比较它们的地址。要比较数组的内容，请使用 <code>java.util.Arrays.equals(Object[], Object[])</code>。若要比较数组的地址，则明确地使用 <code>==</code> 进行指针比较会更清楚。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_INCOMPATIBLE_ARRAY_COMPARE">
    <ShortDescription>使用了用于比较不兼容数组的 equals(...) 方法  equals(...) used to compare incompatible arrays</ShortDescription>
    <LongDescription>在{1}中使用equals比较一个{2.simpleClass}和一个{3.simpleClass}。</LongDescription>
    <Details>
<![CDATA[<p>该方法使用 .equals(Object o) 来比较两个数组，但比较的是不兼容类型的数组（例如 String[] 和 StringBuffer[]，或 String[] 和 int[]）。它们永远不会相等。此外，当使用 equals(...) 比较数组时，它只会检查这两个数组是否是同一个数组，并忽略数组的内容。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="STI_INTERRUPTED_ON_CURRENTTHREAD">
    <ShortDescription>unnecessary 使用了 currentThread() 调用，应该使用 interrupted() 方法  Unneeded use of currentThread() call, to call interrupted()</ShortDescription>
    <LongDescription>{1} 仅仅为了调用 `interrupted()` 而调用了不必要的 `currentThread()`。</LongDescription>
    <Details>
<![CDATA[<p>此方法调用了<code>Thread.currentThread()</code>，只是为了调用<code>interrupted()</code>方法。由于<code>interrupted()</code>是一个静态方法，直接使用<code>Thread.interrupted()</code>更加简单和清晰。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="STI_INTERRUPTED_ON_UNKNOWNTHREAD">
    <ShortDescription>在线程实例上调用静态的 `Thread.interrupted()` 方法  Static Thread.interrupted() method invoked on thread instance</ShortDescription>
    <LongDescription>{1} 在线程实例上调用静态的 `Thread.interrupted()` 方法</LongDescription>
    <Details>
<![CDATA[<p>此方法在一个看似不是当前线程的Thread对象上调用了Thread.interrupted()方法。由于interrupted()方法是静态方法，因此实际上将调用的是另一个对象上的interrupted方法，而不是作者意图调用的对象。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN">
    <ShortDescription>参数在方法入口时是无用的，但被覆盖了  A parameter is dead upon entry to a method but overwritten</ShortDescription>
    <LongDescription>参数 {2} 在进入 {1} 时已死亡，但被覆盖了</LongDescription>
    <Details>
<![CDATA[<p>此参数的初始值将被忽略，并在此被覆写。这通常表明存在这样的误解：对参数进行的写操作会返回给调用者。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DLS_DEAD_LOCAL_STORE_SHADOWS_FIELD">
    <ShortDescription>隐藏字段的局部变量的死.store  Dead store to local variable that shadows field</ShortDescription>
    <LongDescription>在{1}中，将值存入与之同名的字段{2}而不是直接使用临时存储。</LongDescription>
    <Details>
<![CDATA[<p>该指令为局部变量赋值，但此值并未在后续指令中被读取或使用。这通常表示存在错误，因为计算出的值从未被利用过。存在同名的字段。您是不是应该将值赋给那个变量？</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DLS_DEAD_LOCAL_STORE">
    <ShortDescription>局部变量中的死存储  Dead store to local variable</ShortDescription>
    <LongDescription>在{1}中对{2}进行了死存储</LongDescription>
    <Details>
<![CDATA[<p>这条指令为局部变量赋值，但该值并未在后续指令中被读取或使用。通常这表明存在错误，因为计算得到的值从未被利用。</p>
<p>请注意，Sun的javac编译器经常会对final局部变量生成无用存储。由于SpotBugs是一个基于字节码的工具，因此无法轻松消除这些误报。</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="DLS_DEAD_LOCAL_STORE_IN_RETURN">
    <ShortDescription>返回语句中的无用赋值  Useless assignment in return statement</ShortDescription>
    <LongDescription>从 {1} 返回中的无用赋值</LongDescription>
    <Details>
      <![CDATA[<p>该语句在一个返回语句中给局部变量赋值，但该赋值没有效果。请验证该语句是否正确。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DLS_DEAD_LOCAL_INCREMENT_IN_RETURN">
    <ShortDescription>在返回语句中不必要的增量操作  Useless increment in return statement</ShortDescription>
    <LongDescription>从 {1} 返回时的无用递增</LongDescription>
    <Details>
      <![CDATA[<p>此语句包含返回值如<code>return x++;</code> / <code>return x--;</code>。后缀递增/递减不会影响表达式的值，因此该递增/递减操作没有效果。请确认此语句的功能是否正确。</p>]]>
    </Details>
  </BugPattern>



  <BugPattern type="DLS_DEAD_STORE_OF_CLASS_LITERAL">
    <ShortDescription>类字面量的死存储  Dead store of class literal</ShortDescription>
    <LongDescription>在 `{1}` 中检测到对 `{3}.class` 的死存储。</LongDescription>
    <Details>
<![CDATA[<p>此说明将一个类字面量赋值给一个变量，但从未使用它。在 Java 1.4 和 Java 5 中的行为不同。<a href="http://www.oracle.com/technetwork/java/javase/compatibility-137462.html#literal">在 Java 1.4 及更早版本中，对 `Foo.class` 的引用会强制执行 `Foo` 的静态初始化器（如果尚未执行的话）。而在 Java 5 及更高版本中，则不会。</a></p>
<p>有关更多详细信息和示例，请参阅 Oracle 的 <a href="http://www.oracle.com/technetwork/java/javase/compatibility-137462.html#literal">Java SE 兼容性文章</a>，并了解如何在 Java 5+ 中强制执行类初始化。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DLS_DEAD_LOCAL_STORE_OF_NULL">
    <ShortDescription>对局部变量进行null的死.store检查  Dead store of null to local variable</ShortDescription>
    <LongDescription>在{1}中对null进行了死存储到{2}</LongDescription>
    <Details>
<![CDATA[<p>代码将空值存储到局部变量中，而该存储的值并未被读取。这种存储可能曾用于帮助垃圾收集器工作，但在Java SE 6.0及更高版本中，这已不再需要或有用。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MF_METHOD_MASKS_FIELD">
    <ShortDescription>方法定义了变量遮蔽了字段  Method defines a variable that obscures a field</ShortDescription>
    <LongDescription>定义的变量遮蔽了字段 {2.givenClass}</LongDescription>
    <Details>
<![CDATA[<p>该方法定义了一个局部变量，其名称与类或超类中的一个字段同名。这可能会导致方法从字段中读取未初始化的值、使字段保持未初始化状态，或者同时发生这两种情况。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MF_CLASS_MASKS_FIELD">
    <ShortDescription>类定义的字段遮掩了超类中的字段  Class defines field that masks a superclass field</ShortDescription>
    <LongDescription>字段 {1.givenClass} 遮掩了超类 {2.class} 中的字段</LongDescription>
    <Details>
<![CDATA[<p>该类定义了一个与超类中可见实例字段同名的字段。这可能会造成混淆，并且如果方法更新或访问这些字段时本应使用另一个字段，则可能存在错误。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="WMI_WRONG_MAP_ITERATOR">
    <ShortDescription>使用键集迭代器而非条目集迭代器导致效率低下  Inefficient use of keySet iterator instead of entrySet iterator</ShortDescription>
    <LongDescription>{1} 不-efficient 使用了 keySet 迭代器而不是 entrySet 迭代器</LongDescription>
    <Details>
<![CDATA[<p>该方法使用从 keySet 迭代器检索的键来访问 Map 入口的值。直接在映射的 entrySet 上使用迭代器进行遍历更高效，可以避免进行 Map.get(key) 查找。</p>]]>
        </Details>
  </BugPattern>
  <BugPattern type="ISC_INSTANTIATE_STATIC_CLASS">
    <ShortDescription>仅提供静态方法的类的不必要的实例化  Needless instantiation of class that only supplies static methods</ShortDescription>
    <LongDescription>{1} 不必要地实例化只提供静态方法的类</LongDescription>
    <Details>
<![CDATA[<p>该类基于仅提供静态方法的类分配一个对象。不需要创建该对象，可以直接通过类名作为限定符访问静态方法。</p>]]>
        </Details>
  </BugPattern>
  <BugPattern type="REC_CATCH_EXCEPTION">
    <ShortDescription>当没有抛出异常时捕获异常  Exception is caught when Exception is not thrown</ShortDescription>
    <LongDescription>在{1}中捕获了异常，但并未抛出异常</LongDescription>
    <Details>
  <![CDATA[<p>   这个方法使用了 try-catch 语句块来捕获 Exception 对象，但 try 块内部没有抛出 Exception，并且 RuntimeException 没有显式被捕获。将 try { ... } catch (Exception e) { something } 作为一种快捷方式来捕捉多种类型的异常（每种异常的处理代码相同），是一种常见的错误模式。但是这种构造也会意外捕获到 RuntimeException，从而掩盖潜在的bug。</p>
<p>更好的方法是要么显式地捕获具体的抛出的异常，要么显式地捕获 RuntimeException 异常并重新抛出，然后再捕获所有非-Runtime Exceptions，如下所示：</p>
<pre><code>try {     ... } catch (RuntimeException e) {     throw e; } catch (Exception e) {     ... 处理所有非运行时异常 ... } </code></pre>]]>
     </Details>
  </BugPattern>
  <BugPattern type="DCN_NULLPOINTER_EXCEPTION">
    <ShortDescription>NullPointerException 捕获  NullPointerException caught</ShortDescription>
    <LongDescription>不要像{1}那样捕获NullPointerException</LongDescription>
    <Details>
   <![CDATA[根据SEI Cert规则<https://wiki.sei.cmu.edu/confluence/display/java/ERR08-J.+Do+not+catch+NullPointerException+or+any+of+its+ancestors>，不应该捕获NullPointerException。处理NullPointerException被视为比空检查 inferior 的替代方案。

不符合规范的代码通过捕获NullPointerException来判断输入参数是否为空：

```java
boolean hasSpace(String m) {   
  try {     
    String ms[] = m.split(" ");     
    return names.length != 1;   
  } catch (NullPointerException e) {     
    return false;   
  } 
}
```

一个合规的解决方案会使用空检查，如下所示：

```java
boolean hasSpace(String m) {   
  if (m == null) return false;   
  String ms[] = m.split(" ");   
  return names.length != 1;  
}
```]]>
     </Details>
  </BugPattern>
  <BugPattern type="FE_TEST_IF_EQUAL_TO_NOT_A_NUMBER">
    <ShortDescription>对NaN进行相等性测试会导致错误  Doomed test for equality to NaN</ShortDescription>
    <LongDescription>在{1}中对NaN进行相等性测试，这将是失败的。</LongDescription>
    <Details>
   <![CDATA[<p>     这段代码检查一个浮点值是否等于特殊的基本不为数（例如，`if (x == Double.NaN)`）。然而，由于基本不为数 `NaN` 的特殊语义，任何值都不等于 `NaN`，包括 `NaN` 本身。因此，`x == Double.NaN` 总是会评估为 false。     要检查变量 `x` 中的值是否为特殊的不为数，应使用 `Double.isNaN(x)`（如果 `x` 是单精度浮点数，则使用 `Float.isNaN(x)`）。     </p>]]>
     </Details>
  </BugPattern>
  <BugPattern type="FE_FLOATING_POINT_EQUALITY">
    <ShortDescription>测试浮点数相等性  Test for floating point equality</ShortDescription>
    <LongDescription>在{1}中测试浮点数相等性</LongDescription>
    <Details>
   <![CDATA[<p>     此操作用于比较两个浮点值是否相等。由于浮点计算可能会涉及舍入，因此计算得到的 float 和 double 值可能不够准确。对于必须精确的值，例如货币值，考虑使用固定精度类型（如 BigDecimal）。对于不需要精确的值，可以考虑在某个范围内进行相等性比较，例如：<code>if (Math.abs(x - y) < .0000001)</code>。详见 Java 语言规范第 4.2.4 节。</p>]]>
     </Details>
  </BugPattern>
  <BugPattern type="UM_UNNECESSARY_MATH">
    <ShortDescription>方法调用静态Math类的方法并传入常量值  Method calls static Math class method on a constant value</ShortDescription>
    <LongDescription>方法调用常量值的静态Math类方法</LongDescription>
    <Details>
<![CDATA[<p>该方法在常量值上使用了 java.lang.Math 的静态方法。在这种情况下，此方法的结果可以静态确定，并且直接使用常量可能会更快且更准确。检测到的方法如下：</p>
<table>
<tr>
    <th>方法</th>
    <th>参数</th>
</tr>
<tr>
    <td>abs</td>
    <td>- 任意 -</td>
</tr>
<tr>
    <td>acos</td>
    <td>0.0 或 1.0</td>
</tr>
<tr>
    <td>asin</td>
    <td>0.0 或 1.0</td>
</tr>
<tr>
    <td>atan</td>
    <td>0.0 或 1.0</td>
</tr>
<tr>
    <td>atan2</td>
    <td>0.0</td>
</tr>
<tr>
    <td>cbrt</td>
    <td>0.0 或 1.0</td>
</tr>
<tr>
    <td>ceil</td>
    <td>- 任意 -</td>
</tr>
<tr>
    <td>cos</td>
    <td>0.0</td>
</tr>
<tr>
    <td>cosh</td>
    <td>0.0</td>
</tr>
<tr>
    <td>exp</td>
    <td>0.0 或 1.0</td>
</tr>
<tr>
    <td>expm1</td>
    <td>0.0</td>
</tr>
<tr>
    <td>floor</td>
    <td>- 任意 -</td>
</tr>
<tr>
    <td>log</td>
    <td>0.0 或 1.0</td>
</tr>
<tr>
    <td>log10</td>
    <td>0.0 或 1.0</td>
</tr>
<tr>
    <td>rint</td>
    <td>- 任意 -</td>
</tr>
<tr>
    <td>round</td>
    <td>- 任意 -</td>
</tr>
<tr>
    <td>sin</td>
    <td>0.0</td>
</tr>
<tr>
    <td>sinh</td>
    <td>0.0</td>
</tr>
<tr>
    <td>sqrt</td>
    <td>0.0 或 1.0</td>
</tr>
<tr>
    <td>tan</td>
    <td>0.0</td>
</tr>
<tr>
    <td>tanh</td>
    <td>0.0</td>
</tr>
<tr>
    <td>toDegrees</td>
    <td>0.0 或 1.0</td>
</tr>
<tr>
    <td>toRadians</td>
    <td>0.0</td>
</tr>
</table>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CD_CIRCULAR_DEPENDENCY">
    <ShortDescription>测试类之间的循环依赖关系  Test for circular dependencies among classes</ShortDescription>
    <LongDescription>类 {0}与其他类存在循环依赖关系</LongDescription>
    <Details>
   <![CDATA[<p>     该类与其他类存在循环依赖。这使得构建这些类变得困难，因为每个类都依赖于其他类来正确构建。考虑使用接口来打破硬性依赖。     </p>]]>
     </Details>
  </BugPattern>
  <BugPattern type="RI_REDUNDANT_INTERFACES">
    <ShortDescription>类实现了与超类相同的接口  Class implements same interface as superclass</ShortDescription>
    <LongDescription>类 {0} 实现了与超类相同的接口</LongDescription>
    <Details>
   <![CDATA[<p>     该类声明实现了由超类也已实现的一个接口。由于一旦超类实现了某个接口，所有子类默认也会继承这个接口的实现，因此这种实现是冗余的。这可能表明自创建此类以来，继承层次结构发生了变化，并且应考虑接口实现的所有权问题。     </p>]]>
     </Details>
  </BugPattern>
  <BugPattern type="MTIA_SUSPECT_STRUTS_INSTANCE_FIELD">
    <ShortDescription>该类扩展了Struts Action类并且使用了实例变量  Class extends Struts Action class and uses instance variables</ShortDescription>
    <LongDescription>类 {0} 扩展了 Struts 行动类，并使用了实例变量</LongDescription>
    <Details>
   <![CDATA[<p>    这个类从一个Struts Action类继承，使用了一个实例成员变量。由于Struts框架只为一个Struts Action类创建一个实例，并以多线程方式使用，这种模式被强烈推荐避免并且很可能存在问题。考虑仅使用方法局部变量。只有在监控之外被写入的实例字段才会被报告。     </p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="MTIA_SUSPECT_SERVLET_INSTANCE_FIELD">
    <ShortDescription>该类扩展自Servlet类并使用了实例变量  Class extends Servlet class and uses instance variables</ShortDescription>
    <LongDescription>类 {0} 扩展了 Servlet 类并且使用了实例变量</LongDescription>
    <Details>
   <![CDATA[<p>     这个类从一个Servlet类继承，并使用了一个实例成员变量。由于J2EE框架只会创建Servlet类的一个实例并在多线程环境中使用，这种模式高度不被推荐并且很可能存在问题。请考虑仅使用方法局部变量。     </p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="PS_PUBLIC_SEMAPHORES">
    <ShortDescription>类在其公共接口中暴露了同步和信号量机制  Class exposes synchronization and semaphores in its public interface</ShortDescription>
    <LongDescription>类 {0} 在其公共接口中暴露了同步和信号量机制</LongDescription>
    <Details>
   <![CDATA[<p>    这个类使用了同步，并且通过 this（自身）引用调用了 wait()、notify() 或 notifyAll()。客户端类如果使用这个类，还可以将该类的一个实例用作同步对象。由于两个类共用同一个对象进行同步，因此多线程正确性存在疑虑。你不应该在公共引用上进行同步或调用信号量方法。考虑使用一个内部的私有成员变量来控制同步。</p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="ICAST_INTEGER_MULTIPLY_CAST_TO_LONG">
    <ShortDescription>整数相乘后的结果强制转换为long类型  Result of integer multiplication cast to long</ShortDescription>
    <LongDescription>在{1}中，整数相乘的结果被强制转换为long类型。</LongDescription>
    <Details>
<![CDATA[<p>这段代码执行整数乘法，然后将结果转换为长整型，如下所示：</p> <pre><code>long convertDaysToMilliseconds(int days) { return 1000*3600*24*days; } </code></pre> <p> 如果使用长整型算术进行乘法运算，可以避免结果溢出的可能性。例如，你可以将上面的代码修改为：</p> <pre><code>long convertDaysToMilliseconds(int days) { return 1000L*3600*24*days; } </code></pre> <p> 或者 </p> <pre><code>static final long MILLISECONDS_PER_DAY = 24L*3600*1000; long convertDaysToMilliseconds(int days) { return days * MILLISECONDS_PER_DAY; } </code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_INT_2_LONG_AS_INSTANT">
    <ShortDescription>将整数值转换为长整型并用作绝对时间  int value converted to long and used as absolute time</ShortDescription>
    <LongDescription>`int` 转换为 `long` 并作为绝对时间传递给 `{2}` 在 `{1}` 中</LongDescription>
    <Details>
<![CDATA[<p>这段代码将一个32位的int值转换为64位的long值，然后将其作为需要绝对时间值的方法参数传递。绝对时间值是从被称为“纪元”的标准基时间（即1970年1月1日00:00:00 GMT）以来的毫秒数。例如，下面用于将自纪元以来的秒转换为Date的方法是严重错误的：</p>
<pre><code>Date getDate(int seconds) { return new Date(seconds * 1000); } </code></pre>
<p>这里的乘法使用了32位算术运算，并在转换为64位值后使用。当将一个32位值转换为64位并用来表示绝对时间值时，只能表示1969年12月和1970年1月的日期。</p>
<p>上述方法正确的实现方式如下：</p>
<pre><code>// 在2038年后会失败 Date getDate(int seconds) { return new Date(seconds * 1000L); } 

// 更好，适用于所有日期 Date getDate(long seconds) { return new Date(seconds * 1000); } </code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND">
    <ShortDescription>将整数值转换为浮点数，然后传递给Math.round方法  int value cast to float and then passed to Math.round</ShortDescription>
    <LongDescription>将整数值转换为浮点数，然后传递给 `Math.round` 在 `{1}` 处</LongDescription>
    <Details>
<![CDATA[<p>这段代码将一个 int 值转换为浮点数，并且带有小数精度，然后将结果传递给 Math.round() 函数，该函数返回最接近参数的 int/long。由于将整数转换为浮点数应该得到没有小数部分的数字，因此此操作应该始终是无操作的。很可能生成要传递给 Math.round() 的值的操作本应使用浮点数算术来执行。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL">
    <ShortDescription>将整数值转换为双精度数，然后传递给Math.ceil方法  Integral value cast to double and then passed to Math.ceil</ShortDescription>
    <LongDescription>在 `{1}` 处，将整数值强制转换为双精度数值后传给 `Math.ceil` 方法。</LongDescription>
    <Details>
<![CDATA[<p>这段代码将一个整数值（例如，int 或 long）转换为双精度浮点数，然后将其结果传递给 Math.ceil() 函数，该函数会将双精度数向上舍入到下一个更高位的整数。由于将整数转换为双精度数应该得到没有小数部分的数字，因此此操作本应始终是无操作的。很可能生成要传递给 Math.ceil() 的值的操作意图是在双精度浮点数上执行相应的算术运算。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_IDIV_CAST_TO_DOUBLE">
    <ShortDescription>整数除法结果转换为double或float  Integral division result cast to double or float</ShortDescription>
    <LongDescription>在{1}中，整数除法的结果应转换为double或float。</LongDescription>
    <Details>
<![CDATA[<p>这段代码将整数除法操作（例如，int 或 long 除法）的结果强制转换为 double 或 float。整数除法会截断结果，使其向零取整。由于结果被强制转换为 double，这表明应该保留这种精度。实际上应该是将一个或两个操作数在进行除法之前先强制转换为 double。例如：</p>

<pre><code>int x = 2; int y = 5;
// 错误：结果为 0.0
double value1 = x / y;

// 正确：结果为 0.4
double value2 = x / (double) y;
</code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION">
    <ShortDescription>将非序列化的对象存储到HttpSession中  Store of non serializable object into HttpSession</ShortDescription>
    <LongDescription>在{1}中将非序列化的{2}存储到HttpSession中</LongDescription>
    <Details>
<![CDATA[<p>这段代码似乎将一个非序列化的对象存储到了HttpSession中。如果该会话被静化或迁移，将会导致错误。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_NONSERIALIZABLE_OBJECT_WRITTEN">
    <ShortDescription>非序列化对象写入了ObjectOutput  Non serializable object written to ObjectOutput</ShortDescription>
    <LongDescription>非序列化的 {2} 写入了 {1} 中的 ObjectOutput</LongDescription>
    <Details>
<![CDATA[<p>这段代码似乎将一个非序列化对象传递给了ObjectOutput.writeObject方法。如果该对象确实是非序列化的，将会导致错误。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="VA_FORMAT_STRING_USES_NEWLINE">
    <ShortDescription>格式化字符串应该使用%n 而不是\n  Format string should use %n rather than \n</ShortDescription>
    <LongDescription>格式字符串应使用%n 而不是\n 在{1}中</LongDescription>
    <Details>
<![CDATA[<p>这个格式字符串包含一个换行字符（\n）。在格式字符串中，通常建议使用 %n，它可以生成平台特定的分隔符。当使用从 Java 15 引入的文本块时，请使用反斜杠（\）转义序列：<code>String value = """     first line%n\     second line%n\     """;</code></p>]]>
     </Details>
  </BugPattern>
  <BugPattern type="VA_PRIMITIVE_ARRAY_PASSED_TO_OBJECT_VARARG">
    <ShortDescription>原始数组传递给期望可变数量对象参数的函数  Primitive array passed to function expecting a variable number of object arguments</ShortDescription>
    <LongDescription>第{1}个参数中的可变参数方法{3}接收了值{2}</LongDescription>
    <Details>
<![CDATA[<p>这段代码将一个原始数组传递给一个接受可变数量对象参数的函数。为此，创建了一个长度为一的数组来holding 原始数组，并将其传递给该函数。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS">
    <ShortDescription>equals 方法不应假设其参数的类型。  Equals method should not assume anything about the type of its argument</ShortDescription>
    <LongDescription>{0}的equals方法假设参数是{0.givenClass}类型</LongDescription>
    <Details>
<![CDATA[<code>equals(Object o)</code> 方法不应假设 <code>o</code> 的类型。如果 <code>o</code> 不是与 <code>this</code> 相同的类型，它应该简单地返回 false。]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_BAD_CAST_TO_ABSTRACT_COLLECTION">
    <ShortDescription>对抽象集合进行了可疑的类型转换  Questionable cast to abstract collection</ShortDescription>
    <LongDescription>在 `{1}` 中，从 `Collection` 到抽象类 `{3}` 的可疑类型转换 `{2}`</LongDescription>
    <Details>
<![CDATA[<p>该代码将一个集合强制转换为抽象集合（如 <code>List</code>、<code>Set</code> 或 <code>Map</code>）。确保你在进行这样的转换时确实可以得到你期望的类型。如果你只需要遍历集合，则不需要将其强制转换为 Set 或 List。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_IMPOSSIBLE_CAST_PRIMITIVE_ARRAY">
    <ShortDescription>涉及原始数组的不可能转换  Impossible cast involving primitive array</ShortDescription>
    <LongDescription>在 {1} 中涉及原始数组的不可能转换</LongDescription>
    <Details>
<![CDATA[<p>这种转换总是会抛出一个ClassCastException。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_IMPOSSIBLE_CAST">
    <ShortDescription>无法进行强制类型转换  Impossible cast</ShortDescription>
    <LongDescription>在 {1} 中从 {2} 到 {3} 的类型转换不可能。</LongDescription>
    <Details>
<![CDATA[<p>这种转换总是会抛出一个 ClassCastException。SpotBugs 跟踪从 instanceof 检查获取的类型信息，并且还会使用方法返回值和字段加载值时更加精确的类型信息。因此，它可能拥有比变量声明类型更为精确的信息，并可以利用这些信息来确定某个转换在运行时总是会抛出异常。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_IMPOSSIBLE_DOWNCAST">
    <ShortDescription>不可能的向下转换  Impossible downcast</ShortDescription>
    <LongDescription>从 {2} 到 {3} 的向下转换在 {1} 中不可能完成</LongDescription>
    <Details>
<![CDATA[<p>此类型转换总是会抛出ClassCastException。分析认为它知道被转换值的精确类型，尝试将其向下转换为子类型总会因为抛出ClassCastException而失败。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_IMPOSSIBLE_DOWNCAST_OF_TOARRAY">
    <ShortDescription>将 `toArray()` 方法的结果进行不可能的向下转换  Impossible downcast of toArray() result</ShortDescription>
    <LongDescription>将 `toArray()` 方法的结果向下转换为 `{3}` 在 `{1}` 中是不可能的。</LongDescription>
    <Details>
<![CDATA[<p>此代码将调用 `collection` 的 `toArray()` 方法的结果强制转换为比 `Object[]` 更具体的类型，如下所示：</p>
<pre><code>String[] getAsArray(Collection&lt;String&gt; c) {     return (String[]) c.toArray(); }</code></pre>
<p>这通常会通过抛出 `ClassCastException` 而失败。几乎所有的集合的 `toArray()` 方法返回的是 `Object[]`。由于 Collection 对象无法引用集合声明的泛型类型，因此它们别无选择只能返回 `Object[]`。</p>
<p>从 collection 中获取特定类型的数组的正确方式是使用 `c.toArray(new String[0]);` 或 `c.toArray(new String[c.size()]);`（前者自 Java 6 晚期以来 <a href="https://shipilev.net/blog/2016/arrays-wisdom-ancients/#_historical_perspective">稍微更高效</a>）。 </p>
<p>有一个常见的、已知的例外情况。通过 `Arrays.asList(...)` 返回的列表的 `toArray()` 方法将返回协变类型数组。例如，`Arrays.asArray(new String[] { "a" }).toArray()` 将返回一个 `String []`。SpotBugs 试图检测并抑制此类情况，但可能会遗漏一些。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_INSTANCEOF">
    <ShortDescription>已知的空值被检查是否是某个类型的实例  A known null value is checked to see if it is an instance of a type</ShortDescription>
    <LongDescription>在一个已知为null的值在{1}中被检查是否是{2}的实例。</LongDescription>
    <Details>
<![CDATA[<p>这个 `instanceof` 测试始终会返回 false，因为检查的值被保证为 null。虽然这是安全的，但请确保这并不是某种误解或逻辑错误的迹象。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_NULL_INSTANCEOF" deprecated="true"> <!-- deprecated in favor of NP_NULL_INSTANCEOF -->
    <ShortDescription>已知的空值被检查是否为某类型的实例。  A known null value is checked to see if it is an instance of a type</ShortDescription>
    <LongDescription>在一个已知为null的值在{1}中被检查是否是{2}的一个实例。</LongDescription>
    <Details>
<![CDATA[<p>该 `instanceof` 测试总是会返回 false，因为检查的值被保证为 null。虽然这是安全的，但请确保这并不是某种误解或逻辑错误的指示。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_IMPOSSIBLE_INSTANCEOF">
    <ShortDescription>instanceof 总是会返回 false  instanceof will always return false</ShortDescription>
    <LongDescription>在 `{1}` 中，`instanceof` 将始终返回 false，因为一个 `{2}` 不能是一个 `{3}`。</LongDescription>
    <Details>
<![CDATA[<p>此 instanceof 测试始终会返回 false。虽然这是安全的，但请确保这不是某种误解或其它逻辑错误的指示。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_VACUOUS_INSTANCEOF">
    <ShortDescription>instanceof 总是会返回 true  instanceof will always return true</ShortDescription>
    <LongDescription>instanceof 对于 {1} 中的所有非空值总是会返回 true，因为所有的 {2} 都是 {3} 的实例。</LongDescription>
    <Details>
<![CDATA[<p>这个 `instanceof` 测试始终会返回 true（除非被测试的值为 null）。虽然这是安全的，但请确保这不是某种误解或逻辑错误的指示。如果你真的想测试该值是否为 null，可能更清楚的做法是进行一个 null 检测而不是 `instanceof` 检测。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_UNCONFIRMED_CAST">
    <ShortDescription>未检查/未经验证的类型转换  Unchecked/unconfirmed cast</ShortDescription>
    <LongDescription>从{2}到{3}的未检查/未确认类型转换在{1}中使用了</LongDescription>
    <Details>
<![CDATA[<p>此类型转换未进行类型检查，且并非所有从其转换出的实例都能转换为目标类型。请确保您的程序逻辑能够保证该类型的转换不会失败。</p>]]>
    </Details>
  </BugPattern>
   <BugPattern type="BC_UNCONFIRMED_CAST_OF_RETURN_VALUE">
    <ShortDescription>方法返回值未检查/未经确认的类型转换  Unchecked/unconfirmed cast of return value from method</ShortDescription>
    <LongDescription>从{2}到{3}的未检查/未确认类型转换，发生在方法{1}的返回值中</LongDescription>
    <Details>
<![CDATA[<p>该代码对方法返回值进行了未检查的类型转换。虽然代码可能以某种方式调用该方法，从而使转换保证是安全的，但 SpotBugs 无法验证该转换是否安全。请确保您的程序逻辑可以保证此转换不会失败。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_BAD_CAST_TO_CONCRETE_COLLECTION">
    <ShortDescription>对具体集合的可疑类型转换  Questionable cast to concrete collection</ShortDescription>
    <LongDescription>在 {1} 中，从 {2} 到 {3} 的可疑类型转换</LongDescription>
    <Details>
<![CDATA[<p>这段代码将一个抽象集合（如Collection、List或Set）强制转换为特定的具体实现（如ArrayList或HashSet）。这可能不正确，并且可能会使你的代码变得脆弱，因为在将来切换到其他具体实现时会更加困难。除非你有特殊的原因这样做，否则只需使用抽象集合类。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RE_POSSIBLE_UNINTENDED_PATTERN">
    <ShortDescription>“.” 或 “|” 用于正则表达式  "." or "|" used for regular expression</ShortDescription>
    <LongDescription>在{1}中使用“.”或“|”进行正则表达式匹配。</LongDescription>
    <Details>
<![CDATA[<p>正在调用一个字符串函数，并将“.”或“|”作为参数传递给接受正则表达式作为参数的函数。这是否是你想要的结果？例如：</p>
<ul>
<li>`s.replaceAll(".", "/")` 将返回一个每个字符都被替换为'/'的字符串</li>
<li>`s.split(".")` 总是返回一个空字符串数组</li>
<li>`"ab|cd".replaceAll("|", "/")` 将返回`"/a/b/|/c/d/"`</li>
<li>`"ab|cd".split("|")` 将返回包含六个元素（!）的数组：[, a, b, |, c, d]</li>
</ul>
<p>考虑使用 `s.replace(".", "/")` 或 `s.split("\\.")` 替代。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION">
    <ShortDescription>无效的正则表达式语法  Invalid syntax for regular expression</ShortDescription>
    <LongDescription>在 {1} 中的正则表达式语法无效</LongDescription>
    <Details>
<![CDATA[<p>此处的代码使用了一个无效的正则表达式，根据正则表达式的语法规范这是不正确的。当执行此语句时，将会抛出PatternSyntaxException异常。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION">
    <ShortDescription>使用 `File.separator` 用于正则表达式  File.separator used for regular expression</ShortDescription>
    <LongDescription>在{1}中使用了 File.separator 进行正则表达式匹配。</LongDescription>
    <Details>
<![CDATA[<p>此处的代码使用了<code>File.separator</code>，而在正则表达式中需要的是普通字符。在Windows平台上，<code>File.separator</code> 是反斜杠，在正则表达式中反斜杠会被解释为转义字符，因此会失败。作为其他选项之一，你可以使用<code>File.separatorChar=='\\' ? "\\\\" : File.separator</code> 替代<code>File.separator</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DLS_OVERWRITTEN_INCREMENT">
    <ShortDescription>重载增量操作  Overwritten increment</ShortDescription>
    <LongDescription>在{1}中重写了增量操作</LongDescription>
    <Details>
<![CDATA[<p>该代码执行了自增/自减操作（例如，<code>i++</code>/<code>i--</code>），然后立即用原始值覆盖它。例如，<code>i = i++</code>/<code>i = i--</code>会立即将增量/ decrement后的值用原始值覆盖。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT">
    <ShortDescription>将无符号右移转换为short/byte类型  Unsigned right shift cast to short/byte</ShortDescription>
    <LongDescription>将无符号右移转换为short/byte在{1}中</LongDescription>
    <Details>
<![CDATA[<p>该代码执行无符号右移操作，然后将结果强制转换为short或byte类型，这会丢弃结果的高位。由于高位被丢弃，无符号右移和有符号右移的结果可能没有区别（具体取决于位移量的大小）。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BSHIFT_WRONG_ADD_PRIORITY">
    <ShortDescription>可能的位移操作解析错误  Possible bad parsing of shift operation</ShortDescription>
    <LongDescription>在 `{1}` 中可能存在位移操作的不良解析。</LongDescription>
    <Details>
<![CDATA[<p>代码执行的操作类似于(x << 8 + y)。虽然这可能是正确的，但很可能应该是(x << 8) + y，但由于位移操作的优先级较低，实际上会被解析为 x << (8 + y)。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_BAD_SHIFT_AMOUNT">
    <ShortDescription>将32位int整数左移一个不在-31到31范围内的数量。  32 bit int shifted by an amount not in the range -31..31</ShortDescription>
    <LongDescription>32位整数向右移动{2}位在{1}中</LongDescription>
    <Details>
<![CDATA[<p>该代码对一个32位int进行超出-31..31范围的常量位移。这意味着使用整数值的较低5位来决定要位移多少（例如，位移40位与位移8位相同，位移32位与位移0位相同）。这可能不是预期的效果，并且至少会让人感到困惑。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IM_MULTIPLYING_RESULT_OF_IREM">
    <ShortDescription>整数除法的结果乘以整数  Integer multiply of result of integer remainder</ShortDescription>
    <LongDescription>在{1}中的整数余数的整数倍数</LongDescription>
    <Details>
<![CDATA[<p>该代码将一个整数余数与一个整数常量相乘。请确保你的运算符优先级没有搞错。例如，i % 60 * 1000 应该是 (i % 60) * 1000，而不是 i % (60 * 1000)。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_INVOKING_HASHCODE_ON_ARRAY">
    <ShortDescription>对数组调用hashCode方法  Invocation of hashCode on an array</ShortDescription>
    <LongDescription>在{1}中对数组调用hashCode方法</LongDescription>
    <Details>
<![CDATA[<p>该代码对数组调用了hashCode方法。对数组调用hashCode返回的是System.identityHashCode的值，并忽略数组的内容和长度。如果您需要一个依赖于数组<a>内容的hashCode，请使用<code>java.util.Arrays.hashCode(a)</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_INVOKING_TOSTRING_ON_ARRAY">
    <ShortDescription>对数组调用toString方法  Invocation of toString on an array</ShortDescription>
    <LongDescription>在{1}中对{2.givenClass}调用了toString方法</LongDescription>
    <Details>
<![CDATA[<p>该代码对数组调用了toString方法，这将生成一个相当无用的结果，例如[C@16f0472。建议使用Arrays.toString将数组转换为可读的字符串，以便显示数组的内容。参见《编程趣题》，第3章，第12个谜题。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_INVOKING_TOSTRING_ON_ANONYMOUS_ARRAY">
    <ShortDescription>对未命名数组调用toString方法  Invocation of toString on an unnamed array</ShortDescription>
    <LongDescription>在{1}中对未命名数组调用toString方法</LongDescription>
    <Details>
<![CDATA[<p>该代码对一个（匿名）数组调用了toString方法。调用数组的toString方法会产生类似[@C@16f0472]这样的无用结果。考虑使用Arrays.toString将数组转换为可读字符串，以便显示数组的内容。参见《编程趣题》，第3章，第12题。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IM_AVERAGE_COMPUTATION_COULD_OVERFLOW">
    <ShortDescription>平均值计算可能会溢出  Computation of average could overflow</ShortDescription>
    <LongDescription>在 {1} 中，计算平均值可能会发生溢出。</LongDescription>
    <Details>
<![CDATA[<p>该代码使用除法或带符号右移来计算两个整数的平均值，然后将结果用作数组的索引。如果被平均的数值非常大，这可能会导致溢出（从而计算出一个负平均值）。假设结果应为非负数，可以改用无符号右移而不是使用 <code>(low+high)/2</code>，即使用 <code>(low+high) &gt;&gt;&gt; 1</code>。</p>
<p>这个错误存在于许多早期的二分查找和归并排序实现中。Martin Buchholz 在 JDK 库中 <a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6412541">发现了并修复了这个问题</a>，而 Joshua Bloch 则在 <a href="http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html">广泛宣传了这种错误模式</a>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IM_BAD_CHECK_FOR_ODD">
    <ShortDescription>检查奇偶性判断不会处理负数情况  Check for oddness that won't work for negative numbers</ShortDescription>
    <LongDescription>在{1}中，检查奇偶性不会适用于负数。</LongDescription>
    <Details>
<![CDATA[<p>代码使用 x % 2 == 1 来检查一个值是否为奇数，但这对负数无效（例如，(-5) % 2 == -1）。如果代码意图检查奇偶性，可以考虑使用 (x & 1) == 1 或 x % 2 != 0。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_HARDCODED_ABSOLUTE_FILENAME">
    <ShortDescription>代码中包含对绝对路径名的硬编码引用  Code contains a hard coded reference to an absolute pathname</ShortDescription>
    <LongDescription>在 `{1}` 中硬编码了绝对路径引用</LongDescription>
    <Details>
<![CDATA[<p>这段代码使用硬编码的绝对路径构造了一个File对象（例如，<code>new File("/home/dannyc/workspace/j2ee/src/share/com/sun/enterprise/deployment");</code>）</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_BAD_MONTH">
    <ShortDescription>无效的月份常量值  Bad constant value for month</ShortDescription>
    <LongDescription>在 {1} 中传入给 {3} 的 {2} 月份值无效</LongDescription>
    <Details>
<![CDATA[<p>该代码将一个超出预期范围（0..11）的常量月份值传递给一个方法。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_USELESS_SUBSTRING">
    <ShortDescription>对 `substring(0)` 的调用，返回的是原始值。  Invocation of substring(0), which returns the original value</ShortDescription>
    <LongDescription>{1} 调用了 `substring(0)`，这将返回原始值。</LongDescription>
    <Details>
<![CDATA[<p>该代码对一个字符串调用了 substring(0) 方法，这会返回原始值。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_CALLING_NEXT_FROM_HASNEXT">
    <ShortDescription>hasNext方法调用了next方法  hasNext method invokes next</ShortDescription>
    <LongDescription>{1} 调用 {2.givenClass}</LongDescription>
    <Details>
<![CDATA[<p>hasNext()方法调用了next()方法。这几乎肯定是错误的，因为hasNext()方法不应改变迭代器的状态，而next方法应改变迭代器的状态。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SWL_SLEEP_WITH_LOCK_HELD">
    <ShortDescription>持有锁的情况下调用了Thread.sleep()方法  Method calls Thread.sleep() with a lock held</ShortDescription>
    <LongDescription>{1} 在持有锁的情况下调用了Thread.sleep() 方法</LongDescription>
    <Details>
      <![CDATA[<p>此方法在持有锁的情况下调用了 Thread.sleep()。这可能会导致性能非常差和可扩展性问题，甚至可能导致死锁，因为其他线程可能正在等待获取该锁。更好的做法是调用 wait() 方法来释放锁并允许其他线程运行。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="DB_DUPLICATE_BRANCHES">
    <ShortDescription>方法的两个分支使用了相同的代码  Method uses the same code for two branches</ShortDescription>
    <LongDescription>{1} 两个分支使用了相同的代码</LongDescription>
    <Details>
      <![CDATA[<p>该方法使用相同的代码实现条件分支的两个分支。确保这不是一个编码错误。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="DB_DUPLICATE_SWITCH_CLAUSES">
    <ShortDescription>方法在同一开关语句（switch clause）中使用了相同的代码。  Method uses the same code for two switch clauses</ShortDescription>
    <LongDescription>{1} 使用相同的代码为两个 switch 子句</LongDescription>
    <Details>
      <![CDATA[<p>该方法使用相同的代码实现switch语句的两个分支。这可能是重复代码，但也可能表明存在编码错误。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="IMA_INEFFICIENT_MEMBER_ACCESS">
    <ShortDescription>方法访问了所属类的私有成员变量  Method accesses a private member variable of owning class</ShortDescription>
    <LongDescription>{1} 访问了所属类的私有成员变量</LongDescription>
    <Details>
      <![CDATA[<p>这个内类的方法读取或写入拥有者的私有成员变量，或者调用拥有者的私有方法。编译器必须生成一个特殊的方法来访问这个私有成员，这会导致效率较低。放松对该成员变量或方法的保护级别可以使其被视为正常的访问。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="XFB_XML_FACTORY_BYPASS">
    <ShortDescription>方法直接分配了特定实现的xml接口  Method directly allocates a specific implementation of xml interfaces</ShortDescription>
    <LongDescription>{1} 直接分配具体的 XML 接口实现</LongDescription>
    <Details>
      <![CDATA[<p>该方法分配了一个特定的XML接口实现。最好使用提供的工厂类来创建这些对象，以便可以在运行时更改实现。请参阅：</p>
<ul>
    <li>javax.xml.parsers.DocumentBuilderFactory</li>
    <li>javax.xml.parsers.SAXParserFactory</li>
    <li>javax.xml.transform.TransformerFactory</li>
    <li>org.w3c.dom.Document.create<i>XXXX</i></li>
</ul>
<p>以获取更多详细信息。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="USM_USELESS_SUBCLASS_METHOD">
    <ShortDescription>方法无必要地委托给父类的方法  Method superfluously delegates to parent class method</ShortDescription>
    <LongDescription>{1} 无必要地委托给父类的方法</LongDescription>
    <Details>
      <![CDATA[<p>这个派生方法仅仅将接收到的精确参数传递给同一个超类方法。这个方法可以删除，因为它没有提供额外的价值。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="USM_USELESS_ABSTRACT_METHOD">
    <ShortDescription>抽象方法已经在实现的接口中定义  Abstract Method is already defined in implemented interface</ShortDescription>
    <LongDescription>抽象方法 `{1}` 已经在实现的接口中定义。</LongDescription>
    <Details>
      <![CDATA[<p>该抽象方法已在此抽象类实现的接口中定义。由于该方法没有提供额外的价值，因此可以将其移除。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CI_CONFUSED_INHERITANCE">
    <ShortDescription>类是最终类但声明了受保护的字段  Class is final but declares protected field</ShortDescription>
    <LongDescription>类 {0} 是最终类但声明了受保护的字段 {1}</LongDescription>
    <Details>
      <![CDATA[<p>该类被声明为final，但声明了字段为protected。由于类是final的，无法派生，使用protected修饰符会使情况变得困惑。字段的访问修饰符应更改为private或public以正确表示字段的实际用途。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="QBA_QUESTIONABLE_BOOLEAN_ASSIGNMENT">
    <ShortDescription>方法在布尔表达式中赋值布尔常量  Method assigns boolean literal in boolean expression</ShortDescription>
    <LongDescription>{1} 在布尔表达式中赋值布尔字面量</LongDescription>
    <Details>
      <![CDATA[<p>该方法在一个 if 或 while 表达式中给一个布尔变量赋了一个字面量的布尔值（true 或 false）。大多数情况下，这应该是使用 == 进行布尔比较，而不是使用 = 进行赋值。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="VR_UNRESOLVABLE_REFERENCE">
    <ShortDescription>类引用了无法解析的类或方法  Class makes reference to unresolvable class or method</ShortDescription>
    <LongDescription>{0} 无法引用到 {1}</LongDescription>
    <Details>
      <![CDATA[<p>此类引用了一个在分析其所依赖的库中无法解析的类或方法。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="GC_UNCHECKED_TYPE_IN_GENERIC_CALL">
    <ShortDescription>泛型调用中的未检查类型  Unchecked type in generic call</ShortDescription>
    <LongDescription>在{1}处提供了类型为Object的未检查参数，而预期类型应为{3.givenClass}。</LongDescription>
    <Details>
     <![CDATA[<p>这个对泛型集合方法的调用传递了一个类型为 Object 的参数，而期望的是从泛型类型参数派生的具体类型。因此， neither 标准 Java 类型系统 nor 静态分析 无法提供有用的信息来判断传递的对象是否是适当类型的。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="GC_UNRELATED_TYPES">
    <ShortDescription>泛型参数与方法参数之间无关联关系  No relationship between generic parameter and method argument</ShortDescription>
    <LongDescription>在第 {1} 行中，给定的类 {2.givenClass} 与预期的参数类型 {3.givenClass} 不兼容。</LongDescription>
    <Details>
     <![CDATA[<p>此对泛型集合方法的调用包含一个与集合参数不兼容的参数（即，参数的类型既不是相应泛型类型参数的超类也不是子类）。因此，很可能该集合中没有任何对象与此方法使用的参数相等。最有可能的是，传递给方法的值是错误的。</p>
<p>通常情况下，两个无关类的实例不相等。例如，如果Foo和Bar类之间不存在子类型关系，则一个Foo类的实例不应等于一个Bar类的实例。此外，这样做可能会导致equals方法不具有对称性。例如，如果你定义Foo类使得一个Foo可以与String相等，那么你的equals方法就不具有对称性，因为String只能与其自身相等。</p>
<p>在少数情况下，人们确实会定义不对称的equals方法并且仍然能够使代码正常工作。虽然APIs没有文档化或保证这一点，但通常情况下，当你检查一个Collection<String>是否包含一个Foo时，用于执行相等性检测的equals方法是Foo类的equals方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_COLLECTIONS_SHOULD_NOT_CONTAIN_THEMSELVES">
    <ShortDescription>集合不应该包含自身  Collections should not contain themselves</ShortDescription>
    <LongDescription>在调用 `{2.givenClass}` 时，集合不应包含自身。</LongDescription>
    <Details>
     <![CDATA[<p>这个对泛型集合方法的调用只有在集合包含它自己（例如，如果 <code>s.contains(s)</code> 为真）的情况下才有意义。这种情况发生的可能性很小，并且如果真的发生了会导致问题（比如计算哈希码时会出现无限递归）。很可能传递给参数的是错误的值。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_VACUOUS_SELF_COLLECTION_CALL">
    <ShortDescription>空洞的集合调用  Vacuous call to collections</ShortDescription>
    <LongDescription>对于任何集合 c，调用 c.{2.name}(c) 没有任何意义。</LongDescription>
    <Details>
     <![CDATA[<p>这种调用没有意义。对于任何集合 <code>c</code>，调用 <code>c.containsAll(c)</code> 应该总是为真，并且 <code>c.retainAll(c)</code> 应该没有效果。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="PZ_DONT_REUSE_ENTRY_OBJECTS_IN_ITERATORS">
    <ShortDescription>不要在迭代器中重用 entry 对象。  Don't reuse entry objects in iterators</ShortDescription>
    <LongDescription>{0}既是Iterator也是Map.Entry</LongDescription>
    <Details>
     <![CDATA[<p>`entrySet()` 方法允许返回一个视图，该视图包含了一个 Iterator 和 Map.Entry。这个巧妙的想法在多个 Map 实现中被使用，但引入了糟糕的编码错误的可能性。如果映射 `m` 通过 `entrySet` 返回这样的迭代器，那么 `c.addAll(m.entrySet())` 将会出现严重问题。OpenJDK 7 中的所有 Map 实现都已重新编写以避免这个问题，你也应该这样做。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_ENTRY_SETS_MAY_REUSE_ENTRY_OBJECTS">
    <ShortDescription>由于可能重用Entry对象，向entry集添加元素可能会失败。  Adding elements of an entry set may fail due to reuse of Entry objects</ShortDescription>
    <LongDescription>由于在{1}中重用了{2.simpleClass}.Entry对象，因此向entry集添加元素可能会失败。</LongDescription>
    <Details>
     <![CDATA[<p>允许 `entrySet()` 方法返回一个视图，在该视图中，会在迭代过程中重复使用同一个 Entry 对象。截至 Java 6 版本，`IdentityHashMap` 和 `EnumMap` 都是这样做的。在遍历这样的 Map 时，Entry 的值仅在到达下一个迭代之前有效。例如，如果你尝试将这样的 `entrySet` 传递给一个 `addAll` 方法，将会发生严重错误。</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="DMI_USING_REMOVEALL_TO_CLEAR_COLLECTION">
    <ShortDescription>不要使用removeAll来清空集合  Don't use removeAll to clear a collection</ShortDescription>
    <LongDescription>在{1}中，`removeAll` 用于清空集合。</LongDescription>
    <Details>
     <![CDATA[<p>如果你想清空集合<c>中的所有元素，应该使用<c.clear>，而不是<c.removeAll(c)>。调用<c.removeAll(c)>来清空集合不太清晰，容易因为打字错误而出错，效率较低，并且对于某些集合可能会抛出<code>ConcurrentModificationException</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="STCAL_STATIC_CALENDAR_INSTANCE">
    <ShortDescription>静态的日历字段  Static Calendar field</ShortDescription>
    <LongDescription>`{1}` 是 `java.util.Calendar` 类型的静态字段，这不是线程安全的。</LongDescription>
    <Details>
<![CDATA[<p>尽管JavaDoc中没有提到这一点，但Calendar类本质上不适合用于多线程环境。如果不进行适当的同步而在不同线程之间共享单个实例，应用程序的行为将变得不可预测。在1.4版本中，这些问题似乎出现得不如在Java 5版本中频繁，在后者中，你可能会遇到随机的ArrayIndexOutOfBoundsException或IndexOutOfBoundsException错误，这些错误出现在sun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate()方法中。</p> <p>你也可能会遇到序列化问题。</p> <p>建议使用实例字段。</p> <p>有关更多信息，请参阅<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6231579">JDK Bug #6231579</a>和<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6178997">JDK Bug #6178997</a>。</p>]]>
</Details>
  </BugPattern>
  <BugPattern type="STCAL_INVOKE_ON_STATIC_CALENDAR_INSTANCE">
    <ShortDescription>调用静态Calendar方法  Call to static Calendar</ShortDescription>
    <LongDescription>在 {1} 中对静态 java.util.Calendar 的方法进行了调用</LongDescription>
    <Details>
<![CDATA[<p>尽管JavaDoc没有提到这一点，但Calendar对象本质上不适合多线程使用。检测器发现了一次通过静态字段获取的Calendar实例的调用，这看起来可疑。</p>
<p>更多相关信息，请参阅<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6231579">JDK Bug #6231579</a>和<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6178997">JDK Bug #6178997</a>。</p>]]>
</Details>
  </BugPattern>
  <BugPattern type="STCAL_STATIC_SIMPLE_DATE_FORMAT_INSTANCE">
    <ShortDescription>静态的 `DateFormat`  Static DateFormat</ShortDescription>
    <LongDescription>{1} 是一个静态字段，类型为 java.text.DateFormat，并且不是线程安全的。</LongDescription>
    <Details>
<![CDATA[<p>根据JavaDoc的说明，DateFormats 在多线程环境中本质上是不安全的。如果没有适当的同步机制，在线程边界共享单个实例会导致应用程序行为不稳定。</p>
<p>您还可能会遇到序列化问题。</p>
<p>推荐使用实例字段。</p>
<p>更多详细信息请参见 <a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6231579">JDK Bug #6231579</a> 和 <a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6178997">JDK Bug #6178997</a>。</p>]]>
</Details>
  </BugPattern>
  <BugPattern type="STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE">
    <ShortDescription>静态调用DateFormat的方法  Call to static DateFormat</ShortDescription>
    <LongDescription>在 `{1}` 中对静态方法 `java.text.DateFormat` 的调用</LongDescription>
    <Details>
<![CDATA[<p>如JavaDoc所述，DateFormats本质上不适合多线程使用。检测器发现了一个通过静态字段获取的DateFormat实例的调用，这看起来可疑。</p>
<p>有关更多信息，请参阅<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6231579">JDK Bug #6231579</a>和<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6178997">JDK Bug #6178997</a>。</p>]]>
</Details>
  </BugPattern>
  <BugPattern type="TQ_COMPARING_VALUES_WITH_INCOMPATIBLE_TYPE_QUALIFIERS">
    <ShortDescription>使用不兼容的类型限定符比较值  Comparing values with incompatible type qualifiers</ShortDescription>
    <LongDescription>标记为具有类型限定符 {2.simpleName} 的值与从未具有该限定符的值进行相等性比较。</LongDescription>
    <Details>
      <![CDATA[<p>指定带有类型限定符注解的值与从不携带该限定符的值进行比较。</p>
<p>更具体地说，一个带有类型限定符（其 when 属性设置为 ALWAYS）的值会被一个相同类型限定符但其 when 属性设置为 NEVER 的值进行比较。</p>
<p>例如，假设 @NonNegative 是 @Negative(when=When.NEVER) 的别名。下面的代码会生成警告，因为返回语句需要一个 @NonNegative 值，但却接收到一个标记为 @Negative 的值。</p>
<pre><code>public boolean example(@Negative Integer value1, @NonNegative Integer value2) {     return value1.equals(value2); } </code></pre>]]>
    </Details>
  </BugPattern>


  <BugPattern type="TQ_ALWAYS_VALUE_USED_WHERE_NEVER_REQUIRED">
    <ShortDescription>标注了类型限定符的值用于不需要携带该限定符的地方  Value annotated as carrying a type qualifier used where a value that must not carry that qualifier is required</ShortDescription>
    <LongDescription>标记为携带类型限定符 {2.simpleName} 的值用于必须不携带该限定符的地方</LongDescription>
    <Details>
      <![CDATA[<p>指定带有类型限定注解的值在需要该值不带此注解的位置被消费。</p>
<p>更精确地说，带有当为ALWAYS指定的类型限定注解的值保证会到达使用位置，在这些位置上相同的类型限定注解指定为NEVER。 </p>
<p>例如，假设@NonNegative是@Negative(when=When.NEVER)的一个别名。以下代码将生成此警告，因为返回语句需要一个@NonNegative值，但收到的却是标记为@Negative的值。</p>
<pre><code>public @NonNegative Integer example(@Negative Integer value) {     return value; } </code></pre>]]>
    </Details>
  </BugPattern>


  <BugPattern type="TQ_UNKNOWN_VALUE_USED_WHERE_ALWAYS_STRICTLY_REQUIRED">
    <ShortDescription>在需要该限定符的情况下使用了未带类型限定符的值  Value without a type qualifier used where a value is required to have that qualifier</ShortDescription>
    <LongDescription>在需要一个 {2.simpleName} 注解的地方使用了未带类型限定符的值</LongDescription>
    <Details>
      <![CDATA[<p>   该值的使用方式要求对该值进行类型限定。     由于类型限定是严格的，因此工具会拒绝任何未带有适当注解的值。   </p>
<p>   要强制将值转换为具有严格注解的形式，可以定义一个返回值带有严格注解的身份函数。     这是唯一一种将非注解值转变为具有严格类型限定注解的值的方法。   </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="TQ_NEVER_VALUE_USED_WHERE_ALWAYS_REQUIRED">
    <ShortDescription>标注为从未携带类型修饰符的值在需要携带该修饰符的地方被使用  Value annotated as never carrying a type qualifier used where value carrying that qualifier is required</ShortDescription>
    <LongDescription>标记为不携带类型限定符的值{2.simpleName}用于需要携带该限定符的场合</LongDescription>
    <Details>
      <![CDATA[<p>指定为不携带类型限定注解的值保证会在需要该值携带该注解的位置或多个位置被消费。</p>
<p>更精确地说，标记有类型限定符且when=NEVER的值会保证到达使用或多个使用这些值的地方，在那里相同的类型限定符规定为when=ALWAYS。</p>
<p>TODO：示例</p>]]>
    </Details>
  </BugPattern>




  <BugPattern type="TQ_MAYBE_SOURCE_VALUE_REACHES_ALWAYS_SINK">
    <ShortDescription>可能没有类型修饰符的值总是以需要该类型修饰符的方式使用  Value that might not carry a type qualifier is always used in a way requires that type qualifier</ShortDescription>
    <LongDescription>可能没有携带{2.simpleName}注解的值总是以需要该类型提示的方式来使用。</LongDescription>
    <Details>
      <![CDATA[<p>一个被注解为可能不是由类型限定词表示的值，并且该值保证以需要由那个类型限定词表示的值的方式使用。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="TQ_MAYBE_SOURCE_VALUE_REACHES_NEVER_SINK">
    <ShortDescription>可能带有类型限定符的值总是以不允许其具有该类型限定符的方式使用  Value that might carry a type qualifier is always used in a way prohibits it from having that type qualifier</ShortDescription>
    <LongDescription>带有 `{2.simpleName}` 注解的值总是被用于不允许其具有该类型限定词的方式。</LongDescription>
    <Details>
      <![CDATA[<p>一个被注解为可能是一个类型限定符所表示的值之一，并且该值保证将以禁止使用由那个类型限定符表示的值的方式被使用。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_NEVER_SINK">
    <ShortDescription>需要值没有类型修饰符，但标记为未知  Value required to not have type qualifier, but marked as unknown</ShortDescription>
    <LongDescription>值要求不能是 {2.simpleName}，但被明确注解为与 {2.simpleName} 无关。</LongDescription>
    <Details>
      <![CDATA[<p>一个值被使用的方式要求它不能带有某种类型限定符，但存在一个明确的注解表示尚不清楚该值在哪种情况下不允许有那种类型限定符。要么是使用方式不正确，要么是注解不正确。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_ALWAYS_SINK">
    <ShortDescription>需要类型限定符的值被标记为未知  Value required to have type qualifier, but marked as unknown</ShortDescription>
    <LongDescription>值必须始终为 {2.simpleName}，但关于 {2.simpleName} 该值明确标注为未知。</LongDescription>
    <Details>
      <![CDATA[<p>该值的使用方式要求它必须总是带有类型限定符，但存在一个显式注解表明并不知道值在何处需要具有该类型限定符。要么是该值的使用方式不正确，要么是注解不正确。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IO_APPENDING_TO_OBJECT_OUTPUT_STREAM">
    <ShortDescription>企图将内容追加到对象输出流中  Doomed attempt to append to an object output stream</ShortDescription>
    <LongDescription>在{1}中尝试向对象输出流追加操作是无效的。</LongDescription>
    <Details>
      <![CDATA[<p>此代码以追加模式打开一个文件，然后将结果包装在一个对象输出流中，如下所示：</p>
<pre><code>OutputStream out = new FileOutputStream(anyFile, true);
new ObjectOutputStream(out);
</code></pre>
<p>这并不会允许你追加到已经存储在文件中的对象输出流。如果你希望能够追加到对象输出流，你需要保持该对象输出流的打开状态。</p>
<p>唯一可以使在以追加模式打开文件并在其中写入对象输出流有效的情况是，在读取文件时计划以随机访问模式打开文件并定位到追加操作开始的字节偏移量。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="WL_USING_GETCLASS_RATHER_THAN_CLASS_LITERAL">
    <ShortDescription>而不是使用类字面量，在获取类对象时进行同步  Synchronization on getClass rather than class literal</ShortDescription>
    <LongDescription>在{1}处使用getClass进行同步而不是类字面量。</LongDescription>
    <Details>
      <![CDATA[<p>      此实例方法对 <code>this.getClass()</code> 进行了同步。如果此类被子类化，子类将对该子类的类对象进行同步，这可能不是预期的行为。例如，考虑 Java.awt.Label 中的这段代码：</p>
<pre><code>private static final String base = "label"; private static int nameCounter = 0;  String constructComponentName() {     synchronized (getClass()) {   return base + nameCounter++;     } }
</code></pre>
<p>Label 的子类不会对相同的类对象进行同步，从而导致数据竞争。相反，这段代码应该对 <code>Label.class</code> 进行同步。</p>
<pre><code>private static final String base = "label"; private static int nameCounter = 0;  String constructComponentName() {     synchronized (Label.class) {   return base + nameCounter++;     } }
</code></pre>
<p>该错误模式由 Jason Mehrens 提供。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="OBL_UNSATISFIED_OBLIGATION">
    <ShortDescription>方法可能无法正确清理流或资源  Method may fail to clean up stream or resource</ShortDescription>
    <LongDescription>{1} 可能无法清理 {2}</LongDescription>
    <Details>
          <![CDATA[<p>    该方法可能未能正确清理（关闭、释放）流、数据库对象或其他需要显式清理操作的资源。</p>
<p>    通常来说，如果一个方法打开了一个流或其他资源，应该使用 try/finally 块来确保在方法返回前这些流或资源被正确清理。</p>
<p>    此错误模式实质上与 OS_OPEN_STREAM 和 ODR_OPEN_DATABASE_RESOURCE 错误模式相同，但基于不同的（希望更好的）静态分析技术。我们对这个错误模式的有用性很感兴趣。如果您想提供反馈，请查看：</p>
<ul>
<li><a href="https://github.com/spotbugs/spotbugs/blob/master/.github/CONTRIBUTING.md">贡献指南</a></li>
<li><a href="https://github.com/spotbugs/discuss/issues?q=">邮件列表</a></li>
</ul>
<p>    特别的是，此错误模式的假阳性抑制启发式规则尚未进行广泛的调优，因此关于假阳性的报告对我们很有帮助。</p>
<p>    有关分析技术的描述，请参见 Weimer 和 Necula 的 <i>Finding and Preventing Run-Time Error Handling Mistakes</i>（<a href="https://people.eecs.berkeley.edu/~necula/Papers/rte_oopsla04.pdf">PDF</a>）。</p>]]>
      </Details>
  </BugPattern>




  <BugPattern type="OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE">
    <ShortDescription>方法可能在处理受检异常时无法清理流或资源  Method may fail to clean up stream or resource on checked exception</ShortDescription>
    <LongDescription>{1} 在处理已检查异常时可能未能清理 {2}</LongDescription>
    <Details>
          <![CDATA[<p>     此方法可能无法清理（关闭、处置）流、数据库对象或其他需要显式清理操作的资源。     </p>      <p>     一般来说，如果一个方法打开了一个流或其它资源，该方法应该使用 try/finally 块来确保在方法返回之前清理了流或资源。     </p>      <p>     这种错误模式实质上与 OS_OPEN_STREAM 和 ODR_OPEN_DATABASE_RESOURCE 错误模式相同，但基于不同的（希望更好的）静态分析技术。我们对这种错误模式的有用性感兴趣。对于反馈，请参阅：     </p>     <ul> <li><a href="https://github.com/spotbugs/spotbugs/blob/master/.github/CONTRIBUTING.md">贡献指南</a></li> <li><a href="https://github.com/spotbugs/discuss/issues?q=">邮件列表</a></li>     </ul>      <p>     特别是，     对于此错误模式的假阳性抑制启发式尚未进行广泛调优，因此关于假阳性的报告对我们很有帮助。     </p>      <p>     可以参考 Weimer 和 Necula 的论文《寻找和预防运行时错误处理错误》（<a href="https://people.eecs.berkeley.edu/~necula/Papers/rte_oopsla04.pdf">PDF</a>），了解分析技术的描述。     </p>]]>
      </Details>
  </BugPattern>















  <BugPattern type="FB_UNEXPECTED_WARNING">
    <ShortDescription>来自SpotBugs的意外/不必要的警告  Unexpected/undesired warning from SpotBugs</ShortDescription>
    <LongDescription>在{1}中发现了意外/不 desired 的 {2} SpotBugs 警告</LongDescription>
    <Details>
          <![CDATA[<p>SpotBugs生成了一个警告，根据一个@NoWarning注解，这个警告是意外的或不希望出现的。</p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="FB_MISSING_EXPECTED_WARNING">
    <ShortDescription>缺少SpotBugs期望或所需的警告  Missing expected or desired warning from SpotBugs</ShortDescription>
    <LongDescription>在{1}中缺少预期或所需的第{2}个SpotBugs警告</LongDescription>
    <Details>
          <![CDATA[<p>SpotBugs 没有生成根据 <code>@ExpectedWarning</code> 注解预期或希望产生的警告。</p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="RV_RETURN_VALUE_OF_PUTIFABSENT_IGNORED">
    <ShortDescription>`putIfAbsent` 的返回值被忽略，传给 `putIfAbsent` 的值被重复使用  Return value of putIfAbsent ignored, value passed to putIfAbsent reused</ShortDescription>
    <LongDescription>putIfAbsent 的返回值被忽略，但 {4} 在 {1} 中被重复使用</LongDescription>
    <Details>
          <![CDATA[`putIfAbsent` 方法通常用于确保给定键关联一个单一值（成功时为该键设置的第一个值）。如果你忽略了返回值并保留了传入值的引用，可能会保留与映射中键关联的不是最新值。如果使用的是未存储在映射中的那个值，并且这个选择对你来说很重要，那么你的程序将会行为不当。]]>
      </Details>
  </BugPattern>
  <BugPattern type="LG_LOST_LOGGER_DUE_TO_WEAK_REFERENCE">
    <ShortDescription>由于弱引用在OpenJDK中的使用可能导致潜在的日志记录器更改丢失  Potential lost logger changes due to weak reference in OpenJDK</ShortDescription>
    <LongDescription>在 `{1}` 中对 logger 的更改可能会丢失。</LongDescription>
    <Details>
          <![CDATA[<p>OpenJDK 引入了一种潜在的不兼容性。特别是，java.util.logging.Logger 的行为发生了变化。它现在内部使用弱引用而不是强引用。这是一个合理的改变，但不幸的是，有些代码依赖于旧的行为——在更改日志器配置时，它简单地丢弃了日志器引用。这意味着垃圾回收器可以回收这部分内存，从而导致日志器配置丢失。例如考虑以下情况：</p>
<pre><code>public static void initLogging() throws Exception {     Logger logger = Logger.getLogger("edu.umd.cs");     logger.addHandler(new FileHandler()); // 调用更改日志器配置     logger.setUseParentHandlers(false); // 另一个更改日志器配置的调用 } </code></pre>
<p>在方法结束时丢失了 logger 引用（它没有逃出该方法），因此如果在 initLogging 调用之后立即发生垃圾回收周期，日志器配置将会丢失（因为 Logger 只保持弱引用）。</p>
<pre><code>public static void main(String[] args) throws Exception {     initLogging(); // 为 logger 添加文件处理程序     System.gc(); // 日志器配置丢失     Logger.getLogger("edu.umd.cs").info("Some message"); // 预期不会将此消息记录到文件中 </code></pre>
<p><em>Ulf Ochsenfahrt 和 Eric Fellheimer</em></p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="AT_OPERATION_SEQUENCE_ON_CONCURRENT_ABSTRACTION">
    <ShortDescription>对并发抽象的调用序列可能不是原子操作  Sequence of calls to concurrent abstraction may not be atomic</ShortDescription>
    <LongDescription>在 `{1}` 中，对 `{2}` 的连续调用可能不是原子操作。</LongDescription>
    <Details>
          <![CDATA[这段代码包含对并发抽象（如并发哈希映射）的一系列调用。这些调用不会被原子执行。]]>
      </Details>
  </BugPattern>
  <BugPattern type="DM_DEFAULT_ENCODING">
    <ShortDescription>依赖默认编码  Reliance on default encoding</ShortDescription>
    <LongDescription>在 {1} 中发现了对默认编码的依赖：{2}</LongDescription>
    <Details>
<![CDATA[<p>发现了一个将字节转换为字符串（或字符串转换为字节）的方法调用，并且该方法假设默认平台编码是合适的。这会导致应用程序的行为在不同平台上有所差异。请使用其他API，并显式指定字符集名称或字符集对象。</p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="NP_METHOD_PARAMETER_RELAXING_ANNOTATION">
    <ShortDescription>方法收紧了参数的空值注解  Method tightens nullness annotation on parameter</ShortDescription>
    <LongDescription>方法 `{1}` 覆盖了空值注解，从而放松了对参数的祖先方法的要求。</LongDescription>
    <Details>
        <![CDATA[<p>一个方法在覆盖父类的方法时，应该始终实现该方法的合同。因此，如果一个方法接收一个标记为@Nullable的参数，你不应在一个子类中用一个方法来覆盖它，而这个方法中的相同参数被标记为@Nonnull。这样做违反了方法应处理空参数的合同。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_METHOD_PARAMETER_TIGHTENS_ANNOTATION">
    <ShortDescription>方法紧化了参数的空值注解  Method tightens nullness annotation on parameter</ShortDescription>
    <LongDescription>方法 `{1}` 以不兼容的方式Override了参数 `{2}` 的非空性注解</LongDescription>
    <Details>
        <![CDATA[<p>一个方法在覆盖父类的方法时，应该始终实现该方法的契约。因此，如果一个方法接受一个标记为@Nullable的参数，你不应该在子类中用一个该参数标记为@Nonnull的方法来覆盖它。这样做会违反该方法应处理空参数的契约。</p>]]>
      </Details>
  </BugPattern>

  <BugPattern type="NP_METHOD_RETURN_RELAXING_ANNOTATION">
    <ShortDescription>方法放松了返回值的非空注解  Method relaxes nullness annotation on return value</ShortDescription>
    <LongDescription>方法 `{1}` 以不兼容的方式覆盖了返回值的空值注解。</LongDescription>
    <Details>
        <![CDATA[<p>   一个方法在覆盖父类的方法时，应该始终实现该方法的合同。因此，如果一个方法被注解为返回@Nonnull 值，你不应该在一个子类中用一个被注解为返回@Nullable 或 @CheckForNull 值的方法来覆盖它。这样做会违反该方法不应返回 null 的合同。</p>]]>
      </Details>
  </BugPattern>

  <BugPattern type="EOS_BAD_END_OF_STREAM_CHECK">
    <ShortDescription>数据读取在比较之前被转换为-1  Data read is converted before comparison to -1</ShortDescription>
    <LongDescription>在方法 {1} 中，{2} 的返回值在与 {4} 进行比较之前被转换为 {3}。</LongDescription>
    <Details>
      <![CDATA[<p>方法 `java.io.FileInputStream.read()` 返回一个 int。如果将这个 int 转换为 byte，则 -1（表示 EOF）和 byte 0xFF 就无法区分。在循环中将转换后的结果与 -1 进行比较会导致在遇到字符 0xFF 时提前结束读取。</p>
<p>同样，方法 `java.io.FileReader.read()` 也返回一个 int。如果将其转换为 char，则 -1 变为 0xFFFF，即 `Character.MAX_VALUE`。将结果与 -1 进行比较是没有意义的，因为在 Java 中字符是无符号的。如果使用检查 EOF 的条件来控制循环，则该循环将是无限的。</p>
<p>请参见 SEI CERT 规则 <a href="https://wiki.sei.cmu.edu/confluence/display/java/FIO08-J.+Distinguish+between+characters+or+bytes+read+from+a+stream+and+-1">FIO08-J. 区分从流中读取的字符或字节与 -1</a>。</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="REFLC_REFLECTION_MAY_INCREASE_ACCESSIBILITY_OF_CLASS">
    <ShortDescription>公共方法使用反射在其参数中获取一个类来创建该类，这可能会增加任何类的可访问性。  Public method uses reflection to create a class it gets in its parameter which could increase the accessibility of any class</ShortDescription>
    <LongDescription>公共方法 {1} 使用反射根据其参数获取的类来创建类，这可能会增加任何类的可访问性。</LongDescription>
    <Details>
      <![CDATA[<p>SEI CERT SEC05-J 规则禁止使用反射来增加类、方法或字段的访问性。如果一个包中的类提供了一个接受 java.lang.Class 实例作为参数的公共方法，并调用了其 newInstance() 方法，那么这将不通过公有构造函数而增加同一包中类的访问性。攻击者的代码可能会调用此方法并传递此类以创建其实例。为了避免这种情况，可以通过使其方法非公共或在包上检查包访问权限来避免。第三个选择是使用 java.beans.Beans.instantiate() 方法代替 java.lang.Class.newInstance()，该方法会检查接收到的 Class 对象是否有任何公有构造函数。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="REFLF_REFLECTION_MAY_INCREASE_ACCESSIBILITY_OF_FIELD">
    <ShortDescription>公共方法使用反射修改其参数中获取的字段，这可能会增加任何类的可访问性。  Public method uses reflection to modify a field it gets in its parameter which could increase the accessibility of any class</ShortDescription>
    <LongDescription>公共方法 `{1}` 使用反射修改其参数中获取的字段，这可能会增加任何类的可访问性。</LongDescription>
    <Details>
      <![CDATA[<p>SEI CERT SEC05-J 规则禁止使用反射来增加类、方法或字段的可访问性。如果一个包中的类提供了一个接受 java.lang.reflect.Field 实例作为参数的公共方法，并且调用了 setter（或 setAccessible()）方法，那么这将增加同一包中私有、受保护或包内访问级别的字段的可访问性。攻击者的代码可能会调用此方法并传递此类字段以进行更改。为了避免这种情况，可以通过使其方法非公共或将包访问权限检查添加到包上来避免这种做法。</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="MC_OVERRIDABLE_METHOD_CALL_IN_CONSTRUCTOR">
    <ShortDescription>构造函数中调用了可被重写的方法  An overridable method is called from a constructor</ShortDescription>
    <LongDescription>可被重写的方法 {2} 在构造函数 {1} 中被调用。</LongDescription>
    <Details>
      <![CDATA[<p>在构造函数中调用可被重写的方法可能会导致使用未初始化的数据。此外，这还可能导致部分构建对象的 this 引用泄漏。仅应从构造函数中调用静态、最终或私有方法。</p>
<p>请参见 SEI CERT 规则 <a href="https://wiki.sei.cmu.edu/confluence/display/java/MET05-J.+Ensure+that+constructors+do+not+call+overridable+methods">MET05-J. 确保构造函数不调用可被重写的方法</a>。</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="MC_OVERRIDABLE_METHOD_CALL_IN_CLONE">
    <ShortDescription>`clone()` 方法中调用了可被覆盖的方法。  An overridable method is called from the clone() method.</ShortDescription>
    <LongDescription>可覆盖方法 {2} 在类 {0} 的克隆方法 clone() 中被调用。</LongDescription>
    <Details>
      <![CDATA[从 `clone()` 方法中调用可覆盖的方法是不安全的，因为子类可以重写该方法，从而影响 `clone()` 的行为。此外，这也可能导致观察或修改处于部分初始化状态的克隆对象。仅应调用静态、最终或私有方法从 `clone()` 方法中执行。

请参阅 SEI CERT 规则 <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88487921">MET06-J. 不在 `clone()` 中调用可覆盖的方法</a>。]]>
    </Details>
  </BugPattern>
  <BugPattern type="MC_OVERRIDABLE_METHOD_CALL_IN_READ_OBJECT">
    <ShortDescription>从 `readObject` 方法中调用了可以被覆盖的方法。  An overridable method is called from the readObject method.</ShortDescription>
    <LongDescription>可覆盖的方法 {2} 在 readObject 方法中被调用。</LongDescription>
    <Details>
      <![CDATA[<p>`readObject()` 方法不得调用任何可重写方法。从 `readObject()` 方法调用可重写方法可能会使覆盖的方法在对象完全初始化之前访问该对象的状态。这是因为，在反序列化过程中，`readObject` 起到了构造函数的作用，因此直到 `readObject` 退出时对象的初始化才完成。</p>
<p> <br/>请参阅 SEI CERT 规则 <a href="https://wiki.sei.cmu.edu/confluence/display/java/SER09-J.+Do+not+invoke+overridable+methods+from+the+readObject%28%29+method">SER09-J. 不应在 `readObject()` 方法中调用可重写方法</a>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SING_SINGLETON_IMPLEMENTS_CLONEABLE">
    <ShortDescription>直接使用单例设计模式的类实现了Cloneable接口。  Class using singleton design pattern directly implements Cloneable interface.</ShortDescription>
    <LongDescription>类（{0}）直接实现了Cloneable接口，并使用了单例设计模式。</LongDescription>
    <Details>
      <![CDATA[<p>
如果一个使用单例设计模式的类直接实现了Cloneable接口，可能会创建该对象的副本，从而违反单例模式。<br>
因此，应避免实现Cloneable接口。<br><br>

更多信息，请参见：<a href="https://wiki.sei.cmu.edu/confluence/display/java/MSC07-J.+Prevent+multiple+instantiations+of+singleton+objects">SEI CERT MSC07-J</a>。
</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SING_SINGLETON_INDIRECTLY_IMPLEMENTS_CLONEABLE">
    <ShortDescription>使用单例设计模式的类间接实现了Cloneable接口。  Class using singleton design pattern indirectly implements Cloneable interface.</ShortDescription>
    <LongDescription>类（{0}）间接实现了Cloneable接口，并使用了单例设计模式。</LongDescription>
    <Details>
      <![CDATA[<p>
如果一个使用单例设计模式的类间接实现了Cloneable接口，可能会创建该对象的副本，从而违反单例模式。
因此，应避免实现Cloneable接口。如果因为扩展了超类而无法避免，则解决方案是在clone方法中无条件抛出CloneNotSupportedException异常。

更多信息，请参见：<a href="https://wiki.sei.cmu.edu/confluence/display/java/MSC07-J.+Prevent+multiple+instantiations+of+singleton+objects">SEI CERT MSC07-J</a>。
</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SING_SINGLETON_IMPLEMENTS_CLONE_METHOD">
    <ShortDescription>使用单例设计模式的类实现了clone()方法，但不是无条件抛出CloneNotSupportedException。  Class using singleton design pattern implements clone() method without being an unconditional CloneNotSupportedException-thrower.</ShortDescription>
    <LongDescription>类 ({0}) 使用单例设计模式实现clone()方法，但不是无条件抛出CloneNotSupportedException。</LongDescription>
    <Details>
      <![CDATA[<p>   这个类使用了单例设计模式，并未实现 Cloneable 接口，但却实现了 clone() 方法且不带 unconditional 的 CloneNotSupportedException 抛出。因此，可以创建该对象的副本，从而违反了单例模式。<br>
   因此，应避免实现 clone 方法，否则需要覆写 clone 方法并使其无条件抛出 CloneNotSupportedException。<br><br>
    更多信息，请参见： <a href="https://wiki.sei.cmu.edu/confluence/display/java/MSC07-J.+Prevent+multiple+instantiations+of+singleton+objects">SEI CERT MSC07-J</a>。   </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SING_SINGLETON_HAS_NONPRIVATE_CONSTRUCTOR">
    <ShortDescription>使用单例设计模式的类具有非私有构造函数。  Class using singleton design pattern has non-private constructor.</ShortDescription>
    <LongDescription>使用单例设计模式的类({0})拥有非私有构造函数。</LongDescription>
    <Details>
      <![CDATA[<p>
   该类使用了单例设计模式，并且其构造器不是私有的（请注意可能存在一个默认的构造器，但它是非私有的）。因此，可以创建该对象的副本，从而违反了单例模式。
   更简单的方法是将构造器设为私有。
   
   <a href="https://wiki.sei.cmu.edu/confluence/display/java/MSC07-J.+Prevent+multiple+instantiations+of+singleton+objects">SEI CERT MSC07-J</a> 规则
</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SING_SINGLETON_IMPLEMENTS_SERIALIZABLE">
    <ShortDescription>直接或间接使用单例设计模式的类直接实现了Serializable接口。  Class using singleton design pattern directly or indirectly implements Serializable interface.</ShortDescription>
    <LongDescription>类 ({0}) 直接或间接使用单例设计模式，并实现了Serializable接口。</LongDescription>
    <Details>
      <![CDATA[<p>这个类（使用了单例设计模式）直接或间接实现了Serializable接口，这使得类可以被序列化。<br>反序列化会使单例类产生多个实例，并因此应避免。<br><br><a href="https://wiki.sei.cmu.edu/confluence/display/java/MSC07-J.+Prevent+multiple+instantiations+of+singleton+objects">SEI CERT MSC07-J</a> 规则</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SING_SINGLETON_GETTER_NOT_SYNCHRONIZED">
    <ShortDescription>使用单例设计模式的类中，实例获取方法未进行同步。  Instance-getter method of class using singleton design pattern is not synchronized.</ShortDescription>
    <LongDescription>使用单例设计模式的类（{0}）中的实例获取方法未同步。</LongDescription>
    <Details>
      <![CDATA[<p>使用单例设计模式的类的实例获取方法未进行同步。当该方法被两个或多个线程同时调用时，可能会导致单例类产生多个实例。<br><br>      <a href="https://wiki.sei.cmu.edu/confluence/display/java/MSC07-J.+Prevent+multiple+instantiations+of+singleton+objects">SEI CERT MSC07-J</a> 规则 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SSD_DO_NOT_USE_INSTANCE_LOCK_ON_SHARED_STATIC_DATA">
    <ShortDescription>在共享静态数据上使用了实例级别锁。  Instance level lock was used on a shared static data</ShortDescription>
    <LongDescription>静态字段 "{2}" 被实例级别 的 {3} 修改。</LongDescription>
    <Details>
      <![CDATA[<p>如果锁或同步方法不是静态的，并且修改了静态字段，那么共享的静态数据可能会在并发访问时得不到保护。这种情况可以通过两种方式发生：如果同步方法使用了一个非静态锁对象，或者同步方法声明为非静态。这两种方式都是无效的。最佳解决方案是使用一个私有的静态最终（final）锁对象来保护共享的静态数据。</p>
<p>参见SEI CERT规则：<a href="https://wiki.sei.cmu.edu/confluence/display/java/LCK06-J.+Do+not+use+an+instance+lock+to+protect+shared+static+data">LCK06-J. 不要使用实例锁来保护共享静态数据</a>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FL_FLOATS_AS_LOOP_COUNTERS">
    <ShortDescription>不要将浮点变量用作循环计数器。  Do not use floating-point variables as loop counters</ShortDescription>
    <LongDescription>使用浮点数作为循环计数器可能会导致意外的行为。</LongDescription>
    <Details>
      <![CDATA[<p>不应使用浮点变量作为循环计数器，因为它们不够精确，可能会导致循环不正确。循环计数器是一个在每次迭代中都会更改的变量，并控制何时终止循环。它会在每次迭代中增加或减少一个固定量。</p>
<p>请参见规则 <a href="https://wiki.sei.cmu.edu/confluence/display/java/NUM09-J.+Do+not+use+floating-point+variables+as+loop+counters">NUM09-J</a>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="THROWS_METHOD_THROWS_RUNTIMEEXCEPTION">
    <ShortDescription>方法故意抛出 `RuntimeException`。  Method intentionally throws RuntimeException.</ShortDescription>
    <LongDescription>方法故意抛出 `RuntimeException`。</LongDescription>
    <Details>
      <![CDATA[<p>方法故意抛出 RuntimeException。<br>根据 <a href="https://wiki.sei.cmu.edu/confluence/display/java/ERR07-J.+Do+not+throw+RuntimeException%2C+Exception%2C+or+Throwable">SEI CERT ERR07-J 规则</a>，抛出 RuntimeException 可能会导致错误，例如调用者无法检查异常，因此不能适当恢复。<br>此外，抛出 RuntimeException 会迫使调用者捕获 RuntimeException，从而违反 <a href="https://wiki.sei.cmu.edu/confluence/display/java/ERR08-J.+Do+not+catch+NullPointerException+or+any+of+its+ancestors">SEI CERT ERR08-J 规则</a>。<br>请注意，您可以从 Exception 或 RuntimeException 继承，并且可以抛出该异常的新实例。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="THROWS_METHOD_THROWS_CLAUSE_BASIC_EXCEPTION">
    <ShortDescription>方法在其throws声明中列出了Exception。  Method lists Exception in its throws clause.</ShortDescription>
    <LongDescription>方法在其throws子句中列出了Exception。</LongDescription>
    <Details>
      <![CDATA[<p>方法在其抛出声明中列出了 Exception。<br>在声明方法时，throws子句中的异常类型应尽可能具体。因此，在 throws 子句中使用 Exception 会迫使调用者要么将其包含在自己的 throws 子句中，要么将其放在 try-catch 块中（但并不一定包含关于抛出异常的任何有意义的信息）。<br><br>欲了解更多信息，请参阅 <a href="https://wiki.sei.cmu.edu/confluence/display/java/ERR07-J.+Do+not+throw+RuntimeException%2C+Exception%2C+or+Throwable">SEI CERT ERR07-J 规则</a>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="THROWS_METHOD_THROWS_CLAUSE_THROWABLE">
    <ShortDescription>方法在其throws语句中列出了Throwable。  Method lists Throwable in its throws clause.</ShortDescription>
    <LongDescription>方法在其抛出异常列表中列出了Throwable。</LongDescription>
    <Details>
      <![CDATA[<p>
   方法在其 throws 子句中列出了 Throwable。<br>
   在声明方法时，throws 子句中的异常类型应尽可能具体。因此，在 throws 子句中使用 Throwable 会强制调用者要么在自己的 throws 子句中使用它，要么在 try-catch 块中处理它（尽管它可能不包含关于抛出的异常的重要信息）。<br>
   此外，这种做法从语义上来说是不良实践。因为 Throwables 包括 Errors，在本质上它们发生在不可恢复的情境中。<br><br>
   有关更多信息，请参阅 <a href="https://wiki.sei.cmu.edu/confluence/display/java/ERR07-J.+Do+not+throw+RuntimeException%2C+Exception%2C+or+Throwable">SEI CERT ERR07-J 规则</a>。
</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="PERM_SUPER_NOT_CALLED_IN_GETPERMISSIONS">
    <ShortDescription>自定义类加载器未调用其超类的getPermissions()方法  Custom class loader does not call its superclass's getPermissions()</ShortDescription>
    <LongDescription>自定义类加载器 {1} 没有调用其超类的 getPermissions() 方法</LongDescription>
    <Details>
      <![CDATA[<p>SEI CERT 规则 SEC07-J 要求，在自定义类加载器的 getPermissions() 方法中，必须始终调用其 superclass 的 getPermissions() 方法来初始化最终返回的对象。省略此步骤意味着使用该自定义类加载器定义的类将具有完全独立于系统策略文件中指定权限的权限，实际上这些类的权限覆盖了系统策略文件中的设置。</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="USC_POTENTIAL_SECURITY_CHECK_BASED_ON_UNTRUSTED_SOURCE">
    <ShortDescription>基于不受信任来源的潜在安全检查。  Potential security check based on untrusted source.</ShortDescription>
    <LongDescription>在公共方法 `{1}` 中，非最终方法 `{4}` 在进入 `doPrivileged` 块之前被调用于 `{5}` 位置，并且在同一块内部也在 `{6}` 位置对 `{3}` 的非最终类实例进行了调用。如果此调用是一个在进入 `doPrivileged()` 块之前的检查，则可能不可靠，因为该方法可能会接收到一个恶意派生类的实例，而这个派生类重写了此方法使其行为与预期不同。</LongDescription>
    <Details>
      <![CDATA[<p>公共类中的公共方法可能被外部包调用，这意味着可能会传入未信任的数据。在调用方法之前进行安全检查（如检查返回值），然后在类内部再次调用同一方法是危险的，尤其是如果该方法或其包含的类不是最终类。攻击者可以通过传递恶意子类的实例而不是预期的实例来绕过这种检查，而这些方法可能在其被重写时返回不同的值。例如，一个返回文件路径的方法可能会在进入doPrivileged块之前返回一个无害的路径进行检查，而在doPrivileged块内部调用时返回敏感文件。为了避免这种情况，应防御性地复制通过参数接收到的对象，例如使用作为形式参数类型所使用的类的拷贝构造函数。这确保了该方法的行为符合预期。 </p>
<p>参见SEI CERT规则 <a href="https://wiki.sei.cmu.edu/confluence/display/java/SEC02-J.+Do+not+base+security+checks+on+untrusted+sources">SEC02-J. 不要基于未信任的来源进行安全检查</a>。 </p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="ASE_ASSERTION_WITH_SIDE_EFFECT">
    <ShortDescription>断言中的表达式可能会产生副作用  Expression in assertion may produce a side effect</ShortDescription>
    <LongDescription>在{1}处的断言中使用的表达式可能会产生副作用。如果禁用了断言，该表达式将不会被执行，方法的结果可能会发生变化。</LongDescription>
    <Details>
      <![CDATA[<p>断言中使用的表达式不得产生副作用。</p>
<p>详见 <https://wiki.sei.cmu.edu/confluence/display/java/EXP06-J.+Expressions+used+in+assertions+must+not+produce+side+effects><code>SEI CERT规则 EXP06</code></a> 以获得更多信息。</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="ASE_ASSERTION_WITH_SIDE_EFFECT_METHOD">
    <ShortDescription>断言中调用的方法可能会产生副作用  Method invoked in assertion may produce a side effect</ShortDescription>
    <LongDescription>在位置 `{1}` 的断言中调用的方法可能会产生副作用。如果禁用了断言，该方法的调用将不会执行，从而可能导致方法的结果发生变化。</LongDescription>
    <Details>
      <![CDATA[<p>断言中使用的表达式不得产生副作用。</p>
<p>更多信息请参阅 <https://wiki.sei.cmu.edu/confluence/display/java/EXP06-J.+Expressions+used+in+assertions+must+not+produce+side+effects><code>SEI CERT 规则 EXP06</code></a>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="PA_PUBLIC_PRIMITIVE_ATTRIBUTE">
    <ShortDescription>原始字段是公有的  Primitive field is public</ShortDescription>
    <LongDescription>原始字段 {1} 是公共的，并且在类内部被设置，这使其暴露过度。考虑将其设为私有以限制外部访问权限。</LongDescription>
    <Details>
      <![CDATA[<p>SEI CERT规则OBJ01-J要求字段的访问性必须被限制。否则，这些字段的值可能会从类外部进行操作，这可能会导致意想不到或不期望的行为。通常而言，并非不允许任何字段为public过于苛刻且不切实际。即使该规则也提到final字段可以是public的。除了final字段外，还有其他使用public字段的情况：某些public字段可能充当“标志”，影响类的行为。这类标志字段预期会被当前实例（或在静态字段的情况下是当前类）读取，但由外部写入。如果一个字段既由当前实例的方法（或在静态字段的情况下是当前类）写入，又被外部写入，则代码可能是可疑的。考虑将这些字段改为private，并提供必要的setter方法。请注意，构造函数、初始化器和析构函数是例外情况，只要它们在类内部写入字段，则该字段不被视为由类本身写入。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="PA_PUBLIC_ARRAY_ATTRIBUTE">
    <ShortDescription>数组类型的字段是公共的  Array-type field is public</ShortDescription>
    <LongDescription>数组类型的字段 {1} 是公开的，这使其暴露得太广泛。考虑将其设为私有以限制外部访问。</LongDescription>
    <Details>
      <![CDATA[<p>SEI CERT 规则 OBJ01-J 要求字段的访问权限必须被限制。将数组类型的字段设为 final 并不会阻止其他类修改该数组的内容。然而，通常要求不允许任何字段是 public 的过于苛刻且不现实。公共字段可能用于充当“标志”，影响类的行为。这样的标志字段预期会被当前实例（或在静态字段的情况下为当前类）读取，但由外部写入。如果一个字段既被当前实例的方法（或在静态字段的情况下为当前类）内的方法所写入，也被外部写入，则代码可能存在可疑之处。考虑将这些字段设为 private，并在必要时提供相应的 setter 方法。请注意，构造函数、初始化器和终结器是例外情况，只要它们仅在类内部写入该字段，则该字段不被视为由类本身写入。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="PA_PUBLIC_MUTABLE_OBJECT_ATTRIBUTE">
    <ShortDescription>可变的对象类型字段是公共的  Mutable object-type field is public</ShortDescription>
    <LongDescription>可变的对象类型字段 {1} 是公共的，这使其暴露在外。考虑将其改为私有以限制外部访问。</LongDescription>
    <Details>
      <![CDATA[<p>SEI CERT规则OBJ01-J要求字段的访问性必须被限制。将一个可变的对象类型字段声明为final并不能防止其他类修改该对象的内容。然而，一般而言，并不允许任何字段是公开的过于苛求且不现实。某些情况下公共字段是有用的：一些公共字段可以作为“标志”，影响类的行为。这些标志字段通常会被当前实例（或对于静态字段，则为当前类）读取，但由外部写入。如果一个字段既被当前实例的方法（或对于静态字段则是当前类的方法）和外部所修改，那么代码可能是可疑的。考虑将这些字段声明为私有，并在必要时提供相应的setter方法。请注意，构造函数、初始化器和终结器是例外情况：仅当它们内部写入字段时，该字段不被视为由类本身写的。对于对象类型的字段，“写入”意味着调用表明修改的方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="VSC_VULNERABLE_SECURITY_CHECK_METHODS">
    <ShortDescription>非私有且非最终的安全检查方法存在漏洞  Non-Private and non-final security check methods are vulnerable</ShortDescription>
    <LongDescription>方法 `{1}` 使用 `Security Manager` 类的 `{2}` 方法进行安全性检查，但该方法是可以被覆盖的。为了解决问题，请将该方法声明为 `final` 或 `private`。</LongDescription>
    <Details>
      <![CDATA[<p>执行安全检查的方法应防止被重写，因此它们必须声明为 <strong>私有 (private)</strong> 或 <strong>最终 (final)</strong>。否则，恶意子类可以重写这些方法并跳过检查从而使其失效。</p>
<p>请参见 SEI CERT 规则 <a href="https://wiki.sei.cmu.edu/confluence/display/java/MET03-J.+Methods+that+perform+a+security+check+must+be+declared+private+or+final">MET03-J. 执行安全检查的方法必须声明为私有或最终</a>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="AA_ASSERTION_OF_ARGUMENTS">
    <ShortDescription>断言用于验证公共方法的参数有效性  Assertion is used to validate an argument of a public method</ShortDescription>
    <LongDescription>断言在位置{1}验证方法参数。如果禁用了断言，将不会进行任何参数验证。</LongDescription>
    <Details>
      <![CDATA[<p>公共方法的参数验证不应使用断言进行，因为如果禁用断言，则不会执行这些验证。</p>
<p>更多信息请参阅SEI CERT规则：<a href="https://wiki.sei.cmu.edu/confluence/display/java/MET01-J.+Never+use+assertions+to+validate+method+arguments">MET01-J. 从未使用断言来验证方法参数</a></p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="PI_DO_NOT_REUSE_PUBLIC_IDENTIFIERS_CLASS_NAMES">
        <ShortDescription>不要从JSL中重复使用公有标识符作为类名  Do not reuse public identifiers from JSL as class name</ShortDescription>
        <LongDescription>类名 {0} � contrasted 公开可用的 Java 标准库标识符。</LongDescription>
        <Details>
            <![CDATA[<p>避免在类名中重用来自Java标准库的公共标识符是一个好习惯。这是因为Java标准库是Java平台的一部分，并且预期会在所有Java环境中可用。这样做可能会导致命名冲突和混淆，使代码更难理解和维护。最好选择能够准确反映自己代码的目的和功能的独特且描述性的类名。例如，如果你想在应用程序中创建一个处理日期的类，不要使用常见的名称“Date”，因为它与现有的java.util.Date类冲突，可以选用更加具体且独特的名称如“AppDate”或“DisplayDate”。在选择标识符名称时，请注意以下几点：<ul>   <li>使用有意义的前缀或命名空间：为你的类名添加项目特定的前缀或命名空间以使其与众不同。例如，如果你的项目名为“MyApp”，你可以使用"MyAppDate"作为类名。</li>   <li>使用描述性名称：选择能够清楚表明其目的和功能的描述性强的类名。这有助于避免遮蔽现有的Java标准库标识符。例如，不要使用“List”，而是考虑使用“CustomAppList”。 </li>   <li>遵循命名约定：遵守Java的命名约定，例如使用驼峰命名法（如MyClass）为类命名。这可以提高代码可读性并减少冲突的机会。</li> </ul>  </p>
<p>请参阅SEI CERT规则<a href="https://wiki.sei.cmu.edu/confluence/display/java/DCL01-J.+Do+not+reuse+public+identifiers+from+the+Java+Standard+Library">DCL01-J. 不要重用Java标准库中的公共标识符</a>。</p>]]>
        </Details>
  </BugPattern>
  <BugPattern type="PI_DO_NOT_REUSE_PUBLIC_IDENTIFIERS_FIELD_NAMES">
        <ShortDescription>不要从JSL中重复使用公共标识符作为字段名。  Do not reuse public identifiers from JSL as field name</ShortDescription>
        <LongDescription>在类 {0} 中，字段 {1.name} 遮蔽了来自 Java 标准库的公开标识符。</LongDescription>
        <Details>
            <![CDATA[<p>避免在代码中重用Java标准库中的公共标识符作为字段名是一种良好的实践。这样做可能会导致混淆和潜在的冲突，使得理解和维护代码库变得更加困难。相反，建议选择能够准确反映其用途且与标准库标识符区分开来的唯一且描述性强的名字。例如，如果你想创建一个处理日期的应用类，可以避免使用“Date”这样的通用名称（它会与现有的java.util.Date类发生冲突），而选择更为具体和独特的名称如“AppDate”或“DisplayDate”。同样地，如果你正在创建一个代表汽车的类，不要使用“Component”这样的字段名（因为它会与现有的java.awt.Component类产生冲突），而是选择更具体且不同的名称如“VehiclePart”或“CarComponent”。在为标识符命名时需要注意以下几点：<ul>   <li>使用描述性强的名字：选用能够明确表示其目的和功能的字段名，以避免遮蔽Java标准库中的现有标识符。例如，不要使用“list”，而是考虑使用“myFancyList”。</li>   <li>遵循命名约定：遵守Java的命名约定，如字段名采用混合大小写格式（首字母小写，内部单词首字母大写），例如`myFieldUsesMixedCase`。这有助于提高代码可读性并减少冲突的可能性。</li> </ul>  </p> <p>请参见SEI CERT规则：<a href="https://wiki.sei.cmu.edu/confluence/display/java/DCL01-J.+Do+not+reuse+public+identifiers+from+the+Java+Standard+Library">DCL01-J. 不要重用Java标准库中的公共标识符</a>。</p>]]>
        </Details>
  </BugPattern>
  <BugPattern type="PI_DO_NOT_REUSE_PUBLIC_IDENTIFIERS_METHOD_NAMES">
        <ShortDescription>不要从JSL中重复使用公共标识符作为方法名称。  Do not reuse public identifiers from JSL as method name</ShortDescription>
        <LongDescription>方法名 `{1}` � contrast 了来自 Java 标准库的公共标识符。</LongDescription>
        <Details>
            <![CDATA[<p>避免在代码中重用来自Java标准库的公共标识符作为方法名是一个良好的实践。这样做可能会导致混淆、潜在冲突和意外行为。为了保持代码清晰并确保正确功能，建议选择能够准确反映其目的且与标准库标识符区分开来的独特且描述性强的方法名称。例如，如果你想创建一个处理自定义文件生成的方法，在应用中使用“File”这样的通用方法名会与现有的java.io.File类冲突，你可以选择更具体和独特的名称，如“generateFile”或“createOutputFile”。在选择标识符命名时需要注意以下几点：<ul>   <li>使用描述性强的名称：选用能够清楚表明其目的和功能的方法名称。这有助于避免遮蔽现有Java标准库的标识符。例如，不要使用“abs()”，而是考虑使用“calculateAbsoluteValue()”。</li>   <li>遵循命名约定：遵守Java的命名规范，如方法名使用混合大小写。方法名应以动词开头，并且首字母小写，内部单词首字母大写（例如，“runFast()”）。这有助于提高代码可读性并减少冲突的可能性。</li> </ul>  </p><p>请参阅SEI CERT规则：<a href="https://wiki.sei.cmu.edu/confluence/display/java/DCL01-J.+Do+not+reuse+public+identifiers+from+the+Java+Standard+Library">DCL01-J. 不要重用来自Java标准库的公共标识符</a>。</p>]]>
        </Details>
  </BugPattern>
  <BugPattern type="PI_DO_NOT_REUSE_PUBLIC_IDENTIFIERS_LOCAL_VARIABLE_NAMES">
        <ShortDescription>不要从JSL中重复使用公共标识符作为方法名称。  Do not reuse public identifiers from JSL as method name</ShortDescription>
        <LongDescription>在方法 {1} 中，变量名 {2} 遮蔽了来自 Java 标准库的公开标识符。</LongDescription>
        <Details>
            <![CDATA[<p>在声明局部变量时，最好避免重新使用来自 Java 标准库的公共标识符。将这些标识符用作局部变量名会导致混淆，妨碍代码理解，并可能与 Java 标准库中现有的公开可用标识符名称发生冲突。为了保持代码清晰并避免此类问题，最好为您的局部变量选择独特的且描述性强的名字。例如，如果你想存储一个自定义字体值到一个变量里，不要使用“Font”这样的常见名（它会与已有的 java.awt.Font 类冲突），而是可以选择更具特定性和唯一性的名称，如“customFont”或“loadedFontName”。在选择标识符命名时，请记住以下几点：<ul>   <li>使用描述性名称：选择能够清楚表明其用途和功能的变量名。这有助于避免遮蔽现有的 Java 标准库标识符。例如，不要使用“variable”，而可以考虑使用“myVariableName”。</li>   <li>遵循命名约定：遵守 Java 的命名约定，如变量名使用混合大小写形式。首字母小写，内部单词的首字母大写（例如 myVariableName）。这有助于提高代码可读性并减少冲突的机会。</li> </ul></p> 
<p>请参阅 SEI CERT 规则 <a href="https://wiki.sei.cmu.edu/confluence/display/java/DCL01-J.+Do+not+reuse+public+identifiers+from+the+Java+Standard+Library">DCL01-J. 不要重新使用来自 Java 标准库的公共标识符</a>。</p>]]>
        </Details>
  </BugPattern>
  <BugPattern type="ENV_USE_PROPERTY_INSTEAD_OF_ENV">
    <ShortDescription>建议使用可移植的Java属性而不是环境变量。  It is preferable to use portable Java property instead of environment variable.</ShortDescription>
    <LongDescription>在方法 `{1}` 中，最好使用可移植的Java属性 `{3}` 而不是环境变量 `{2}`。</LongDescription>
    <Details>
      <![CDATA[<p>环境变量不具有可移植性，运行的操作系统不同，变量名称本身（不仅仅是值）也可能不同。不仅特定环境变量的名称可能有所不同（例如，在 Windows 系统中为 `USERNAME`，在 Unix 系统中为 `USER`），它们的语义也可能不同，比如大小写敏感性（Windows 是不区分大小写的，而 Unix 则是区分大小写的）。此外，`java.lang.System.getenv()` 返回的环境变量 Map 及其集合视图可能不会遵守 `Object.equals(java.lang.Object)` 和 `Object.hashCode()` 方法的一般合同。因此，在使用环境变量时可能会产生意外的效果。另外，与 Java 属性相比，环境变量的可见性限制较少：它们不仅对定义该过程的所有子进程可见，而且对其直接的 Java 子进程也是如此。基于这些原因，即使在 `java.lang.System` API 中也建议在可能的情况下使用 Java 属性（`java.lang.System.getProperty(java.lang.String)`）而不是环境变量（`java.lang.System.getenv(java.lang.String)`）。 </p>
<p>如果一个值可以通过 `System.getProperty()` 和 `System.getenv()` 两者访问，那么应优先使用前者。 </p>
<p>对应的 Java 系统属性映射如下：   <table>     <tr>  <th>环境变量</th> <th>属性</th>     </tr>     <tr><td>JAVA_HOME</td> <td>java.home</td></tr>     <tr><td>JAVA_VERSION</td> <td>java.version</td></tr>     <tr><td>TEMP</td> <td>java.io.tmpdir</td></tr>     <tr><td>TMP</td> <td>java.io.tmpdir</td></tr>     <tr><td>PROCESSOR_ARCHITECTURE</td> <td>os.arch</td></tr>     <tr><td>OS</td> <td>os.name</td></tr>     <tr><td>USER</td> <td>user.name</td></tr>     <tr><td>USERNAME</td> <td>user.name</td></tr>     <tr><td>HOME</td> <td>user.home</td></tr>     <tr><td>HOMEPATH</td> <td>user.home</td></tr>     <tr><td>CD</td> <td>user.dir</td></tr>     <tr><td>PWD</td> <td>user.dir</td></tr>   </table> </p>
<p>详见 SEI CERT 规则 <a href="https://wiki.sei.cmu.edu/confluence/display/java/ENV02-J.+Do+not+trust+the+values+of+environment+variables">ENV02-J. 不要信任环境变量的值</a>。 </p>]]>
    </Details>
  </BugPattern>
  <!--
  **********************************************************************
   BugCodes
  **********************************************************************
   -->
  <BugCode abbrev="FS">格式字符串问题  Format string problem</BugCode>
  <BugCode abbrev="SKIPPED">分析跳过  Analysis skipped</BugCode>
  <BugCode abbrev="IL">无限循环  Infinite Loop</BugCode>
  <BugCode abbrev="VO">volatile 的使用  Use of volatile</BugCode>
  <BugCode abbrev="UI">不安全的继承  Unsafe inheritance</BugCode>
  <BugCode abbrev="FL">浮点精度的使用  Use of floating point precision</BugCode>
  <BugCode abbrev="TEST">测试原型和未完成的错误模式  Testing prototype and incomplete bug pattern</BugCode>
  <BugCode abbrev="IMSE">可疑的 `IllegalMonitorStateException` 捕获  Dubious catching of IllegalMonitorStateException</BugCode>
  <BugCode abbrev="CN">克隆模式的不良实现  Bad implementation of cloneable idiom</BugCode>
  <BugCode abbrev="CAA">协变数组赋值  Covariant array assignment</BugCode>
  <BugCode abbrev="AT">可能的原子性违规  Possible atomicity violation</BugCode>
  <BugCode abbrev="FI">不正确的使用finalize方法  Incorrect use of finalizers</BugCode>
  <BugCode abbrev="ES">使用 == 或 != 检查 String 的相等性  Checking String equality using == or !=</BugCode>
  <BugCode abbrev="ML">更新字段上的同步（可变锁）  Synchronization on updated field (Mutable Lock)</BugCode>
  <BugCode abbrev="UG">未同步的get方法，同步的set方法  Unsynchronized get method, synchronized set method</BugCode>
  <BugCode abbrev="IO">输入/输出问题  Input/Output problem</BugCode>
  <BugCode abbrev="IC">初始化循环依赖  Initialization circularity</BugCode>
  <BugCode abbrev="SI">可疑的静态初始化器  Suspicious static initializer</BugCode>
  <BugCode abbrev="MSF">可变的servlet字段  Mutable servlet field</BugCode>
  <BugCode abbrev="IS">不一致的同步  Inconsistent synchronization</BugCode>
  <BugCode abbrev="Eq">equals() 方法的实现问题  Problems with implementation of equals()</BugCode>
  <BugCode abbrev="Co">compareTo()方法的实现问题  Problems with implementation of compareTo()</BugCode>
  <BugCode abbrev="HE">相等的对象必须具有相同的哈希码  Equal objects must have equal hashcodes</BugCode>
  <BugCode abbrev="AM">API误用  API misuse</BugCode>
  <BugCode abbrev="Dm">可疑的方法使用  Dubious method used</BugCode>
  <BugCode abbrev="Bx">原始值的可疑装箱  Questionable Boxing of primitive value</BugCode>
  <BugCode abbrev="UR">在构造函数中对未初始化的字段进行读取  Uninitialized read of field in constructor</BugCode>
  <BugCode abbrev="RR">方法忽略了InputStream.read()的方法结果。  Method ignores results of InputStream.read()</BugCode>
  <BugCode abbrev="NN">裸露的通知  Naked notify</BugCode>
  <BugCode abbrev="UW">无条件等待  Unconditional wait</BugCode>
  <BugCode abbrev="SP">方法在字段上旋转  Method spins on field</BugCode>
  <BugCode abbrev="DC">双重检查模式  Double-check pattern</BugCode>
  <BugCode abbrev="Wa">不在循环中等待  Wait not in loop</BugCode>
  <BugCode abbrev="No">使用notify()而非notifyAll()  Using notify() rather than notifyAll()</BugCode>
  <BugCode abbrev="DE">抛出或忽略的异常  Dropped or ignored exception</BugCode>
  <BugCode abbrev="Ru">方法调用run()  Method invokes run()</BugCode>
  <BugCode abbrev="It">迭代器的定义不正确  Incorrect definition of Iterator</BugCode>
  <BugCode abbrev="SnVI">序列化类没有版本ID  Serializable class with no Version ID</BugCode>
  <BugCode abbrev="Se">序列化类的定义不正确  Incorrect definition of Serializable class</BugCode>
  <BugCode abbrev="WS">类的 `writeObject()` 方法是同步的，但其他部分都不是。  Class's writeObject() method is synchronized but nothing else is</BugCode>
  <BugCode abbrev="RS">类的readObject()方法是同步的  Class's readObject() method is synchronized</BugCode>
  <BugCode abbrev="SC">构造函数调用了Thread.start()方法  Constructor invokes Thread.start()</BugCode>
  <BugCode abbrev="MS">可变的静态字段  Mutable static field</BugCode>
  <BugCode abbrev="ME">可变枚举字段  Mutable enum field</BugCode>
  <BugCode abbrev="EI">返回数组的方法可能会暴露内部表示。  Method returning array may expose internal representation</BugCode>
  <BugCode abbrev="Nm">迷惑性的方法名  Confusing method name</BugCode>
  <BugCode abbrev="SS">未读取的字段应为静态的  Unread field should be static</BugCode>
  <BugCode abbrev="UuF">未使用的字段  Unused field</BugCode>
  <BugCode abbrev="UrF">未读字段  Unread field</BugCode>
  <BugCode abbrev="UwF">未定义的字段  Unwritten field</BugCode>
  <BugCode abbrev="SIC">内部类可以声明为静态类  Inner class could be made static</BugCode>
  <BugCode abbrev="TLW">持有两个锁时进行等待  Wait with two locks held</BugCode>
  <BugCode abbrev="RANGE">范围检查  Range checks</BugCode>
  <BugCode abbrev="RV">方法返回值的不良使用  Bad use of return value from method</BugCode>
  <BugCode abbrev="LG">日志问题  Logger problem</BugCode>
  <BugCode abbrev="IA">模棱两可的调用  Ambiguous invocation</BugCode>
  <BugCode abbrev="HSC">巨大的字符串常量  Huge String constants</BugCode>
  <BugCode abbrev="HRS">HTTP 响应拆分漏洞  HTTP Response splitting vulnerability</BugCode>
  <BugCode abbrev="PT">路径遍历  Path traversal</BugCode>
  <BugCode abbrev="XSS">跨站脚本漏洞  Cross site scripting vulnerability</BugCode>
  <BugCode abbrev="NP">空指针脱引咎  Null pointer dereference</BugCode>
  <BugCode abbrev="NOISE">无效的随机警告  Bogus random warning</BugCode>
  <BugCode abbrev="RpC">重复的条件判断  Repeated conditional test</BugCode>
  <BugCode abbrev="OS">在所有路径上未关闭流  Stream not closed on all paths</BugCode>
  <BugCode abbrev="PZLA">prefer 零长度数组而不是 null 来表示没有结果  Prefer zero length arrays to null to indicate no results</BugCode>
  <BugCode abbrev="UCF">无用的控制流  Useless control flow</BugCode>
  <BugCode abbrev="RCN">对空值的冗余比较  Redundant comparison to null</BugCode>
  <BugCode abbrev="UL">锁在所有路径上未释放  Lock not released on all paths</BugCode>
  <BugCode abbrev="RC">质疑使用引用等价性而非调用equals方法  Questionable use of reference equality rather than calling equals</BugCode>
  <BugCode abbrev="EC">比较不兼容的类型是否相等  Comparing incompatible types for equality</BugCode>
  <BugCode abbrev="MWN">匹配错误的wait()或notify()  Mismatched wait() or notify()</BugCode>
  <BugCode abbrev="SA">无用的自操作  Useless self-operation</BugCode>
  <BugCode abbrev="INT">可疑的整数表达式  Suspicious integer expression</BugCode>
  <BugCode abbrev="BIT">可疑的位运算逻辑表达式  Suspicious bitwise logical expression</BugCode>
  <BugCode abbrev="LI">未同步的懒初始化  Unsynchronized Lazy Initialization</BugCode>
  <BugCode abbrev="JLM">同步对 java.util.concurrent 包中的对象  Synchronization on java.util.concurrent objects</BugCode>
  <BugCode abbrev="UPM">私有方法从未被调用  Private method is never called</BugCode>
  <BugCode abbrev="UMAC">匿名类中的不可调用方法  Uncallable method of anonymous class</BugCode>
  <BugCode abbrev="EI2">存储对可变对象的引用  Storing reference to mutable object</BugCode>
  <BugCode abbrev="NS">非短路布尔运算符的可疑使用  Suspicious use of non-short-circuit boolean operator</BugCode>
  <BugCode abbrev="ODR">在所有路径中未关闭数据库资源  Database resource not closed on all paths</BugCode>
  <BugCode abbrev="SBSC">在循环中使用 + 运算符进行字符串连接  String concatenation in loop using + operator</BugCode>
  <BugCode abbrev="IIL">可以在循环外部移动的低效代码  Inefficient code which can be moved outside of the loop</BugCode>
  <BugCode abbrev="IIO">对字符串使用 `String.indexOf(String)` 或 `String.lastIndexOf(String)` 的效率低下  Inefficient use of String.indexOf(String) or String.lastIndexOf(String)</BugCode>
  <BugCode abbrev="ITA">不高效地使用 `collection.toArray(new Foo[0])`  Inefficient use of collection.toArray(new Foo[0])</BugCode>
  <BugCode abbrev="SW">Swing编码规范  Swing coding rules</BugCode>
  <BugCode abbrev="IJU">未正确实现的JUnit测试用例  Improperly implemented JUnit TestCase</BugCode>
  <BugCode abbrev="BOA">恶意重写适配器  Badly Overridden Adapter</BugCode>
  <BugCode abbrev="SF">switch-case 会意外地延续到下一个案例  Switch case falls through</BugCode>
  <BugCode abbrev="SIO">多余的 instanceof 测试  Superfluous instanceof</BugCode>
  <BugCode abbrev="BAC">不良的Applet构造函数  Bad Applet Constructor</BugCode>
  <BugCode abbrev="UOE">使用 Object.equals() 方法  Use Object Equals</BugCode>
  <BugCode abbrev="STI">可疑的线程中断  Suspicious Thread Interrupted</BugCode>
  <BugCode abbrev="DLS">死掉的局部变量存储  Dead local store</BugCode>
  <BugCode abbrev="IP">被忽略的参数  Ignored parameter</BugCode>
  <BugCode abbrev="MF">遮罩字段  Masked Field</BugCode>
  <BugCode abbrev="WMI">不高效的Map迭代器使用  Inefficient Map Iterator</BugCode>
  <BugCode abbrev="ISC">静态类实例化  Instantiated Static Class</BugCode>
  <BugCode abbrev="DCN">不要捕获空指针异常  Don't Catch NullPointer Exception</BugCode>
  <BugCode abbrev="REC">异常运行时捕获  RuntimeException capture</BugCode>
  <BugCode abbrev="FE">测试浮点数相等性  Test for floating point equality</BugCode>
  <BugCode abbrev="UM">不必要的数学运算常量上  Unnecessary Math on constants</BugCode>
  <BugCode abbrev="UC">无用代码  Useless code</BugCode>
  <BugCode abbrev="CNT">已知常量的粗略值  Rough value of known constant</BugCode>
  <BugCode abbrev="CD">循环依赖  Circular Dependencies</BugCode>
  <BugCode abbrev="RI">多余的接口  Redundant Interfaces</BugCode>
  <BugCode abbrev="MTIA">多线程实例访问  Multithreaded Instance Access</BugCode>
  <BugCode abbrev="PS">公共信号量  Public Semaphores</BugCode>
  <BugCode abbrev="BSHIFT">不良的位移  Bad shift</BugCode>
  <BugCode abbrev="ICAST">整数值的类型转换  Casting from integer values</BugCode>
  <BugCode abbrev="RE">正则表达式  Regular expressions</BugCode>
  <BugCode abbrev="SQL">潜在的SQL问题  Potential SQL Problem</BugCode>
  <BugCode abbrev="WL">可能在错误的对象上进行加锁  Possible locking on wrong object</BugCode>
  <BugCode abbrev="ESync">空的同步块  Empty Synchronized blocks</BugCode>
  <BugCode abbrev="QF">可疑的for循环  Questionable for loops</BugCode>
  <BugCode abbrev="VA">变长参数问题  Vararg problems</BugCode>
  <BugCode abbrev="BC">对象引用的不良转换  Bad casts of object references</BugCode>
  <BugCode abbrev="IM">可疑的整数运算  Questionable integer math</BugCode>
  <BugCode abbrev="ST">静态字段的误用  Misuse of static fields</BugCode>
  <BugCode abbrev="JCIP">违反net.jcip注解规范  Violation of net.jcip annotations</BugCode>
  <BugCode abbrev="USELESS_STRING">生成了无用/非信息性的字符串  Useless/non-informative string generated</BugCode>
  <BugCode abbrev="DMI">可疑的方法调用  Dubious method invocation</BugCode>
  <BugCode abbrev="PZ">警告灵感来源于Joshua Bloch和Neal Gafter的Programming Puzzlers  Warning inspired by Joshua Bloch's and Neal Gafter's Programming Puzzlers</BugCode>
  <BugCode abbrev="SWL">带锁睡眠  Sleep with lock held</BugCode>
  <BugCode abbrev="J2EE">Java 2 Enterprise Edition 错误  J2EE error</BugCode>
  <BugCode abbrev="DB">重复分支  Duplicate Branches</BugCode>
  <BugCode abbrev="IMA">无效的成员访问  Inefficient Member Access</BugCode>
  <BugCode abbrev="XFB">XML工厂绕过  XML Factory Bypass</BugCode>
  <BugCode abbrev="USM">无用的子类方法  Useless Subclass Method</BugCode>
  <BugCode abbrev="CI">混淆的继承  Confused Inheritance</BugCode>
  <BugCode abbrev="QBA">可疑的布尔值赋值  Questionable Boolean Assignment</BugCode>
  <BugCode abbrev="VR">版本兼容性问题  Version compatibility issue</BugCode>
  <BugCode abbrev="DP">使用doPrivileged方法  Use doPrivileged</BugCode>
  <BugCode abbrev="GC">泛型集合方法的可疑调用  Suspicious calls to generic collection methods</BugCode>
  <BugCode abbrev="STCAL">静态使用类型Calendar或DateFormat  Static use of type Calendar or DateFormat</BugCode>
  <BugCode abbrev="TQ">类型限定注解的一致性使用不当  Inconsistent use of type qualifier annotations</BugCode>
  <BugCode abbrev="OBL">未满足清理流或资源的义务  Unsatisfied obligation to clean up stream or resource</BugCode>
  <BugCode abbrev="FB">SpotBugs 在对某个方法进行检查时未产生预期的警告信息  SpotBugs did not produce the expected warnings on a method</BugCode>
  <BugCode abbrev="DL">由于在共享对象上锁定而导致的意外竞争或可能的死锁  Unintended contention or possible deadlock due to locking on shared objects</BugCode>
  <BugCode abbrev="JUA">JUnit断言中的问题  Problems in JUnit Assertions</BugCode>
  <BugCode abbrev="EOS">非法的流结束检查  Bad End of Stream check</BugCode>
  <BugCode abbrev="REFLC">反射增强了类的可访问性  Reflection increasing accessibility of classes</BugCode>
  <BugCode abbrev="REFLF">反射增加字段的可访问性  Reflection increasing accessibility of fields</BugCode>
  <BugCode abbrev="MC">可覆盖方法的调用存在风险  Dangerous call to overridable method</BugCode>
  <BugCode abbrev="CT">构造函数抛出异常  Constructor throws</BugCode>
  <BugCode abbrev="SSD">不要使用实例锁来保护共享静态数据  Do not use an instance lock to protect shared static data</BugCode>
  <BugCode abbrev="SING">单例问题  Singleton problems</BugCode>
  <BugCode abbrev="THROWS">与异常抛出相关的问题  Exception throwing related problems</BugCode>
  <BugCode abbrev="PERM">自定义类加载器未调用其超类的getPermissions()方法  Custom class loader does not call its superclass's getPermissions()</BugCode>
  <BugCode abbrev="USC">基于未信任源的潜在安全检查  Potential security check based on untrusted source</BugCode>
  <BugCode abbrev="ASE">带有副作用的断言  Assertion with side effect</BugCode>
  <BugCode abbrev="PA">公共属性  Public Attribute</BugCode>
  <BugCode abbrev="VSC">易受攻击的安全检查执行方法  Vulnerable security check performing methods</BugCode>
  <BugCode abbrev="AA">公有方法参数检查中不当使用断言  Misuse of assertions for checking arguments of public methods</BugCode>
  <BugCode abbrev="PI">不要从Java标准库中重复使用公共标识符  Do not reuse public identifiers from Java Standard Library</BugCode>
  <BugCode abbrev="ENV">环境变量被用于替代对应的Java属性  Environment variable is used instead of the corresponding Java property</BugCode>
</MessageCollection>
