<?xml version="1.0" encoding="UTF-8"?>
<MessageCollection xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="messagecollection.xsd">
  <!--
  **********************************************************************
  Plugin information
  **********************************************************************
  -->
  <Plugin>
    <ShortDescription>Core SpotBugs plugin</ShortDescription>
    <Details>
<![CDATA[
<p>
This plugin contains all of the standard SpotBugs detectors.
</p>
]]>
    </Details>
    <BugsUrl>https://spotbugs.readthedocs.io/en/latest/bugDescriptions.html</BugsUrl>
    <AllBugsUrl>https://spotbugs.readthedocs.io/en/latest/bugDescriptions.html</AllBugsUrl>
  </Plugin>
  <FindBugsMain cmd="addMessages" class="edu.umd.cs.findbugs.AddMessages">
    <Description>将错误的文字描述（例如：代码bug的文本说明）添加到分析结果中  Add msgs (e.g., textual descriptions of bugs) to analysis results</Description>
  </FindBugsMain>
  <FindBugsMain cmd="analyze" class="edu.umd.cs.findbugs.FindBugs2">
    <Description>执行SpotBugs分析  Perform SpotBugs Analysis</Description>
  </FindBugsMain>
  <FindBugsMain cmd="gui" class="edu.umd.cs.findbugs.gui2.Driver">
    <Description>启动SpotBugs图形界面  Launch SpotBugs GUI</Description>
  </FindBugsMain>
  <FindBugsMain cmd="list" class="edu.umd.cs.findbugs.PrintingBugReporter">
    <Description>将分析结果转换为文本形式  Convert analysis results to textual form</Description>
  </FindBugsMain>
  <FindBugsMain cmd="help" class="edu.umd.cs.findbugs.ShowHelp">
    <Description>提供命令帮助  Provide help for commands</Description>
  </FindBugsMain>
  <FindBugsMain cmd="version" class="edu.umd.cs.findbugs.Version">
    <Description>列出SpotBugs版本信息  List SpotBugs version</Description>
  </FindBugsMain>
  <FindBugsMain cmd="filter" class="edu.umd.cs.findbugs.workflow.Filter">
    <Description>过滤分析结果  Filter analysis results</Description>
  </FindBugsMain>
  <FindBugsMain cmd="set" class="edu.umd.cs.findbugs.workflow.SetBugDatabaseInfo">
    <Description>设置项目配置/选项  Set project configuration/options</Description>
  </FindBugsMain>
  <FindBugsMain cmd="history" class="edu.umd.cs.findbugs.workflow.MineBugHistory">
    <Description>列出多版本分析结果的详细信息  List details from multi-version analysis results</Description>
  </FindBugsMain>
  <FindBugsMain cmd="union" class="edu.umd.cs.findbugs.workflow.UnionResults">
    <Description>合并来自不相交组件的分析结果  Merge analysis results from disjoint components</Description>
  </FindBugsMain>
  <FindBugsMain cmd="merge" class="edu.umd.cs.findbugs.workflow.Update">
    <Description>将不同版本软件的分析结果结合以产生多版本分析结果  Combine analysis results from different versions of software to produce multi-version analysis results</Description>
  </FindBugsMain>

  <FindBugsMain cmd="dis" class="edu.umd.cs.findbugs.workflow.PrintClass">
    <Description>反汇编类文件  Disassemble a class file</Description>
  </FindBugsMain>
  <FindBugsMain cmd="errors" class="edu.umd.cs.findbugs.workflowListErrors">
    <Description>将结果文件中的列表分析错误存储起来  List analysis errors stored in results file</Description>
  </FindBugsMain>

  <!-- On changing this, please also update default cloud id in FindbugsPlugin -->
  <Cloud id="edu.umd.cs.findbugs.cloud.doNothingCloud">
    <Description>(cloud disabled)</Description>
    <Details>Bug reviews are disabled when using this plugin.</Details>
  </Cloud>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.SuppressMultithreaded">
    <Description>抑制多线程正确性问题  Suppress multithreaded correctness issues</Description>
    <Details>抑制所有多线程正确性问题  Suppress all multithreaded correctness issues</Details>
  </PluginComponent>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.SuppressI18N">
    <Description>抑制国际化问题  Suppress internationalization issues</Description>
    <Details>抑制所有国际化问题  Suppress all internationalization issues</Details>
  </PluginComponent>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.SelectivelySuppressI18N">
    <Description>在所有但选定的包中抑制国际化问题  Suppress internationalization issues in all but selected packages</Description>
    <Details>除了i18n.properties资源中指定的以外，抑制所有国际化问题。  Suppress all internationalization issues except those specified in the i18n.properties resource</Details>
  </PluginComponent>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.MaxRank14">
    <Description>抑制优先级高于14的所有问题  Suppress all issues with rank higher than 14</Description>
    <Details>禁止所有优先级高于14的问题  Suppress all issues with rank higher than 14</Details>
  </PluginComponent>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.SuppressMalicious">
    <Description>抑制关于恶意代码漏洞的警告  Suppress warnings about vulnerabilities to malicious code</Description>
    <Details>抑制关于恶意代码漏洞的警告  Suppress warnings about vulnerabilities to malicious code</Details>
  </PluginComponent>
  <!--
  **********************************************************************
  Categories (replacing the BugCategoryDescriptions.properties file)
  **********************************************************************
   -->
  <BugCategory category="CORRECTNESS">
    <Description>正确性  Correctness</Description>
    <Abbreviation>C</Abbreviation>
    <Details>可能存在的bug - 似乎是代码错误，导致编写的代码很可能不是开发人员原本的意图。我们力争保持较低的误报率。  Probable bug - an apparent coding mistake resulting in code that was probably not what the developer intended. We strive for a low false positive rate.</Details>
  </BugCategory>
  <BugCategory category="NOISE">
    <Description>无效的随机噪声  Bogus random noise</Description>
    <Abbreviation>N</Abbreviation>
    <Details>虚假的随机噪声：旨在在数据挖掘实验中作为控制变量使用，而不是用于查找软件中的实际 bug。  Bogus random noise: intended to be useful     as a control in data mining experiments, not in finding actual bugs in software</Details>
  </BugCategory>
  <BugCategory category="SECURITY">
    <Description>安全性  Security</Description>
    <Abbreviation>S</Abbreviation>
    <Details>在使用未信任输入的方式，可能会创建一个可远程利用的安全漏洞。  A use of untrusted input in a way that could create a remotely exploitable security vulnerability.</Details>
  </BugCategory>
  <BugCategory category="BAD_PRACTICE">
    <Description>不良做法  Bad practice</Description>
    <Abbreviation>B</Abbreviation>
    <Details>违反了推荐和必要的编码实践。例如，哈希码和equals问题、可克隆模式问题、遗漏的异常、Serializable问题以及错误使用finalize。我们力求使这种分析准确，但某些团队可能不关心其中的一些不良习惯。  Violations of recommended and essential coding practice. Examples include hash code and equals problems, cloneable idiom, dropped exceptions, Serializable problems, and misuse of finalize. We strive to make this analysis accurate, although some groups may not care about some of the bad practices.</Details>
  </BugCategory>
  <BugCategory category="STYLE">
    <Description>棘手的代码  Dodgy code</Description>
    <Abbreviation>D</Abbreviation>
    <Details>代码混乱、异常或容易导致错误的编写方式。示例包括死掉的局部变量存储、switch语句未显式break导致的延续、未经确认的类型转换以及对已知为null的值进行冗余的非空检查。接受更多的误报。在之前的SpotBugs版本中，这一类别被称为Style。  code that is confusing, anomalous, or written in a way that leads itself to errors. Examples include dead local stores, switch fall through, unconfirmed casts, and redundant null check of value known to be null. More false positives accepted. In previous versions of SpotBugs, this category was known as Style.</Details>
  </BugCategory>
  <BugCategory category="PERFORMANCE">
    <Description>性能  Performance</Description>
    <Abbreviation>P</Abbreviation>
    <Details>代码未必错误但可能不够高效  code that is not necessarily incorrect but may be inefficient</Details>
  </BugCategory>
  <BugCategory category="MALICIOUS_CODE">
    <Description>恶意代码漏洞检查工具  Malicious code vulnerability</Description>
    <Abbreviation>V</Abbreviation>
    <Details>来自不受信任代码的攻击易受攻击的代码  code that is vulnerable to attacks from untrusted code</Details>
  </BugCategory>
  <BugCategory category="MT_CORRECTNESS">
    <Description>多线程正确性检查  Multithreaded correctness</Description>
    <Abbreviation>M</Abbreviation>
    <Details>与线程、锁和volatile相关的代码缺陷  code flaws having to do with threads, locks, and volatiles</Details>
  </BugCategory>
  <BugCategory category="I18N">
    <Description>国际化  Internationalization</Description>
    <Abbreviation>I</Abbreviation>
    <Details>与国际化和区域设置相关的代码缺陷  code flaws having to do with internationalization and locale</Details>
    <!-- DM_CONVERT_CASE is the only core bug pattern in this category -->
  </BugCategory>
  <BugCategory category="EXPERIMENTAL">
    <Description>实验性  Experimental</Description>
    <Abbreviation>X</Abbreviation>
    <Details>实验性质且尚未完全验证的错误模式  Experimental and not fully vetted bug patterns</Details>
    <!-- DM_CONVERT_CASE is the only core bug pattern in this category -->
  </BugCategory>

  <!--
  **********************************************************************
  Detectors
  **********************************************************************
   -->
  <Detector class="edu.umd.cs.findbugs.detect.OverridingMethodsMustInvokeSuperDetector">
    <Details>
<![CDATA[<p>查找必须调用 super 的覆写方法。 </p>  <p> Finds overriding methods that must call super. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindRoughConstants">
    <Details>
<![CDATA[<p>查找大致等于已知值（但不精确等于，例如Math.PI）的常量。 </p>  <p> Finds constants which roughly (but not precisely) equal to known values like Math.PI. </p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InitializeNonnullFieldsInConstructor">
    <Details>
<![CDATA[<p>查找在构造函数中未被写入的非空字段。 </p>  <p> Finds non-null fields that are not written to in constructors. </p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.IntCast2LongAsInstant">
    <Details>
<![CDATA[<p>查找使用32位值表示自纪元以来的毫秒数。 </p>  <p> Finds uses of 32-bit values to describe milliseconds since the epoch. </p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainLongInstantfParams">
    <Details>
<![CDATA[<p>构建一个参数数据库，这些参数表示自纪元以来的毫秒值（64位）。</p>  <p> Builds database of parameters that take a 64 bit value describing milliseconds since the epoch.</p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InconsistentAnnotations">
    <Details>
<![CDATA[<p>该检测器发现直接应用于方法参数的类型限定符与这些方法参数的使用之间的不一致性。 </p>  <p> This detector finds inconsistencies between type qualifiers directly applied to method parameters and uses of those method parameters. </p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.AtomicityProblem">
    <Details>
<![CDATA[<p>查找会对并发抽象进行非原子执行的操作序列（例如，get/put等）。     </p>  <p> Finds sequences of operations (e.g., get/put) on a concurrent abstraction     that will not be executed atomically.     </p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SynchronizationOnSharedBuiltinConstant">
    <Details>
<![CDATA[<p>该检测器查找对共享内置常量（如字符串）的同步操作。</p>  <p> This detector looks for synchronization on a shared built-in constant (such as a String).</p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SynchronizeAndNullCheckField">
    <Details>
<![CDATA[<p>这个检测器查找一个既进行了同步操作又进行了空检查的字段。</p>  <p> This detector looks for a field that is synchronized on and then null checked.</p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckImmutableAnnotation">
    <Details>
<![CDATA[<p>查找被标注为net.jcip.annotationsImmutable或javax.annotation.concurrent.Immutable的类违反规则的情况。</p>  <p> Looks for violations of the rules for classes annotated as net.jcip.annotations.Immutable or javax.annotation.concurrent.Immutable.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.VarArgsProblems">
    <Details>
<![CDATA[<p>查找来自 Java 1.5 可变参数的方法引起的问题。</p>  <p> Looks for problems with arising from Java 1.5 varargs.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteJCIPAnnotation">
    <Details>
<![CDATA[<p>记录来自net.jcip.annotations包的注解。</p>  <p> Record annotations from the net.jcip.annotations package.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteDirectlyRelevantTypeQualifiers">
    <Details>
<![CDATA[<p>注意与分析方法相关的类型限定符。</p>  <p> Note the type qualifiers relevant to analyzing a method.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BuildInterproceduralCallGraph">
    <Details>
      <![CDATA[<p>构建调用图。</p>  <p>Builds the interprocedural call graph.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BuildObligationPolicyDatabase">
    <Details>
          <![CDATA[构建FindUnsatisfiedObligation检测器所需的责任类型和方法的数据库。  <p>Builds the database of obligation types and methods used by the FindUnsatisfiedObligation detector.]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteSuppressedWarnings">
    <Details>
<![CDATA[<p>基于使用edu.umd.cs.findbugs.annotations.NoteSuppressWarnings注解来抑制警告。</p>  <p> Suppresses warnings based on use of the edu.umd.cs.findbugs.annotations.NoteSuppressWarnings annotation.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteAnnotationRetention">
    <Details>
<![CDATA[<p>记录注解保留。</p>  <p> Records annotation retention.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteSyntheticElements">
    <Details>
      <![CDATA[<p>记录合成类、方法、字段等。</p>  <p>Records synthetic classes, methods, fields, etc.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.Methods">
    <Details>
<![CDATA[<p>为其他检测器构建一个包含所有分析类中定义的方法的数据库。</p>  <p> Builds a database of all methods defined in analyzed classes, for use by other detectors.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ReflectiveClasses">
    <Details>
<![CDATA[<p>尝试确定哪些类对其.class对象进行了常量引用。  </p>  <p> Try to determine which classes have constant references to their .class objects.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CalledMethods">
    <Details>
<![CDATA[<p>为其他检测器构建一个包含所有调用的方法的数据库。</p>  <p> Builds a database of all methods invoked in analyzed classes, for use by other detectors.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNoSideEffectMethods">
    <Details>
<![CDATA[<p>查找没有副作用，仅仅返回某些值的方法。</p>  <p> Looks for the methods which have no side effect, just return some value.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BuildStringPassthruGraph">
    <Details>
<![CDATA[<p>构建数据库，记录从一个方法传递到另一个方法且未更改的字符串参数。</p>  <p> Builds the database of string parameters passed from method to method unchanged.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FunctionsThatMightBeMistakenForProcedures">
    <Details>
<![CDATA[<p>查找那些具有返回类新实例的方法的不可变类，人们可能会错误地认为这些方法会修改调用它的实例。 </p>  <p> Looks for immutable classes with methods that return new instances of that class, where people might accidentally think those methods mutate the instance they are invoked on. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ConfusionBetweenInheritedAndOuterMethod">
    <Details>
<![CDATA[<p>查找可能混淆的继承方法和外部方法。</p>  <p> Looks for potential confusion between inherited and outer methods.</p>]]>
    </Details>
  </Detector>
    <Detector class="edu.umd.cs.findbugs.detect.NoteCheckReturnValueAnnotations">
    <Details>
<![CDATA[<p>查找注解以检查方法的返回值。 </p>  <p> Looks for annotations to check return values of a method. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SynchronizeOnClassLiteralNotGetClass">
    <Details>
      <![CDATA[<p>查找使用getClass的结果而不是类字面量进行同步的代码。</p>  <p> Looks for code that synchronizes on the results of getClass rather than on class literals. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FieldItemSummary">
    <Details>
      <![CDATA[<p>     该检测器生成关于存储到字段中的信息的汇总。</p>  <p>     This detector produces summary information for what is stored     into fields. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteNonNullAnnotations">
    <Details>
      <![CDATA[<p>查找方法、字段和参数上的@Nonnull注解。这些注解可以被FindNullDeref检测器使用，生成警告，当可能为null的值在只应使用非null值的上下文中使用时。</p>  <p> Looks for @Nonnull annotations on methods, fields, and parameters. These can be used by the FindNullDeref detector to generate warnings when a possibly-null value is used in a context where only non-null values should be used. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteUnconditionalParamDerefs">
    <Details>
      <![CDATA[<p>分析应用程序中的所有方法，确定哪些方法无条件地解引用参数。这些信息用于后续的分析过程，以找到可能传递空值给这些方法的调用点。</p>
<p>这是一个较慢的检测器。</p>  <p> Analyze all methods in the application to determine which dereference parameters unconditionally.  This information is used in a later analysis pass to find call sites where null values may be passed to those methods. </p> <p> This is a slow detector. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteNonnullReturnValues">
    <Details>
      <![CDATA[<p>分析应用程序中的所有方法以确定哪些方法始终返回非空值。 </p>  <p> Analyze all methods in the application to determine which     methods always return non-null values. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BooleanReturnNull">
    <Details>
<![CDATA[查找返回类型为Boolean的方法，这些方法Explicitly返回null值。  <p> Looks for methods with Boolean return type that return explicit null values.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.OptionalReturnNull">
    <Details>
<![CDATA[<p>查找返回类型为 Optional 但显式返回 null 值的方法。</p>  <p> Looks for methods with Optional return type that return explicit null values.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUselessObjects">
    <Details>
<![CDATA[<p>查找无用的对象。</p>  <p> Looks for useless objects.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MutableEnum">
    <Details>
          <![CDATA[<p>检查并警告可能存在的可变枚举字段。</p>  <p> Looks and warns about mutable enum fields.</p>]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BadUseOfReturnValue">
    <Details>
<![CDATA[<p>查找函数返回值在检查非空后被丢弃的情况。  </p>  <p> Looks for cases where the return value of a function is discarded after being checked for non-null.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InheritanceUnsafeGetResource">
    <Details>
<![CDATA[<p>查找对 `this.getClass().getResource(...)` 的使用，如果该类被另一个包中的类扩展，则可能会导致意外的结果。 </p>  <p> Looks for uses of this.getClass().getResource(...), which can give unexpected results if the class is extended by a class in another package. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InfiniteRecursiveLoop">
    <Details>
<![CDATA[查找无限递归循环。  <p> Looks for an infinite recursive loop. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InfiniteLoop">
    <Details>
<![CDATA[<p>查找无限循环。</p>  <p> Looks for an infinite loop. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.VolatileUsage">
    <Details>
<![CDATA[<p>查找对volatile字段使用的错误模式。 </p>  <p> Looks for bug patterns in the usage of volatile fields. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.EmptyZipFileEntry">
    <Details>
<![CDATA[<p>此检查寻找创建空zip文件条目的情况。它是一个相对较快的检测器。</p>  <p> This looks for creation of empty zip file entries. It is a moderately fast detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.UncallableMethodOfAnonymousClass">
    <Details>
<![CDATA[<p>该检测器查找定义了可能意图覆盖超类中方法但实际上并未覆盖的方法的匿名内部类。 </p>  <p> This detector looks for anonymous inner classes that define methods that are probably intended to but do not override methods in a superclass. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DontUseEnum">
    <Details>
<![CDATA[<p>检查字段和方法不要使用assert或enum作为名称，因为它们是Java 5中的关键字。</p>  <p>Checks that fields and methods don't use the name assert or enum as they are keywords in Java 5.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.URLProblems">
    <Details>
<![CDATA[<p>在 `java.net.URL` 类上实现的 `equals` 和 `hashCode` 方法会解析域名。因此，这些操作可能会非常耗时，这个检测器会查找这些方法可能被调用的地方。 </p>  <p> The equals and hashCode method on <code>java.net.URL</code> resolve the domain name. As a result, these operations can be very expensive, and this detector looks for places where those methods might be invoked. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FinalizerNullsFields">
    <Details>
<![CDATA[<p>此检测器查找对类的字段进行置空操作的终结器。这种做法对垃圾收集器没有任何帮助，置空字段也不会产生任何效果。</p>  <p> This detector looks for finalizers that null out fields of a class. This does not help the garbage collector in any way, the nulling out of fields has no effect. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CrossSiteScripting">
    <Details>
<![CDATA[<p>此检测器寻找明显的跨站脚本漏洞案例。</p>  <p> This detector looks for obvious/blatant cases of cross site scripting vulnerabilities.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.RepeatedConditionals">
    <Details>
<![CDATA[这个检测器会查找包含重复条件测试的代码，例如 (x == 5 || x == 5)。  <p> This detector looks for code containing repeated conditional tests, such as (x == 5 || x == 5).]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.RedundantConditions">
    <Details>
<![CDATA[这个检测器会查找包含多余条件的代码，比如这个表达式中的第二个条件：(x >= 10 && x >= 5)。  <p> This detector looks for code containing useless conditions like the second condition in this expression: (x >= 10 && x >= 5).]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CallToUnsupportedMethod">
    <Details>
<![CDATA[此检测器会查找对不支持方法的调用。  <p> This detector looks for calls to methods that are unsupported.]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FormatStringChecker">
    <Details>
<![CDATA[<p>检查错误的格式字符串。</p>  <p> Checks for incorrect format strings. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.EqualsOperandShouldHaveClassCompatibleWithThis">
    <Details>
<![CDATA[<p>检查是否对某个操作数进行了其类与定义equals方法的类不兼容的实例检查。 </p>  <p> Checks for equals methods that check for their operand being an instance of a class that is not compatible with the class defining the equals method. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestingGround">
    <Details>
<![CDATA[<p>这个检测器只是一个用于测试新检测器的挂钩。通常，这个检测器什么也不做。</p>  <p> This detector is just a hook for testing new detectors. Normally, this detector does nothing.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestingGround2">
    <Details>
<![CDATA[<p>这个检测器只是一个用于测试新检测器的钩子。通常情况下，这个检测器什么也不做。</p>  <p> This detector is just a hook for testing new detectors. Normally, this detector does nothing.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.LostLoggerDueToWeakReference">
    <Details>
<![CDATA[<p>此检测器查找在使用弱引用持有 Logger 的情况下，代码在 OpenJDK 1.6 中表现不同的情况。</p>  <p> This detector finds code that behaves differently under OpenJDK 1.6, where weak references are used to hold onto Loggers. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestingGround2">
    <Details>
<![CDATA[<p>这个检测器只是一个用于测试新检测器的钩子。通常情况下，这个检测器什么都不会做。</p>  <p> This detector is just a hook for testing new detectors. Normally, this detector does nothing.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.Noise">
    <Details>
<![CDATA[<p>此检测器生成随机信号：这些警告仅基于方法执行的操作的哈希值。这些警告是虚假的随机噪声，旨在作为数据挖掘实验中的控制变量，并不用于查找软件中的实际 bug。此检测器只是一个测试新检测器的钩子，在正常情况下，此检测器不会做任何事情。</p>  <p> This detector generates a random signal: warnings that are just based on hash values of the operations performed by methods. These warnings are bogus random noise, intended to be useful   as a control in data mining experiments, not in finding actual bugs in software.   This detector is just a hook for testing new detectors. Normally, this detector does nothing.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoiseNullDeref">
    <Details>
<![CDATA[<p>用于检测空指针引用的噪音检测器。旨在作为关于警告的有效性或预测能力的实验中的控制变量使用，而不是用于查找代码中的问题。</p>  <p> Noisy detector for null dereferences. Intended to be used as a control in experiments about the validity or predictive ability of warnings, not as a way to find problems in code. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.HugeSharedStringConstants">
    <Details>
<![CDATA[<p>该检测器查找在多个类文件中重复的字符串常量。 </p>  <p> This detector looks for string constants that are duplicated across multiple classfiles. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DoInsideDoPrivileged">
    <Details>
<![CDATA[<p>查找应在doPrivileged块中执行的代码。</p>  <p> Looks for code that should be executed inside doPrivileged blocks.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ResolveAllReferences">
    <Details>
<![CDATA[<p>检查所有引用是否可以解析。 </p>  <p> Checks that all references call be resolved.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SwitchFallthrough">
    <Details>
<![CDATA[<p>该检测器查找包含跳过到下一项语句的switch语句。</p>  <p> This detector looks for switch statements containing fall through. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindFieldSelfAssignment">
    <Details>
<![CDATA[<p>该检测器查找将字段赋值为其自身字段值的地方。  </p>  <p> This detector looks for places where a field is assigned by reading the value of the same field.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSelfComparison">
    <Details>
<![CDATA[<p>这个检测器查找将值与其自身进行比较的地方。</p>  <p> This detector looks for places where a value is compared with itself.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSelfComparison2">
    <Details>
<![CDATA[<p>此检测器查找将值与其自身的比较之处。</p>  <p> This detector looks for places where a value is compared with itself.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNonShortCircuit">
    <Details>
<![CDATA[<p>此检测器寻找可疑的非短路布尔运算符（使用<code>|</code> 和 <code>&amp;</code> 而不是 <code>||</code> 和 <code>&&amp;&amp;</code>）的用法。</p>  <p> This detector looks for suspicious uses of non-short-circuiting boolean operators (<code>|</code> and <code>&amp;</code> instead of <code>||</code> and <code>&amp;&amp;</code>).</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DontCatchIllegalMonitorStateException">
    <Details>
<![CDATA[<p>此检测器寻找捕获IllegalMonitorStateException的try-catch块。</p>  <p> This detector looks for try-catch blocks that catch an IllegalMonitorStateException.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindFloatMath">
    <Details>
<![CDATA[<p>此检测器用于查找浮点数学的使用情况。它是一个中等速度的检测器。</p>  <p> This detector looks for uses of floating point math. It is a moderately fast detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CloneIdiom">
    <Details>
<![CDATA[<p>此检测器用于查找违反可克隆类编写惯用法的违规情况。 </p>  <p> This detector looks for violations of the idioms for writing cloneable classes. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ComparatorIdiom">
    <Details>
<![CDATA[<p>此检测器用于查找违反编写实现 <code>Comparator</code> 接口的类的方法习惯用法的问题。 </p>  <p> This detector looks for violations of the idioms for writing classes that implement <code>Comparator</code>. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DroppedException">
    <Details>
<![CDATA[<p>该检测器查找捕获了异常但未对异常进行处理的代码。  </p>  <p> This detector looks for code where an exception is caught, but nothing is done to handle the exception.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.LoadOfKnownNullValue">
    <Details>
<![CDATA[<p>查找许多已知为null的值。</p>  <p> Looks for loads of values known to be null. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DumbMethodInvocations">
    <Details>
<![CDATA[<p>该检测器查找被传递给方法的不良参数（例如，substring(0)）。 </p>  <p> This detector looks for bad arguments being passed to methods (e.g., substring(0)). </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DumbMethods">
    <Details>
<![CDATA[<p>该检测器查找调用无意义方法的调用，例如无参的String构造函数。 </p>  <p> This detector looks for calls to pointless methods, such as the no-argument String constructor. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CovariantArrayAssignment">
    <Details>
<![CDATA[<p>该检测器查找类似于 `Object[] array = new String[10]` 的协变数组赋值，可能会在运行时导致 `ArrayStoreException`。 </p>  <p> This detector looks for covariant array assignments like Object[] array = new String[10] which may cause ArrayStoreException at runtime. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NumberConstructor">
    <Details>
<![CDATA[<p>查找对使用原始类型作为参数的Number构造函数的调用。 </p>  <p> Looks for calls to Number constructors with primitive arguments. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindDoubleCheck">
    <Details>
<![CDATA[<p>该检测器查找双重锁定实例。</p>  <p> This detector looks for instances of double checked locking. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindFinalizeInvocations">
    <Details>
<![CDATA[<p>该检测器查找对 finalize() 的调用以及其他与最终化相关的问题。 </p>  <p> This detector looks for calls to finalize() and other finalizer-related issues.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindHEmismatch">
    <Details>
<![CDATA[<p>该检测器查找 `hashCode()` 和 `equals()` 方法定义中存在的问题。</p>  <p> This detector looks for problems in the definition of the hashCode() and equals() methods.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.OverridingEqualsNotSymmetrical">
    <Details>
<![CDATA[<p>查找重写自超类的equals方法，其中等价关系可能不是对称的。 </p>  <p> Looks for equals methods that override equals methods in a superclass where the equivalence relationship might not be symmetrical. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNakedNotify">
    <Details>
<![CDATA[<p>此检测器寻找看起来没有修改可变对象状态的对notify()的调用。  </p>  <p> This detector looks for calls to notify() that don't seem to modify mutable object state.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindReturnRef">
    <Details>
<![CDATA[<p>此检测器查找返回可变静态数据的方法。 </p>  <p> This detector looks for methods that return mutable static data. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindRunInvocations">
    <Details>
<![CDATA[<p>此检测器会查找对 Thread.run() 的调用。它是一个快速的检测器。</p>  <p> This detector looks for calls to Thread.run().  It is a fast detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSpinLoop">
    <Details>
<![CDATA[<p>该检测器查找从字段读取的循环。</p>  <p> This detector looks for loops that spin reading from a field. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindTwoLockWait">
    <Details>
<![CDATA[<p>该检测器查找持有两个（或多个）锁的情况下调用wait()的情况。它是一个较慢的检测器。</p>  <p> This detector looks for calls to wait() with two (or more) locks held. It is a slow detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnconditionalWait">
    <Details>
<![CDATA[<p>此检测器查找不在条件语句或循环中的 wait() 调用。 </p>  <p> This detector looks for calls to wait() not in a conditional or loop. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUninitializedGet">
    <Details>
<![CDATA[<p>该检测器查找在构造函数中读取未初始化字段的情况。</p>  <p> This detector looks for reads of uninitialized fields in constructors. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnsyncGet">
    <Details>
<![CDATA[<p>此检测器寻找在获取方法（get）未进行同步处理而设置方法（set）进行了同步处理的情况。 </p>  <p> This detector looks for get and set methods where the get is unsynchronized while the set is synchronized.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InitializationChain">
    <Details>
<![CDATA[<p>该检测器用于查找可能存在循环类初始化依赖关系。  </p>  <p> This detector looks for potentially circular class initialization dependencies.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.IteratorIdioms">
    <Details>
<![CDATA[<p>这个检测器寻找Iterator类定义中存在的问题。 </p>  <p> This detector looks for problems in how Iterator classes are defined. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.LockedFields">
    <Details>
<![CDATA[<p>这个检测器寻找以不一致的方式访问字段的情况，特别是与加锁相关的访问。</p>  <p> This detector looks for fields that are accessed in an inconsistent manner with respect to locking.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.EqStringTest">
    <Details>
<![CDATA[<p>该检测器寻找使用 == 或 != 操作符比较 String 对象的情况。</p>  <p> This detector looks for comparisons of String objects using the == or != operators.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MutableLock">
    <Details>
<![CDATA[<p>此检测器寻找对来自修改字段的对象进行同步的场景。 </p>  <p> This detector looks for synchronization on objects read from modified fields.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SynchronizingOnContentsOfFieldToProtectField">
    <Details>
<![CDATA[<p>这个检测器寻找那些看起来是为了保护对该字段的更新而对字段进行同步的代码。</p>  <p> This detector looks for code that seems to be synchronizing on a field in order to guard updates of that field. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MutableStaticFields">
    <Details>
<![CDATA[<p>该检测器查找可能被恶意代码修改的静态字段。 </p>  <p> This detector looks for static fields that may be modified by malicious code.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.Naming">
    <Details>
<![CDATA[<p>这个检测器寻找命名可疑的方法。 </p>  <p> This detector looks for suspiciously-named methods.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ReadReturnShouldBeChecked">
    <Details>
<![CDATA[<p>这个检测器查找对 InputStream.read() 或 InputStream.skip() 的调用，其中返回值被忽略了。</p>  <p> This detector looks for calls to InputStream.read() or InputStream.skip() where the return value is ignored.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SerializableIdiom">
    <Details>
<![CDATA[<p>该检测器用于查找可序列化类实现中的潜在问题。  </p>  <p> This detector looks for potential problems in the implementation of Serializable classes.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.StartInConstructor">
    <Details>
<![CDATA[<p>该检测器查找启动线程的构造函数。  </p>  <p> This detector looks for constructors that start threads.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindBadForLoop">
    <Details>
<![CDATA[<p>这个检测器寻找不正确的for循环。 </p>  <p> This detector looks for incorrect for loops. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ExplicitSerialization">
    <Details>
<![CDATA[<p>查找显式序列化（通过readObject和writeObject实现）的证据，以确定该类确实是可序列化的。</p>  <p> Looks for explicit serialization via readObject and     writeObject as evidence that this class is, indeed, serialized. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.UnreadFields">
    <Details>
<![CDATA[<p>这个检测器寻找值从未被读取的字段。</p>  <p> This detector looks for fields whose value is never read.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.WaitInLoop">
    <Details>
<![CDATA[<p>该检测器查找不在循环中的 wait() 调用。</p>  <p> This detector looks for calls to wait() that are not in a loop. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BCPMethodReturnCheck">
    <Details>
<![CDATA[<p>此检测器用于查找调用方法但对其返回值可疑地忽略的情况。它是一个较慢的检测器。</p>  <p> This detector looks for calls to methods where the return value is suspiciously ignored.  It is a slow detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindComparatorProblems">
    <Details>
<![CDATA[<p>此检测器用于查找Comparator.compare或Comparable.compareTo实现中的问题。</p>  <p> This detector looks for problems in Comparator.compare or Comparable.compareTo implementation.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNullDeref">
    <Details>
<![CDATA[<p>该检测器查找可能导致空指针异常的地方，还会检查对引用值与null的冗余比较。它是一个运行较慢的检测器。</p>  <p> This detector looks for places where a null pointer exception might occur.  It also looks for redundant comparisons of reference values against null.  It is a slow detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNullDerefsInvolvingNonShortCircuitEvaluation">
    <Details>
<![CDATA[<p>该检测器查找可能出现空指针异常的地方，并且非短路评估的使用使得常规技术失效。</p>  <p> This detector looks for places where a null pointer exception might occur, and the use of non-short-circuit evaluation causes the usual techniques to fail. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindOpenStream">
    <Details>
<![CDATA[<p>该检测器查找不会从方法中逃逸且似乎不在所有方法退出路径上被关闭的IO流对象。这是一个运行较慢的检测器。</p>  <p> This detector looks for IO stream objects which do not escape the method and do not appear to be closed on all paths out of the method. It is a slow detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.PreferZeroLengthArrays">
    <Details>
<![CDATA[<p>该检测器查找返回数组或明确的空引用的方法。在这种情况下，返回零长度数组通常比返回空引用更可取。</p>  <p> This detector looks for methods that return either arrays or an explicit null reference. Returning a zero length array is generally preferred in this context to returning a null reference. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUselessControlFlow">
    <Details>
<![CDATA[<p>该检测器查找没有任何效果的控制流语句。 </p>  <p> This detector looks for control flow statements which have no effect. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnreleasedLock">
    <Details>
<![CDATA[<p>此检测器用于查找在方法中获取但未在所有路径上释放的 JSR-166（`java.util.concurrent`）锁。这是一个相对较快的检测器。请注意，为了使用此检测器，您需要在辅助类路径中包含 `java.util.concurrent` 包（或者正在分析该包本身）。 </p>  <p> This detector looks for JSR-166 (<code>java.util.concurrent</code>) locks which are acquired, but not released on all paths out of the method.&nbsp; It is a moderately fast detector.&nbsp; Note that in order to use this detector, you need to have the <code>java.util.concurrent</code> package in the auxiliary classpath (or be analyzing the package itself).</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindRefComparison">
    <Details>
<![CDATA[<p>这个检测器查找使用 == 或 != 操作符比较两个引用值的地方，而类是那种类型（例如 <code>java.lang.String</code>）的情况下，比较引用值通常是一个错误。这是一个执行较慢的检测器。</p>  <p> This detector looks for places where two reference values are compared with the == or != operator, and the class is of a type (such as <code>java.lang.String</code>) where comparing reference values is generally an error.  It is a slow detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindMismatchedWaitOrNotify">
    <Details>
<![CDATA[<p>此检测器寻找对 wait()、notify() 或 notifyAll() 的调用，但这些调用似乎并未在当前被锁定的对象上进行。这是一个较快的检测器。<b>由于该检测器仍在开发中，并产生了太多误报，因此已禁用此检测器。</b></p>  <p> This detector looks for calls to wait(), notify(), or notifyAll() which do not appear to be made on an object which is currently locked.&nbsp; It is a moderately fast detector.&nbsp; <b>This detector is disabled because it is still under development, and produces too many false positives.</b></p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindEmptySynchronizedBlock">
    <Details>
<![CDATA[<p>此检测器查找空的同步块。</p>  <p> This detector looks for empty synchronized blocks.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindInconsistentSync2">
    <Details>
<![CDATA[<p>此检测器会查找以不一致方式访问的字段，特别是与加锁相关的访问。它是一个较慢的检测器。</p>  <p> This detector looks for fields that are accessed in an inconsistent manner with respect to locking.  It is a slow detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindLocalSelfAssignment2">
    <Details>
<![CDATA[<p>该检测器查找本地变量的自赋值。</p>  <p> This detector looks for self assignments of local variables. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.IncompatMask">
    <Details>
<![CDATA[<p>此检测器寻找可疑的位逻辑表达式。 </p>  <p> This detector looks for suspicious bitwise logical expressions. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.LazyInit">
    <Details>
<![CDATA[<p>该检测器查找非易失性字段的懒初始化情况。它是一个较快的检测器。</p>  <p> This detector looks for lazy field initialization where the field is not volatile.  It is a moderately fast detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindJSR166LockMonitorenter">
    <Details>
<![CDATA[<p>该检测器用于查找对JSR166锁进行的普通同步操作。它是一个中等速度的检测器。</p>  <p> This detector looks for ordinary synchronization performed on JSR166 locks.  It is a moderately fast detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUncalledPrivateMethods">
    <Details>
<![CDATA[<p>这个检测器查找从未被调用的私有方法。 </p>  <p> This detector looks for private methods that are never called. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.StringConcatenation">
    <Details>
<![CDATA[<p>这个检测器查找循环中使用 + 进行字符串连接的情况。</p>  <p> This detector looks for String concatenation in loops using +. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InefficientInitializationInsideLoop">
    <Details>
<![CDATA[<p>此检测器查找在循环中初始化的对象，可以将这些对象移到循环外部以提高性能。</p>  <p> This detector looks for objects initialized within loop which can be moved outside for better performance. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InefficientIndexOf">
    <Details>
<![CDATA[<p>该检测器查找使用 `String.indexOf(String)` 或 `String.lastIndexOf(String)` 并传递长度为1的常量字符串的代码。建议使用更高效的整数实现。这是一个快速检测器。</p>  <p> This detector looks for code that uses String.indexOf(String) or String.lastIndexOf(String), passing a constant string of length 1. It is recommended to use the more efficient integer implementations. A fast detector. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InefficientToArray">
    <Details>
<![CDATA[<p>该检测器查找使用 `toArray()` 方法将集合转换为数组但传递了一个零长度数组原型的情况。</p>  <p> This detector looks for code that converts Collections to arrays using the toArray() method that takes a prototype array, passing an array argument which is zero-length. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InvalidJUnitTest">
    <Details>
<![CDATA[<p>这个检测器用于查找格式错误的JUnit测试。 </p>  <p> This detector looks for JUnit tests that are malformed. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BadlyOverriddenAdapter">
    <Details>
<![CDATA[<p>该检测器查找扩展了Adapter类并用错误的签名重写了Listener方法的代码。</p>  <p> This detector looks for code that extends an Adapter class and overrides a Listener method with the wrong signature. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BadResultSetAccess">
    <Details>
<![CDATA[<p>此检测器查找对结果集的 getXXX 或 setXXX 方法的调用，其中字段索引为 0。由于结果集中的字段从索引 1 开始，这总是错误的。 </p>  <p> This detector looks for calls to getXXX or setXXX methods of a result set where the field index is 0. As ResultSet fields start at index 1, this is always a mistake. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SuperfluousInstanceOf">
    <Details>
<![CDATA[<p>该检测器查找使用instanceof操作符进行的类型检查，其中可以通过静态方式确定。</p>  <p> This detector looks for type checks using the instanceof operator where the determination can be done statically. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BadAppletConstructor">
    <Details>
<![CDATA[<p>该检测器查找调用了依赖于Applet Stub的方法的Applet构造函数。由于此Stub直到初始化init()方法前不久才进行初始化，因此这些方法将在构造函数中失效。</p>  <p> This detector looks for Applet constructors that call methods in the parent Applet that rely on the Applet stub. Since this stub isn't initialized until just before the init() method, these methods will fail in the constructor. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SuspiciousThreadInterrupted">
    <Details>
<![CDATA[<p>该检测器会查找从非静态上下文中对 Thread.interrupted() 的调用。如果它是从 Thread.currentThread().interrupted() 调用的，那么这只是一个无用的操作，可以直接使用 Thread.interrupted()。然而，如果它是在任意线程对象上调用的，则大多数情况下是一个错误，因为 interrupted() 总是针对当前线程被调用。 </p>  <p> This detector looks for calls to Thread.interrupted() from a non-static context. If it is called from Thread.currentThread().interrupted(), then it is just a useless exercise, just use Thread.interrupted(). However if it is called on an arbitrary thread object, it is most probably an error, as interrupted() is always called on the current thread. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSqlInjection">
    <Details>
<![CDATA[<p>该检测器使用数据流分析来查找除常量字符串外，还传入其他参数到SQL语句的execute方法调用。</p>  <p> This detector uses data flow analysis to look for invocations of execute methods on SQL statements in which something other than a constant string is passed as an argument. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindDeadLocalStores">
    <Details>
<![CDATA[<p>该检测器会查找未后续读取的局部变量赋值情况。它是一个较快的检测器。</p>  <p> This detector looks for assignments to local variables that are never subsequently read. It is a moderately fast detector. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindMaskedFields">
    <Details>
<![CDATA[<p>该检测器用于查找被方法内定义的局部字段屏蔽掉的类级字段。 </p>  <p> This detector looks for class level fields that are masked by local fields defined in methods. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.WrongMapIterator">
    <Details>
<![CDATA[<p>该检测器查找使用通过keySet迭代器检索的键来访问Map条目的值的情况。</p>  <p> This detector looks for accessing the value of a Map entry, using a key that was retrieved from a keySet iterator. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InstantiateStaticClass">
    <Details>
<![CDATA[<p>该检测器寻找基于仅定义静态方法的类创建对象的代码。 </p>  <p> This detector looks for code that creates objects based on classes that only define static methods. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.RuntimeExceptionCapture">
    <Details>
<![CDATA[<p>此检测器查找那些捕获Exception异常但块中并未抛出Exception异常的catch子句。 </p>  <p> This detector looks for catch clauses that catch Exception, when no code in the block throws Exception. </p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindFloatEquality">
    <Details>
<![CDATA[<p>查找浮点数相等表达式。快速检测器。</p>  <p> Looks for floating point equality expressions. A fast detector. </p>]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnsatisfiedObligation">
    <Details>
<![CDATA[<p>此检测器会查找在方法的所有路径结束处未清理的I/O流和数据库资源。这是一个运行较慢的检测器。</p>  <p>This detector looks for I/O streams and database resources that are not cleaned up on all paths out of a method.  This is a slow detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.UnnecessaryMath">
    <Details>
<![CDATA[<p>此检测器会查找调用 java.lang.Math 静态方法并传入常量值的情况，其中返回的值是静态已知的常量。直接使用常量通常更快，并且有时更准确。</p>  <p>This detector looks for code that calls java.lang.Math static methods on constant values, where the resultant value is a statically known constant. It is faster, and sometimes more accurate, to use the constant instead.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindCircularDependencies">
    <Details>
<![CDATA[<p>此检测器用于查找类之间的循环依赖关系。</p>  <p>This detector looks for circular dependencies among classes. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.RedundantInterfaces">
    <Details>
<![CDATA[<p>此检测器查找声明实现与超类相同接口的类。如果超类实现了某个接口，那么子类也会自动实现该接口，因此这是冗余的。</p>  <p>This detector looks for classes that declare they implement the same interface as a super class. This is redundant, if a superclass implements an interface, so does the subclass.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MultithreadedInstanceAccess">
    <Details>
<![CDATA[<p>该检测器用于查找实现Struts框架时可能存在的问题。</p>  <p>This detector looks for potential problems in implementing the Struts framework. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.PublicSemaphores">
    <Details>
<![CDATA[<p>此检测器查找公开类，这些类使用了synchronize并调用了wait()、notify()或notifyAll()方法。这将同步实现暴露为类的公共构件。该类的客户端可能使用该类的一个实例作为其自己的同步对象，并导致基实现出现故障。</p>  <p>This detector looks for public classes that synchronize and use wait(), notify() or notifyAll() on <b>this</b>. This exposes a synchronization implementation as a public artifact of the class. Clients of the class may use an instance of the class as its own synchronizing object, and cause havoc to the base implementation. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MethodReturnCheck">
    <Details>
<![CDATA[<p>该检测器查找可能被可疑地忽略返回值的方法调用。</p>  <p> This detector looks for calls to methods where the return value is suspiciously ignored.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.IDivResultCastToDouble">
    <Details>
<![CDATA[<p>此检测器寻找将整数除法的结果强制转换为双精度浮点数的情况。通常，本意应该是将整数运算量强制转换为双精度浮点数后再进行除法运算。</p>  <p> This detector looks for places where the result of integer division is cast to double. Often, what was meant was to cast the integer operands to double and then perform the division. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindBadCast2">
    <Details>
<![CDATA[<p>该检测器通过数据流分析查找对象引用的不良转换。 </p>  <p> This detector looks for bad casts of object references using data flow analysis. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNonSerializableStoreIntoSession">
    <Details>
<![CDATA[<p>此检测器查找将非序列化对象存储到HTTP会话中的情况。 </p>  <p> This detector looks for stores of non Serializable objects into HTTP sessions. </p>]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindUseOfNonSerializableValue">
    <Details>
<![CDATA[<p>该检测器查找在需要实现序列化-context中使用了非序列化对象的情况。</p>  <p> This detector looks for uses of non Serializable objects in contexts that require them to be serializable. </p>]]>
    </Details>
  </Detector>


  <Detector class="edu.umd.cs.findbugs.detect.FindNonSerializableValuePassedToWriteObject">
    <Details>
<![CDATA[<p>此检测器查找传递给ObjectOutput的writeObject方法的非Serializable对象。 </p>  <p> This detector looks for non Serializable objects passed to the writeObject method of an ObjectOutput. </p>]]>
    </Details>
  </Detector>



  <Detector class="edu.umd.cs.findbugs.detect.BadSyntaxForRegularExpression">
    <Details>
<![CDATA[<p>此检测器用于查找无效语法的正则表达式。  </p>  <p> This detector looks for regular expressions that have invalid syntax.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindPuzzlers">
    <Details>
<![CDATA[<p>这个检测器查找由朱斯豪·布洛克和尼尔·加fter在《编程 puzzlers》工作中提到的一些琐碎的小错误。  </p>  <p> This detector looks for miscellaneous small errors mentioned by Joshua Bloch and Neal Gafter in their work on Programming Puzzlers.   </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSleepWithLockHeld">
    <Details>
      <![CDATA[<p>    这个检测器会在持有锁的情况下查找对Thread.sleep()的调用。它是一个较慢的检测器。</p>  <p>    This detector looks for calls to Thread.sleep() made with    a lock held.  It is a slow detector. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DuplicateBranches">
    <Details>
<![CDATA[此检测器查找具有两条分支且代码相同的 if/else 或 switch 语句，从而使测试变得无效。这种情况往往是由复制粘贴两条分支引起的，导致一条分支的逻辑错误。  <p> This detector looks for if/else or switch statements that have the same code for two branches, thus rendering the test useless. This often is caused by copying and pasting the two branches, causing incorrect logic for the one branch.</p><p></p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InefficientMemberAccess">
    <Details>
<![CDATA[<p>此检测器查找在拥有类的私有成员变量上进行写操作的内部类。在这种情况下，需要使用特殊编译器生成的访问者方法来写入该变量。将可见性放宽到保护级别将允许直接写入字段。</p>  <p> This detector looks for internal classes that write to member variables of the owning class, when that member variable is private. In this case, a special compiler generated accessor method needs to be used to write to this variable. Relaxing the visibility to protected will allow the field to be directly written.</p> <p></p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.XMLFactoryBypass">
    <Details>
<![CDATA[<p>此检测器寻找直接分配XML接口实现的实例。这将代码绑定到特定的实现，而不是使用提供的工厂模式来创建这些对象。</p>  <p> This detector looks for direct allocations of implementations of XML interfaces. This ties the code to a specific implementation, rather than using the supplied factory pattern to create these objects.</p> <p></p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.UselessSubclassMethod">
    <Details>
      <![CDATA[<p>该检测器查找子类中实现的由超类定义的方法，这些方法只是将参数原封不动地传递给父类的方法。这些方法可以直接删除。</p>  <p> This detector looks for subclasses that implement methods defined in the super class, that only pass the parameters untouched to the parent class method. These methods can just be removed. </p> <p></p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ConfusedInheritance">
    <Details>
      <![CDATA[<p>该检测器查找声明了受保护成员的最终类。由于此类无法派生，成员使用受保护访问是不正确的。应将访问级别更改为 public 或 private，以正确表示该字段的意图。这可能是由于未完全将此类的所有内容转换为新范式而引起的用法变更所致。</p> <p></p>  <p> This detector looks for final classes that declare protected members. As this class can not be derived from, the use of protected access for members is incorrect. The access should be changed to public or private to represent the correct intention of the field. This was probably caused by a change in use for this class, without completely changing all of the class to the new paradigm. </p> <p></p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.QuestionableBooleanAssignment">
    <Details>
      <![CDATA[<p>此检测器查找将字面量布尔值简单赋值给变量以用于条件表达式的情况。 </p>  <p> This detector looks for simple assignments of literal boolean values to variables in conditional expressions. </p> <p></p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainNullReturnValues">
    <Details>
      <![CDATA[<p>TrainNullReturnValues确定哪些方法可能返回null，并将这些方法保存到一个文件中。生成的文件可以在后续过程中用于提高空指针检测器的精度。由于这只是训练过程，因此不会报告任何警告。</p>
<p>这是一个较慢的检测器。</p>  <p> TrainNullReturnValues determines which methods may return null and saves them to a file.  The resulting file may be used in a subsequent pass to improve the precision of the null-dereference detector. Since this is just a training pass, no warnings are reported. </p> <p> This is a slow detector. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainUnconditionalDerefParams">
    <Details>
      <![CDATA[<p> TrainUnconditionalParamDerefs 确定哪些方法会无条件地反引参参数，并将这些信息保存到一个文件中。生成的文件可以在后续处理中使用，以提高空指针反引参检测器的精度。由于这只是训练过程，不会报告任何警告。</p>
<p> 这是一个较慢的检测器。 </p>  <p> TrainUnconditionalParamDerefs determines which methods may unconditionally dereference parameters and saves them to a file. The resulting file may be used in a subsequent pass to improve the precision of the null-dereference detector. Since this is just a training pass, no warnings are reported. </p> <p> This is a slow detector. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainFieldStoreTypes">
    <Details>
      <![CDATA[<p>TrainFieldStoreTypes分析存储在字段中的类型，并将这些类型存储到数据库中。该数据库可以在后续过程中用于使类型分析更加精确。</p>
<p>这是一个较慢的检测器。</p>  <p> TrainFieldStoreTypes analyzes the types stored into fields and stores them to a database.  The database may be used in a later pass to make type analysis more precise. </p> <p> This is a slow detector. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainNonNullAnnotations">
    <Details>
      <![CDATA[<p>TrainNonNullAnnotations 收集 @Nonnull 和 @PossiblyNull 注解，并将其存储到数据库文件中。这是一个快速检测器。</p>  <p> TrainNonNullAnnotations collects @Nonnull and @PossiblyNull annotations and stores them to database files.  This is a fast detector. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckCalls">
    <Details>
      <![CDATA[<p>这个检测器仅用于调试SpotBugs中的方法调用解析，请勿启用。</p>  <p>This detector is just for debugging method call resolution in SpotBugs. Don't enable it.</p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindBugsSummaryStats">
    <Details>
<![CDATA[<p>这个检测器仅仅收集分析过程的汇总统计信息。 </p>  <p> This detector just collects summary statistics information about the analysis process. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestASM">
    <Details>
    <![CDATA[<p>     这个检测器是一个代码示例，展示了如何使用ASM字节码分析框架编写SpotBugs检测器。     </p>  <p>     This detector is a code example showing how to write a SpotBugs     detector using the ASM bytecode analysis framework.     </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnrelatedTypesInGenericContainer">
    <Details>
    <![CDATA[<p>这个检测器会检查传递给泛型集合方法的参数，这些方法接收一个<code>java.lang.Object</code>。它会查看该参数的类型是否与集合的参数相关。如果参数的类类型与其无关，则该参数永远不会在集合中出现。例如，如果<code>foo</code>是一个<code>List&lt;String&gt;</code>而<code>bar</code>是一个<code>StringBuffer</code>，那么调用<code>foo.contains(bar)</code>将总是返回false。这是一个快速的检测器。</p>  <p> This detector looks at the arguments of calls to generic     collection methods that receive a <code>java.lang.Object</code>     to see if the argument's type is related to the collection's     parameter. Arguments with unrelated class types are never going     to be in the collection. For example, if <code>foo</code> is a     <code>List&lt;String&gt;</code> and <code>bar</code> is a     <code>StringBuffer</code>, the call <code>foo.contains(bar)</code>     will always return false. This is a fast detector.     </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.StaticCalendarDetector">
    <Details>
<![CDATA[<p>此检测器会警告关于类型为 java.util.Calendar 或 java.text.DateFormat（及其子类）的静态字段，因为 Calendar 在多线程环境中是不安全的。 </p>  <p>This detector warns about static fields of type java.util.Calendar or java.text.DateFormat (and subclasses) because  Calendars are inherently unsafe for multithreaded use. </p>]]>
</Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestDataflowAnalysis">
    <Details>
      <![CDATA[这是一款内部检测器，仅用于测试数据流分析。它默认不会启用。  <p>This is an internal detector used only for testing dataflow analyses.     It is not enabled by default.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckTypeQualifiers">
    <Details>
      <![CDATA[<p>检查违反由JSR-305类型质量注解指定的属性。</p>  <p>Check for violations of properties specified by JSR-305   type qualifier annotations.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.AppendingToAnObjectOutputStream">
    <Details>
      <![CDATA[查找向对象输出流追加的尝试。  <p>Looks for an attempt to append to an object output stream.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckExpectedWarnings">
    <Details>
          <![CDATA[<p>检查@ExpectedWarning和@NoWarning注释。此检测器仅用于测试SpotBugs。</p>  <p>Checks @ExpectedWarning and @NoWarning annotations.     This detector is used only for testing SpotBugs.</p>]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DontIgnoreResultOfPutIfAbsent">
    <Details>
          <![CDATA[检查如果使用 `putIfAbsent` 的结果被忽略，第二个参数传递的值不应被重复使用。  <p>Checks that if the result of putIfAbsent is ignored, the value passed as the second argument is not reused. </p>]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ReadOfInstanceFieldInMethodInvokedByConstructorInSuperclass">
    <Details>
          <![CDATA[<p>检查从构造方法调用的 superclass 方法。 </p>  <p>Checks for methods invoked from constructors for superclasses.  </p>]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DefaultEncodingDetector">
    <Details>
<![CDATA[<p>检查对使用用户默认平台编码进行字节到字符串（或字符串到字节）转换的方法调用。这可能会导致应用程序的行为在不同平台上有所不同。</p>  <p> Checks for calls to methods which perform a byte to String (or String to byte) conversion using the user's default  platform encoding. This can cause the application behaviour to vary between platforms.  </p>]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckRelaxingNullnessAnnotation">
    <Details>
      <![CDATA[<p>检查覆盖方法不得放宽 @Nonnull（变为 @CheckForNull）的返回值或 @CheckForNull（变为 @Nonnull）的参数。</p>  <p>Checks that overriding methods do not relax @Nonnull (made @CheckForNull) on return values   or @CheckForNull (made @Nonnull) on parameters.</p>]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DontAssertInstanceofInTests">
    <Details>
      <![CDATA[<p>用于检测JUnit测试中通过assert instanceof操作符检查对象类型的模式。</p>
<p>应当避免这种方式，因为不当类型转换抛出的ClassCastException可能会提供更多关于错误原因的信息，而不是assert instanceof操作符结果所产生的“false is not true”消息。</p>
<p>这是一个快速检测器。</p>  <p>Detector for patterns in JUnit tests where the type of an object    is checked by asserting the instanceof operator.</p> <p>    This should be avoided as the ClassCastException that would result    from an improper cast may provide more information regarding the    cause of the error than a "false is not true" message which would    result from asserting the result of the instanceof operator. </p>    <p>It is a fast detector</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindBadEndOfStreamCheck">
    <Details>
      <![CDATA[<p>检测将 java.io.FileInputStream.read() 或 java.io.FileReader.read() 的返回值在与 -1 比较之前进行转换的模式。</p>
<p>    这两个方法都返回 int 类型。如果将 int 转换为 byte（对于 FileInputStream.read()），那么 -1 和 0xFF 将变得无法区分。如果将其转换为 char（对于 FileReader.read()），-1 将变为 0xFFFF，这在 Java 中等同于 Character.MAX_VALUE，因为字符是无符号的。</p>  <p>Detector for patterns where the return value of java.io.FileInputStream.read() or    java.io.FileReader.read() is converted before checking against -1.</p> <p>    Both methods return an int. If this int is converted to byte (in the case of    FileInputStream.read()) then -1 and the byte 0xFF become indistinguishable.    If it is converted to char (in the case of FileReader.read()) then -1 becomes    0xFFFF which is Character.MAX_VALUE since characters are unsigned in Java. </p>]]>
    </Details>
  </Detector>
  <!--
  **********************************************************************
  BugPatterns
  **********************************************************************
   -->

  <BugPattern type="JUA_DONT_ASSERT_INSTANCEOF_IN_TESTS">
    <ShortDescription>在测试中使用 `instanceof` 检查值是不推荐的。  Asserting value of instanceof in tests is not recommended.</ShortDescription>
    <LongDescription>在{3}处，类型为{0}的断言可能会掩盖掉有关为何会发生类型转换失败的有用信息。</LongDescription>
    <Details>
      <![CDATA[<p>在测试中进行类型断言不是推荐的做法，因为类转换异常信息可能比 instanceof 断言更能说明使用了错误类型的实例的原因。</p>
<p>当调试因不良转换而失败的测试时，观察 ClassCastException 的输出可能会更有用，因为它可以提供实际遇到类型的更多信息。而在转换前进行类型断言则会导致更不informative 的“false is not true”消息。</p>
<p>如果使用 JUnit 和 hamcrest，可以使用 hamcrest 中的 <a href="https://junit.org/junit4/javadoc/latest/index.html?org/hamcrest/core/IsInstanceOf.html"><code>IsInstanceOf</code></a> 类替代。</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="OVERRIDING_METHODS_MUST_INVOKE_SUPER">
    <ShortDescription>使用了@OverridingMethodsMustInvokeSuper注解的方法，但覆盖方法并未调用超类方法。  Super method is annotated with @OverridingMethodsMustInvokeSuper, but the overriding method isn't calling the super method.</ShortDescription>
    <LongDescription>使用了@OverridingMethodsMustInvokeSuper注解的方法，但{1}没有调用父类方法。</LongDescription>
    <Details>
      <![CDATA[<p>@OverridingMethodsMustInvokeSuper 注解了超方法，但覆盖方法并未调用超方法。</p>]]>
    </Details>  </BugPattern>
  <BugPattern type="CNT_ROUGH_CONSTANT_VALUE">
    <ShortDescription>已知常量的粗略值被找到  Rough value of known constant found</ShortDescription>
    <LongDescription>找到的近似值为 {3}：{2}</LongDescription>
    <Details>
      <![CDATA[<p>建议使用预定义的库常量以提高代码清晰度和精度。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SKIPPED_CLASS_TOO_BIG">
    <ShortDescription>分析的类太大了。  Class too big for analysis</ShortDescription>
    <LongDescription>{0} 分析起来太大了。</LongDescription>
    <Details>
      <![CDATA[<p>此类的大小超过了可以有效处理的范围，并且没有进行全面的错误分析。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NOISE_NULL_DEREFERENCE">
    <ShortDescription>关于空指针解引用的虚假警告  Bogus warning about a null pointer dereference</ShortDescription>
    <LongDescription>在{1}中关于空指针解引用的虚假警告</LongDescription>
    <Details>
      <![CDATA[<p>无效警告。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NOISE_METHOD_CALL">
    <ShortDescription>关于方法调用的虚假警告  Bogus warning about a method call</ShortDescription>
    <LongDescription>在{1}中关于方法调用{2}的无效警告</LongDescription>
    <Details>
      <![CDATA[<p>无效警告。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NOISE_FIELD_REFERENCE">
    <ShortDescription>关于字段引用的虚假警告  Bogus warning about a field reference</ShortDescription>
    <LongDescription>关于在{1}中引用{2}的虚假警告</LongDescription>
    <Details>
      <![CDATA[<p>虚假警告。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NOISE_OPERATION">
    <ShortDescription>关于操作的虚假警告  Bogus warning about an operation</ShortDescription>
    <LongDescription>关于操作 {1} 的虚假警告</LongDescription>
    <Details>
      <![CDATA[<p>无效警告。</p>]]>
    </Details>
  </BugPattern>
    <BugPattern type="DMI_BIGDECIMAL_CONSTRUCTED_FROM_DOUBLE">
        <ShortDescription>从不是精确表示的双精度数(double)构造的BigDecimal  BigDecimal constructed from double that isn't represented precisely</ShortDescription>
        <LongDescription>从 {1} 构造了 BigDecimal 对象 {4}</LongDescription>
        <Details>
      <![CDATA[<p>这段代码从一个double值创建了一个BigDecimal，但这个转换对十进制数来说并不是很好。例如，人们可能会认为在Java中编写 new BigDecimal(0.1) 创建的BigDecimal会精确等于0.1（未标度值为1，比例为1），但实际上它等于0.1000000000000000055511151231257827021181583404541015625。你可能应该使用BigDecimal.valueOf(double d) 方法，该方法使用double的字符串表示来创建BigDecimal（例如，BigDecimal.valueOf(0.1) 给出的是0.1）。 </p>]]>
    </Details>
    </BugPattern>

    <BugPattern type="DMI_DOH">
        <ShortDescription>哎呀！一个毫无意义的方法调用  D'oh! A nonsensical method invocation</ShortDescription>
        <LongDescription>哎呀！在{1}中非理性地调用了{2.nameAndSignature}。</LongDescription>
        <Details>
      <![CDATA[<p>这种部分方法调用没有意义，原因通过检查即可明显看出。 </p>]]>
    </Details>
    </BugPattern>

  <BugPattern type="DMI_VACUOUS_CALL_TO_EASYMOCK_METHOD">
    <ShortDescription>对EasyMock方法的无用/空洞调用  Useless/vacuous call to EasyMock method</ShortDescription>
    <LongDescription>在{1}中调用了不必要的/{2}空洞的调用{2}</LongDescription>
    <Details>
      <![CDATA[<p>这个调用没有向EasyMock方法传递任何对象，因此该调用什么都不会做。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_SCHEDULED_THREAD_POOL_EXECUTOR_WITH_ZERO_CORE_THREADS">
    <ShortDescription>创建具有零核线程的ScheduledThreadPoolExecutor  Creation of ScheduledThreadPoolExecutor with zero core threads</ShortDescription>
    <LongDescription>在 {1} 中使用零核心线程创建 ScheduledThreadPoolExecutor</LongDescription>
    <Details>
      <![CDATA[<p>(<a href="http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html#ScheduledThreadPoolExecutor%28int%29">Javadoc</a>) 一个核心线程数为零的 ScheduledThreadPoolExecutor 将不会执行任何任务；对最大线程池大小的更改将被忽略。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_FUTILE_ATTEMPT_TO_CHANGE_MAXPOOL_SIZE_OF_SCHEDULED_THREAD_POOL_EXECUTOR">
    <ShortDescription>尝试更改 ScheduledThreadPoolExecutor 的最大池大小无济于事  Futile attempt to change max pool size of ScheduledThreadPoolExecutor</ShortDescription>
    <LongDescription>在 {1} 中尝试更改 ScheduledThreadPoolExecutor 的最大线程池大小失败</LongDescription>
    <Details>
      <![CDATA[<p>(<a href="http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html">Javadoc</a>) 虽然ScheduledThreadPoolExecutor 继承自 ThreadPoolExecutor，但其中一些继承来的调优方法对其并无用处。特别是，由于它作为一个固定大小的线程池使用 corePoolSize 个线程和一个无界队列工作，对 maximumPoolSize 的调整没有任何实际效果。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_UNSUPPORTED_METHOD">
    <ShortDescription>调用不支持的方法  Call to unsupported method</ShortDescription>
    <LongDescription>在{1}中调用了不支持的方法{2}</LongDescription>
    <Details>
      <![CDATA[<p>此方法调用的所有目标都会抛出一个 UnsupportedOperationException。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_EMPTY_DB_PASSWORD">
    <ShortDescription>空数据库密码  Empty database password</ShortDescription>
    <LongDescription>在{1}中空数据库密码</LongDescription>
    <Details>
      <![CDATA[<p>这段代码使用空密码创建数据库连接，这表明该数据库没有设置密码保护。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_CONSTANT_DB_PASSWORD">
    <ShortDescription>硬编码的数据库密码  Hardcoded constant database password</ShortDescription>
    <LongDescription>在{1}中硬编码了数据库密码常量</LongDescription>
    <Details>
      <![CDATA[<p>这段代码使用硬编码的常量密码建立数据库连接。任何能够访问源代码或编译后代码的人都可以轻松获取到密码。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="HRS_REQUEST_PARAMETER_TO_COOKIE">
    <ShortDescription>来自不可信输入的HTTP cookie  HTTP cookie formed from untrusted input</ShortDescription>
    <LongDescription>从不可信输入{1}生成的HTTP_cookie</LongDescription>
    <Details>
      <![CDATA[<p>此代码使用了一个不可信的HTTP参数构造HTTP Cookie。如果将该Cookie添加到HTTP响应中，将会导致HTTP响应拆分漏洞。有关更多信息，请参阅<a href="http://en.wikipedia.org/wiki/HTTP_response_splitting">http://en.wikipedia.org/wiki/HTTP_response_splitting</a>。</p>
<p>SpotBugs 只会寻找最明显的HTTP响应拆分案例。如果 SpotBugs 发现了任何此类情况，你几乎可以肯定还有其他未被报告的漏洞。如果你关心HTTP响应拆分问题，你应该认真考虑使用商用静态分析或渗透测试工具。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="HRS_REQUEST_PARAMETER_TO_HTTP_HEADER">
    <ShortDescription>HTTP 响应拆分漏洞  HTTP Response splitting vulnerability</ShortDescription>
    <LongDescription>在{1}中，直接将HTTP参数写入HTTP头部输出。</LongDescription>
    <Details>
            <![CDATA[<p>这段代码直接将HTTP参数写入HTTP标头中，这允许发生HTTP响应拆分漏洞。有关更多信息，请参阅<a href="http://en.wikipedia.org/wiki/HTTP_response_splitting">http://en.wikipedia.org/wiki/HTTP_response_splitting</a>。</p>
<p>SpotBugs 只检查最明显的基本的HTTP响应拆分情况。如果 SpotBugs 发现了任何这种情况，你很可能还有其他 SpotBugs 没有报告的漏洞。如果你担心HTTP响应拆分问题，你应该考虑使用商业静态分析或渗透测试工具。 </p>]]>
        </Details>
  </BugPattern>



  <BugPattern type="PT_RELATIVE_PATH_TRAVERSAL">
    <ShortDescription>相对路径遍历在Servlet中的使用  Relative path traversal in servlet</ShortDescription>
    <LongDescription>在{1}中存在相对路径遍历问题</LongDescription>
    <Details>
<![CDATA[<p>该软件使用HTTP请求参数构建文件路径，并且应该限制在某个受限目录内，但并未妥善中和诸如 ".." 这样的序列，这些序列可能解析为超出该目录的位置。有关更多信息，请参阅 <a href="http://cwe.mitre.org/data/definitions/23.html">http://cwe.mitre.org/data/definitions/23.html</a>。</p>
<p>SpotBugs 只查找最明显的相对路径遍历情况。如果 SpotBugs 发现了任何此类问题，你几乎可以确定还存在其他未被报告的漏洞。如果你担心相对路径遍历的问题，你应该认真考虑使用商用静态分析或渗透测试工具。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="PT_ABSOLUTE_PATH_TRAVERSAL">
    <ShortDescription>在Servlet中使用绝对路径遍历  Absolute path traversal in servlet</ShortDescription>
    <LongDescription>在{1}中存在绝对路径遍历问题</LongDescription>
    <Details>
<![CDATA[<p>该软件使用HTTP请求参数构建文件路径，且应限制在某个受限目录内，但并未妥善中和诸如"/abs/path"这样的绝对路径序列，这些序列可能解析为超出该目录的位置。有关更多信息，请参见 <a href="http://cwe.mitre.org/data/definitions/36.html">http://cwe.mitre.org/data/definitions/36.html</a>。</p>
<p>SpotBugs 只查找最明显的绝对路径遍历漏洞。如果 SpotBugs 发现了任何此类问题，你很可能还有其他未被报告的漏洞。如果你担心绝对路径遍历问题，你应该考虑使用商业静态分析或渗透测试工具。 </p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER">
    <ShortDescription>反射型跨站脚本漏洞  Servlet reflected cross site scripting vulnerability</ShortDescription>
    <LongDescription>在{1}中将HTTP参数写入Servlet输出中。</LongDescription>
    <Details>
<![CDATA[<p>这段代码直接将HTTP参数写入Servlet输出，这允许发生反射型跨站脚本漏洞。有关更多信息，请参见 <a href="http://en.wikipedia.org/wiki/Cross-site_scripting">http://en.wikipedia.org/wiki/Cross-site_scripting</a>。</p>
<p>SpotBugs 只查找最明显的跨站脚本漏洞案例。如果 SpotBugs 发现了任何这类情况，你很可能还有其他 SpotBugs 没有报告的跨站脚本漏洞。如果你担心跨站脚本问题，你应该认真考虑使用商业静态分析或渗透测试工具。</p>]]>
    </Details>
  </BugPattern>


  <BugPattern type="XSS_REQUEST_PARAMETER_TO_SEND_ERROR">
    <ShortDescription>错误页面中反射式跨站脚本漏洞  Servlet reflected cross site scripting vulnerability in error page</ShortDescription>
    <LongDescription>将HTTP参数写入到Servlet错误页面{1}中</LongDescription>
    <Details>
<![CDATA[<p>这段代码直接将HTTP参数写入服务器错误页面（使用HttpServletResponse.sendError）。将这种不受信任的输入回显出来可能会导致反射型跨站脚本漏洞。有关更多信息，请参阅 <a href="http://en.wikipedia.org/wiki/Cross-site_scripting">http://en.wikipedia.org/wiki/Cross-site_scripting</a>。</p>
<p>SpotBugs 只寻找最明显的跨站脚本漏洞案例。如果 SpotBugs 发现了任何这类问题，你很可能还有其他 SpotBugs 没有报告的跨站脚本漏洞。如果你担心跨站脚本攻击，你应该认真考虑使用商业静态代码分析或渗透测试工具。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="XSS_REQUEST_PARAMETER_TO_JSP_WRITER">
    <ShortDescription>反射型跨站脚本漏洞  JSP reflected cross site scripting vulnerability</ShortDescription>
    <LongDescription>将HTTP参数直接写入JSP输出，导致在{1.class}中存在反射型XSS漏洞。</LongDescription>
    <Details>
<![CDATA[<p>这段代码直接将HTTP参数写入JSP输出，这允许跨站脚本漏洞。更多信息，请参阅 <a href="http://en.wikipedia.org/wiki/Cross-site_scripting">http://en.wikipedia.org/wiki/Cross-site_scripting</a>。</p>
<p>SpotBugs 只寻找最明显的跨站脚本漏洞情况。如果 SpotBugs 发现了任何这种情况，你很可能还有其他未被报告的跨站脚本漏洞。如果你担心跨站脚本问题，你应该考虑使用商业静态代码分析或渗透测试工具。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SW_SWING_METHODS_INVOKED_IN_SWING_THREAD">
    <ShortDescription>某些Swing方法需要在Swing线程中调用  Certain swing methods need to be invoked in Swing thread</ShortDescription>
    <LongDescription>在 `{1}` 中对 swing 方法的调用需要在 Swing 事件线程中执行</LongDescription>
    <Details>
<![CDATA[<p>(来自JDC技术提示): Swing 方法 show()、setVisible() 和 pack() 会为框架创建相关的同辈对象。随着同辈对象的创建，系统会创建事件分派线程。这会引起问题，因为事件分派线程可能会在 pack 和 validate 处理过程中通知监听者。这种情况可能导致两个线程同时遍历基于 Swing 组件的 GUI —— 这是一个严重的缺陷，可能会导致死锁或其他相关线程问题。pack 调用会使组件被实现。当它们正在被实现（即不一定可见）时，可能会触发事件分派线程上的监听者通知。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IL_INFINITE_LOOP">
    <ShortDescription>一个明显的无限循环  An apparent infinite loop</ShortDescription>
    <LongDescription>在{1}中有明显的无限循环。</LongDescription>
    <Details>
<![CDATA[<p>这个循环似乎没有终止的方式（除非抛出异常）。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IL_INFINITE_RECURSIVE_LOOP">
    <ShortDescription>一个明显的无限递归循环  An apparent infinite recursive loop</ShortDescription>
    <LongDescription>在 `{1}` 中存在明显的无限递归循环。</LongDescription>
    <Details>
<![CDATA[<p>该方法无条件地调用自身。这似乎表明存在一个无限递归循环，最终会导致堆栈溢出。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IL_CONTAINER_ADDED_TO_ITSELF">
    <ShortDescription>一个集合将其自身添加到其中。  A collection is added to itself</ShortDescription>
    <LongDescription>在一个集合中将自己添加了{1}次。</LongDescription>
    <Details>
<![CDATA[<p>将一个集合添加到它自己中。结果，计算这个集合的hashCode时会抛出StackOverflowException异常。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="VO_VOLATILE_REFERENCE_TO_ARRAY">
    <ShortDescription>一个volatile引用的数组不会将数组元素视为volatile。  A volatile reference to an array doesn't treat the array elements as volatile</ShortDescription>
    <LongDescription>{1} 是一个易失性引用到数组；数组元素是非易失性的。</LongDescription>
    <Details>
<![CDATA[<p>这声明了一个对数组的volatile引用，可能不是你想要的效果。带有volatile引用的数组，对其引用的读写会被视为volatile操作，但数组元素本身是非volatile的。如果你需要volatile数组元素，你需要使用java.util.concurrent中的原子数组类（从Java 5.0开始提供）。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="VO_VOLATILE_INCREMENT">
    <ShortDescription>对volatile字段的增量操作不是原子性的。  An increment to a volatile field isn't atomic</ShortDescription>
    <LongDescription>在 `{1}` 中对易变字段 `{2}` 进行递增操作</LongDescription>
    <Details>
<![CDATA[<p>这段代码会递增/递减一个volatile字段。volatile字段的递增/递减不是原子操作。如果多个线程同时对字段进行递增/递减，可能会丢失一些递增/递减的操作。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UI_INHERITANCE_UNSAFE_GETRESOURCE">
    <ShortDescription>使用GetResource可能在类被扩展时是不安全的。  Usage of GetResource may be unsafe if class is extended</ShortDescription>
    <LongDescription>在 `{1}` 中使用 GetResource 可能不安全，因为类可能被扩展。</LongDescription>
    <Details>
<![CDATA[<p>如果此类被另一个包中的类扩展，那么调用<code>this.getClass().getResource(...)</code>可能会得到意外的结果。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_BOOLEAN_RETURN_NULL">
    <ShortDescription>方法返回布尔类型值但显式返回了null  Method with Boolean return type returns explicit null</ShortDescription>
    <LongDescription>{1}返回布尔类型，并显式地返回了null</LongDescription>
    <Details>
       <![CDATA[<p>     返回 Boolean.TRUE、Boolean.FALSE 或 null 的方法是一个潜在的问题。     这个方法可以像返回 boolean 类型的值一样被调用，     编译器会自动将 Boolean 值拆箱。如果返回 null 值，     将会导致 NullPointerException。</p>]]>
       </Details>
  </BugPattern>
  <BugPattern type="NP_OPTIONAL_RETURN_NULL">
    <ShortDescription>带有Optional返回类型的方法显式返回null  Method with Optional return type returns explicit null</ShortDescription>
    <LongDescription>{1}具有Optional返回类型并且显式地返回null</LongDescription>
    <Details>
       <![CDATA[<p>     使用 `Optional` 返回类型（即 `java.util.Optional` 或 `com.google.common.base.Optional`）总是意味着明确的空值返回不符合设计要求。在这种情况下返回 null 将违反契约，并且很可能会破坏客户端代码。</p>]]>
       </Details>
  </BugPattern>
  <BugPattern type="NP_NONNULL_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR">
    <ShortDescription>非空字段未初始化  Non-null field is not initialized</ShortDescription>
    <LongDescription>非空字段 {2.name} 未在 {1} 中初始化</LongDescription>
    <Details>
       <![CDATA[<p>该字段被标记为非空，但构造函数并未对其进行初始化。该字段可能在构造函数的其他地方进行了初始化，或者总是会在使用前进行初始化。</p>]]>
       </Details>
  </BugPattern>
  <BugPattern type="NP_SYNC_AND_NULL_CHECK_FIELD">
    <ShortDescription>在同一字段上进行同步和空值检查。  Synchronize and null check on the same field.</ShortDescription>
    <LongDescription>在 {1} 中，字段 {2.givenClass} 被同步并随后检查是否为空。</LongDescription>
    <Details>
<![CDATA[<p>由于该字段进行了同步锁定，似乎不太可能为空。如果为空然后再进行同步操作将抛出NullPointerException，从而使检查变得毫无意义。最好同步另一个字段。</p>]]>
     </Details>
  </BugPattern>
  <BugPattern type="RpC_REPEATED_CONDITIONAL_TEST">
    <ShortDescription>重复的条件判断  Repeated conditional tests</ShortDescription>
    <LongDescription>在{1}中重复了条件测试</LongDescription>
    <Details>
<![CDATA[代码中包含一个条件测试连续进行了两次（例如，`x == 0 || x == 0`）。也许第二次出现的是其他意思（例如，`x == 0 || y == 0`）。]]>
    </Details>
  </BugPattern>
  <BugPattern type="TESTING">
    <ShortDescription>测试  Testing</ShortDescription>
    <LongDescription>在{1}生成警告提示</LongDescription>
    <Details>
<![CDATA[<p>此错误模式仅由新、不完全实现的bug检测器生成。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="TESTING1">
    <ShortDescription>测试 1  Testing 1</ShortDescription>
    <LongDescription>在{1}生成了警告1</LongDescription>
    <Details>
<![CDATA[<p>此错误模式仅由新开发、尚未完全实现的错误检测器生成。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="TESTING2">
    <ShortDescription>测试 2  Testing 2</ShortDescription>
    <LongDescription>在 {1} 生成了测试警告 2</LongDescription>
    <Details>
<![CDATA[<p>这个错误模式仅由新开发、不完全实现的错误检测器生成。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="TESTING3">
    <ShortDescription>测试 3  Testing 3</ShortDescription>
    <LongDescription>在{1}生成了测试警告3</LongDescription>
    <Details>
<![CDATA[<p>该错误模式仅由新开发且尚未完全实现的错误检测器生成。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UNKNOWN">
    <ShortDescription>未知的错误模式  Unknown bug pattern</ShortDescription>
    <LongDescription>在第{1}行中发现未知的错误模式 BUG_PATTERN</LongDescription>
    <Details>
<![CDATA[<p>记录了警告，但SpotBugs无法找到此错误模式的描述，因此无法对其进行说明。这种情况只应在SpotBugs或其配置存在 bug、或者分析使用的是某个插件但当前未加载该插件的情况下发生。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="AM_CREATES_EMPTY_ZIP_FILE_ENTRY">
    <ShortDescription>创建一个空的zip文件条目  Creates an empty zip file entry</ShortDescription>
    <LongDescription>在 {1} 中创建了空的 ZIP 文件条目</LongDescription>
    <Details>
<![CDATA[<p>代码调用了<code>putNextEntry()</code>，紧接着调用了<code>closeEntry()</code>。这会导致一个空的Zip文件条目。条目的内容应该在调用<code>putNextEntry()</code>和<code>closeEntry()</code>之间写入到Zip文件中。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="AM_CREATES_EMPTY_JAR_FILE_ENTRY">
    <ShortDescription>创建一个空的jar文件条目  Creates an empty jar file entry</ShortDescription>
    <LongDescription>在 {1} 中创建了空的 JAR 文件条目</LongDescription>
    <Details>
<![CDATA[<p>代码调用了<code>putNextEntry()</code>，紧接着又调用了<code>closeEntry()</code>。这会导致一个空的Jar文件条目。应在调用<code>putNextEntry()</code>和<code>closeEntry()</code>之间向Jar文件写入条目的内容。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IMSE_DONT_CATCH_IMSE">
    <ShortDescription>可疑的对IllegalMonitorStateException的捕获  Dubious catching of IllegalMonitorStateException</ShortDescription>
    <LongDescription>在{1}中疑似捕获了非法监视状态异常（IllegalMonitorStateException）</LongDescription>
    <Details>
<![CDATA[<p>IllegalMonitorStateException 通常仅在您的代码设计存在缺陷时（例如，在不持有锁的情况下调用wait或notify方法）抛出。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FL_MATH_USING_FLOAT_PRECISION">
    <ShortDescription>方法使用浮点精度执行数学运算  Method performs math using floating point precision</ShortDescription>
    <LongDescription>{1} 使用浮点精度进行数学运算</LongDescription>
    <Details>
<![CDATA[<p>该方法使用浮点精度执行数学运算。浮点精度非常不精确。例如，16777216.0f + 1.0f = 16777216.0f。可以考虑改为使用双精度数学运算。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CAA_COVARIANT_ARRAY_FIELD">
    <ShortDescription>向字段赋covariant数组类型  Covariant array assignment to a field</ShortDescription>
    <LongDescription>类型为{2}的数组被分配给类型为{3}的字段</LongDescription>
    <Details>
<![CDATA[<p>协变类型数组被赋值给一个字段。这可能会导致混淆，并且如果稍后在该数组中存储其他类型的引用，可能会在运行时引发ArrayStoreException，如下所示的代码： </p>
<pre><code>Number[] arr = new Integer[10]; arr[0] = 1.0; </code></pre>
<p>考虑更改创建数组的类型或字段类型。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CAA_COVARIANT_ARRAY_LOCAL">
    <ShortDescription>局部变量的协变数组赋值  Covariant array assignment to a local variable</ShortDescription>
    <LongDescription>类型为 {2} 的数组被赋值给类型为 {3} 的变量</LongDescription>
    <Details>
<![CDATA[<p>协变类型数组被赋值给一个局部变量。这可能会导致混淆，并且如果以后在该数组中存储了其他类型的引用，会在运行时引发ArrayStoreException，如下代码所示： </p>
<pre><code>Number[] arr = new Integer[10]; arr[0] = 1.0; </code></pre>
<p>考虑更改创建的数组类型或局部变量的类型。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CAA_COVARIANT_ARRAY_RETURN">
    <ShortDescription>方法返回了协变数组  Covariant array is returned from the method</ShortDescription>
    <LongDescription>方法的返回类型为{3}，但该方法返回了类型为{2}的数组。</LongDescription>
    <Details>
<![CDATA[<p>返回的方法会返回协变类型数组。这可能会导致混淆，并且如果调用代码尝试将其他类型的引用存储在返回的数组中，可能会在运行时引发ArrayStoreException。</p>
<p>考虑更改创建的数组类型或方法的返回类型。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CAA_COVARIANT_ARRAY_ELEMENT_STORE">
    <ShortDescription>可变数组中存储了不兼容的元素  Possibly incompatible element is stored in covariant array</ShortDescription>
    <LongDescription>类型为 {2} 的值被存储到了元素类型为 {3} 的数组中</LongDescription>
    <Details>
<![CDATA[<p>将值存储到数组中，但该值的类型与数组类型不符。分析得知实际数组类型比其变量或字段声明的类型更窄，且此赋值不满足原始数组类型的要求。这种赋值可能会在运行时导致ArrayStoreException。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CN_IDIOM">
    <ShortDescription>该类实现了Cloneable接口，但未定义或使用clone方法。  Class implements Cloneable but does not define or use clone method</ShortDescription>
    <LongDescription>类 {0} 实现了 Cloneable 但未定义或使用 clone 方法</LongDescription>
    <Details>
<![CDATA[<p>类实现了Cloneable接口，但未定义或使用clone方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE">
    <ShortDescription>类定义了clone() 但未实现Cloneable接口  Class defines clone() but doesn't implement Cloneable</ShortDescription>
    <LongDescription>{0} 定义了 clone() 但没有实现 Cloneable 接口</LongDescription>
    <Details>
<![CDATA[<p>该类定义了clone()方法，但类并未实现Cloneable接口。在某些情况下这是可以接受的（例如，您希望控制子类如何进行克隆），但在实施此功能时请确保这正是您的意图。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CN_IDIOM_NO_SUPER_CALL">
    <ShortDescription>克隆方法没有调用super.clone()  clone method does not call super.clone()</ShortDescription>
    <LongDescription>{1} 没有调用 super.clone()</LongDescription>
    <Details>
<![CDATA[<p>此非最终类定义了一个 `clone()` 方法，该方法没有调用 `super.clone()`。如果该类（<i>A</i>）被子类（<i>B</i>）扩展，并且子类<i>B</i>调用了 `super.clone()`，那么很可能<i>B</i>`的` `clone()` 方法将返回一个类型为<i>A</i>的对象，这违反了`clone()`的标准合约。</p>
<p>如果所有的 `clone()` 方法都调用 `super.clone()`，则可以确保它们使用 `Object.clone()`，而 `Object.clone()` 总是会返回正确类型的对象。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_FUTURE_KEYWORD_USED_AS_IDENTIFIER">
    <ShortDescription>在较新版本的Java中，使用关键字作为标识符  Use of identifier that is a keyword in later versions of Java</ShortDescription>
    <LongDescription>{1} 使用了 {2} 作为变量名，这在较新的Java版本中是一个关键字。</LongDescription>
    <Details>
<![CDATA[<p>标识符是将来版本的Java中保留的关键字，因此您的代码需要进行修改才能在后来的Java版本中编译。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_FUTURE_KEYWORD_USED_AS_MEMBER_IDENTIFIER">
    <ShortDescription>在较新的Java版本中，使用关键字作为标识符  Use of identifier that is a keyword in later versions of Java</ShortDescription>
    <LongDescription>{1} 与较新版本Java中的关键字冲突</LongDescription>
    <Details>
<![CDATA[<p>这个标识符在较新的Java版本中被用作关键字。这段代码，以及引用此API的任何代码，在编译较新版本的Java时都需要进行更改。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DE_MIGHT_DROP">
    <ShortDescription>方法可能会丢弃异常  Method might drop exception</ShortDescription>
    <LongDescription>可能会丢失 {2}</LongDescription>
    <Details>
<![CDATA[<p>此方法可能会抛出异常。一般情况下，异常应当以某种方式处理或上报，或者从方法中抛出。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DE_MIGHT_IGNORE">
    <ShortDescription>方法可能会忽略异常  Method might ignore exception</ShortDescription>
    <LongDescription>可能会忽略 {2}</LongDescription>
    <Details>
<![CDATA[<p>该方法可能会忽略一个异常。通常情况下，异常应该以某种方式处理或报告，或者从方法中抛出。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DP_DO_INSIDE_DO_PRIVILEGED">
    <ShortDescription>应在doPrivileged块内调用的方法被外部调用了  Method invoked that should be only be invoked inside a doPrivileged block</ShortDescription>
    <LongDescription>在{1}中调用了{2}，而该调用应当位于doPrivileged块之内。</LongDescription>
    <Details>
<![CDATA[<p>此代码调用了需要进行安全权限检查的方法。如果此代码将被授予安全权限，但可能会由未获得安全权限的代码调用，则该调用需要发生在doPrivileged块中。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DP_DO_INSIDE_DO_PRIVILEDGED"> <!-- misspelled for backward compatibility -->
    <ShortDescription>应在 `doPrivileged` 块内部调用的方法却被外部调用  Method invoked that should be only be invoked inside a doPrivileged block</ShortDescription>
    <LongDescription>在{1}中调用了{2}，而该方法应该在一个doPrivileged块内被调用。</LongDescription>
    <Details>
<![CDATA[<p>该代码调用了一个需要进行安全权限检查的方法。如果此代码将被授予安全权限，但可能会由没有安全权限的代码来调用，则该调用需要发生在doPrivileged块中。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED">
    <ShortDescription>类装载器只应该在 doPrivileged 块中创建  Classloaders should only be created inside doPrivileged block</ShortDescription>
    <LongDescription>{1} 创建了一个 {2} 类加载器，这应该在 doPrivileged 块中执行。</LongDescription>
    <Details>
<![CDATA[<p>这段代码创建了一个类加载器，如果安装了安全管理系统，则需要权限。 如果此代码可能由没有安全权限的代码调用，那么类加载器的创建需要发生在doPrivileged块中。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="JCIP_FIELD_ISNT_FINAL_IN_IMMUTABLE_CLASS">
    <ShortDescription>Immutable 类的字段应为 final  Fields of immutable classes should be final</ShortDescription>
    <LongDescription>{1.givenClass} 应该是最终类（final），因为 {0} 被标记为Immutable。</LongDescription>
    <Details>
<![CDATA[该类被注释为 `net.jcip.annotationsImmutable` 或 `javax.annotation.concurrent.Immutable`，而这些注解的规则要求所有字段都是 final 的。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_THREAD_PASSED_WHERE_RUNNABLE_EXPECTED">
    <ShortDescription>线程参数预期为Runnable接口实例  Thread passed where Runnable expected</ShortDescription>
    <LongDescription>在{1}处，使用了Thread，但预期是Runnable。</LongDescription>
    <Details>
<![CDATA[<p>将一个 Thread 对象作为参数传递给一个预期接收 Runnable 的方法。这相当不寻常，可能表示逻辑错误或导致意外行为。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_COLLECTION_OF_URLS">
    <ShortDescription>映射和集合中的URL可能会成为性能瓶颈  Maps and sets of URLs can be performance hogs</ShortDescription>
    <LongDescription>{1} 使用了URL的映射或集合，这可能会成为性能瓶颈。</LongDescription>
    <Details>
<![CDATA[<p>该方法或字段使用了 URL 的 Map 或 Set。由于 URL 的 equals 和 hashCode 方法会进行域名解析，这可能会导致性能下降。更多信息请参见 <a href="http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html">http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html</a>。考虑使用 <code>java.net.URI</code> 代替。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_BLOCKING_METHODS_ON_URL">
    <ShortDescription>URL的equals和hashCode方法存在问题  The equals and hashCode methods of URL are blocking</ShortDescription>
    <LongDescription>在{1}中调用了{2}，该方法会阻塞以进行域名解析。</LongDescription>
    <Details>
<![CDATA[<p>URL的equals和hashCode方法会执行域名解析，这可能会导致性能下降。更多信息请参见<a href="http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html">http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html</a>。考虑使用<code>java.net.URI</code>代替。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION">
    <ShortDescription>无法使用反射检查未在运行时保留的注解是否存在。  Can't use reflection to check for presence of annotation without runtime retention</ShortDescription>
    <LongDescription>使用反射检查是否存在未在运行时保留的注解{3}，在{1}中</LongDescription>
    <Details>
<![CDATA[<p>除非注解本身被标注了 @Retention(RetentionPolicy.RUNTIME)，否则无法通过反射（例如，使用 isAnnotationPresent 方法）来观察该注解。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_EXIT">
    <ShortDescription>方法调用了System.exit(...)。  Method invokes System.exit(...)</ShortDescription>
    <LongDescription>{1} 调用了 `System.exit(...)`, 这将关闭整个虚拟机。</LongDescription>
    <Details>
<![CDATA[<p>调用System.exit会关闭整个Java虚拟机。这只有在适当的情况下才应该这样做。这样的调用会使其他代码难以或无法调用你的代码。考虑抛出一个RuntimeException代替。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_RUN_FINALIZERS_ON_EXIT">
    <ShortDescription>方法调用了危险的方法runFinalizersOnExit  Method invokes dangerous method runFinalizersOnExit</ShortDescription>
    <LongDescription>{1} 调用了危险的方法 runFinalizersOnExit</LongDescription>
    <Details>
<![CDATA[<p><em>严禁调用System.runFinalizersOnExit或Runtime.runFinalizersOnExit方法：它们是Java库中最危险的方法之一。</em>——尤金·布洛克</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_STRING_CTOR">
    <ShortDescription>方法调用了低效的 `new String(String)` 构造函数  Method invokes inefficient new String(String) constructor</ShortDescription>
    <LongDescription>{1} 调用了低效的 `new String(String)` 构造函数</LongDescription>
    <Details>
<![CDATA[<p>使用 <code>java.lang.String(String)</code> 构造函数会浪费内存，因为这样构造的对象将与传入的 <code>String</code> 参数功能上无法区分。可以直接使用参数 <code>String</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_STRING_VOID_CTOR">
    <ShortDescription>方法调用了效率低的 `new String()` 构造函数  Method invokes inefficient new String() constructor</ShortDescription>
    <LongDescription>{1} 调用了低效的 `new String()` 构造函数</LongDescription>
    <Details>
<![CDATA[<p>使用无参构造函数创建新的<code>java.lang.String</code>对象会浪费内存，因为这样创建的对象在功能上将与空字符串常量<code>""</code>无法区分。Java 保证了相同的字符串常量将会被表示为同一个<code>String</code>对象。因此，你应该直接使用空字符串常量。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_STRING_TOSTRING">
    <ShortDescription>方法在调用字符串的toString()方法。  Method invokes toString() method on a String</ShortDescription>
    <LongDescription>{1} 对字符串调用toString()方法</LongDescription>
    <Details>
<![CDATA[调用<code>String.toString()</code>只是多余的操作。只需直接使用字符串即可。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_GC">
    <ShortDescription>显式的垃圾回收；除非在基准代码中，否则极其可疑。  Explicit garbage collection; extremely dubious except in benchmarking code</ShortDescription>
    <LongDescription>强制执行垃圾回收；仅在基准代码中极为可疑。</LongDescription>
    <Details>
<![CDATA[<p>代码显式调用垃圾收集。除了特定的基准测试用途外，这通常是值得怀疑的。</p>
<p>过去，在关闭或 finalize 方法等例行程序中显式调用垃圾收集器的情况导致了巨大的性能瓶颈。垃圾收集可能非常昂贵。任何会导致成百上千次垃圾收集的情况都会使机器几乎停止工作。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_BOOLEAN_CTOR">
    <ShortDescription>方法调用了低效的Boolean构造函数；请使用Boolean.valueOf(...)代替。  Method invokes inefficient Boolean constructor; use Boolean.valueOf(...) instead</ShortDescription>
    <LongDescription>{1} 调用了低效的 `Boolean` 构造函数；请使用 `Boolean.valueOf(...)` 代替。</LongDescription>
    <Details>
<![CDATA[<p>创建新的 <code>java.lang.Boolean</code> 实例会浪费内存，因为 <code>Boolean</code> 对象是不可变的，并且这种类型只有两种有用的价值。建议使用 <code>Boolean.valueOf()</code> 方法（或 Java 1.5 的自动装箱）来创建 <code>Boolean</code> 对象。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_NUMBER_CTOR">
    <ShortDescription>方法调用了效率低的Number构造函数；请改为使用静态的valueOf方法。  Method invokes inefficient Number constructor; use static valueOf instead</ShortDescription>
    <LongDescription>{1} 调用了低效的 {2} 构造函数；请改为使用 {3}。</LongDescription>
    <Details>
      <![CDATA[<p>使用 <code>new Integer(int)</code> 会始终创建一个新的对象，而 <code>Integer.valueOf(int)</code> 允许编译器、类库或 JVM 进行值缓存。使用缓存的值可以避免对象分配，代码执行也会更快。</p>
<p>-128 到 127 范围内的值都会对应有缓存实例，使用 <code>valueOf</code> 比使用构造函数大约快 3.5 倍。对于超出常量范围的值，两种风格的性能相同。</p>
<p>除非类必须与早于 Java 1.5 的 JVM 兼容，否则在创建 <code>Long</code>、<code>Integer</code>、<code>Short</code>、<code>Character</code> 和 <code>Byte</code> 实例时，请使用自动装箱或 <code>valueOf()</code> 方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_FP_NUMBER_CTOR">
    <ShortDescription>方法调用了效率低的浮点Number构造函数；请改为使用静态valueOf方法。  Method invokes inefficient floating-point Number constructor; use static valueOf instead</ShortDescription>
    <LongDescription>{1} 调用了低效的 {2} 构造函数；请使用 {3} 代替。</LongDescription>
    <Details>
      <![CDATA[<p>使用 <code>new Double(double)</code> 总是会创建一个新的对象，而 <code>Double.valueOf(double)</code> 允许编译器、类库或 JVM 进行值的缓存。使用缓存的值可以避免对象分配并使代码运行得更快。</p>
<p>除非类必须兼容早于 Java 1.5 的 JVM，否则在创建 <code>Double</code> 和 <code>Float</code> 实例时，请使用自动装箱或 <code>valueOf()</code> 方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_CONVERT_CASE">
    <ShortDescription>考虑使用Locale参数化的调用方法版本  Consider using Locale parameterized version of invoked method</ShortDescription>
    <LongDescription>在{1}中使用未本地化的String.toUpperCase()或String.toLowerCase()方法</LongDescription>
    <Details>
<![CDATA[<p>正在使用平台默认编码将 String 转换为大写或小写。这可能会在使用国际字符时导致不正确的转换。应使用以下版本：</p>
<ul>
    <li>`String.toUpperCase(Locale l)`</li>
    <li>`String.toLowerCase(Locale l)`</li>
</ul>
<p>代替。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR">
    <ShortDescription>原始值在三元运算中被拆箱并强制转换  Primitive value is unboxed and coerced for ternary operator</ShortDescription>
    <LongDescription>在{1}中，原始值通过三元运算符进行了拆箱和类型转换。</LongDescription>
    <Details>
<![CDATA[<p>在条件三元运算符（即 `b ? e1 : e2` 运算符）的评估过程中，一个包装原始值被拆箱并转换为另一种原始类型。Java 的语义规定，如果 `e1` 和 `e2` 是包装数值类型，在拆箱后会将这些值转换/强制类型转换为其共同类型（例如，如果 `e1` 类型是 `Integer` 而 `e2` 类型是 `Float`，那么 `e1` 会被拆箱并转换为浮点数再重新封装。参见 JLS 第 15.25 条节。）</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BX_BOXING_IMMEDIATELY_UNBOXED">
    <ShortDescription>原始值被装箱然后立即拆箱  Primitive value is boxed and then immediately unboxed</ShortDescription>
    <LongDescription>原始值被装箱然后立即拆箱在{1}中</LongDescription>
    <Details>
<![CDATA[<p>一个原始类型被包装成装箱对象，然后立即又被拆箱。这可能是由于在一个需要未包装值的地方手动进行了装箱，从而迫使编译器立即取消之前的工作。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BX_UNBOXING_IMMEDIATELY_REBOXED">
    <ShortDescription>装箱值随即拆箱然后重新装箱  Boxed value is unboxed and then immediately reboxed</ShortDescription>
    <LongDescription>在{1}中，已装箱的值立即进行了拆箱和再装箱操作。</LongDescription>
    <Details>
<![CDATA[<p>一个装箱值立即进行了拆箱然后再装箱。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION">
    <ShortDescription>原始值被装箱然后拆箱以执行原始类型转换  Primitive value is boxed then unboxed to perform primitive coercion</ShortDescription>
    <LongDescription>原始值被装箱然后拆箱在{1}中进行原生类型转换</LongDescription>
    <Details>
<![CDATA[<p>使用包装值构建然后立即转换为不同的原始类型（例如，<code>new Double(d).intValue()</code>）。直接进行原始类型的转换即可（例如，<code>(int) d</code>)。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_BOXED_PRIMITIVE_TOSTRING">
    <ShortDescription>方法分配了一个装箱原始类型，仅仅是为了调用toString方法。  Method allocates a boxed primitive just to call toString</ShortDescription>
    <LongDescription>仅仅为了调用toString方法而在{1}处对原始类型进行装箱</LongDescription>
    <Details>
<![CDATA[<p>为了调用 `toString()`，会分配一个boxing类型的实例。直接使用接受原始值的静态 `toString` 形式更为有效。因此，可以将以下代码替换为：</p>
<table>
<tr><th>替换...</th><th>使用此...</th></tr>
<tr><td>`new Integer(1).toString()`</td><td>`Integer.toString(1)`</td></tr>
<tr><td>`new Long(1).toString()`</td><td>`Long.toString(1)`</td></tr>
<tr><td>`new Float(1.0).toString()`</td><td>`Float.toString(1.0)`</td></tr>
<tr><td>`new Double(1.0).toString()`</td><td>`Double.toString(1.0)`</td></tr>
<tr><td>`new Byte(1).toString()`</td><td>`Byte.toString(1)`</td></tr>
<tr><td>`new Short(1).toString()`</td><td>`Short.toString(1)`</td></tr>
<tr><td>`new Boolean(true).toString()`</td><td>`Boolean.toString(true)`</td></tr>
</table>]]>
    </Details>
  </BugPattern>
    <BugPattern type="DM_BOXED_PRIMITIVE_FOR_PARSING">
    <ShortDescription>将原始类型进行装箱/拆箱以解析  Boxing/unboxing to parse a primitive</ShortDescription>
    <LongDescription>将原始类型进行装箱/拆箱以解析 {1}</LongDescription>
    <Details>
<![CDATA[<p>从字符串创建了一个装箱原始值，只是为了提取未装箱的原始值。直接调用静态parseXXX方法更为高效。</p>]]>
    </Details>
  </BugPattern>
    <BugPattern type="DM_BOXED_PRIMITIVE_FOR_COMPARE">
    <ShortDescription>将原始类型包装后再进行比较  Boxing a primitive to compare</ShortDescription>
    <LongDescription>原始类型被包装调用：使用 {3} 而不是 {2}</LongDescription>
    <Details>
<![CDATA[<p>创建了一个装箱原始类型只是为了调用compareTo方法。从Java 1.4开始对double和float类型，从Java 1.7开始对其他原始类型可以直接使用静态compare方法来直接操作原始类型，这更高效。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_NEW_FOR_GETCLASS">
    <ShortDescription>方法分配了一个对象，只是为了获取该对象的类对象  Method allocates an object, only to get the class object</ShortDescription>
    <LongDescription>仅分配对象以获取类对象</LongDescription>
    <Details>
<![CDATA[<p>这种方法分配了一个对象只是为了调用其上的getClass()方法以获取其Class对象。直接访问类的.class属性更为简单。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_MONITOR_WAIT_ON_CONDITION">
    <ShortDescription>在Condition上调用了wait()方法  Monitor wait() called on Condition</ShortDescription>
    <LongDescription>在{1}中调用了Condition的wait()</LongDescription>
    <Details>
      <![CDATA[<p>该方法对一个 <code>java.util.concurrent.locks.Condition</code> 对象调用了 <code>wait()</code>。使用 <code>Condition</code> 接口定义的其中任何一个 <code>await()</code> 方法来等待 <code>Condition</code> 会更好。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="RV_01_TO_INT">
    <ShortDescription>从0到1之间的随机值被强制转换为整数0  Random value from 0 to 1 is coerced to the integer 0</ShortDescription>
    <LongDescription>{1} 使用生成一个介于 0 和 1 之间的随机值，然后将该值强制转换为整数 0。</LongDescription>
    <Details>
<![CDATA[<p>一个在0到1之间的随机值被强制转换为整数值0。你可能希望在将其强制转换为整数之前将随机值乘以其他某个值，或者使用<code>Random.nextInt(n)</code>方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_INVALID_MIN_MAX">
    <ShortDescription>Math.max 和 Math.min 的不正确组合  Incorrect combination of Math.max and Math.min</ShortDescription>
    <LongDescription>使用 `Math.max` 和 `Math.min` 的错误组合：此代码始终返回 `{2}`</LongDescription>
    <Details>
<![CDATA[<p>这段代码尝试使用类似 `Math.min(0, Math.max(100, value))` 的构造来限制值的范围。然而，这里的常量顺序不正确：应该为 `Math.min(100, Math.max(0, value))`。因此，这段代码总是产生相同的结果（或者如果 value 是 NaN，则返回 NaN）。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_NEXTINT_VIA_NEXTDOUBLE">
    <ShortDescription>使用 `nextInt` 方法生成随机整数，而不是使用 `nextDouble` 方法。  Use the nextInt method of Random rather than nextDouble to generate a random integer</ShortDescription>
    <LongDescription>{1} 使用 Random 的 nextDouble 方法生成随机整数；使用 nextInt 更高效。</LongDescription>
    <Details>
<![CDATA[如果 `r` 是一个 `java.util.Random`，你可以使用 `r.nextInt(n)` 生成一个从 `0` 到 `n-1` 的随机数，而不是使用 `(int)(r.nextDouble() * n)`。  
nextInt 的参数必须为正数。例如，如果你想生成一个从 -99 到 0 的随机值，可以使用 `-r.nextInt(100)`。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE">
    <ShortDescription>在SQL语句的execute或addBatch方法中传递了非常量字符串  Nonconstant string passed to execute or addBatch method on an SQL statement</ShortDescription>
    <LongDescription>{1} 将非常量的 String 传递给 SQL 语句的 execute 或 addBatch 方法</LongDescription>
    <Details>
<![CDATA[<p>该方法对一个看起来像是动态生成的字符串调用了SQL语句的execute或addBatch方法。考虑使用预编译语句代替。这样既更高效，也更能避免SQL注入攻击。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING">
    <ShortDescription>一个非常量字符串生成了一个预处理语句。  A prepared statement is generated from a nonconstant String</ShortDescription>
    <LongDescription>从非常量字符串{1}生成了预编译语句。</LongDescription>
    <Details>
<![CDATA[<p>该代码从一个非常量字符串创建SQL预编语句。如果不进行检查，用户提供的污染数据可能会被用于构建这个字符串，从而可能导致预编语句执行意外且不希望发生的操作，存在SQL注入的风险。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_USELESS_THREAD">
    <ShortDescription>使用默认的空run方法创建了一个线程。  A thread was created using the default empty run method</ShortDescription>
    <LongDescription>{1} 使用默认的空run方法创建线程</LongDescription>
    <Details>
<![CDATA[<p>该方法创建一个线程，既没有通过继承 Thread 类指定 run 方法，也没有传递 Runnable 对象。这个线程只会浪费时间，不做任何事情。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DC_DOUBLECHECK">
    <ShortDescription>可能的字段双重检查  Possible double check of field</ShortDescription>
    <LongDescription>在 {1} 中可能在 {2} 处存在双重检查问题</LongDescription>
    <Details>
<![CDATA[<p>该方法可能包含双重加锁实例。根据Java内存模型的语义，这种模式是不正确的。更多信息，请参阅网页 <a href="http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html">http://www.cs.umd.edu/~pugh/java/memoryModel/Double-checked Locking.html</a>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DC_PARTIALLY_CONSTRUCTED">
    <ShortDescription>可能暴露部分初始化的对象  Possible exposure of partially initialized object</ShortDescription>
    <LongDescription>在 {1} 中可能暴露了部分初始化的对象</LongDescription>
    <Details>
<![CDATA[<p>看起来这个方法使用了双重检查锁定的延迟字段初始化。虽然字段被正确声明为volatile，但在字段赋值之后，对象的内部结构可能会发生变化，从而另一个线程可能看到一个部分初始化的对象。</p>
<p>要解决这个问题，请考虑首先将对象存储到局部变量中，并在对象完全构造后再将其保存到volatile字段中。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_FINALIZER_NULLS_FIELDS">
    <ShortDescription>最终化器使字段为空  Finalizer nulls fields</ShortDescription>
    <LongDescription>在 `{1.class}` 类的 finalize 方法中，将 `{3}` 设置为 null。</LongDescription>
    <Details>
<![CDATA[<p>这个终结器将字段置为空。这通常是一个错误，因为它无助于垃圾回收，并且对象本身很快就会被垃圾回收。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_FINALIZER_ONLY_NULLS_FIELDS">
    <ShortDescription>仅使字段为null  Finalizer only nulls fields</ShortDescription>
    <LongDescription>仅检查为空的字段</LongDescription>
    <Details>
<![CDATA[<p>这个最终化器除了将字段置为空之外没有任何作用。这完全是多余的，并且需要对象被垃圾回收、最终化，然后再进行一次垃圾回收。你应该直接移除finalize方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_PUBLIC_SHOULD_BE_PROTECTED">
    <ShortDescription>finalizer 应该是受保护的，而不是公有的  Finalizer should be protected, not public</ShortDescription>
    <LongDescription>{1} 是公共的；应当是受保护的</LongDescription>
    <Details>
<![CDATA[<p>一个类的 <code>finalize()</code> 方法应具有受保护访问权限，而不是公共访问权限。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_EMPTY">
    <ShortDescription>空的finalize方法应当被删除  Empty finalizer should be deleted</ShortDescription>
    <LongDescription>{1} 是空的，应该被删除。</LongDescription>
    <Details>
<![CDATA[<p>空的<code>finalize()</code>方法是无用的，因此应该删除它们。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_NULLIFY_SUPER">
    <ShortDescription>最终化器取消了超类的最终化器  Finalizer nullifies superclass finalizer</ShortDescription>
    <LongDescription>`{1}` 使 `{2}.finalize()` 失效。这正是你所期望的吗？</LongDescription>
    <Details>
<![CDATA[<p>这个空的<code>finalize()</code>方法显式地抵消了其超类定义的任何终结器的效果。除非superclass中定义的任何终结器动作有意不执行，否则应删除此方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_USELESS">
    <ShortDescription>最终化器除了调用超类的最终化器外不做其他事情。  Finalizer does nothing but call superclass finalizer</ShortDescription>
    <LongDescription>仅调用了super.finalize()；删除它。</LongDescription>
    <Details>
<![CDATA[这个 `finalize()` 方法唯一做的就是调用超类的 `finalize()` 方法，使其变得多余。请删除它。]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_MISSING_SUPER_CALL">
    <ShortDescription>finalizer 未调用父类的 finalizer  Finalizer does not call superclass finalizer</ShortDescription>
    <LongDescription>{1} 缺少对 `super.finalize()` 的调用，因此 {2}.finalize() 也不会被调用。</LongDescription>
    <Details>
<![CDATA[<p>这个 `finalize()` 方法没有调用其超类的 `finalize()` 方法。因此，定义在超类中的任何终结器操作将不会被执行。请添加对 `super.finalize()` 的调用。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_EXPLICIT_INVOCATION">
    <ShortDescription>显式调用终结器  Explicit invocation of finalizer</ShortDescription>
    <LongDescription>在{1}中显式调用{2}</LongDescription>
    <Details>
<![CDATA[<p>该方法显式调用了对象的 <code>finalize()</code> 方法。因为.finalize() 方法应该只由 VM 一次性执行，所以这样做是不好的。</p>
<p>如果一组相关的对象开始进行终结化操作，那么 VM 将在同一时间在不同的线程中对所有可终结的对象调用 finalize 方法。因此，在类 X 的 finalize 方法中调用对其它对象的 finalize 方法是一个特别糟糕的想法，因为这些对象可能已经在单独的线程中被终结化了。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS">
    <ShortDescription>相等检查操作不兼容  Equals checks for incompatible operand</ShortDescription>
    <LongDescription>{1} 检查操作数是否为 {2.givenClass}</LongDescription>
    <Details>
<![CDATA[<p>此equals方法用于检查参数是否为不兼容类型（即既不是定义equals方法的类的超类型也不是子类型）。例如，Foo类的equals方法可能如下所示：</p>
<pre><code>public boolean equals(Object o) {     if (o instanceof Foo)   return name.equals(((Foo)o).name);     else if (o instanceof String)   return name.equals(o);     else return false; } </code></pre>
<p>这被视为不良实践，因为它使得实现对称性和传递性的equals方法变得非常困难。没有这些属性，可能会出现非常意外的行为。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_DONT_DEFINE_EQUALS_FOR_ENUM">
    <ShortDescription>枚举中定义了协变equals()方法  Covariant equals() method defined for enum</ShortDescription>
    <LongDescription>枚举 {0} 定义了 equals({0.givenClass})</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个枚举，枚举间的相等性是基于对象身份来定义的。为枚举值定义协变的equals方法是一种非常不良的做法，因为它可能会导致使用协变枚举方法比较时有两个不同的枚举值被认为是相等的，而在正常情况下比较却不相等。不要这样做。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_SELF_USE_OBJECT">
    <ShortDescription>同变的 equals() 方法定义，继承自 Object.equals(Object)  Covariant equals() method defined, Object.equals(Object) inherited</ShortDescription>
    <LongDescription>{0} 定义了 equals({0.givenClass}) 方法，并使用了 Object.equals(Object) 方法。</LongDescription>
    <Details>
<![CDATA[<p>该类定义了一个协变版本的 `equals()` 方法，但继承了从基类 `java.lang.Object` 继承的正常 `equals(Object)` 方法。该类应该可能定义一个 `boolean equals(Object)` 方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_OTHER_USE_OBJECT">
    <ShortDescription>定义了 equals() 方法但没有重写 Object 的 equals(Object) 方法  equals() method defined that doesn't override Object.equals(Object)</ShortDescription>
    <LongDescription>{0} 定义了 {1.givenClass} 方法，并使用了 Object.equals(Object) 方法。</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个<code>equals()</code>方法，该方法没有覆盖基础的<code>java.lang.Object</code>类中定义的<code>equals(Object)</code>方法。此类应该定义一个<code>boolean equals(Object)</code>方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_OTHER_NO_OBJECT">
    <ShortDescription>定义了等于方法（equals()），但未重写 Object 类的 equals(Object) 方法。  equals() method defined that doesn't override equals(Object)</ShortDescription>
    <LongDescription>{0} 定义了 {1.givenClass} 方法，但并未重写 equals(Object) 方法。</LongDescription>
    <Details>
<![CDATA[<p>该类定义了一个<code>equals()</code>方法，这个方法并没有重写基类<code>java.lang.Object</code>中定义的正常<code>equals(Object)</code>方法，而是从超类继承了<code>equals(Object)</code>方法。这个类应该 probably 定义一个<code>boolean equals(Object)</code>方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_DOESNT_OVERRIDE_EQUALS">
    <ShortDescription>类未在超类中重写 equals 方法  Class doesn't override equals in superclass</ShortDescription>
    <LongDescription>{0} 没有覆盖 {2.givenClass}</LongDescription>
    <Details>
<![CDATA[<p>这个类扩展了一个定义了equals方法的类并添加了字段，但自己并没有定义equals方法。因此，该类实例之间的相等性将忽略子类的身份以及新增的字段。请确保这是有意为之，并且你不需要覆盖equals方法。即使你不打算覆盖equals方法，也考虑覆写它以说明子类的equals方法只是返回调用super.equals(o)的结果。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_SELF_NO_OBJECT">
    <ShortDescription>协变定义的equals()方法  Covariant equals() method defined</ShortDescription>
    <LongDescription>{0} 定义了 equals({0.givenClass}) 方法，但未定义 equals(Object) 方法。</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个协变版本的<code>equals()</code>。为了正确覆盖<code>java.lang.Object</code>中的<code>equals()</code>方法，<code>equals()</code>的方法参数必须是<code>java.lang.Object</code>类型。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_OVERRIDING_EQUALS_NOT_SYMMETRIC">
    <ShortDescription>`equals` 方法重写了超类中的 `equals`，并且可能不是对称的。  equals method overrides equals in superclass and may not be symmetric</ShortDescription>
    <LongDescription>在 `{2.class.givenClass}` 中，`{1.class}` 重写了 `equals` 方法，并且可能不是对称的。</LongDescription>
    <Details>
<![CDATA[<p>该类定义了一个重写自超类的equals方法。这两个equals方法在确定两个对象是否相等时都使用了<code>instanceof</code>。这存在很大的风险，因为equals方法的重要特性是其对称性（换句话说，<code>a.equals(b) == b.equals(a)</code>)。如果B是A的子类型，并且A的equals方法检查参数是否为A的实例，而B的equals方法检查参数是否为B的实例，那么这些方法定义的等价关系很可能不是对称的。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_GETCLASS_AND_CLASS_CONSTANT">
    <ShortDescription>equals方法对于子类型会失效  equals method fails for subtypes</ShortDescription>
    <LongDescription>{1} 不适用于子类型</LongDescription>
    <Details>
<![CDATA[<p>该类中的equals方法如果被子类继承可能会失效。它会将一个类字面量与参数的类进行比较（例如，在类<code>Foo</code>中，它可能检查<code>Foo.class == o.getClass()</code>)。更好的做法是使用<code>this.getClass() == o.getClass()</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_UNUSUAL">
    <ShortDescription>异常的equals方法  Unusual equals method</ShortDescription>
    <LongDescription>{1} 是不寻常的</LongDescription>
    <Details>
<![CDATA[<p>这个类并没有使用我们识别的任何模式来检查参数类型是否与*this*对象的类型兼容。这段代码可能没有问题，但值得对其进行审查。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_COMPARING_CLASS_NAMES">
    <ShortDescription>equals方法比较的是类名而不是类对象  equals method compares class names rather than class objects</ShortDescription>
    <LongDescription>{1} 比较类名而非类对象</LongDescription>
    <Details>
<![CDATA[<p>该类定义了一个equals方法，通过检查两个对象的类名是否相同来判断它们是否为同一类。即使由不同的类加载器加载，也可能存在同名的不同类。只需检查类对象是否相同即可。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_ALWAYS_TRUE">
    <ShortDescription>equals方法总是返回true  equals method always returns true</ShortDescription>
    <LongDescription>{1} 总是返回 true</LongDescription>
    <Details>
<![CDATA[<p>该类定义了一个总是返回true的equals方法。虽然这很有趣，但并不聪明。此外，这意味着equals方法不是对称的。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_ALWAYS_FALSE">
    <ShortDescription>equals方法总是返回false  equals method always returns false</ShortDescription>
    <LongDescription>{1} 总是返回 false</LongDescription>
    <Details>
<![CDATA[<p>这个类定义了一个总是返回 false 的 equals 方法。这意味着对象不等于自身，并且不可能创建此类的对象用于 Map 或 Set。更根本的是，这表示 equals 不具有反射性，这是 equals 方法的要求之一。</p>
<p>所期望的语义是对象身份：即一个对象等于其本身。这是从类 <code>Object</code> 继承来的行为。如果你需要覆盖从其他超类继承而来的 equals 方法，可以使用以下代码：</p>
<pre><code>public boolean equals(Object o) {     return this == o; } </code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="HSC_HUGE_SHARED_STRING_CONSTANT">
    <ShortDescription>巨大的字符串常量在多个类文件中被重复使用  Huge string constants is duplicated across multiple class files</ShortDescription>
    <LongDescription>{1} 被初始化为一个长度为 {2} 的字符串常量，并且在其他 {3} 个类文件中进行了复制。</LongDescription>
    <Details>
      <![CDATA[<p>多个类文件中重复使用了一个长的字符串常量。这很可能是因为一个final字段被初始化为字符串常量，而Java语言要求其他类对final字段的所有引用都要被内联到该类文件中。参见<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6447475">JDK问题6447475</a>，了解此 bug 在 JDK 中的描述以及解决它如何使 JDK 的大小减少了 1 兆字节。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_ARGUMENT_MIGHT_BE_NULL">
    <ShortDescription>方法未检查传入的空值参数  Method does not check for null argument</ShortDescription>
    <LongDescription>{1} 不检查空参数</LongDescription>
    <Details>
      <![CDATA[<p>     该方法的参数已被识别为始终需要检查是否为空的值，但该参数在没有先行空检的情况下被解引用。 </p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT">
    <ShortDescription>equals() 方法未检查空参数  equals() method does not check for null argument</ShortDescription>
    <LongDescription>{1} 不检查空参数</LongDescription>
    <Details>
      <![CDATA[<p>此实现中的equals(Object)方法违反了java.lang.Object.equals()所定义的合同，因为它没有检查传递的参数是否为null。所有equals()方法在接收到null值时都应返回false。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="RV_NEGATING_RESULT_OF_COMPARETO">
    <ShortDescription>对比结果的否定  Negating the result of compareTo()/compare()</ShortDescription>
    <LongDescription>{1} 取消了 {2} 的返回值。</LongDescription>
    <Details>
<![CDATA[<p>该代码负向使用了compareTo或compare方法的返回值。这是一种值得怀疑或不好的编程实践，因为如果返回值是Integer.MIN_VALUE，那么对返回值取反将不会改变结果的符号。你可以通过反转操作数的顺序而不是对结果取反来实现相同的目的。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CO_COMPARETO_RESULTS_MIN_VALUE">
    <ShortDescription>`compareTo()`/`compare()` 方法返回 `Integer.MIN_VALUE`  compareTo()/compare() returns Integer.MIN_VALUE</ShortDescription>
    <LongDescription>{1} 返回 `Integer.MIN_VALUE`，这个值无法取反。</LongDescription>
    <Details>
<![CDATA[在某些情况下，`compareTo` 或 `compare` 方法返回常量 `Integer.MIN_VALUE`，这是一种非常糟糕的实践。`compareTo` 的返回值唯一重要的只是其符号。但人们有时会取反 `compareTo` 的返回值，期望这样做可以改变结果的符号。这在大多数情况下确实可以实现，除了返回值为 `Integer.MIN_VALUE` 的情况。因此，直接返回 -1 而不是 `Integer.MIN_VALUE`。]]>
    </Details>
  </BugPattern>
  <BugPattern type="CO_COMPARETO_INCORRECT_FLOATING">
    <ShortDescription>将浮点或双精度值传递给`compareTo()`/`compare()`方法时可能会出现问题。  compareTo()/compare() incorrectly handles float or double value</ShortDescription>
    <LongDescription>{1} 不正确地处理了 {2} 值</LongDescription>
    <Details>
<![CDATA[<p>此方法使用类似于以下模式比较 double 或 float 值：val1 > val2 ? 1 : val1 < val2 ? -1 : 0。这种模式对于 -0.0 和 NaN 值会工作错误，可能导致排序结果不正确或集合损坏（如果比较值用作键）。考虑使用 Double.compare 或 Float.compare 静态方法，它们可以正确处理所有特殊情况。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CO_SELF_NO_OBJECT">
    <ShortDescription>可变的compareTo()方法定义  Covariant compareTo() method defined</ShortDescription>
    <LongDescription>{0} 定义了 compareTo({0.givenClass}) 方法，但未定义 compareTo(Object) 方法。</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个协变版本的 <code>compareTo()</code>。为了正确重写 <code>Comparable</code> 接口中的 <code>compareTo()</code> 方法，<code>compareTo()</code> 的参数必须具有类型 <code>java.lang.Object</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_SIGNATURE_DECLARES_HASHING_OF_UNHASHABLE_CLASS">
    <ShortDescription>签名声明在哈希构造中使用了不可哈希的类  Signature declares use of unhashable class in hashed construct</ShortDescription>
    <LongDescription>在 `{1}` 中，`{2}` 被用于哈希上下文中但未定义 `hashCode()` 方法。</LongDescription>
    <Details>
<![CDATA[<p>一个方法、字段或类声明了泛型签名，其中使用了不可哈希的类，在需要可哈希类的上下文中。声明了equals方法但继承自Object的hashCode()方法的类是不可哈希的，因为等价对象必须具有相同的hashCode，而该类没有满足这一要求。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_USE_OF_UNHASHABLE_CLASS">
    <ShortDescription>在哈希数据结构中未使用具有 `hashCode()` 方法的类  Use of class without a hashCode() method in a hashed data structure</ShortDescription>
    <LongDescription>在 `{1}` 中，`{2}` 没有定义 `hashCode()` 方法，但被用于哈希数据结构中。</LongDescription>
    <Details>
<![CDATA[<p>一个类定义了 equals(Object) 方法但没有定义 hashCode() 方法，因此无法满足相等对象具有相同哈希码的要求。如果该类的实例被用在哈希数据结构中，则修复这个问题的需求最为重要。]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_HASHCODE_USE_OBJECT_EQUALS">
    <ShortDescription>类定义了hashCode()方法并使用了Object的equals()方法  Class defines hashCode() and uses Object.equals()</ShortDescription>
    <LongDescription>{0} 定义了hashCode方法，并使用了Object.equals()方法。</LongDescription>
    <Details>
<![CDATA[<p>该类定义了<code>hashCode()</code>方法，但其<code>equals()</code>方法继承自<code>java.lang.Object</code>(后者通过比较对象引用定义了相等性)。虽然这可能会满足相等对象必须具有相同哈希码的合同要求，但这可能不是覆盖<code>hashCode()</code>方法时所期望的行为。(覆盖<code>hashCode()</code>意味着对象的身份基于比简单引用相等更复杂的标准。)</p>
<p>如果认为此类的实例不会插入到HashMap/HashTable中，则推荐使用的<code>hashCode</code>实现是：</p>
<pre><code>public int hashCode() {     assert false : "hashCode not designed";     return 42; // 任意常量都可以 </code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_COMPARETO_USE_OBJECT_EQUALS">
    <ShortDescription>类定义了compareTo(...))方法并且使用了Object.equals()方法  Class defines compareTo(...) and uses Object.equals()</ShortDescription>
    <LongDescription>{0} 定义了 {1.givenClass} 并使用了 Object.equals() 方法</LongDescription>
    <Details>
<![CDATA[<p>该类定义了<code>compareTo(...)</code>方法，但继承了<code>java.lang.Object</code>的<code>equals()</code>方法。通常情况下，<code>compareTo</code>返回零当且仅当<code>equals</code>返回真。如果违反这一原则，在如PriorityQueue这样的类中将会出现奇怪和不可预测的失败情况。在Java 5中，<code>PriorityQueue.remove</code>方法使用了<code>compareTo</code>方法，而在Java 6中则使用了<code>equals</code>方法。</p>

<p>从Comparable接口中的compareTo方法的JavaDoc说明： <blockquote>强烈建议但不强制要求<code>(x.compareTo(y)==0) == (x.equals(y))</code>。通常来说，任何实现了Comparable接口并且违反这一条件的类应该清楚地表明这一点。推荐的语言是“注意：该类的自然排序与其equals方法不一致。” </blockquote></p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_HASHCODE_NO_EQUALS">
    <ShortDescription>类定义了hashCode()方法但未定义equals()方法  Class defines hashCode() but not equals()</ShortDescription>
    <LongDescription>{0}定义了hashCode方法但未定义equals方法</LongDescription>
    <Details>
<![CDATA[<p>此类定义了 <code>hashCode()</code> 方法但未定义 <code>equals()</code> 方法。因此，该类可能会违反相等对象必须具有相同哈希码的不变量。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_EQUALS_USE_HASHCODE">
    <ShortDescription>类定义了equals()方法并且使用了Object.hashCode()方法  Class defines equals() and uses Object.hashCode()</ShortDescription>
    <LongDescription>{0} 定义了 equals 并使用了 Object.hashCode() 方法</LongDescription>
    <Details>
<![CDATA[<p>此类重写了<code>equals(Object)</code>，但没有重写<code>hashCode()</code>，而是继承了<code>java.lang.Object</code>的<code>hashCode()</code>实现（返回对象的身份哈希码，是由VM随意分配的一个值）。因此，该类很可能违反相等对象必须具有相同哈希码的不变量。</p>
<p>如果你认为此类的实例永远不会插入到HashMap/HashTable中，则推荐使用的<code>hashCode</code>实现是：</p>
<pre><code>public int hashCode() {     assert false : "hashCode not designed";     return 42; // 任何任意常量都可以 } </code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_INHERITS_EQUALS_USE_HASHCODE">
    <ShortDescription>类继承了equals()方法并使用了Object.hashCode()方法  Class inherits equals() and uses Object.hashCode()</ShortDescription>
    <LongDescription>{0} 继承了 equals 并使用了 Object.hashCode() 方法</LongDescription>
    <Details>
<![CDATA[<p>该类从抽象超类继承了<code>equals(Object)</code>方法，并从<code>java.lang.Object</code>继承了<code>hashCode()</code>(返回的是对象的身份哈希码，由虚拟机分配的一个任意值)。因此，这个类很可能违反相等对象必须具有相同哈希码的不变量。</p>
<p>如果不希望定义<code>hashCode</code>方法，或者不认为该对象会被放入<code>HashMap/Hashtable</code>中，可以将<code>hashCode()</code>方法定义为抛出<code>UnsupportedOperationException</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_EQUALS_NO_HASHCODE">
    <ShortDescription>类定义了equals()方法但未定义hashCode()方法  Class defines equals() but not hashCode()</ShortDescription>
    <LongDescription>{0} 定义了 equals 但未定义 hashCode</LongDescription>
    <Details>
<![CDATA[<p>该类重写了<code>equals(Object)</code>，但未重写<code>hashCode()</code>。因此，该类可能会违反等价对象必须具有相同哈希码的不变量。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_ABSTRACT_SELF">
    <ShortDescription>抽象类定义了协变的equals()方法  Abstract class defines covariant equals() method</ShortDescription>
    <LongDescription>抽象类 {0} 定义了 equals({0.givenClass}) 方法</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个协变版本的 <code>equals()</code> 方法。为了正确重写 <code>java.lang.Object</code> 中的 <code>equals()</code> 方法，<code>equals()</code> 的参数必须具有类型 <code>java.lang.Object</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ES_COMPARING_STRINGS_WITH_EQ">
    <ShortDescription>使用 `==` 或 `!=` 比较String对象  Comparison of String objects using == or !=</ShortDescription>
    <LongDescription>在{1}中使用==或!=比较String对象。</LongDescription>
    <Details>
<![CDATA[<p>此代码使用 `==` 或 `!=` 运算符比较 `java.lang.String` 对象的引用相等性。除非两个字符串都是源文件中的常量，或者已经通过 `String.intern()` 方法进行intern化，否则相同的字符串值可能会由两个不同的 String 对象表示。建议改为使用 `equals(Object)` 方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ES_COMPARING_PARAMETER_STRING_WITH_EQ">
    <ShortDescription>使用 `==` 或 `!=` 比较 String 参数  Comparison of String parameter using == or !=</ShortDescription>
    <LongDescription>在{1}中使用==或!=比较String参数</LongDescription>
    <Details>
<![CDATA[<p>此代码使用==或!=运算符比较<code>java.lang.String</code>参数的引用相等性。要求调用者仅传递字符串常量或intern化的字符串给方法是不必要的脆弱，并且很少能带来可测量的性能提升。考虑改为使用<code>equals(Object)</code>方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CO_ABSTRACT_SELF">
    <ShortDescription>抽象类定义了协变的compareTo()方法  Abstract class defines covariant compareTo() method</ShortDescription>
    <LongDescription>抽象类 {0} 定义了 compareTo({0.givenClass}) 方法</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个协变版本的 <code>compareTo()</code> 方法。为了正确重写 <code>Comparable</code> 接口中的 <code>compareTo()</code> 方法，<code>compareTo()</code> 的参数必须是类型 <code>java.lang.Object</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IS_FIELD_NOT_GUARDED">
    <ShortDescription>字段未防护以防止并发访问  Field not guarded against concurrent access</ShortDescription>
    <LongDescription>{1.givenClass} 未对并发访问进行保护；有 {2}% 的时间进行了锁定</LongDescription>
    <Details>
<![CDATA[<p>该字段使用了net.jcip.annotations.GuardedBy或javax.annotation.concurrent.GuardedBy进行注解，但似乎以违反这些注解的方式被访问。</p>]]>
</Details>
  </BugPattern>
  <BugPattern type="MSF_MUTABLE_SERVLET_FIELD">
    <ShortDescription>可变的Servlet字段  Mutable servlet field</ShortDescription>
    <LongDescription>{1} 是一个可变的servlet字段</LongDescription>
    <Details>
<![CDATA[<p>通常，Web服务器只会为Servlet或JSP类创建一个实例（即，将类视为单例），并通过该实例的多个线程同时处理请求。因此，拥有可变实例字段往往会引发竞态条件。]]>
    </Details>
  </BugPattern>
  <BugPattern type="IS2_INCONSISTENT_SYNC">
    <ShortDescription>不一致的同步  Inconsistent synchronization</ShortDescription>
    <LongDescription>在不一致的同步中，{1} 被锁定了 {2}% 的时间。</LongDescription>
    <Details>
<![CDATA[<p>此类的字段似乎在同步方面存在不一致的访问方式。此错误报告表明，错误模式检测器判断该：</p>
<ul>
<li>类包含锁定和未锁定访问的混合,</li>
<li>类没有标注为javax.annotation.concurrent.NotThreadSafe,</li>
<li>类的某个方法执行了锁定访问,</li>
<li>未同步字段（读取和写入）的次数不超过总访问次数的三分之一，写操作的权重是读操作的两倍。</li>
</ul>
<p>符合此错误模式的一个典型问题是，在打算线程安全的类中忘记对某个方法进行同步。</p>
<p>你可以选择标记为“未同步访问”的节点，以显示检测器认为字段在未同步的情况下被访问的代码位置。</p>
<p>请注意，此检测器存在各种准确性问题；例如，检测器无法静态地检测所有持有锁的情况。即使检测器能够准确地区分锁定和未锁定的访问，所涉及的代码仍然可能是正确的。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NN_NAKED_NOTIFY">
    <ShortDescription>裸露的notify方法  Naked notify</ShortDescription>
    <LongDescription>在{1}中使用了裸露的通知机制</LongDescription>
    <Details>
<![CDATA[<p>在调用了<code>notify()</code>或<code>notifyAll()</code>方法时，并没有伴随任何（明显）对可变对象状态的修改。通常，调用监视器上的通知方法是因为某个条件已经变得满足，而其他线程正在等待这个条件。然而，为了使这种条件有意义，它必须涉及到两个线程都能看到的堆对象。</p>
<p>此错误不一定表示存在错误，因为对可变对象状态的更改可能在另一个方法中发生，该方法随后调用了包含通知的方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_EXPOSE_REP">
    <ShortDescription>公共静态方法可能通过返回数组暴露内部表示。  Public static method may expose internal representation by returning array</ShortDescription>
    <LongDescription>公共静态块{1}可能通过返回{2.givenClass}来暴露内部表示。</LongDescription>
    <Details>
<![CDATA[<p>一个公共静态方法返回一个数组的引用，该数组是类的静态状态的一部分。任何调用此方法的代码都可以自由修改底层数组。一种修复方法是返回数组的副本。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_REP">
    <ShortDescription>可能通过返回可变对象的引用暴露内部表示形式  May expose internal representation by returning reference to mutable object</ShortDescription>
    <LongDescription>{1} 可能会通过返回 {2.givenClass} 曝露内部表示。</LongDescription>
    <Details>
<![CDATA[<p>返回存储在对象某个字段中的可变对象引用会暴露该对象的内部表示形式。如果实例被不可信代码访问，并且对可变对象的未检查更改会危及安全性或其他重要属性，您就需要采取不同的方法。在许多情况下，返回对象的新副本是一个更好的选择。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_REP2">
    <ShortDescription>可能通过包含对可变对象的引用暴露内部表示。  May expose internal representation by incorporating reference to mutable object</ShortDescription>
    <LongDescription>将可外部修改的对象存储到{2.givenClass}中可能会暴露内部表示。</LongDescription>
    <Details>
<![CDATA[<p>此代码将对外部可变对象的引用存储在对象的内部表示中。如果实例被不可信代码访问，并且对可变对象的未检查更改会危及安全或其他重要属性，您需要采取不同的措施。在许多情况下，存储对象的副本是更好的方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_STATIC_REP2">
    <ShortDescription>可能通过将可变对象存储到静态字段中暴露内部的静态状态  May expose internal static state by storing a mutable object into a static field</ShortDescription>
    <LongDescription>{1} 可能会通过将可变对象存储到静态字段中而暴露内部的静态状态 {2}</LongDescription>
    <Details>
<![CDATA[<p>此代码将对外部可变对象的引用存储在静态字段中。如果未经过检查地修改该可变对象会影响安全或其他重要属性，您需要采取不同的措施。在许多情况下，存储对象的副本是更好的方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_EXPOSE_BUF">
    <ShortDescription>可能通过返回共享非公开数据的缓冲区暴露内部表示。  May expose internal representation by returning a buffer sharing non-public data</ShortDescription>
    <LongDescription>{1} 可能会通过返回 {2.givenClass} 暴露内部表示。</LongDescription>
    <Details>
<![CDATA[<p>一个公共静态方法要么返回一个缓冲区（java.nio.*Buffer），该缓冲区通过仅持有对该类的静态状态中部分数组的引用来包裹一个数组，要么返回一个浅拷贝的缓冲区，该缓冲区也是部分属于类的静态状态，并与原始缓冲区共享其引用。调用此方法的任何代码都可以自由修改底层数组。一种修复方法是返回一个只读缓冲区或一个新的包含数组副本的缓冲区。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_BUF">
    <ShortDescription>可能通过返回共享非公开数据的缓冲区暴露内部表示。  May expose internal representation by returning a buffer sharing non-public data</ShortDescription>
    <LongDescription>{1} 可能会通过返回 {2.givenClass} 暴露内部表示。</LongDescription>
    <Details>
<![CDATA[<p>返回一个缓冲区（java.nio.*Buffer）的引用，该缓冲区封装了对象某个字段中存储的一个数组，会暴露数组元素的内部表示，因为缓冲区只存储对数组的引用而不是复制其内容。同样地，通过使用其duplicate()方法在对象的某个字段中存储此类缓冲区的浅拷贝也会暴露缓冲区的内部表示。如果实例被不可信代码访问，并且对数组的未检查更改会危及安全或其他重要属性，则您需要采取不同的措施。在这种情况下，在许多情况下返回一个只读缓冲区（使用其asReadOnly()方法）或将数组复制到新缓冲区（使用其put()方法）是一个更好的选择。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_BUF2">
    <ShortDescription>可能通过创建包含数组引用的缓冲区来暴露内部表示。  May expose internal representation by creating a buffer which incorporates reference to array</ShortDescription>
    <LongDescription>{1} 可能会通过创建包含外部数组的缓冲区而暴露内部表示形式，并将其传递给 {2.givenClass}。</LongDescription>
    <Details>
<![CDATA[<p>这段代码创建了一个缓冲区，该缓冲区存储了对外部数组或外部缓冲区的引用，并将其表示为对象的内部表示形式。如果这些实例被不可信的代码访问，并且对数组的未检查更改会危及安全或其他重要属性，那么你需要采取不同的措施。在许多情况下，复制数组是一个更好的方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_STATIC_BUF2">
    <ShortDescription>可能通过创建存储外部数组的静态字段来暴露内部静态状态  May expose internal static state by creating a buffer which stores an external array into a static field</ShortDescription>
    <LongDescription>{1} 可能会通过将外部数组存储到静态字段中来暴露内部的静态状态 {2}</LongDescription>
    <Details>
<![CDATA[<p>此代码创建了一个缓冲区，该缓冲区存储了对外部数组或外部缓冲区的引用到一个静态字段中。如果对外部数组进行未检查的修改会危害安全或其他重要属性，您需要采取不同的措施。在许多情况下，复制数组并存储副本是一个更好的方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RU_INVOKE_RUN">
    <ShortDescription>在线程上调用run（您是想启动它而不是调用它吗？）  Invokes run on a thread (did you mean to start it instead?)</ShortDescription>
    <LongDescription>{1} 显式调用了线程的 `run` 方法（您本意是要启动它吗？）</LongDescription>
    <Details>
<![CDATA[<p>此方法显式地在对象上调用了<code>run()</code>方法。通常情况下，类实现<code>Runnable</code>接口是因为它们的<code>run()</code>方法将在新线程中被调用，在这种情况下应该使用<code>Thread.start()</code>来调用。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SP_SPIN_ON_FIELD">
    <ShortDescription>方法依赖于字段的旋转  Method spins on field</ShortDescription>
    <LongDescription>在{1}中绕行{2.givenClass}</LongDescription>
    <Details>
<![CDATA[<p>该方法在一个循环中读取一个字段。编译器可能会合法地将读取操作移出循环，从而使代码变成无限循环。应该修改类以使用适当的同步（包括wait和notify调用）。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NS_DANGEROUS_NON_SHORT_CIRCUIT">
    <ShortDescription>非短路逻辑的潜在危险使用  Potentially dangerous use of non-short-circuit logic</ShortDescription>
    <LongDescription>在{1}中潜在危险地使用了非短路逻辑</LongDescription>
    <Details>
<![CDATA[<p>这段代码似乎使用了非短路逻辑（例如，& 或 |）而不是短路逻辑（&& 或 ||）。此外，根据左侧的值，你可能不想评估右侧（因为这可能会引起副作用、抛出异常或非常昂贵。</p>

<p>非短路逻辑会导致表达式的两边都被评估，即使可以根据左边的结果推断结果。这可能会降低效率，并且如果左边作为条件判断右侧会发生错误的情况，则可能导致错误。</p>

<p>详细内容请参见 <a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.22.2">Java 语言规范</a>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NS_NON_SHORT_CIRCUIT">
    <ShortDescription>非短路逻辑的可疑使用  Questionable use of non-short-circuit logic</ShortDescription>
    <LongDescription>在 {1} 中使用了不可短路逻辑的可疑用法</LongDescription>
    <Details>
<![CDATA[<p>这段代码似乎使用了非短路逻辑（例如，& 或 |），而不是短路逻辑（&& 或 ||）。非短路逻辑会导致表达式的两边都被评估，即使可以根据左半部分的结果来推断结果也是如此。这可能会导致效率降低，并且如果左半部分用于保护某些情况，在评估右半部分时会产生错误。 <p>详细内容请参见 <a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.22.2">Java 语言规范</a>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="TLW_TWO_LOCK_WAIT">
    <ShortDescription>持有两个锁时，请等待。  Wait with two locks held</ShortDescription>
    <LongDescription>在{1}中持有两个锁的情况下调用wait()</LongDescription>
    <Details>
<![CDATA[<p>在持有一个以上的锁的同时调用wait可能会导致死锁。调用wait只会释放被等待对象上的锁，而不会释放其他任何锁。这不一定就是错误，但值得仔细检查。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="TLW_TWO_LOCK_NOTIFY" deprecated="true"> <!-- never generated -->
    <ShortDescription>持有两个锁进行通知  Notify with two locks held</ShortDescription>
    <LongDescription>在{1}中持有了两个锁的情况下使用notify()或notifyAll*()方法</LongDescription>
    <Details>
<![CDATA[<p>代码在持有两个锁的情况下调用了notify()或notifyAll()。如果这种通知是为了唤醒另一个正在持有相同锁的wait()，可能会导致死锁，因为wait只会释放一个锁，而notify将无法获取这两个锁，从而导致通知失败。如果有关于双锁wait的通知警告，那么存在bug的可能性相当高。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UW_UNCOND_WAIT">
    <ShortDescription>无条件等待  Unconditional wait</ShortDescription>
    <LongDescription>在{1}中无条件等待</LongDescription>
    <Details>
<![CDATA[<p>该方法包含对 <code>java.lang.Object.wait()</code> 的调用，但没有用条件控制流进行防护。代码应在调用 wait 之前验证它打算等待的条件是否已经满足；否则，任何先前的通知都将被忽略。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UR_UNINIT_READ">
    <ShortDescription>在构造函数中读取未初始化的字段  Uninitialized read of field in constructor</ShortDescription>
    <LongDescription>在{1}中对未初始化的{2.name}进行了读取</LongDescription>
    <Details>
<![CDATA[<p>该构造函数读取了一个尚未被赋值的字段。这通常是由程序员错误地使用了字段而不是构造函数的一个参数引起的。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UR_UNINIT_READ_CALLED_FROM_SUPER_CONSTRUCTOR">
    <ShortDescription>从超类构造函数中调用对未初始化字段的方法  Uninitialized read of field method called from constructor of superclass</ShortDescription>
    <LongDescription>在从超类构造函数调用时，{1}.{2.name} 没有被初始化。</LongDescription>
    <Details>
<![CDATA[<p>此方法在超类构造器中调用。此时，类的字段尚未初始化。</p>
<p>为了使这一点更加具体，请考虑以下类：</p>
<pre><code>抽象类 A {
    int hashCode;
    抽象 Object getValue();

    A() {
        hashCode = getValue().hashCode();
    }
}

类 B 扩展 A {
    Object value;

    B(Object v) {
        this.value = v;
    }

    Object getValue() {
        return value;
    }
}
</code></pre>
<p>当构造一个 <code>B</code> 时，<code>A</code> 类的构造器在 <code>B</code> 的构造器设置 <code>value</code> 之前被调用。因此，当 <code>A</code> 构造器调用 <code>getValue</code> 时，会读取未初始化的 <code>value</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UG_SYNC_SET_UNSYNC_GET">
    <ShortDescription>未同步的get方法，同步的set方法  Unsynchronized get method, synchronized set method</ShortDescription>
    <LongDescription>{1} 是未同步的，{2} 是已同步的</LongDescription>
    <Details>
<![CDATA[<p>此类包含同名的 get 和 set 方法，其中 set 方法是同步的而 get 方法不是。这可能会导致在运行时出现错误行为，因为调用 get 方法的代码不一定能够看到对象的一致状态。get 方法应该也被声明为同步的。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IC_INIT_CIRCULARITY">
    <ShortDescription>初始化循环依赖  Initialization circularity</ShortDescription>
    <LongDescription>在{0}和{1}之间存在初始化循环。</LongDescription>
    <Details>
<![CDATA[<p>检测到了两个由错误实例引用的类的静态初始化器中的循环依赖问题。此类循环可能会导致许多不可预期的行为。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION">
    <ShortDescription>在初始化过程中，超类使用了子类。  Superclass uses subclass during initialization</ShortDescription>
    <LongDescription>初始化{0}访问了类{2}，但该类尚未初始化。</LongDescription>
    <Details>
<![CDATA[在类的初始化过程中，该类主动使用了一个子类。此时子类还未完成初始化。例如，在以下代码中，`foo` 将会是 `null`。

```java
public class CircularClassInitialization {     
    static class InnerClassSingleton extends CircularClassInitialization {       
        static InnerClassSingleton singleton = new InnerClassSingleton();     
    }     
    
    static CircularClassInitialization foo = InnerClassSingleton.singleton; 
}
```]]>
    </Details>
  </BugPattern>
  <BugPattern type="IT_NO_SUCH_ELEMENT">
    <ShortDescription>Iterator的next()方法不能抛出NoSuchElementException异常。  Iterator next() method can't throw NoSuchElementException</ShortDescription>
    <LongDescription>{1} 不得抛出 NoSuchElementException 异常。</LongDescription>
    <Details>
<![CDATA[<p>这个类实现了<code>java.util.Iterator</code>接口。然而，其<code>next()</code>方法不能抛出<code>java.util.NoSuchElementException</code>。应将<code>next()</code>方法修改为，在没有更多元素可返回时调用该方法时抛出<code>NoSuchElementException</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DL_SYNCHRONIZATION_ON_SHARED_CONSTANT">
    <ShortDescription>同步在interned字符串上  Synchronization on interned String</ShortDescription>
    <LongDescription>在 `{1}` 中对 interned String 进行同步</LongDescription>
    <Details>
<![CDATA[<p>代码使用interned String进行同步。</p>
<pre><code>private static String LOCK = "LOCK"; ... synchronized(LOCK) {     ... } ... </code></pre>
<p>常量字符串会被intern并由JVM加载的所有其他类共享。因此，这段代码是在锁定其他代码也可能锁定的对象上。这可能会导致非常奇怪且难以诊断的阻塞和死锁行为。详见 <a href="http://www.javalobby.org/java/forums/t96352.html">http://www.javalobby.org/java/forums/t96352.html</a> 和 <a href="http://jira.codehaus.org/browse/JETTY-352">http://jira.codehaus.org/browse/JETTY-352</a>。</p>
<p>详见CERT <a href="https://www.securecoding.cert.org/confluence/display/java/CON08-J.+Do+not+synchronize+on+objects+that+may+be+reused">CON08-J. Do not synchronize on objects that may be reused</a> 获取更多信息。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DL_SYNCHRONIZATION_ON_BOOLEAN">
    <ShortDescription>同步布尔值  Synchronization on Boolean</ShortDescription>
    <LongDescription>在{1}中对布尔值进行同步</LongDescription>
    <Details>
      <![CDATA[<p>代码使用一个装箱原始常量（例如 Boolean）进行同步。</p>
<pre><code>private static Boolean inited = Boolean.FALSE; ... synchronized(inited) {     if (!inited) {   init();   inited = Boolean.TRUE;     } } ... </code></pre>
<p>由于通常只有两个 Boolean 对象，这段代码可能会与其他无关的代码同步到同一个对象上，导致响应性差并且可能引发死锁。</p>
<p>请参阅 CERT <a href="https://www.securecoding.cert.org/confluence/display/java/CON08-J.+Do+not+synchronize+on+objects+that+may+be+reused">CON08-J. 不要在可能会被重用的对象上进行同步</a> 以获取更多信息。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DL_SYNCHRONIZATION_ON_UNSHARED_BOXED_PRIMITIVE">
    <ShortDescription>同步操作基于装箱原始值  Synchronization on boxed primitive values</ShortDescription>
    <LongDescription>在 {1} 中对 {2} 进行同步</LongDescription>
    <Details>
      <![CDATA[<p>代码对一个显式未共享的装箱原始类型进行同步，例如一个Integer。</p>
<pre><code>private static final Integer fileLock = new Integer(1); ... synchronized(fileLock) {     .. 做一些事情 .. } ... </code></pre>
<p>在这一段代码中，最好将fileLock重新声明为</p>
<pre><code>private static final Object fileLock = new Object(); </code></pre>
<p>现有的代码可能没有问题，但这样做会让人困惑。将来进行重构时（例如使用IntelliJ中的“移除装箱”重构），可能会用到整个JVM中共享的interned Integer对象，这会导致行为混乱甚至出现死锁。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DL_SYNCHRONIZATION_ON_BOXED_PRIMITIVE">
    <ShortDescription>同步操作涉及装箱原始类型  Synchronization on boxed primitive</ShortDescription>
    <LongDescription>在{1}中对{2}进行同步</LongDescription>
    <Details>
      <![CDATA[<p>代码使用了一个装箱原始常量（例如，Integer）进行同步。</p>
<pre><code>private static Integer count = 0; ... synchronized(count) {     count++; } ... </code></pre>
<p>由于Integer对象可以被缓存并共享，这段代码可能会与其他无关的代码同步在同一个对象上，导致响应性差甚至可能出现死锁。</p>
<p>有关更多信息，请参阅CERT <a href="https://www.securecoding.cert.org/confluence/display/java/CON08-J.+Do+not+synchronize+on+objects+that+may+be+reused">CON08-J. 不要在可能被重用的对象上进行同步</a>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ESync_EMPTY_SYNC">
    <ShortDescription>空的同步块  Empty synchronized block</ShortDescription>
    <LongDescription>在 `{1}` 中存在空的同步块</LongDescription>
    <Details>
<![CDATA[<p>代码中包含一个空的同步块：</p>
<pre><code>synchronized() { }
</code></pre>
<p>空的同步块比大多数人认识到的还要微妙和难以正确使用，而且空的同步块几乎从来都不是比更加巧妙的解决方案更好的选择。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IS_INCONSISTENT_SYNC">
    <ShortDescription>不一致的同步  Inconsistent synchronization</ShortDescription>
    <LongDescription>{1}的一致同步性问题；锁住{2}%的时间</LongDescription>
    <Details>
<![CDATA[<p>此类的字段似乎在同步方面存在不一致的访问情况。这个错误报告指出，错误模式检测器判断该：</p>
<ul>
    <li>类中混用了加锁和未加锁的访问,</li>
    <li>至少有一个加锁的访问是由该类自己的方法执行的,</li>
    <li>未同步字段访问（读取和写入）的数量不超过所有访问的三分之一，写操作被赋予两倍于读操作的重要性</li>
</ul>
<p>符合这种错误模式的一个典型示例是在设计为线程安全的类中忘记对一个方法进行同步。</p>
<p>请注意，此检测器存在多种不准确性来源；例如，检测器不能静态地检测所有持有锁的情况。即使检测器能够准确地区分加锁和未加锁的访问，被检查的代码也可能是正确的。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ML_SYNC_ON_FIELD_TO_GUARD_CHANGING_THAT_FIELD">
    <ShortDescription>在尝试保护字段时对字段进行同步，但这是一种徒劳的努力  Synchronization on field in futile attempt to guard that field</ShortDescription>
    <LongDescription>在{2.givenClass}上进行同步，这是一种徒劳的努力，试图保护它</LongDescription>
    <Details>
<![CDATA[<p>此方法在似乎试图防止同时更新该字段时对一个字段进行同步。但是，保护一个字段实际上是获取引用对象的锁，而不是字段本身的锁。这可能无法提供你需要的互斥性，并且其他线程可能会为了其他目的而获取引用对象的锁。这种模式的一个例子如下：</p>
<pre><code>private Long myNtfSeqNbrCounter = new Long(0);
private Long getNotificationSequenceNumber() {
    Long result = null;
    synchronized(myNtfSeqNbrCounter) {
        result = new Long(myNtfSeqNbrCounter.longValue() + 1);
        myNtfSeqNbrCounter = new Long(result.longValue());
    }
    return result;
}
</code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ML_SYNC_ON_UPDATED_FIELD">
    <ShortDescription>方法在更新后的字段上进行同步  Method synchronizes on an updated field</ShortDescription>
    <LongDescription>在更新字段 {2.givenClass} 时进行了同步操作。</LongDescription>
    <Details>
<![CDATA[<p>该方法对一个引用了可变字段的对象进行同步。由于不同的线程可能会对不同的对象进行同步，因此这种做法不太 likely 会有有用的语义。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_OOI_PKGPROTECT">
    <ShortDescription>字段应该从接口中移动出来，并且改为包私有访问级别  Field should be moved out of an interface and made package protected</ShortDescription>
    <LongDescription>{1} 应该从接口中移出，并改为包私有访问级别</LongDescription>
    <Details>
<![CDATA[<p>在一个接口中定义的final static字段引用了一个可变对象，如数组或哈希表。这个可变对象可能会被恶意代码或从另一个包中的意外操作修改。为了解决这个问题，需要将该字段移动到一个类中，并将其改为包私有，以避免这种漏洞。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_FINAL_PKGPROTECT">
    <ShortDescription>字段应当既是final的，又是包私有（package-private）的。  Field should be both final and package protected</ShortDescription>
    <LongDescription>{1} 应该同时是 final 和包访问级别</LongDescription>
    <Details>
<![CDATA[<p>    可变的静态字段可能会被恶意代码或来自其他包的意外操作更改。可以将该字段改为包保护级别和/或将之声明为final以避免此漏洞。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_SHOULD_BE_REFACTORED_TO_BE_FINAL">
    <ShortDescription>字段不是最终变量，但应当重构为最终变量。  Field isn't final but should be refactored to be so</ShortDescription>
    <LongDescription>{1} 不是最终变量，但应当重构为最终变量。</LongDescription>
    <Details>
<![CDATA[<p>这个静态字段是 public 但不是 final，因此可能会被恶意代码或意外从另一个包中修改。可以通过将字段设为 final 来避免这种漏洞。然而，静态初始化器包含对字段的多次写入操作，所以这样做需要进行一些重构。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_SHOULD_BE_FINAL">
    <ShortDescription>字段不是最终变量但应当是  Field isn't final but should be</ShortDescription>
    <LongDescription>{1} 不是最终变量但应该被声明为最终变量</LongDescription>
    <Details>
<![CDATA[<p>这是一个静态字段，被声明为public但不是final的，因此可能会被恶意代码或不小心从另一个包中更改。可以将该字段声明为final以避免此漏洞。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_PKGPROTECT">
    <ShortDescription>字段应为包私有访问修饰符  Field should be package protected</ShortDescription>
    <LongDescription>{1} 应该是包私有访问级别</LongDescription>
    <Details>
<![CDATA[<p>可变的静态字段可能被恶意代码或偶然更改。可以将该字段改为包保护级别以避免此漏洞。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_MUTABLE_HASHTABLE">
    <ShortDescription>字段是一个可变的Hashtable。  Field is a mutable Hashtable</ShortDescription>
    <LongDescription>{1} 是一个可变的Hashtable。</LongDescription>
    <Details>
<![CDATA[<p>一个最终静态字段引用了一个Hashtable，并且可以被恶意代码或不小心从另一个包中访问。这段代码可以自由地修改Hashtable的内容。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_MUTABLE_COLLECTION">
    <ShortDescription>字段是一个可变集合  Field is a mutable collection</ShortDescription>
    <LongDescription>{1} 是一个可变集合。</LongDescription>
    <Details>
<![CDATA[<p>将可变集合实例分配给一个最终静态字段，因此可能会被恶意代码或不小心从另一个包中修改。考虑使用 Collections.unmodifiableSet/List/Map 等方法对该字段进行包装，以避免此漏洞。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_MUTABLE_COLLECTION_PKGPROTECT">
    <ShortDescription>Field 是一个可变集合，应设为包私有。  Field is a mutable collection which should be package protected</ShortDescription>
    <LongDescription>{1} 是一个可变集合，应该声明为包私有。</LongDescription>
    <Details>
<![CDATA[<p>将可变集合实例赋值给一个最终静态字段，从而可能被恶意代码或另一个包中的意外操作修改。可以将该字段改为包保护级别以避免此漏洞。 alternatively, 您也可以通过使用 Collections.unmodifiableSet/List/Map 等方法来包裹这个字段，以避免此漏洞。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_MUTABLE_ARRAY">
    <ShortDescription>字段是一个可变数组  Field is a mutable array</ShortDescription>
    <LongDescription>{1} 是一个可变数组。</LongDescription>
    <Details>
<![CDATA[<p>一个最终静态字段引用了一个数组，可能会被恶意代码或意外地从另一个包中访问。这段代码可以自由修改数组的内容。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_CANNOT_BE_FINAL">
    <ShortDescription>字段不是最终变量，无法防止恶意代码对其进行保护  Field isn't final and can't be protected from malicious code</ShortDescription>
    <LongDescription>{1} 不是 final 的，无法防止恶意代码对其进行保护。</LongDescription>
    <Details>
<![CDATA[<p>可变的静态字段可能会被恶意代码或另一包中的意外操作改变。不幸的是，字段的使用方式并不允许对此问题进行简单的修复。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ME_MUTABLE_ENUM_FIELD">
    <ShortDescription>枚举字段是公共可变的  Enum field is public and mutable</ShortDescription>
    <LongDescription>{1}字段是公共可变的</LongDescription>
    <Details>
<![CDATA[<p>在一个公共枚举中定义了一个可变的公共字段，因此可能会被恶意代码或意外地从其他包更改。尽管可以使用可变的枚举字段进行懒加载初始化，但将它们暴露给外部世界不是一个好习惯。考虑将此字段声明为 final 和/或将访问级别改为包私有。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ME_ENUM_FIELD_SETTER">
    <ShortDescription>公共枚举方法无条件地设置其字段  Public enum method unconditionally sets its field</ShortDescription>
    <LongDescription>{1} 无条件地设置了字段 {2.name}</LongDescription>
    <Details>
<![CDATA[<p>这个在公共枚举中声明的公共方法无条件地设置了枚举字段，因此该字段可以从另一个包中的恶意代码或意外更改。尽管可变枚举字段可以用于懒汉初始化，但向外部暴露它们是一种不良实践。考虑移除此方法或将其实限为包私有。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IA_AMBIGUOUS_INVOCATION_OF_INHERITED_OR_OUTER_METHOD">
    <ShortDescription>可能具有歧义的调用，可能是继承来的或外部的方法  Potentially ambiguous invocation of either an inherited or outer method</ShortDescription>
    <LongDescription>在 {1} 中可能存在二义性调用，可能是外部方法 {2} 或继承的方法。</LongDescription>
    <Details>
<![CDATA[<p>一个内部类调用了既可以解析为继承的方法也可以解析为外部类中定义的方法。例如，你调用了<code>foo(17)</code>，这个方法既在超类中定义也在外部类中定义。根据Java语义，它将被解析为调用继承的方法，但这可能不是你的意图。</p>
<p>如果你确实想调用继承的方法，请通过super调用该方法（例如，调用<code>super.foo(17)</code>），这样其他阅读你代码的人和SpotBugs就可以清楚地知道你想调用继承的方法而不是外部类中的方法。</p>
<p>如果你调用了<code>this.foo(17)</code>，则会调用继承的方法。然而，由于SpotBugs只能查看类文件，它无法区分<code>this.foo(17)</code>和<code>foo(17)</code>的调用，因此仍然会报错提示可能存在含糊的调用。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_SAME_SIMPLE_NAME_AS_SUPERCLASS">
    <ShortDescription>类名不应该与超类的简单名称相同shadow  Class names shouldn't shadow simple name of superclass</ShortDescription>
    <LongDescription>类名 {0} � contrast 了超类的简单名称 {1}</LongDescription>
    <Details>
<![CDATA[<p>这个类的简单名称与其超类相同，只是其超类在不同的包中（例如，`alpha.Foo` 扩展了 `beta.Foo`）。这可能会极其混淆，在很多情况下你需要查看导入语句来解析引用，并且会有很多机会不小心定义不覆盖超类方法的方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_SAME_SIMPLE_NAME_AS_INTERFACE">
    <ShortDescription>类名不应该遮蔽实现接口的简单名称  Class names shouldn't shadow simple name of implemented interface</ShortDescription>
    <LongDescription>类名 {0} � contrasted 着 实现的接口 {1} 的简单名称</LongDescription>
    <Details>
<![CDATA[<p>该类/接口的简单名称与实现/扩展的接口的简单名称相同，仅包不同（例如，<code>alpha.Foo</code> 实现了 <code>beta.Foo</code>）。这可能会造成极大的混淆，在引用时需要查看导入语句来解析引用，并且会有很多机会不小心定义的方法不能覆盖超类中的方法。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_CLASS_NAMING_CONVENTION">
    <ShortDescription>类名应以大写字母开头  Class names should start with an upper case letter</ShortDescription>
    <LongDescription>类名 {0} 没有以大写字母开头</LongDescription>
    <Details>
<![CDATA[<p>类名应为名词，采用混合大小写的形式，每个内部单词的首字母大写。尽量使类名简单且具有描述性。使用完整的单词，避免使用缩写和简称（除非该缩写比长名称更为人所知，例如 URL 或 HTML）。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_METHOD_NAMING_CONVENTION">
    <ShortDescription>方法名应以小写字母开头  Method names should start with a lower case letter</ShortDescription>
    <LongDescription>方法名 `{1}` 没有以小写字母开头</LongDescription>
    <Details>
<![CDATA[<p>方法应使用动词，并采用混合大小写的形式，首字母小写，内部单词的首字母大写。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_FIELD_NAMING_CONVENTION">
    <ShortDescription>字段名应以小写字母开头  Field names should start with a lower case letter</ShortDescription>
    <LongDescription>字段名称 {1} 没有以小写字母开头</LongDescription>
    <Details>
<![CDATA[<p>如果不是最终字段的名称应该采用混合大小写格式，首字母小写，后续单词的首字母大写。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_VERY_CONFUSING">
    <ShortDescription>非常混淆的方法名称  Very confusing method names</ShortDescription>
    <LongDescription>在方法 {1} 和 {3} 中使用方法非常令人困惑。</LongDescription>
    <Details>
<![CDATA[<p>引用的方法名称仅在大小写上有所不同。这非常混乱，因为如果大小写完全相同，则一个方法将覆盖另一个方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_VERY_CONFUSING_INTENTIONAL">
    <ShortDescription>方法名非常混乱（但可能是故意的）  Very confusing method names (but perhaps intentional)</ShortDescription>
    <LongDescription>方法 `{1}` 和 `{3}` 的命名非常令人困惑（也许这是故意的）。</LongDescription>
    <Details>
<![CDATA[<p>引用的方法名称仅通过大小写不同。这非常令人困惑，因为如果大小写相同，则其中一个方法将覆盖另一个方法。从其他方法的存在来看，似乎这两个方法都存在是有意的，但这确实很让人迷惑。你应该尽量消除其中的一个方法，除非由于冻结的API不得不同时使用它们。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_WRONG_PACKAGE">
    <ShortDescription>方法由于参数的错误包名而不覆盖超类中的方法  Method doesn't override method in superclass due to wrong package for parameter</ShortDescription>
    <LongDescription>{1} 没有覆盖超类中的方法，因为参数类型 {4} 不匹配超类的参数类型 {5}</LongDescription>
    <Details>
<![CDATA[<p>子类中的方法并没有覆盖父类中一个相似的方法，因为参数的类型与 superclass 中对应参数的类型不完全匹配。例如，如果你有以下代码：</p>
<pre><code>import alpha.Foo;  
public class A {  
    public int f(Foo x) { return 17; }  
}  
----  
import beta.Foo;  
public class B extends A {  
    public int f(Foo x) { return 42; }  
}  
</code></pre>
<p>类 <code>B</code> 中定义的 <code>f(Foo)</code> 方法并没有覆盖类 <code>A</code> 中定义的 <code>f(Foo)</code> 方法，因为参数类型来自不同的包。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_WRONG_PACKAGE_INTENTIONAL">
    <ShortDescription>方法由于参数的错误包名而不覆盖超类中的方法  Method doesn't override method in superclass due to wrong package for parameter</ShortDescription>
    <LongDescription>{1} 没有覆盖上级类中的方法，因为参数类型 {4} 与上级类中的参数类型 {5} 不匹配。</LongDescription>
    <Details>
<![CDATA[<p>子类中的方法没有覆盖超类中类似的某个方法，因为参数的类型与超类中对应参数的类型不完全匹配。例如，假设你有以下代码：</p>
<pre><code>import alpha.Foo;  
public class A {     
    public int f(Foo x) { return 17; } 
} ---- import beta.Foo;  
public class B extends A {     
    public int f(Foo x) { return 42; }     
    public int f(alpha.Foo x) { return 27; } 
}</code></pre>
<p>子类 <code>B</code> 中定义的 <code>f(Foo)</code> 方法并没有覆盖超类 <code>A</code> 中定义的 <code>f(Foo)</code> 方法，因为参数类型来自不同的包。</p>
<p>在这种情况下，子类确实定义了一个与 superclass 中方法签名完全相同的 method，因此这似乎是可以理解的。但是，这样的方法会非常令人困惑。你应该强烈考虑移除或弃用具有相似但不相同签名的方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_CONFUSING">
    <ShortDescription>混淆的方法名称  Confusing method names</ShortDescription>
    <LongDescription>方法 {1} 和 {3} 看起来有点混淆。</LongDescription>
    <Details>
<![CDATA[<p>引用的方法名称仅通过大小写不同。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_METHOD_CONSTRUCTOR_CONFUSION">
    <ShortDescription>方法/构造器混淆  Apparent method/constructor confusion</ShortDescription>
    <LongDescription>{1} 可能被意图用作构造函数。</LongDescription>
    <Details>
<![CDATA[<p>该方法的名称与定义它的类相同。这很可能是一个构造函数。如果确实是要定义一个构造函数，应移除返回类型为 void 的声明。如果您不小心定义了此方法并意识到错误，在实现兼容性的情况下仍无法删除该方法，则可以对该方法进行弃用处理。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_LCASE_HASHCODE">
    <ShortDescription>类定义了hashcode()；应该写作hashCode()？  Class defines hashcode(); should it be hashCode()?</ShortDescription>
    <LongDescription>类 {0} 中定义了 `hashcode()`；应该写作 `hashCode()` 吗？</LongDescription>
    <Details>
<![CDATA[<p>该类定义了一个名为<code>hashcode()</code>的方法。这个方法没有重写来自<code>java.lang.Object</code>的<code>hashCode()</code>方法，这可能是作者的本意。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_LCASE_TOSTRING">
    <ShortDescription>类定义了tostring()；应该使用toString()？  Class defines tostring(); should it be toString()?</ShortDescription>
    <LongDescription>类 {0} 定义了 `tostring()`；应该使用 `toString()` 吗？</LongDescription>
    <Details>
<![CDATA[<p>该类定义了一个名为<code>tostring()</code>的方法。这个方法并未覆盖<code>java.lang.Object</code>中的<code>toString()</code>方法，这可能是作者的本意。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_BAD_EQUAL">
    <ShortDescription>Class 定义了 equal(Object)；应该使用 equals(Object) 吗？  Class defines equal(Object); should it be equals(Object)?</ShortDescription>
    <LongDescription>类 {0} 定义了 `equal(Object)`，应该使用 `equals(Object)` 吗？</LongDescription>
    <Details>
<![CDATA[<p>该类定义了一个方法<code>equal(Object)</code>。此方法并未覆盖来自<code>java.lang.Object</code>的<code>equals(Object)</code>方法，这可能是开发者原本的意图。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_CLASS_NOT_EXCEPTION">
    <ShortDescription>类虽然名为异常类，但并没有继承自Exception。  Class is not derived from an Exception, even though it is named as such</ShortDescription>
    <LongDescription>类 {0} 没有继承自 Exception，尽管它的名称表明它是一个异常类。</LongDescription>
    <Details>
<![CDATA[<p>这个类没有继承其他异常，但以‘Exception’结尾。这会让使用这个类的用户感到困惑。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RR_NOT_CHECKED">
    <ShortDescription>Method忽略了InputStream.read()的方法结果  Method ignores results of InputStream.read()</ShortDescription>
    <LongDescription>{1} 忽略了 {2} 的结果</LongDescription>
    <Details>
<![CDATA[<p>此方法忽略了 <code>java.io.InputStream.read()</code> 的一个变体的返回值，该方法可以返回多个字节。如果不检查返回值，调用者将无法正确处理实际读取的字节数少于请求字节数的情况。这是一种特别危险的bug，因为在许多程序中，从输入流中读取通常会读取完整个请求的数据，导致程序仅偶尔失败。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SR_NOT_CHECKED">
    <ShortDescription>方法忽略了 `InputStream.skip()` 的结果。  Method ignores results of InputStream.skip()</ShortDescription>
    <LongDescription>{1} 忽略了 {2} 的结果</LongDescription>
    <Details>
<![CDATA[<p>此方法忽略了 <code>java.io.InputStream.skip()</code> 的返回值，该方法可以跳过多个字节。如果不检查返回值，调用者将无法正确处理实际跳过的字节数少于请求的字节数的情况。这是一种特别危险的错误类型，在许多程序中，从输入流中的跳过操作通常会跳过全部要求的字节数据，导致程序仅在偶尔情况下失败。然而，在使用缓冲流的情况下，<code>skip()</code> 只会在缓冲区中跳过数据，并且经常无法跳过请求的完整字节数。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_READ_RESOLVE_IS_STATIC">
    <ShortDescription>readResolve 方法不得声明为静态方法。  The readResolve method must not be declared as a static method.</ShortDescription>
    <LongDescription>{1} 应该声明为实例方法而非静态方法。</LongDescription>
    <Details>
<![CDATA[<p>为了使读取解析方法被序列化机制识别，它不能声明为静态方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_PRIVATE_READ_RESOLVE_NOT_INHERITED">
    <ShortDescription>私有readResolve方法不会被子类继承  Private readResolve method not inherited by subclasses</ShortDescription>
    <LongDescription>在{0}中未声明私有的readResolve方法，并且其子类也没有继承该方法。</LongDescription>
    <Details>
<![CDATA[<p>该类定义了一个私有的 readResolve 方法。由于是私有的，因此不会被子类继承。这可能是有意为之并且是可以接受的，但应该进行审查以确保这是预期的行为。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_READ_RESOLVE_MUST_RETURN_OBJECT">
    <ShortDescription>readResolve 方法必须声明为返回类型为 Object。  The readResolve method must be declared with a return type of Object.</ShortDescription>
    <LongDescription>方法 `{1}` 必须声明为返回类型为 `Object` 而不是 `{1.returnType}`</LongDescription>
    <Details>
<![CDATA[<p>为了使readResolve方法被序列化机制识别，必须将其返回类型声明为Object。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_TRANSIENT_FIELD_OF_NONSERIALIZABLE_CLASS">
    <ShortDescription>类中的 transient 字段不是可序列化的。  Transient field of class that isn't Serializable.</ShortDescription>
    <LongDescription>`{1.givenClass}` 是 transient 的，但 `{0}` 没有实现 Serializable 接口。</LongDescription>
    <Details>
<![CDATA[<p>该字段被标记为 transient，但类并未实现 Serializable，因此对该字段进行 transient 标记实际上没有任何效果。这可能是之前版本的代码中类实现了 Serializable 而遗留下来的标记，或者表明对序列化的工作原理存在误解。</p>
<p><em>仅在设置了特殊选项 <tt>reportTransientFieldOfNonSerializableClass</tt> 时才会报告此错误。</em></p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_TRANSIENT_FIELD_NOT_RESTORED">
    <ShortDescription>反序列化时不被设置的 transient 字段。  Transient field that isn't set by deserialization.</ShortDescription>
    <LongDescription>字段 {1} 是 transient 的，但在反序列化时并未被设置。</LongDescription>
    <Details>
<![CDATA[<p>该类包含一个在多个地方被更新的字段，因此似乎它是类的状态的一部分。然而，由于该字段被标记为transient，并且不在readObject或readResolve中设置，所以在类的任何反序列化实例中该字段都将包含默认值。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_METHOD_MUST_BE_PRIVATE">
    <ShortDescription>为了使序列化生效，该方法必须是私有的。  Method must be private in order for serialization to work</ShortDescription>
    <LongDescription>方法 `{1.givenClass}` 必须是私有方法，才能在 `{0}` 的序列化/反序列化中被调用。</LongDescription>
    <Details>
<![CDATA[<p>该类实现了<code>Serializable</code>接口，并定义了一个用于自定义序列化/反序列化的方法。但由于该方法没有声明为私有，因此会被序列化/反序列化API默默地忽略。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION">
    <ShortDescription>类实现了Externalizable接口，但没有定义无参构造函数。  Class is Externalizable but doesn't define a void constructor</ShortDescription>
    <LongDescription>{0}实现了Externalizable接口，但没有定义一个无参构造函数。</LongDescription>
    <Details>
<![CDATA[<p>该类实现了<code>Externalizable</code>接口，但没有定义公共空构造函数。当反序列化Externalizable对象时，它们首先需要通过调用公共空构造函数来构建。由于该类没有定义这样的构造函数，在运行时进行序列化和反序列化将失败。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NO_SUITABLE_CONSTRUCTOR">
    <ShortDescription>类实现了Serializable接口，但其超类没有定义一个无参构造函数。  Class is Serializable but its superclass doesn't define a void constructor</ShortDescription>
    <LongDescription>{0}实现了Serializable接口，但其超类没有定义可访问的无参构造函数。</LongDescription>
    <Details>
<![CDATA[<p>该类实现了 `Serializable` 接口，而其超类并未实现。当此类的对象被反序列化时，需要通过调用超类的无参构造函数来初始化超类的字段。由于超类并没有提供无参构造函数，因此在运行时进行序列化和反序列化将会失败。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NO_SERIALVERSIONID">
    <ShortDescription>类是可序列化的，但没有定义serialVersionUID  Class is Serializable, but doesn't define serialVersionUID</ShortDescription>
    <LongDescription>{0} 实现了 Serializable 接口；考虑声明一个 serialVersionUID。</LongDescription>
    <Details>
<![CDATA[<p>该类实现了 <code>Serializable</code> 接口，但没有定义 <code>serialVersionUID</code> 字段。简单的更改（如添加对 .class 对象的引用）将会向类中添加合成字段，不幸的是这会改变隐式的 <code>serialVersionUID</code>（例如，添加对 <code>String.class</code> 的引用将生成一个静态字段 <code>class$java$lang$String</code>）。另外，不同的源代码到字节码编译器可能会使用不同的命名约定来为对象类或内部类的引用生成合成变量。为了确保版本之间的序列化互操作性，可以考虑添加一个显式的 <code>serialVersionUID</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_COMPARATOR_SHOULD_BE_SERIALIZABLE">
    <ShortDescription>Comparator 没有实现 Serializable 接口  Comparator doesn't implement Serializable</ShortDescription>
    <LongDescription>{0} 实现了 Comparator 但未实现 Serializable</LongDescription>
    <Details>
<![CDATA[<p>该类实现了<code>Comparator</code>接口。您应该考虑它是否也应该实现<code>Serializable</code>接口。如果使用比较器来构造有序集合（例如，<code>TreeMap</code>），那么只有当比较器也是可序列化的情况下，<code>TreeMap</code>才会是可序列化的。由于大多数比较器几乎没有或没有状态，使其实现可序列化通常是很简单且符合防御性编程的良好实践。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SF_SWITCH_FALLTHROUGH">
    <ShortDescription>在 Switch 语句中发现一个 case 跳转到了下一个 case 中  Switch statement found where one case falls through to the next case</ShortDescription>
    <LongDescription>在 {1} 中发现 switch 语句，其中某个 case 意味着会直接跳到下一个 case 继续执行。</LongDescription>
    <Details>
<![CDATA[<p>该方法包含一个 switch 语句，其中一种情况分支将会延续到下一个情况。通常你需要在这种情况结束处加上 break 或 return。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SF_SWITCH_NO_DEFAULT">
    <ShortDescription>在缺少默认情况"default case"的情况下找到了 switch 语句  Switch statement found where default case is missing</ShortDescription>
    <LongDescription>在 {1} 中发现了 switch 语句，但缺少默认情况"default case"。</LongDescription>
    <Details>
<![CDATA[<p>此方法包含一个缺少默认情况"default case"的switch语句。通常情况下，你需要提供一个默认情况。</p>
<p>由于分析仅检查生成的字节码，在switch语句没有包含其他情况的break语句且默认情况位于switch语句末尾时，此警告可能会被错误触发。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH">
    <ShortDescription>由于switch语句的fall through导致的死存储  Dead store due to switch statement fall through</ShortDescription>
    <LongDescription>从之前的用例来看，{2.givenClass} 的值在这里因为 switch 语句的通跌（fall-through）而被覆盖了。</LongDescription>
    <Details>
<![CDATA[<p>在这里，之前的 switch 案例中的值被覆盖了，这是因为发生了 switch 跳转。很可能你在上一个 case 的末尾忘了添加 break 或 return。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH_TO_THROW">
    <ShortDescription>由于开关语句会导致抛出异常而形成死-store  Dead store due to switch statement fall through to throw</ShortDescription>
    <LongDescription>由于switch语句会导致fall-through到throw，因此从上一个case获取的{2.givenClass}值在这里丢失了。</LongDescription>
    <Details>
<![CDATA[<p>在此处存储在之前 switch 案例中的值被忽略，因为发生了 switch 传递导致在一个抛出异常的位置。这很可能意味着你在之前的案例末尾忘记了放置 break 或 return。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="WS_WRITEOBJECT_SYNC">
    <ShortDescription>writeObject() 方法是同步的，但其他部分都不是。  Class's writeObject() method is synchronized but nothing else is</ShortDescription>
    <LongDescription>{0}的writeObject方法是同步的，但其他部分并非如此。</LongDescription>
    <Details>
<![CDATA[<p>该类包含一个名为<code>writeObject()</code>的同步方法；然而，类中的其他方法均未同步。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RS_READOBJECT_SYNC">
    <ShortDescription>class的readObject()方法是同步的  Class's readObject() method is synchronized</ShortDescription>
    <LongDescription>{0} 的 readObject 方法是同步的</LongDescription>
    <Details>
<![CDATA[<p>这个可序列化的类定义了一个同步的<code>readObject()</code>方法。根据定义，在反序列化过程中创建的对象只能被一个线程访问，因此不需要将<code>readObject()</code>方法声明为同步的。如果<code>readObject()</code>方法本身导致对象变得可见于另一个线程，则这是一种非常可疑的编码风格。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NONSTATIC_SERIALVERSIONID">
    <ShortDescription>serialVersionUID 不是静态的  serialVersionUID isn't static</ShortDescription>
    <LongDescription>{1} 不是静态的</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个非静态的 `serialVersionUID` 字段。如果该字段旨在指定序列化目的下的版本UID，则应将其声明为静态。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NONFINAL_SERIALVERSIONID">
    <ShortDescription>`serialVersionUID` 不是 final 的  serialVersionUID isn't final</ShortDescription>
    <LongDescription>{1} 不是 final 的</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个非最终的 <code>serialVersionUID</code> 字段。如果打算为此字段指定序列化版本UID，则应将其声明为最终（final）。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NONLONG_SERIALVERSIONID">
    <ShortDescription>serialVersionUID 不是 long 类型  serialVersionUID isn't long</ShortDescription>
    <LongDescription>"{1} 并不长"</LongDescription>
    <Details>
<![CDATA[<p>该类定义了一个不是long类型的<code>serialVersionUID</code>字段。如果打算为此序列化目的指定版本UID，应将该字段改为long类型。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_BAD_FIELD">
    <ShortDescription>可序列化的类中存在非瞬态且非序列化的实例字段  Non-transient non-serializable instance field in serializable class</ShortDescription>
    <LongDescription>类 {0} 定义了非暂存且非序列化的实例字段 {1.name}</LongDescription>
    <Details>
<![CDATA[<p>此可序列化类定义了一个非原始实例字段，该字段既不是 transient、Serializable 或 java.lang.Object，并且没有实现 Externalizable 接口或 readObject() 和 writeObject() 方法。如果此字段存储了非序列化的对象，则使用该类的对象在反序列化时将无法正确解析。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_BAD_FIELD_INNER_CLASS">
    <ShortDescription>非序列化类包含一个可序列化的内部类  Non-serializable class has a serializable inner class</ShortDescription>
    <LongDescription>{0}是可以序列化，但也是非序列化类的内部类。</LongDescription>
    <Details>
<![CDATA[<p>这个Serializable类是嵌套在非Serializable类中的内部类。因此，尝试序列化它时也会试图将与其关联的外部类实例一起关联起来，从而导致运行时错误。</p>
<p>如果可能的话，将内部类改为静态内部类可以解决这个问题。使外部类可序列化也可能奏效，但这意味着序列化内部类的实例也将总是同时序列化外部类的实例，而这通常并不是你真正想要的。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_INNER_CLASS">
    <ShortDescription>可序列化的内部类  Serializable inner class</ShortDescription>
    <LongDescription>{0}是可以序列化的内部类</LongDescription>
    <Details>
<![CDATA[这个可序列化的类是一个内部类。任何尝试序列化它的操作也会序列化相关的外部实例。由于外部实例是可序列化的，所以这不会失败，但可能会序列化比预期更多的数据。如果可能的话，将内部类改为静态内部类（也称为嵌套类）可以解决这个问题。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_BAD_FIELD_STORE">
    <ShortDescription>序列化类的实例字段中存储了非序列化值  Non-serializable value stored into instance field of a serializable class</ShortDescription>
    <LongDescription>将值{2}存储到了非瞬态字段{1.givenClass}中</LongDescription>
    <Details>
<![CDATA[<p>可序列化的类中存储了非序列化的值到一个非瞬态字段中。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SC_START_IN_CTOR">
    <ShortDescription>构造函数调用了Thread.start()  Constructor invokes Thread.start()</ShortDescription>
    <LongDescription>{1} 调用 {2}</LongDescription>
    <Details>
<![CDATA[<p>构造函数启动了一个线程。如果该类被扩展或子类化，这可能是错误的，因为线程将在子类构造函数启动之前启动。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SS_SHOULD_BE_STATIC">
    <ShortDescription>未读字段：这个字段应该设置为静态吗？  Unread field: should this field be static?</ShortDescription>
    <LongDescription>未读字段：{1}；这个字段应该声明为静态的吗？</LongDescription>
    <Details>
<![CDATA[<p>该类包含一个实例最终字段，初始化为编译时静态值。考虑将该字段声明为静态。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UUF_UNUSED_FIELD">
    <ShortDescription>未使用字段  Unused field</ShortDescription>
    <LongDescription>未使用的字段：{1}</LongDescription>
    <Details>
<![CDATA[<p>该字段从未使用过。考虑从类中移除它。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="URF_UNREAD_FIELD">
    <ShortDescription>未读字段  Unread field</ShortDescription>
    <LongDescription>未读字段：{1}</LongDescription>
    <Details>
<![CDATA[<p>此字段从未被读取。考虑从类中移除它。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD">
    <ShortDescription>未使用的公共或保护字段  Unused public or protected field</ShortDescription>
    <LongDescription>未使用的公共或受保护字段：{1}</LongDescription>
    <Details>
<![CDATA[<p>此字段从未被使用。该字段是公有或保护的，也许它是打算与其他在分析中未看到的类一起使用。如果不是这样，请考虑从类中移除它。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD">
    <ShortDescription>未读取的公共/受保护字段  Unread public/protected field</ShortDescription>
    <LongDescription>未读取的公共/受保护字段：{1}</LongDescription>
    <Details>
<![CDATA[<p>此字段从未被读取。该字段是公共或受保护的，也许它打算与其他未包含在分析中的类一起使用。如果不是这样，请考虑从类中移除它。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="QF_QUESTIONABLE_FOR_LOOP">
    <ShortDescription>复杂的、微妙的或错误的循环增量在for循环中  Complicated, subtle or wrong increment in for-loop</ShortDescription>
    <LongDescription>在for循环中使用复杂、微妙或错误的递增操作 {1}</LongDescription>
    <Details>
<![CDATA[<p>你确定这个for循环是正确地增减了变量吗？似乎另一个变量是由for循环初始化和检查的。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UWF_NULL_FIELD">
    <ShortDescription>字段仅被设置为null  Field only ever set to null</ShortDescription>
    <LongDescription>仅被设置为 null：{1}</LongDescription>
    <Details>
<![CDATA[<p>此字段的所有写入都是常量值null，因此所有对该字段的读取都会返回null。检查是否有错误，如果无用则可以移除。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD">
    <ShortDescription>未定义的公共或保护字段  Unwritten public or protected field</ShortDescription>
    <LongDescription>未定义的公共或保护字段：{1}</LongDescription>
    <Details>
<![CDATA[<p>未对该公共/受保护字段进行写操作。所有对该字段的读取都将返回默认值。检查是否有错误（是否应该对其进行初始化？），或者如果该字段无用则可以移除它。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UWF_UNWRITTEN_FIELD">
    <ShortDescription>未定义字段  Unwritten field</ShortDescription>
    <LongDescription>未定义字段：{1}</LongDescription>
    <Details>
<![CDATA[<p>此字段从未被写入。所有对该字段的读取都将返回默认值。检查是否存在错误（它应该被初始化吗？），或者如果它是无用的则可以移除它。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD">
    <ShortDescription>从实例方法中写入静态字段  Write to static field from instance method</ShortDescription>
    <LongDescription>从实例方法 {1} 向静态字段 {2} 写入</LongDescription>
    <Details>
<![CDATA[<p>该实例方法写入了一个静态字段。如果多个实例被同时操作，这会很难正确实现，并且通常被认为是不良做法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_LOAD_OF_KNOWN_NULL_VALUE">
    <ShortDescription>已知为空值的负载  Load of known null value</ShortDescription>
    <LongDescription>在{1}处加载已知的空值</LongDescription>
    <Details>
<![CDATA[<p>在此点引用的变量已被确认为null，这是因为之前对该变量进行了null检查。虽然这种情况是有效的，但也可能是错误（也许您本应引用不同的变量，或者之前的检查应该是非空检查而非空检查）。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_DEREFERENCE_OF_READLINE_VALUE">
    <ShortDescription>读取行的结果未进行空检查便解引用  Dereference of the result of readLine() without nullcheck</ShortDescription>
    <LongDescription>在第{1}行中对读取的結果进行解引用而未进行空检査</LongDescription>
    <Details>
<![CDATA[<p>调用 readLine() 后其结果未检查是否为 null 就进行了解引用。如果不再有可读取的文本行，readLine() 将返回 null，并对 null 进行解引将引发空指针异常。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_IMMEDIATE_DEREFERENCE_OF_READLINE">
    <ShortDescription>对读取行的结果立即进行解引用  Immediate dereference of the result of readLine()</ShortDescription>
    <LongDescription>在 {1} 中立即解引用 readline() 的结果。</LongDescription>
    <Details>
<![CDATA[<p>调用 readline() 的结果立即解引用。如果没有更多的文本行可读取，readline() 将返回 null，并解引用该值会导致空指针异常。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_UNWRITTEN_FIELD">
    <ShortDescription>未写入的字段读取  Read of unwritten field</ShortDescription>
    <LongDescription>在 `{1}` 中读取未写入的字段 `{2.name}`</LongDescription>
    <Details>
<![CDATA[该程序正在解引用一个似乎从未被写入非空值的字段。除非该字段是通过分析未看到的某些机制初始化的，否则解引用此值将会生成空指针异常。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD">
    <ShortDescription>读取未初始化的公共或保护字段  Read of unwritten public or protected field</ShortDescription>
    <LongDescription>在 `{1}` 中读取未初始化的公共或保护字段 `{2.name}`</LongDescription>
    <Details>
<![CDATA[<p>该程序正在引用一个公共或受保护的字段，但似乎从未有非空值被写入到这个字段中。除非该字段是通过分析未见的某种机制初始化的，否则引用此值将会生成空指针异常。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIC_THREADLOCAL_DEADLY_EMBRACE">
    <ShortDescription>非静态内部类和线程局部变量的致命拥抱  Deadly embrace of non-static inner class and thread local</ShortDescription>
    <LongDescription>{0} 需要声明为 _static_ 以避免与 {1} 的致命拥抱</LongDescription>
    <Details>
<![CDATA[<p>这个类是一个内部类，但很可能应该定义为静态内部类。由于当前不是静态内部类，它会保留对外部类的引用。如果外部类的线程局部变量包含对内部类实例的引用，则内外两个对象都将可达且不会被垃圾回收。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIC_INNER_SHOULD_BE_STATIC">
    <ShortDescription>应该是静态内部类  Should be a static inner class</ShortDescription>
    <LongDescription>{0}应该是一个静态内部类吗？</LongDescription>
    <Details>
<![CDATA[<p>这个内部类并不使用其对创建它的对象的引用。这个引用使得该类的实例更大，并且可能会使对创建者对象的引用存活时间比必要的时间更长。如果可能，应该将该类声明为静态类。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR">
    <ShortDescription>在构造函数中未初始化的字段但在未进行空检查的情况下被引用  Field not initialized in constructor but dereferenced without null check</ShortDescription>
    <LongDescription>在构造函数中未初始化 `{1.givenClass}`，并在 `{2}` 中解引用。</LongDescription>
    <Details>
<![CDATA[<p>此字段在任何构造函数中都没有被初始化，因此对象构建后可能会是null。在其他地方，该字段被加载并解引用而没有进行null检查。这可能是错误或者是可疑的设计，因为这意味着如果在该字段被初始化之前对其进行解引用来访问，将会生成空指针异常。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIC_INNER_SHOULD_BE_STATIC_ANON">
    <ShortDescription>可以重构为带名称的静态内部类  Could be refactored into a named static inner class</ShortDescription>
    <LongDescription>类 {0} 可以重构为一个名为的\_静态_内部类</LongDescription>
    <Details>
<![CDATA[<p>这个内部类是一个嵌套类，但并不使用其对创建它的对象的引用。该引用会使该类的实例更大，并可能使对创建者对象的引用保持存活时间过长。如果可行，应该将此类改为静态内部类。由于匿名内部类不能标记为静态，因此需要重新调整内部类使其成为命名内部类。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS">
    <ShortDescription>可以重构为静态内部类  Could be refactored into a static inner class</ShortDescription>
    <LongDescription>类 {0} 可以重构为一个 _静态_ 内部类</LongDescription>
    <Details>
<![CDATA[<p>这个内部类是一个嵌套类，但在其构造过程中除了在构造内部对象时外，并未使用到创建它的对象的引用。该引用使得此类的实例变大，并可能使对外部对象的引用保持存活时间过长。如果可能的话，应该将此类改为静态内部类。由于构造内部实例时需要对外部对象的引用，因此内部类需要重新架构，以便在构造内部类的对象时传递外部实例的引用。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="WA_NOT_IN_LOOP">
    <ShortDescription>不在循环中等待  Wait not in loop</ShortDescription>
    <LongDescription>在{1}中不要阻塞等待循环中</LongDescription>
    <Details>
<![CDATA[<p>该方法调用了<code>java.lang.Object.wait()</code>&nbsp;但没有放在循环中。如果锁用于多个条件，则调用者等待的条件可能并不是实际发生的情况。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="WA_AWAIT_NOT_IN_LOOP">
    <ShortDescription>Condition.await() 不要在循环中使用  Condition.await() not in loop</ShortDescription>
    <LongDescription>在{1}中，`Condition.await()` 不应在循环外使用。</LongDescription>
    <Details>
<![CDATA[<p>此方法中包含对 <code>java.util.concurrent.await()</code>（或其变体）的调用，并且该调用不在循环中。如果对象用于多个条件，则调用者意图等待的情况可能并不是实际发生的情况。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NO_NOTIFY_NOT_NOTIFYALL">
    <ShortDescription>使用notify()而不是notifyAll()  Using notify() rather than notifyAll()</ShortDescription>
    <LongDescription>在{1}中使用notify而不是notifyAll</LongDescription>
    <Details>
<![CDATA[<p>该方法调用了<code>notify()</code> 而不是<code>notifyAll()</code>。Java 监视器通常用于处理多种条件。调用<code>notify()</code> 只会唤醒一个线程，这意味着被唤醒的线程可能并不是刚刚被满足等待条件的那个线程。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UC_USELESS_VOID_METHOD">
    <ShortDescription>无用的非空void方法  Useless non-empty void method</ShortDescription>
    <LongDescription>方法 {1} 看起来是多余的。</LongDescription>
    <Details>
<![CDATA[<p>我们的分析表明，这个非空的空方法实际上并没有执行任何有用的工作。请检查它：可能它的代码中有错误，或者其内容完全可以移除。</p>
<p>我们尽量减少误报的数量，但在某些情况下此警告可能是错误的。常见的误报情况包括：</p>
<ul>
<li>该方法旨在触发加载某个类，这可能会产生副作用。</li>
<li>该方法旨在隐式抛出某种不显眼的异常。</li>
</ul>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UC_USELESS_CONDITION">
    <ShortDescription>条件不起作用  Condition has no effect</ShortDescription>
    <LongDescription>无用的条件：在此状态下已知{2}</LongDescription>
    <Details>
<![CDATA[<p>这种条件总是会产生与之前窄化变量值相同的结果。可能是原本的意思没有表达清楚，或者这个条件可以被移除。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UC_USELESS_CONDITION_TYPE">
    <ShortDescription>条件判断由于变量类型的原因无效。  Condition has no effect due to the variable type</ShortDescription>
    <LongDescription>无用的条件：它的值总是{2}，因为变量类型是{3}</LongDescription>
    <Details>
<![CDATA[<p>由于涉及变量的类型范围，此条件总是产生相同的结果。可能是其他某些东西被意指了，或者该条件可以被移除。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UC_USELESS_OBJECT">
    <ShortDescription>创建了不必要的对象  Useless object created</ShortDescription>
    <LongDescription>方法 `{1}` 中存储在变量 `{2}` 中的对象是无用的</LongDescription>
    <Details>
<![CDATA[<p>我们的分析显示，该对象是无用的。它被创建并修改，但其值从不超出方法范围或产生任何副作用。要么是有误，对象本应被使用，要么可以移除。</p>
<p>这种分析很少产生假阳性。常见的假阳性情况包括：</p>
<ul>
    <li>- 该对象曾隐式抛出某种不显眼的异常。</li>
    <li>- 该对象用作占位符以泛化代码。</li>
    <li>- 该对象用于持有对弱引用/软引用对象的强大引用。</li>
</ul>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UC_USELESS_OBJECT_STACK">
    <ShortDescription>在栈上创建了无用的对象  Useless object created on stack</ShortDescription>
    <LongDescription>在方法 {1} 中创建了不必要的对象</LongDescription>
    <Details>
<![CDATA[<p>这个对象仅用于执行一些没有副作用的修改。可能原本另有他用，或者这个对象可以被移除。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RANGE_ARRAY_INDEX">
    <ShortDescription>数组下标越界  Array index is out of bounds</ShortDescription>
    <LongDescription>数组索引越界：{3}</LongDescription>
    <Details>
<![CDATA[<p>进行了数组操作，但数组索引越界，将在运行时导致ArrayIndexOutOfBoundsException。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RANGE_ARRAY_OFFSET">
    <ShortDescription>数组越界  Array offset is out of bounds</ShortDescription>
    <LongDescription>数组越界：{3}</LongDescription>
    <Details>
<![CDATA[<p>方法带数组参数和偏移量参数被调用，但偏移量超出范围。这将在运行时导致索引越界异常（IndexOutOfBoundsException）。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RANGE_ARRAY_LENGTH">
    <ShortDescription>数组长度越界  Array length is out of bounds</ShortDescription>
    <LongDescription>数组长度超出范围：{3}</LongDescription>
    <Details>
<![CDATA[<p>方法使用了数组参数和长度参数，但长度超出了边界。这将在运行时导致索引越界异常（IndexOutOfBoundsException）。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RANGE_STRING_INDEX">
    <ShortDescription>字符串索引超出范围  String index is out of bounds</ShortDescription>
    <LongDescription>在调用 `{5}` 时，字符串索引越界：{3}</LongDescription>
    <Details>
<![CDATA[<p>调用了字符串方法，并指定了超出边界的有效字符串索引。这将在运行时导致StringIndexOutOfBoundsException。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_CHECK_FOR_POSITIVE_INDEXOF">
    <ShortDescription>方法检查 `String.indexOf` 的结果是否为正数  Method checks to see if result of String.indexOf is positive</ShortDescription>
    <LongDescription>{1} 检查 `String.indexOf` 的结果是否为正数</LongDescription>
    <Details>
<![CDATA[<p>该方法调用了String.indexOf方法，并检查其结果是否为正数或非正数。通常的做法是检查结果是否为负数或非负数。只有当要检查的子字符串在字符串中的位置不在开头时，结果才为正数。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_DONT_JUST_NULL_CHECK_READLINE">
    <ShortDescription>在检查 `readLine` 返回值是否非空后，方法忽略了对其返回值的处理  Method discards result of readLine after checking if it is non-null</ShortDescription>
    <LongDescription>在检查 `readLine` 返回值是否非空后，丢弃了其返回结果。</LongDescription>
    <Details>
<![CDATA[<p>在检查readLine返回值是否非空后，如果返回值非空，则通常希望使用这个非空值。但如果再次调用readLine，将会得到不同的行。</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="RV_RETURN_VALUE_IGNORED_INFERRED">
    <ShortDescription>方法忽略了返回值，这样可以吗？  Method ignores return value, is this OK?</ShortDescription>
    <LongDescription>{2.给定类}的返回值被忽略，这在{1}中是可以接受的吗？</LongDescription>
    <Details>
<![CDATA[<p>该代码调用了一个方法并忽略了返回值。返回值与调用方法的对象类型相同，从我们的分析来看，返回值可能是重要的（例如，类似于忽略 `String.toLowerCase()` 的返回值）。</p>
<p>仅仅根据对方法体的简单分析，我们猜测忽略返回值可能不是一个好主意。你可以使用 @CheckReturnValue 注解来告知 SpotBugs 忽略该方法的返回值是否重要或可接受。</p>
<p>请仔细调查以决定是否可以忽略该返回值。</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT">
    <ShortDescription>没有副作用的方法返回值被忽略  Return value of method without side effect is ignored</ShortDescription>
    <LongDescription>{2.givenClass} 方法的返回值被忽略，但该方法没有副作用。</LongDescription>
    <Details>
<![CDATA[<p>此代码调用了一个方法并忽略了其返回值。然而，我们的分析显示该方法（包括任何子类的实现）除了返回值外没有任何其他效果。因此可以移除这个调用。</p>
<p>我们尽量减少误报的数量，但在某些情况下，这条警告可能是错误的。常见的误报情况包括：</p>
<ul>
    <li>该方法设计为被覆盖并在其他项目中产生副作用（而这些项目超出了分析范围）。</li>
    <li>调用该方法是为了触发类加载，可能有其他副作用。</li>
    <li>调用该方法只是为了获取某些异常。</li>
</ul>
<p>如果您认为我们的假设是错误的，可以使用 @CheckReturnValue 注解来指示 SpotBugs 忽略此方法的返回值是可以接受的。</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="RV_RETURN_VALUE_IGNORED">
    <ShortDescription>方法忽略了返回值  Method ignores return value</ShortDescription>
    <LongDescription>在 {1} 中，{2.givenClass} 的返回值被忽略。</LongDescription>
    <Details>
<![CDATA[<p>此方法的返回值应当被检查。这种警告的一个常见原因是，在调用不可变对象的方法时，误以为该方法会更新对象。例如，在以下代码片段中：</p>
<pre><code>String dateString = getHeaderField(name); dateString.trim(); </code></pre>
<p>程序员似乎认为 trim() 方法会更新由 dateString 引用的 String 对象。但由于 String 是不可变的，trim() 函数返回一个新的 String 值，这里这个新值被忽略了。代码应该更正为：</p>
<pre><code>String dateString = getHeaderField(name); dateString = dateString.trim(); </code></pre>]]>
    </Details>
  </BugPattern>


  <BugPattern type="RV_RETURN_VALUE_IGNORED_BAD_PRACTICE">
    <ShortDescription>方法忽略了异常返回值的处理  Method ignores exceptional return value</ShortDescription>
    <LongDescription>在 `{1}` 中忽略了 `{2}` 的异常返回值</LongDescription>
    <Details>
<![CDATA[<p>该方法返回一个值但未进行检查。返回值应当被检查，因为其可以指示异常或意外的功能执行。例如，<code>File.delete()</code> 方法在无法成功删除文件时会返回 false（而不是抛出异常）。如果不检查结果，你就不会注意到方法调用通过返回非典型返回值来信号异常行为。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_CHECK_COMPARETO_FOR_SPECIFIC_RETURN_VALUE">
    <ShortDescription>代码检查特定值的返回情况，这些值是由compareTo方法返回的。  Code checks for specific values returned by compareTo</ShortDescription>
    <LongDescription>检查{2.givenClass}的返回值是否等于{3}</LongDescription>
    <Details>
<![CDATA[<p>该代码调用了 `compareTo` 或 `compare` 方法，并检查返回值是否为特定值，如 1 或 -1。在调用这些方法时，你应该仅检查结果的符号，而不是特定的非零值。虽然许多或大多数 `compareTo` 和 `compare` 方法只返回 -1、0 或 1，但有些方法会返回其他值。]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_EXCEPTION_NOT_THROWN">
    <ShortDescription>异常创建后未抛出而是被销毁  Exception created and dropped rather than thrown</ShortDescription>
    <LongDescription>在 `{1}` 中没有抛出 `{2.givenClass}`。</LongDescription>
    <Details>
<![CDATA[这段代码创建了一个异常（或错误）对象，但并没有做任何处理。例如：

```java
if (x < 0) { 
    new IllegalArgumentException("x必须是非负数"); 
}
```

程序员本意可能是要抛出这个创建的异常：

```java
if (x < 0) { 
    throw new IllegalArgumentException("x必须是非负数"); 
}
```]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_ALWAYS_NULL">
    <ShortDescription>空指针解引用  Null pointer dereference</ShortDescription>
    <LongDescription>在 `{1}` 中对 `{2.givenClass}` 进行空指针解引用。</LongDescription>
    <Details>
<![CDATA[<p>这里对空指针进行了解引用操作。当代码执行时，这将导致一个<code>NullPointerException</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_CLOSING_NULL">
    <ShortDescription>在调用 `close()` 时，所作用的值始终为 `null`。  close() invoked on a value that is always null</ShortDescription>
    <LongDescription>由于在{1}中{2.givenClass}始终为null，因此无法关闭它。</LongDescription>
    <Details>
<![CDATA[`close()` 方法被调用在始终为 null 的值上。如果执行此语句，将会发生空指针异常。但更大的风险在于你应该关闭的东西却没有被关闭。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_STORE_INTO_NONNULL_FIELD">
    <ShortDescription>将空值存储到标记了@Nonnull注解的字段中  Store of null value into field annotated @Nonnull</ShortDescription>
    <LongDescription>在 `{1}` 中将空值存储到由 `@Nonnull` 注解标注的字段 `{2.givenClass}` 中</LongDescription>
    <Details>
      <![CDATA[<p>将可能为null的值存储到了已经被标注为@Nonnull的字段中。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_ALWAYS_NULL_EXCEPTION">
    <ShortDescription>在异常路径中对空指针进行解引用  Null pointer dereference in method on exception path</ShortDescription>
    <LongDescription>在异常路径上，{1} 中的 {2.givenClass} 发生空指针解引用。</LongDescription>
    <Details>
<![CDATA[<p>在异常路径上，一个为空的指针被解引用了。当代码执行时，这将导致<code>NullPointerException</code>。请注意，由于SpotBugs当前不修剪不可能的异常路径，因此这可能是一个误报。</p>
<p>另外，请注意，SpotBugs认为switch语句的默认情况是异常路径，因为默认情况通常是不可能发生的。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE">
    <ShortDescription>参数必须是非空的，但被标记为可为空。  Parameter must be non-null but is marked as nullable</ShortDescription>
    <LongDescription>{2} 必须为非空，但被标记为可为空。</LongDescription>
    <Details>
<![CDATA[<p>这个参数总是以非空的方式使用，但该参数明确注解为可为空。要么参数的使用方式有误，要么注解有误。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_ON_SOME_PATH">
    <ShortDescription>可能的空指针解引用  Possible null pointer dereference</ShortDescription>
    <LongDescription>在{1}中可能对{2.givenClass}进行了空指针解引用。</LongDescription>
    <Details>
<![CDATA[<p>存在一个分支语句，如果执行的话，会保证出现空值引用，从而在代码执行时生成 <code>NullPointerException</code>。当然，问题可能是该分支或语句是不可行的，因此空指针异常永远不可能被执行；决定这一点超出了 SpotBugs 的能力范围。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_ON_SOME_PATH_MIGHT_BE_INFEASIBLE">
    <ShortDescription>在可能不可行的分支上对空指针进行解引用  Possible null pointer dereference on branch that might be infeasible</ShortDescription>
    <LongDescription>在第{1}行中可能存在的不可达分支上对{2.givenClass}进行了空指针解引用。</LongDescription>
    <Details>
<![CDATA[<p>存在一个分支语句，如果执行的话，会保证出现空值引用，从而在代码运行时生成 <code>NullPointerException</code>。当然，这个问题可能是该分支或语句不可行，空指针异常实际上从未发生；SpotBugs 无法判断这种情况。由于之前已经对该值进行了空值检查，这种可能性是存在的。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_ON_SOME_PATH_EXCEPTION">
    <ShortDescription>在异常路径中可能存在空指针解引用问题  Possible null pointer dereference in method on exception path</ShortDescription>
    <LongDescription>在异常路径上，可能对 {1.givenClass} 进行空指针解引用在 {2} 中。</LongDescription>
    <Details>
<![CDATA[<p>某些异常控制路径上的引用值为 null，在这里进行了解引用操作。这可能会导致在代码执行时出现 <code>NullPointerException</code>。<br>请注意，由于 SpotBugs 当前不修剪不可能的异常路径，因此这可能是一个假警告。</p>
<p>此外，请注意，SpotBugs 认为 switch 语句中的默认情况是异常路径，因为默认情况通常是不可能发生的。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE">
    <ShortDescription>由于调用方法的返回值可能导致空指针 dereference  Possible null pointer dereference due to return value of called method</ShortDescription>
    <LongDescription>由于调用方法的返回值可能为空，在{1}处可能存在空指针脱 Reference</LongDescription>
    <Details>
      <![CDATA[<p>从方法中返回的值在未进行空检查的情况下被去引号使用，而该方法的返回值通常是应该进行空检查的。这可能会导致在代码执行时出现<code>NullPointerException</code>。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_PARAM_DEREF_NONVIRTUAL">
    <ShortDescription>非虚拟方法调用传递了非null参数为null  Non-virtual method call passes null for non-null parameter</ShortDescription>
    <LongDescription>在 `{1}` 中，非虚拟方法调用传递了对 `{2.givenClass}` 的非空参数为 `null`。</LongDescription>
    <Details>
      <![CDATA[<p>一个可能为 null 的值被传递给一个非 null 方法参数。要么该参数被注解为始终不应为 null，要么分析表明它总是会被引用。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS">
    <ShortDescription>方法调用传递了非空参数的空值  Method call passes null for non-null parameter</ShortDescription>
    <LongDescription>在 `{1}` 中，传递了空值给非空参数 `{2.givenClass}`。</LongDescription>
    <Details>
      <![CDATA[在一个调用点传递了一个可能为空的值，而所有已知的目标方法都要求该参数必须非空。要么该参数被注解为始终不应为空，要么分析已经表明它将总是会被间接引用。]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_PARAM_DEREF">
    <ShortDescription>方法调用传递了空值给非空参数  Method call passes null for non-null parameter</ShortDescription>
    <LongDescription>在{1}中，为{2.givenClass}的非空参数传递了null值。</LongDescription>
    <Details>
      <![CDATA[<p>该方法调用传递了一个空值给一个非空的方法参数。要么该参数被注释为始终不应为空，要么分析显示它将始终被解引用。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_NONNULL_PARAM_VIOLATION">
    <ShortDescription>方法调用向非空参数传递了null值  Method call passes null to a non-null parameter</ShortDescription>
    <LongDescription>在 `{1}` 中，传递了空值给非空参数 `{2.givenClass}`。</LongDescription>
    <Details>
      <![CDATA[<p>该方法将一个空值作为参数传递给必须为非空的方法。要么此参数已被显式标记为@Nonnull，要么分析已确定该参数始终会被解引用。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_NONNULL_RETURN_VIOLATION">
    <ShortDescription>方法可能返回null，但声明为@Nonnull  Method may return null, but is declared @Nonnull</ShortDescription>
    <LongDescription>{1} 可能返回 null，但声明为 @Nonnull</LongDescription>
    <Details>
      <![CDATA[<p>该方法可能会返回一个空值，但该方法（或它覆盖的超类方法）被声明为返回@Nonnull。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_CLONE_COULD_RETURN_NULL">
    <ShortDescription>克隆方法可能会返回null  Clone method may return null</ShortDescription>
    <LongDescription>{1} 可能返回null</LongDescription>
    <Details>
      <![CDATA[<p>     这个克隆方法在某些情况下似乎会返回 null，但克隆操作从未允许返回 null 值。如果你确信这条路径是不可达的，请抛出一个 AssertionError 代替。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_TOSTRING_COULD_RETURN_NULL">
    <ShortDescription>`toString` 方法可能返回 `null`  toString method may return null</ShortDescription>
    <LongDescription>{1} 可能返回 null</LongDescription>
    <Details>
      <![CDATA[<p>    在某些情况下，这个 toString 方法似乎会返回 null。规范可能允许这种情况发生，但这通常不是一个好主意，并且可能会导致其他代码出错。应该返回空字符串或其他适当的字符串而不是 null。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_GUARANTEED_DEREF">
    <ShortDescription>空值保证会被解引用  Null value is guaranteed to be dereferenced</ShortDescription>
    <LongDescription>在 {1} 中，{2.givenClass} 可能为 null 并且保证会被解引用。</LongDescription>
    <Details>
          <![CDATA[<p>如果执行某个语句或分支可以保证在此点有一个值为null，并且该值在后续路径中（除涉及运行时异常的向前路径外）必定会被解引用，则该情况被视为不安全。</p>
<p>请注意，类似于<code>if (x == null) throw new NullPointerException();</code>这样的检查也被视为对<x>的解引用。</p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH">
    <ShortDescription>值为null，并且在异常路径中保证会被解引用。  Value is null and guaranteed to be dereferenced on exception path</ShortDescription>
    <LongDescription>在异常路径中，{1} 中保证了对 {2.name} 为空的去引用操作是安全的。</LongDescription>
    <Details>
          <![CDATA[<p>在异常路径上存在一条语句或分支，如果执行这条语句或分支可以保证该点处的值为null，并且这个值将在后续处理中被反引用来访问（除非涉及运行时异常的前向路径）。 </p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="SI_INSTANCE_BEFORE_FINALS_ASSIGNED">
    <ShortDescription>静态初始化器在所有静态final字段赋值之前创建实例  Static initializer creates instance before all static final fields assigned</ShortDescription>
    <LongDescription>{0}的静态初始化器在所有static final字段被赋值之前创建了实例</LongDescription>
    <Details>
<![CDATA[<p>该类的静态初始化器在所有静态最终字段被赋值之前创建了类的一个实例。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="OS_OPEN_STREAM">
    <ShortDescription>方法可能无法关闭流  Method may fail to close stream</ShortDescription>
    <LongDescription>{1} 可能未能关闭流</LongDescription>
    <Details>
<![CDATA[<p>该方法创建了一个IO流对象，但没有将其分配给任何字段，也没有将它传递给其他可能关闭它的方法，或者返回它，并且在方法的所有路径结束时都没有显式关闭流。这可能会导致文件描述符泄漏。通常建议使用<code>finally</code>块来确保流被正确关闭。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="OS_OPEN_STREAM_EXCEPTION_PATH">
    <ShortDescription>方法在异常情况下可能无法关闭流  Method may fail to close stream on exception</ShortDescription>
    <LongDescription>{1} 可能在异常情况下未能关闭流</LongDescription>
    <Details>
<![CDATA[<p>该方法创建了一个IO流对象，但并未将其赋值给任何字段、传给其他方法或返回它，并且在方法的所有可能异常退出路径中都没有关闭它。这可能会导致文件描述符泄漏。通常来说，在 finally 块中确保流被关闭是一个好主意。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="PZLA_PREFER_ZERO_LENGTH_ARRAYS">
    <ShortDescription>考虑返回一个空数组而不是null  Consider returning a zero length array rather than null</ShortDescription>
    <LongDescription>{1} 应该返回一个空数组而不是 null？</LongDescription>
    <Details>
<![CDATA[<p>通常，返回长度为零的数组而不是空引用以表示没有结果（即结果列表为空）是一种更好的设计。这样，方法的调用者就不需要进行空指针检查。</p>
<p>另一方面，使用空引用表示“对这个问题没有答案”可能是合适的。例如，<code>File.listFiles()</code> 如果给定一个不包含文件的目录会返回一个空列表，并且如果给定的文件不是一个目录则会返回 null。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UCF_USELESS_CONTROL_FLOW">
    <ShortDescription>无用的控制流  Useless control flow</ShortDescription>
    <LongDescription>在 `{1}` 中存在不必要的控制流。</LongDescription>
    <Details>
<![CDATA[<p>该方法包含一个无用的控制流语句，无论分支是否被选择，控制流都会继续前往相同的地方。例如，这是由于在一个 <code>if</code> 语句中有一个空语句块引起的：</p>
<pre><code>if (argv.length == 0) {     // TODO: 处理这种情况
}</code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UCF_USELESS_CONTROL_FLOW_NEXT_LINE">
    <ShortDescription>无用的控制流跳转到下一行  Useless control flow to next line</ShortDescription>
    <LongDescription>在 {1} 中使用了不必要的控制流到下一行</LongDescription>
    <Details>
<![CDATA[<p>该方法包含一个无用的控制流语句，无论分支是否被选择，控制流都会跟随到同一行或后续行。这通常是无意中将空语句作为 <code>if</code> 语句的主体导致的，例如：</p>
<pre><code>if (argv.length == 1);     System.out.println("Hello, " + argv[0]); </code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE">
    <ShortDescription>之前解引用过的值的空检査  Nullcheck of value previously dereferenced</ShortDescription>
    <LongDescription>在第{4#lineNumber}行的{2#givenClass}中的值之前已在{1}中解引用，现在进行空检查。</LongDescription>
    <Details>
<![CDATA[<p>这里检查一个值是否为空，但这个值实际上不可能为空，因为它之前已经被去引用过了，在之前的去引用中如果它为空，则会在更早的去引用时抛出空指针异常。本质上，这段代码和之前的去引用在是否允许该值为 null 上存在分歧。要么这个检查是多余的，要么之前的去引用有误。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE">
    <ShortDescription>对已知为null的值进行冗余空指针检查  Redundant nullcheck of value known to be null</ShortDescription>
    <LongDescription>在{1}中，{2}已知为null，在此对{2}进行多余的空指针检查</LongDescription>
    <Details>
<![CDATA[<p>该方法中对已知为空值的变量进行了与常量null的冗余检查。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE">
    <ShortDescription>已知非空的值进行了多余的空指针检查  Redundant nullcheck of value known to be non-null</ShortDescription>
    <LongDescription>在{1}中已知{2}为非空的情况下，对{2}进行了冗余的空检校。</LongDescription>
    <Details>
<![CDATA[<p>该方法对已知非空值进行了冗余的常量null检查。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES">
    <ShortDescription>两个null值的冗余比较  Redundant comparison of two null values</ShortDescription>
    <LongDescription>在{1}中对两个空值进行了冗余比较。</LongDescription>
    <Details>
<![CDATA[<p>该方法中包含两个已知为必定为空的引用之间的冗余比较。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE">
    <ShortDescription>对非空值进行与空值的冗余比较  Redundant comparison of non-null value to null</ShortDescription>
    <LongDescription>在 {1} 中对非空值进行了与 null 的冗余比较</LongDescription>
    <Details>
<![CDATA[<p>该方法中包含一个已知非空的引用和另一个已知为空的引用。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_CHECKED_NULL_COMPARISON" deprecated="true"> <!-- deprecated in favor of two separate RCN_ patterns -->
    <ShortDescription>之前已检查过的值对空的冗余比较  Redundant comparison to null of previously checked value</ShortDescription>
    <LongDescription>在{1}中，对之前已检查过的{2}进行了多余的null比较。</LongDescription>
    <Details>
<![CDATA[<p>该方法中包含对引用值与null的冗余比较。报告了两种类型的冗余比较：</p>
<ul>
<li>被比较的两个值都确定为null</li>
<li>一个值确定为null而另一个值确定不为null</li>
</ul>
<p>这种特定警告通常表示检查了一个已知不会为null的值是否为null。虽然该检查是不必要的，但它可能是出于防御性编程的原因。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UL_UNRELEASED_LOCK">
    <ShortDescription>方法在所有路径上都没有释放锁  Method does not release lock on all paths</ShortDescription>
    <LongDescription>在所有路径上未释放锁</LongDescription>
    <Details>
<![CDATA[<p>该方法获取了一个JSR-166（`java.util.concurrent`）锁，但在方法的所有退出路径中并未释放该锁。通常使用JSR-166锁的正确方式如下：</p>
<pre><code>Lock l = ...;  
l.lock();  
try {  
    // 执行某些操作  
} finally {  
    l.unlock();  
}  
</code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="UL_UNRELEASED_LOCK_EXCEPTION_PATH">
    <ShortDescription>方法在所有异常路径上都没有释放锁  Method does not release lock on all exception paths</ShortDescription>
    <LongDescription>在所有异常路径上没有释放锁。</LongDescription>
    <Details>
<![CDATA[<p>该方法获取了一个JSR-166（<code>java.util.concurrent</code>）锁，但并未在所有异常退出路径中释放该锁。通常使用JSR-166锁的正确方式为：</p>
<pre><code>Lock l = ...;  
l.lock();  
try {  
    // 执行某些操作  
} finally {  
    l.unlock();  
} </code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RC_REF_COMPARISON">
    <ShortDescription>可疑的引用比较  Suspicious reference comparison</ShortDescription>
    <LongDescription>在 {1} 中对 {2} 的引用进行了可疑比较。</LongDescription>
    <Details>
<![CDATA[<p>此方法使用 == 或 != 操作符比较两个引用值，而通常情况下，此类实例的正确比较方式是使用 equals() 方法。有可能创建出相等但不相同的独立实例，因为它们是不同的对象。作为一般规则，不应按引用比较的类示例包括 java.lang.Integer、java.lang.Float 等。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RC_REF_COMPARISON_BAD_PRACTICE">
    <ShortDescription>将常量与可疑引用进行比较  Suspicious reference comparison to constant</ShortDescription>
    <LongDescription>在{1}中将{2}引用与常量进行可疑比较</LongDescription>
    <Details>
<![CDATA[<p>该方法使用==或!=运算符将引用值与常量进行比较，而这种情况下通常应该使用equals()方法来进行比较。可能存在不同的实例具有相同的值但不会通过==比较为相等的情况，因为它们是不同的对象。例如，java.lang.Integer、java.lang.Float等类一般不应按引用方式进行比较。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN">
    <ShortDescription>布尔值的可疑引用比较  Suspicious reference comparison of Boolean values</ShortDescription>
    <LongDescription>在{1}中进行了布尔引用的可疑比较。</LongDescription>
    <Details>
<![CDATA[<p>该方法使用 == 或 != 操作符比较两个Boolean值。通常只有两种Boolean值（Boolean.TRUE 和 Boolean.FALSE），但可以使用 <code>new Boolean(b)</code> 构造函数创建其他Boolean对象。最好避免使用这些对象，但如果它们确实存在，则使用 == 或 != 检查Boolean对象的相等性将给出与使用 <code>.equals(...)</code> 不同的结果。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_UNRELATED_TYPES_USING_POINTER_EQUALITY">
    <ShortDescription>使用指针相等性来比较不同类型的值  Using pointer equality to compare different types</ShortDescription>
    <LongDescription>在{1}中使用指针相等性比较一个{2.givenClass}与一个{3.givenClass}。</LongDescription>
    <Details>
<![CDATA[<p>该方法使用指针相等性来比较两个看似是不同类型的引用。这种比较的结果在运行时总是为假。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_UNRELATED_TYPES">
    <ShortDescription>比较不同类型的调用equals()方法  Call to equals() comparing different types</ShortDescription>
    <LongDescription>在{1}中调用了{3.simpleClass}.equals({2.simpleClass})方法</LongDescription>
    <Details>
<![CDATA[<p>该方法对不同类类型的两个引用调用了equals(Object)方法，并且分析表明它们在运行时将是不同类的对象。进一步检查将要被调用的equals方法表明，要么这次调用总是返回false，要么equals方法不是对称的（这是类Object中equals方法合同要求的一个属性）。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_UNRELATED_INTERFACES">
    <ShortDescription>在比较不同接口类型时调用了equals()方法  Call to equals() comparing different interface types</ShortDescription>
    <LongDescription>在 {1} 中调用了 `{3.simpleClass}` 的 `equals({2.simpleClass})` 方法。</LongDescription>
    <Details>
<![CDATA[<p>该方法对两个不相关接口类型的引用调用了equals(Object)方法， neither 是另一个的子类型，并且没有已知的具体非抽象类同时实现这两个接口。因此，在运行时比较的对象很可能不属于同一个类（除非有些应用类未被分析，或者在运行时可以动态加载类）。根据equals()的方法合同，不同类的对象应该始终比较为不相等；因此，根据java.lang.Object.equals(Object)定义的合同，在运行时该比较的结果总是为false。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_UNRELATED_CLASS_AND_INTERFACE">
    <ShortDescription>对不相关类和接口调用equals()方法  Call to equals() comparing unrelated class and interface</ShortDescription>
    <LongDescription>在 {1} 中调用了 `{3.simpleClass}.equals({2.simpleClass})` 方法。</LongDescription>
    <Details>
      <![CDATA[<p>该方法对一个类引用和一个接口引用调用了equals(Object)方法，但 neither 类及其任何非抽象子类都未实现该接口。因此，在运行时比较的对象很可能不属于同一个类（除非某些应用类未被分析，或者在运行时可以动态加载类）。根据 equals() 方法的合同规定，不同类的对象应该始终比较不相等；因此，根据 java.lang.Object.equals(Object) 定义的合同，在运行时此比较的结果总是 false。 </p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="EC_NULL_ARG">
    <ShortDescription>对 null 调用 equals() 方法  Call to equals(null)</ShortDescription>
    <LongDescription>在 {1} 中调用了 equals(null) 方法</LongDescription>
    <Details>
<![CDATA[<p>此方法调用了 equals(Object) 方法，并将 null 作为参数传递。根据 equals() 方法的合同，此调用始终应返回 <code>false</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MWN_MISMATCHED_WAIT">
    <ShortDescription>不匹配的wait()  Mismatched wait()</ShortDescription>
    <LongDescription>在{1}中匹配错误的wait()方法</LongDescription>
    <Details>
<![CDATA[<p>此方法在没有明显持有该对象锁的情况下调用了Object.wait()。在未持有锁的情况下调用wait()将导致抛出<code>IllegalMonitorStateException</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MWN_MISMATCHED_NOTIFY">
    <ShortDescription>不匹配的notify()  Mismatched notify()</ShortDescription>
    <LongDescription>在{1}中发现不匹配的notify()方法</LongDescription>
    <Details>
<![CDATA[<p>该方法在未明显持有对象锁的情况下调用了Object.notify()或Object.notifyAll()。不在持有的锁上调用notify()或notifyAll()将会抛出<code>IllegalMonitorStateException</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_LOCAL_SELF_ASSIGNMENT_INSTEAD_OF_FIELD">
    <ShortDescription>局部变量的自赋值而不是字段赋值  Self assignment of local rather than assignment to field</ShortDescription>
    <LongDescription>在{1}中，{2}进行了自我赋值而不是分配给字段。</LongDescription>
    <Details>
<![CDATA[<p>该方法中局部变量进行了自我赋值，并且存在一个同名的字段。看起来像是这样的：</p>
<pre><code>int foo;
public void setFoo(int foo) {
    foo = foo;
}
</code></pre>
<p>这种赋值是多余的。您本意是要给字段赋值吗？</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_LOCAL_SELF_ASSIGNMENT">
    <ShortDescription>局部变量的自我赋值  Self assignment of local variable</ShortDescription>
    <LongDescription>在{1}中对{2}进行了自我赋值</LongDescription>
    <Details>
<![CDATA[<p>该方法中包含对局部变量的自我赋值；例如：</p>
<pre><code>public void foo() {     int x = 3;     x = x; } </code></pre>
<p>这样的赋值是多余的，并且可能会指示逻辑错误或打字错误。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_FIELD_SELF_ASSIGNMENT">
    <ShortDescription>字段的自我赋值  Self assignment of field</ShortDescription>
    <LongDescription>在 `{1}` 中，字段 `{2.givenClass}` 的自我赋值。</LongDescription>
    <Details>
<![CDATA[<p>该方法中包含对字段的自我赋值；例如：</p> 
<pre><code>int x;
public void foo() {     x = x; }
</code></pre> 
<p>这样的赋值是多余的，并且可能表明存在逻辑错误或打字错误。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_FIELD_DOUBLE_ASSIGNMENT">
    <ShortDescription>字段的双赋值  Double assignment of field</ShortDescription>
    <LongDescription>在 {1} 中为字段 {2.givenClass} 进行了双重赋值。</LongDescription>
    <Details>
<![CDATA[<p>该方法中对字段进行了双重赋值；例如：</p>
<pre><code>int x, y;
public void foo() {
    x = x = 17;
}</code></pre>
<p>对字段进行两次赋值是多余的，并且可能表明存在逻辑错误或打字错误。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_LOCAL_DOUBLE_ASSIGNMENT">
    <ShortDescription>局部变量的双重赋值  Double assignment of local variable</ShortDescription>
    <LongDescription>在 {1} 中，在 {2} 处进行了双重赋值。</LongDescription>
    <Details>
<![CDATA[<p>此方法中局部变量出现了双重赋值；例如：</p>
<pre><code>public void foo() {     int x,y;     x = x = 17; }</code></pre>
<p>两次给同一个变量赋相同的值是多余的，并且可能表明逻辑错误或打字错误。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_FIELD_SELF_COMPUTATION">
    <ShortDescription>涉及字段的自运算（例如，x &amp; x）  Nonsensical self computation involving a field (e.g., x &amp; x)</ShortDescription>
    <LongDescription>在{1}中，{2.givenClass}自身进行了无意义的计算。</LongDescription>
    <Details>
<![CDATA[<p>该方法对一个字段与同一个字段的另一个引用进行无意义的计算（例如，x&x 或 x-x）。由于计算的本质，这种操作似乎没有意义，并可能表明存在拼写错误或逻辑错误。请重新检查该计算。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_LOCAL_SELF_COMPUTATION">
    <ShortDescription>涉及变量的自计算（例如，x &amp; x）是无意义的  Nonsensical self computation involving a variable (e.g., x &amp; x)</ShortDescription>
    <LongDescription>在{1}中，{2}与自身进行无意义的自我计算。</LongDescription>
    <Details>
<![CDATA[<p>此方法对一个局部变量进行了与自身引用的非理性计算（例如，x&x 或 x-x）。由于该操作的本质似乎没有意义，这可能表明存在打字错误或逻辑错误。请重新检查此计算。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_FIELD_SELF_COMPARISON">
    <ShortDescription>将字段与自身进行比较  Self comparison of field with itself</ShortDescription>
    <LongDescription>{2.givenClass} 在 {1} 中与自身进行了自我比较。</LongDescription>
    <Details>
<![CDATA[<p>该方法将一个字段与自身进行比较，可能会指示拼写错误或逻辑错误。请确保您比较的是正确的内容。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_LOCAL_SELF_COMPARISON">
    <ShortDescription>将自己的值与自身进行比较  Self comparison of value with itself</ShortDescription>
    <LongDescription>将{2}与自身{1}进行自我比较</LongDescription>
    <Details>
<![CDATA[<p>该方法将局部变量与其自身进行比较，可能会指示打字错误或逻辑错误。请确保您比较的是正确的内容。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT">
    <ShortDescription>在对一个int进行调用时使用了Double.longBitsToDouble方法。  Double.longBitsToDouble invoked on an int</ShortDescription>
    <LongDescription>在{1}中，调用了Double.longBitsToDouble方法处理int类型的值。</LongDescription>
    <Details>
<![CDATA[<p>调用了 Double.longBitsToDouble 方法，但传递了一个 32 位 int 值作为参数。这几乎肯定不是预期的行为，也不大可能得到预期的结果。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_ARGUMENTS_WRONG_ORDER">
    <ShortDescription>颠倒的方法参数  Reversed method arguments</ShortDescription>
    <LongDescription>在{1}中对{2.name}的调用参数顺序错误。</LongDescription>
    <Details>
<![CDATA[<p>这个方法调用的参数顺序似乎不对。例如，调用<code>Preconditions.checkNotNull("message", message)</code>时，保留的参数顺序是：要检查的值应该是第一个参数。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_RANDOM_USED_ONLY_ONCE">
    <ShortDescription>随机对象仅创建并使用一次  Random object created and used only once</ShortDescription>
    <LongDescription>在{1}中，随机对象仅创建并使用一次。</LongDescription>
    <Details>
<![CDATA[<p>这段代码创建了一个 java.util.Random 对象，使用它生成一个随机数，然后丢弃该 Random 对象。这会产生质量一般的随机数，并且效率低下。如果可能的话，请重新编写代码，使其只创建一次 Random 对象并保存下来，在每次需要新随机数时调用现有 Random 对象的方法来获取新随机数。</p>
<p>如果生成的随机数不能被猜测到非常重要，则<strong>必须</strong>不要为每个随机数都创建一个新的 Random；这些值太容易被猜到了。你应该强烈考虑使用 java.security.SecureRandom（并且避免为每次需要的新随机数分配一个新 SecureRandom）。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_ABSOLUTE_VALUE_OF_RANDOM_INT">
    <ShortDescription>尝试计算有符号随机整数的绝对值是不良做法。  Bad attempt to compute absolute value of signed random integer</ShortDescription>
    <LongDescription>尝试计算带有符号随机整数的绝对值在{1}中是不正确的。</LongDescription>
    <Details>
<![CDATA[<p>这段代码生成一个随机的带符号整数，然后计算该随机整数的绝对值。如果随机数生成器返回的是 <code>Integer.MIN_VALUE</code>，那么结果也将是负数（因为 <code>Math.abs(Integer.MIN_VALUE) == Integer.MIN_VALUE</code>)。同样地，这个问题对于 long 类型的值也存在。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_ABSOLUTE_VALUE_OF_HASHCODE">
    <ShortDescription>尝试计算有符号32位哈希码的绝对值是一个不良实践。  Bad attempt to compute absolute value of signed 32-bit hashcode</ShortDescription>
    <LongDescription>在{1}处尝试计算带符号32位哈希码的绝对值是一种不良做法。</LongDescription>
    <Details>
<![CDATA[<p>这段代码生成一个哈希码，然后计算该哈希码的绝对值。如果哈希码是 <code>Integer.MIN_VALUE</code>，那么结果也将是负数（因为 <code>Math.abs(Integer.MIN_VALUE) == Integer.MIN_VALUE</code>)。</p>
<p>大约每2^32个字符串的哈希码为 Integer.MIN_VALUE，包括 "polygenelubricants"、"GydZG_" 和 ""DESIGNING WORKHOUSES"。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_REM_OF_RANDOM_INT">
    <ShortDescription>32位有符号随机整数的余数  Remainder of 32-bit signed random integer</ShortDescription>
    <LongDescription>在{1}中计算32位带符号随机整数的余数</LongDescription>
    <Details>
<![CDATA[<p>这段代码生成一个随机的带符号整数，然后计算该值对该另一个值取模。由于随机数可以是负数，所以取余操作的结果也可能为负数。请确保这是预期的行为，并强烈考虑使用 Random.nextInt(int) 方法代替。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_REM_OF_HASHCODE">
    <ShortDescription>hashCode的余数可能是负数  Remainder of hashCode could be negative</ShortDescription>
    <LongDescription>在 `{1}` 中，`hashCode` 的余数可能是负数。</LongDescription>
    <Details>
<![CDATA[<p>这段代码计算哈希码，然后将该值与另一个值进行取模运算。由于哈希码可以是负数，因此取模操作的结果也可能为负数。</p>
<p>假设您希望确保计算结果是非负的，可能需要修改您的代码。如果知道除数是2的幂次，则可以使用位与运算符代替（即，而不是使用<xcode>x.hashCode()%n</xcode>，应使用<xcode>x.hashCode()&(n-1)</xcode>）。这可能比计算余数更快。如果不确定除数是否为2的幂次，则可以取余操作结果的绝对值（即使用<xcode>Math.abs(x.hashCode()%n)</xcode>）。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE">
    <ShortDescription>非负值与负常量或零进行不良比较  Bad comparison of nonnegative value with negative constant or zero</ShortDescription>
    <LongDescription>在{1}中，非负值与{2}进行了不良比较。</LongDescription>
    <Details>
<![CDATA[<p>此代码将一个保证非负的值与一个负常量或零进行比较。</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="INT_BAD_COMPARISON_WITH_SIGNED_BYTE">
    <ShortDescription>signed字节的不良比较  Bad comparison of signed byte</ShortDescription>
    <LongDescription>在{1}中，用{2}对有符号字节进行了不良比较。</LongDescription>
    <Details>
<![CDATA[<p>signed字节的值只能在-128到127之间。将一个signed字节与该范围之外的值进行比较是无意义的，很可能不正确。要将一个signed字节<b>b</b>转换为0..255范围内的无符号值，应使用<code>0xff & b</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="INT_BAD_COMPARISON_WITH_INT_VALUE">
    <ShortDescription>将int值与long常量进行不良比较  Bad comparison of int value with long constant</ShortDescription>
    <LongDescription>在{1}中，int与{2}进行了不良比较。</LongDescription>
    <Details>
<![CDATA[<p>该代码将一个 int 值与一个超出 int 可表示值范围的 long 常量进行比较。这种比较是空洞的，并且可能不正确。</p>]]>
    </Details>
  </BugPattern>


  <BugPattern type="INT_VACUOUS_BIT_OPERATION">
    <ShortDescription>对整数值进行空洞位掩码操作  Vacuous bit mask operation on integer value</ShortDescription>
    <LongDescription>在{1}中对{3}执行空操作{2}</LongDescription>
    <Details>
<![CDATA[这是一些不进行任何有用工作的整数位操作（例如，<code>v & 0xffffffff</code>）。]]>
    </Details>
  </BugPattern>
  <BugPattern type="INT_VACUOUS_COMPARISON">
    <ShortDescription>空洞地比较整数值  Vacuous comparison of integer value</ShortDescription>
    <LongDescription>整数值 {1} 的虚比较</LongDescription>
    <Details>
<![CDATA[<p>存在一个整数比较总是返回相同值的情况（例如，x <= Integer.MAX_VALUE）。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="INT_BAD_REM_BY_1">
    <ShortDescription>取模运算的除数为1  Integer remainder modulo 1</ShortDescription>
    <LongDescription>在{1}中计算了整数余模1操作。</LongDescription>
    <Details>
<![CDATA[<p>(exp % 1) 表达式始终返回零。您是想使用 (exp & 1) 或 (exp % 2) 吗？</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_IOR_OF_SIGNED_BYTE">
    <ShortDescription>有符号字节值的位或运算  Bitwise OR of signed byte value</ShortDescription>
    <LongDescription>在{1}中计算了带符号字节值的按位或运算。</LongDescription>
    <Details>
<![CDATA[<p>加载一个字节值（例如，从字节数组中加载或由返回类型为 byte 的方法返回），并对其进行按位 OR 操作。在对字节值进行任何按位操作之前，字节值会扩展到 32 位。因此，如果 `b[0]` 包含值 `0xff`，并且 `x` 初始值为 0，则代码 `((x << 8) | b[0])` 将会将 `0xff` 扩展到 `0xffffffff`，从而给出结果 `0xffffffff`。</p>
<p>特别是下面用于将字节数组打包到 int 中的代码是错误的：</p>
<pre><code>int result = 0;
for(int i = 0; i < 4; i++) {
    result = ((result << 8) | b[i]);
}
</code></pre>
<p>以下模式将起作用：</p>
<pre><code>int result = 0;
for(int i = 0; i < 4; i++) {
    result = ((result << 8) | (b[i] & 0xff));
}
</code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_ADD_OF_SIGNED_BYTE">
    <ShortDescription>有符号字节值的位运算加法  Bitwise add of signed byte value</ShortDescription>
    <LongDescription>在{1}中计算了带符号字节值的按位加操作</LongDescription>
    <Details>
<![CDATA[<p>将一个字节值和一个已知其下8位均为清零的值相加。从字节数组中加载的值在进行任何位运算之前会被扩展为32位。因此，如果`b[0]`包含值`0xff`，并且`x`初始为0，则代码`((x << 8) + b[0])` 将会将`0xff`扩展为`0xffffffff`，从而得到结果`0xffffffff`。</p>
<p>特别是以下用于将字节数组打包到一个int中的代码是错误的：</p>
<pre><code>int result = 0;
for(int i = 0; i &lt; 4; i++)
    result = ((result &lt;&lt; 8) + b[i]);
</code></pre>
<p>以下模式将起作用：</p>
<pre><code>int result = 0;
for(int i = 0; i &lt; 4; i++)
    result = ((result &lt;&lt; 8) + (b[i] &amp; 0xff));
</code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_AND">
    <ShortDescription>不兼容的位掩码  Incompatible bit masks</ShortDescription>
    <LongDescription>在 `(e &amp; {2} == {3})` 中使用不兼容的位掩码会在 `{1}` 中产生常量结果。</LongDescription>
    <Details>
<![CDATA[<p>该方法将表达式(e & C)与D进行比较，由于常量C和D的具体值，这种比较总是不相等的。这可能表明存在逻辑错误或打字错误。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_SIGNED_CHECK">
    <ShortDescription>检查位运算符号  Check for sign of bitwise operation</ShortDescription>
    <LongDescription>在{1}中检查位运算符号。</LongDescription>
    <Details>
<![CDATA[<p>此方法比较类似于 <code>((event.detail &amp; SWT.SELECTED) &gt; 0)</code> 的表达式。使用位算术然后与大于操作符进行比较可能会导致意外的结果（当然这取决于 `SWT.SELECTED` 的值）。如果 `SWT.SELECTED` 是一个负数，那么这是一个潜在的 bug 候选。即使 `SWT.SELECTED` 不是负数，似乎最好使用 `!= 0` 而不是 `&gt; 0`。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_SIGNED_CHECK_HIGH_BIT">
    <ShortDescription>检查涉及负数的位运算符号  Check for sign of bitwise operation involving negative number</ShortDescription>
    <LongDescription>在 {1} 中检查涉及 {2} 的位运算符号。</LongDescription>
    <Details>
<![CDATA[<p>此方法比较位运算表达式，例如 <code>((val &amp; CONSTANT) > 0)</code>，其中 CONSTANT 是一个负数。使用位运算然后与大于运算符进行比较可能会导致意想不到的结果。这种比较很可能不会按预期工作。良好的做法是使用 '!= 0' 替代 '&gt; 0'。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_AND_ZZ">
    <ShortDescription>检查是否 ((...) &amp; 0) == 0  Check to see if ((...) &amp; 0) == 0</ShortDescription>
    <LongDescription>检查 {(...) &amp; 0} == 0 在 {1} 中是否存在</LongDescription>
    <Details>
<![CDATA[<p>该方法将表达式<code>(e & 0)</code>与0进行比较，这始终会比较相等。这可能指示逻辑错误或打字错误。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_IOR">
    <ShortDescription>不兼容的位掩码  Incompatible bit masks</ShortDescription>
    <LongDescription>在(e | {2} == {3})中使用不兼容的位掩码导致{1}中的常量结果</LongDescription>
    <Details>
<![CDATA[<p>此方法将表达式 <code>(e | C)</code> 与 D 进行比较，由于常量 C 和 D 的特定值，这种比较总是不相等。这可能表明存在逻辑错误或打字错误。</p>
<p>通常，这个bug是因为代码想要在一个位集合中执行成员测试，但使用了按位或运算符（“|”）而不是按位与运算符（“&amp;”）。</p>
<p>此外，在表达式 <code>(e &amp; A | B) == C</code> 中可能会出现这样的bug，它会被解析为 <code>((e &amp; A) | B) == C</code> 而不是期望的 <code>(e &amp; (A | B)) == C</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="LI_LAZY_INIT_INSTANCE" deprecated="true"> <!-- never generated? -->
    <ShortDescription>实例字段的懒初始化不正确  Incorrect lazy initialization of instance field</ShortDescription>
    <LongDescription>在 {1} 中，实例字段 {2} 的懒初始化不正确</LongDescription>
    <Details>
<![CDATA[<p>该方法包含一个未同步的懒初始化非易失性字段。由于编译器或处理器可能会重新排序指令，因此如果该方法可以被多个线程调用，则线程不能保证看到一个完全初始化的对象。你可以将字段声明为易失性以纠正此问题。更多信息，请参阅<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/">Java 内存模型网页</a>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="LI_LAZY_INIT_STATIC">
    <ShortDescription>静态字段的懒初始化不正确  Incorrect lazy initialization of static field</ShortDescription>
    <LongDescription>在 `{1}` 中静态字段 `{2}` 的懒初始化不正确</LongDescription>
    <Details>
<![CDATA[<p>该方法包含了一个未同步的懒加载初始化的非易失静态字段。由于编译器或处理器可能会重排序指令，因此如果该方法可以被多个线程调用，则线程不能保证看到一个完全初始化的对象。你可以将字段声明为易失性（volatile）以解决问题。更多信息，请参见<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/">Java 内存模型网站</a>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="LI_LAZY_INIT_UPDATE_STATIC">
    <ShortDescription>错误的懒加载和静态字段的更新  Incorrect lazy initialization and update of static field</ShortDescription>
    <LongDescription>在{1}中，静态字段{2}的懒初始化和更新不正确。</LongDescription>
    <Details>
<![CDATA[<p>此方法包含一个未同步的懒加载静态字段初始化。一旦字段被设置，存储在该位置的对象将被进一步更新或访问。当字段被设置时，其设置对其他线程是可见的。如果方法中的后续访问用于初始化对象，则除非有其他机制防止任何其他线程在此对象完全初始化之前访问它，否则您将有一个 <em>非常严重</em> 的多线程错误。</p>
<p>即使您认为该方法永远不会由多个线程调用，最好还是在要设置的值完全填充/初始化后再设置静态字段。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="JLM_JSR166_LOCK_MONITORENTER">
    <ShortDescription>同步操作执行于Lock上  Synchronization performed on Lock</ShortDescription>
    <LongDescription>在 {1} 中对 {2} 进行了同步处理</LongDescription>
    <Details>
<![CDATA[<p>该方法对实现 java.util.concurrent.locks.Lock 接口的对象进行同步。这样的对象是通过调用 <code>acquire()</code> 和 <code>release()</code> 方法来加锁/解锁，而不是使用 <code>synchronized (...)</code> 构造。 </p>]]>
</Details>
  </BugPattern>
  <BugPattern type="JML_JSR166_CALLING_WAIT_RATHER_THAN_AWAIT">
    <ShortDescription>在util.concurrent抽象层上使用监控风格的等待方法  Using monitor style wait methods on util.concurrent abstraction</ShortDescription>
    <LongDescription>在{1}中调用{2.name}而不是{3.name}</LongDescription>
    <Details>
<![CDATA[<p>该方法对一个也提供了 <code>await()</code>、<code>signal()</code> 或 <code>signalAll()</code> 方法（例如 util.concurrent 中的 Condition 对象）的对象调用了 <code>wait()</code>、<code>notify()</code> 或 <code>notifyAll()</code>。这可能不是你想要的效果，即使你需要这样做，你也应该考虑改变你的设计，因为其他开发人员会发现这一点非常令人困惑。</p>]]>
</Details>
  </BugPattern>
  <BugPattern type="JLM_JSR166_UTILCONCURRENT_MONITORENTER">
    <ShortDescription>同步操作执行于 util.concurrent 实例  Synchronization performed on util.concurrent instance</ShortDescription>
    <LongDescription>在{1}中对{2}进行了同步</LongDescription>
    <Details>
<![CDATA[<p>该方法对一个实例来自 java.util.concurrent 包（或其子类）的类的对象进行同步。这些类的实例具有与 Java 关键字 <code>synchronized</code> 提供的同步机制相独立的并发控制机制。例如，对一个 <code>AtomicBoolean</code> 进行同步并不会阻止其他线程修改该 <code>AtomicBoolean</code>。</p>
<p>这样的代码可能是正确的，但在代码审查和文档记录时需要特别小心，并且可能会让日后维护代码的人感到困惑。</p>]]>
</Details>
  </BugPattern>
  <BugPattern type="UPM_UNCALLED_PRIVATE_METHOD">
    <ShortDescription>私有方法从未被调用  Private method is never called</ShortDescription>
    <LongDescription>私有方法 {1} 从未被调用</LongDescription>
    <Details>
<![CDATA[<p>该私有方法从未被调用。虽然有可能通过反射来调用该方法，但更可能的是该方法未被使用，并应该被移除。</p>]]>
</Details>
  </BugPattern>
  <BugPattern type="UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS">
    <ShortDescription>在匿名类中定义了无法调用的方法  Uncallable method defined in anonymous class</ShortDescription>
    <LongDescription>在匿名类中定义了无法调用的方法 {1}</LongDescription>
    <Details>
<![CDATA[<p>这个匿名类定义了一个未直接调用的方法，并且也没有覆盖超类中的方法。由于其他类无法直接调用匿名类中声明的方法，看来这个方法可能是不可调用的。该方法可能只是一个死代码，但也有可能是打算覆盖超类中声明的方法，但由于 typo 或其他错误，实际上并未覆盖预期的方法。</p>]]>
</Details>
  </BugPattern>
  <BugPattern type="ODR_OPEN_DATABASE_RESOURCE">
    <ShortDescription>方法可能会未能关闭数据库资源  Method may fail to close database resource</ShortDescription>
    <LongDescription>{1} 可能无法关闭 {2.excludingPackage}</LongDescription>
    <Details>
<![CDATA[<p>该方法创建了一个数据库资源（例如，数据库连接或行集），但并未将其赋值给任何字段、传给其他方法或返回它，并且在方法的所有退出路径中都没有出现关闭对象的情况。如果不在方法的所有退出路径中关闭数据库资源，可能会导致性能不佳，并可能导致应用程序与数据库通信出现问题。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH">
    <ShortDescription>方法在异常情况下可能无法关闭数据库资源  Method may fail to close database resource on exception</ShortDescription>
    <LongDescription>在异常情况下，可能无法关闭数据库资源。</LongDescription>
    <Details>
<![CDATA[<p>该方法创建了一个数据库资源（例如，数据库连接或行集），但未将其分配给任何字段、传递给其他方法或返回它，并且在方法的所有异常路径中都没有出现关闭对象的代码。如果不从所有方法路径中正确关闭数据库资源，可能会导致性能不佳，并可能导致应用程序与数据库通信出现问题。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SBSC_USE_STRINGBUFFER_CONCATENATION">
    <ShortDescription>方法在循环中使用 + 连接字符串  Method concatenates strings using + in a loop</ShortDescription>
    <LongDescription>{1} 在循环中使用 + 连接字符串</LongDescription>
    <Details>
<![CDATA[<p>该方法似乎是在循环中使用连接操作构建一个String。在每次迭代中，字符串会被转换为StringBuffer/StringBuilder进行追加操作，并再次转换回String。这可能导致成本随着迭代次数的增加而呈平方级增长，在每次迭代中都会对不断增长的字符串进行重新复制。</p>
<p>通过显式使用StringBuffer（或Java 1.5中的StringBuilder）可以获得更好的性能。</p>
<p>例如：</p>
<pre><code>// 这是不好的做法
String s = "";
for (int i = 0; i < field.length; ++i) {
    s = s + field[i];
}

// 这是更好的做法
StringBuffer buf = new StringBuffer();
for (int i = 0; i < field.length; ++i) {
    buf.append(field[i]);
}
String s = buf.toString();
</code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIL_PREPARE_STATEMENT_IN_LOOP">
    <ShortDescription>在循环中使用 prepareStatement 方法调用  Method calls prepareStatement in a loop</ShortDescription>
    <LongDescription>{1} 在循环中使用常量参数调用 `prepareStatement` 方法</LongDescription>
    <Details>
<![CDATA[<p>该方法在循环中调用了Connection.prepareStatement，并传递了常量参数。如果PreparedStatement需要多次执行，那么为每个循环迭代重新创建它就没有必要。将此调用移出循环。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIL_ELEMENTS_GET_LENGTH_IN_LOOP">
    <ShortDescription>在循环中调用了 NodeList.getLength() 方法  NodeList.getLength() called in a loop</ShortDescription>
    <LongDescription>{1} 在循环中调用 NodeList 的 getLength() 方法来获取getElementsByTagName的返回值。</LongDescription>
    <Details>
<![CDATA[<p>该方法在循环中调用了NodeList.getLength()，而NodeList是通过getElementsByTagName获取的。NodeList并没有存储其长度，而是每次都在不太理想的方式下重新计算它。可以在循环前将长度值存到一个变量中考虑一下。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIL_PATTERN_COMPILE_IN_LOOP">
    <ShortDescription>在循环中使用Pattern.compile方法  Method calls Pattern.compile in a loop</ShortDescription>
    <LongDescription>{1} 在循环中使用常量参数调用Pattern.compile方法</LongDescription>
    <Details>
<![CDATA[<p>该方法在循环中调用Pattern.compile，传入常量参数。如果Pattern需要多次使用，则无需在每次循环迭代时进行编译。将此调用移出循环，甚至可以放到static final字段中。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIL_PATTERN_COMPILE_IN_LOOP_INDIRECT">
    <ShortDescription>方法会在循环中编译正则表达式  Method compiles the regular expression in a loop</ShortDescription>
    <LongDescription>{1} 在循环中编译正则表达式</LongDescription>
    <Details>
<![CDATA[<p>该方法在循环中创建了相同的正则表达式，因此会在每次迭代时重新编译。可以在循环外部使用Pattern.compile预编译这个正则表达式以提高效率。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIO_INEFFICIENT_INDEX_OF">
    <ShortDescription>对 `String.indexOf(String)` 的使用不够高效  Inefficient use of String.indexOf(String)</ShortDescription>
    <LongDescription>{1} 使用 `String.indexOf(String)` 代替 `String.indexOf(int)` 方法。</LongDescription>
    <Details>
<![CDATA[<p>这段代码将长度为1的常量字符串传递给String.indexOf()方法。使用整数版本的String.indexOf()更加高效，例如调用<code>myString.indexOf('.')</code>而不是<code>myString.indexOf(".")

</code></p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIO_INEFFICIENT_LAST_INDEX_OF">
    <ShortDescription>不高效地使用 `String.lastIndexOf(String)` 方法  Inefficient use of String.lastIndexOf(String)</ShortDescription>
    <LongDescription>{1} 使用了 `String.lastIndexOf(String)` 而不是 `String.lastIndexOf(int)`</LongDescription>
    <Details>
<![CDATA[<p>这段代码将长度为1的常量字符串传递给String.lastIndexOf()方法。使用整数实现的String.lastIndexOf()更为高效，例如调用<code>myString.lastIndexOf('.')</code>而不是<code>myString.lastIndexOf(".')</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ITA_INEFFICIENT_TO_ARRAY">
    <ShortDescription>方法使用了零长度数组作为toArray()的方法参数  Method uses toArray() with zero-length array argument</ShortDescription>
    <LongDescription>{1} 使用零长度数组作为参数的 `Collection.toArray()` 方法</LongDescription>
    <Details>
<![CDATA[<p>该方法使用集合派生类的 toArray() 方法，并传入一个零长度的原型数组参数。更高效的方式是使用 <code>myCollection.toArray(new Foo[myCollection.size()])</code>。如果传递进来的数组大小足以容纳集合中的所有元素，则直接填充并返回该数组，从而避免通过反射创建第二个数组作为结果。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD">
    <ShortDescription>在 `run` 方法中的 JUnit 断言不会被 JUnit 检测到。  JUnit assertion in run method will not be noticed by JUnit</ShortDescription>
    <LongDescription>在 `{1}` 中的 JUnit 断言将不会被 JUnit 检测到。</LongDescription>
    <Details>
<![CDATA[<p>在run方法中执行了一个JUnit断言。失败的JUnit断言只会抛出异常。因此，如果这个异常发生在调用测试方法的线程以外的线程中，将会终止该线程但不会导致测试失败。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IJU_SETUP_NO_SUPER">
    <ShortDescription>testCase定义了setUp方法，但没有调用super.setUp()方法。  TestCase defines setUp that doesn't call super.setUp()</ShortDescription>
    <LongDescription>测试用例 {0} 定义了 `setUp` 但没有调用 `super.setUp()` 方法。</LongDescription>
    <Details>
<![CDATA[<p>Class是一个JUnit测试案例，并实现了setUp方法。但是，setUp方法没有调用super.setUp()。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IJU_TEARDOWN_NO_SUPER">
    <ShortDescription>testCase 定义了 tearDown 但没有调用 super.tearDown()  TestCase defines tearDown that doesn't call super.tearDown()</ShortDescription>
    <LongDescription>测试用例 {0} 定义了 tearDown，但没有调用 super.tearDown() 方法。</LongDescription>
    <Details>
<![CDATA[<p>Class是一个JUnit测试案例，并实现了tearDown方法。但是，tearDown方法没有调用super.tearDown()。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IJU_SUITE_NOT_STATIC">
    <ShortDescription>testCase 实现了一个非静态的套件方法  TestCase implements a non-static suite method</ShortDescription>
    <LongDescription>测试用例 {0} 实现了一个非静态的套件方法</LongDescription>
    <Details>
<![CDATA[<p>Class是一个JUnit测试用例，并实现了suite()方法。但是，suite方法应该被声明为静态方法，但并未如此声明。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IJU_BAD_SUITE_METHOD">
    <ShortDescription>测试用例声明了一个不良的套件方法  TestCase declares a bad suite method</ShortDescription>
    <LongDescription>在{0}中，套件方法的声明有误。</LongDescription>
    <Details>
<![CDATA[<p>Class是一个JUnit TestCase，并定义了一个suite()方法。但是，suite方法需要声明为以下之一：</p>
<pre><code>public static junit.framework.Test suite()
</code></pre>
<p>或者</p>
<pre><code>public static junit.framework.TestSuite suite()
</code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IJU_NO_TESTS">
    <ShortDescription>testCase中没有任何测试用例。  TestCase has no tests</ShortDescription>
    <LongDescription>测试用例 {0} 没有包含任何测试。</LongDescription>
    <Details>
<![CDATA[<p>Class是一个JUnit TestCase，但未实现任何测试方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BOA_BADLY_OVERRIDDEN_ADAPTER">
    <ShortDescription>类在适配器中错误地覆写了超类中实现的方法  Class overrides a method implemented in super class Adapter wrongly</ShortDescription>
    <LongDescription>类 {0} 在重写来自适配器超类的方法 {1} 时存在问题。</LongDescription>
    <Details>
<![CDATA[<p>此方法重写了父类中的一个方法，而该父类是一个适配器，并实现了位于 `java.awt.event` 或 `javax.swing.event` 包中的监听者定义。因此，当事件发生时，此方法不会被调用。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BRSA_BAD_RESULTSET_ACCESS" deprecated="true"> <!-- deprecated in favor of SQL_BAD_RESULTSET_ACCESS -->
    <ShortDescription>方法尝试使用索引 0 访问结果集字段。  Method attempts to access a result set field with index 0</ShortDescription>
    <LongDescription>尝试使用索引0访问结果集字段</LongDescription>
    <Details>
<![CDATA[<p>在调用结果集的getXXX或updateXXX方法时，字段索引为0。由于结果集中的字段从索引1开始，这总是错误的。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SQL_BAD_RESULTSET_ACCESS">
    <ShortDescription>方法尝试使用索引 0 访问结果集字段。  Method attempts to access a result set field with index 0</ShortDescription>
    <LongDescription>尝试使用索引 0 访问结果集字段。</LongDescription>
    <Details>
<![CDATA[<p>在调用结果集的getXXX或updateXXX方法时，字段索引为0。由于ResultSet中的字段索引从1开始，因此这种做法总是错误的。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SQL_BAD_PREPARED_STATEMENT_ACCESS">
    <ShortDescription>方法尝试使用索引 0 访问预处理语句参数。  Method attempts to access a prepared statement parameter with index 0</ShortDescription>
    <LongDescription>尝试使用索引 0 访问预编译语句参数。</LongDescription>
    <Details>
<![CDATA[<p>在调用准备语句的setXXX方法时，参数索引为0。由于参数索引从1开始，这始终是一个错误。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIO_SUPERFLUOUS_INSTANCEOF">
    <ShortDescription>使用 `instanceof` 运算符进行不必要的类型检查  Unnecessary type check done using instanceof operator</ShortDescription>
    <LongDescription>{1} 使用 `instanceof` 运算符进行不必要的类型检查，当可以通过静态分析确定时不应如此。</LongDescription>
    <Details>
<![CDATA[<p>使用 instanceof 运算符进行类型检查，可以在静态确定对象是否为所需类型时使用。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BAC_BAD_APPLET_CONSTRUCTOR">
    <ShortDescription>不良的Applet构造函数依赖于未初始化的AppletStub  Bad Applet Constructor relies on uninitialized AppletStub</ShortDescription>
    <LongDescription>不良的Applet构造函数依赖于未初始化的AppletStub</LongDescription>
    <Details>
<![CDATA[<p>这个构造函数调用了依赖于AppletStub的方法，而AppletStub只有在该Applet的init()方法被调用后才会初始化。因此，这些方法将无法正确执行。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_ARRAY_AND_NONARRAY">
    <ShortDescription>使用 `equals()` 方法比较数组和非数组类型  equals() used to compare array and nonarray</ShortDescription>
    <LongDescription>在{1}中调用了{3.simpleClass}.equals({2.simpleClass})。</LongDescription>
    <Details>
<![CDATA[<p>该方法使用 .equals(Object o) 来比较一个数组和一个看起来不是数组的引用。如果被比较的对象类型不同，它们几乎可以肯定不相等，这种比较很可能是一个错误。即使两者都是数组，数组的 equals 方法只能确定这两个数组是否是同一个对象。要比较数组的内容，请使用 java.util.Arrays.equals(Object[], Object[])。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_BAD_ARRAY_COMPARE">
    <ShortDescription>对数组调用equals()方法，这等同于使用==进行比较。  Invocation of equals() on an array, which is equivalent to ==</ShortDescription>
    <LongDescription>在{1}中，使用.equals来比较两个{2.simpleClass}的实例（相当于==）。</LongDescription>
    <Details>
<![CDATA[<p>此方法在数组上调用了 .equals(Object o) 方法。由于数组未重写 Object 的 equals 方法，因此调用数组的 equals 方法相当于比较它们的地址。若要比较数组的内容，请使用 <code>java.util.Arrays.equals(Object[], Object[])</code>。若要比较数组的地址，则明确地使用 <code>==</code> 进行指针比较会更清晰。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_INCOMPATIBLE_ARRAY_COMPARE">
    <ShortDescription>使用 equals(...) 方法比较不兼容的数组  equals(...) used to compare incompatible arrays</ShortDescription>
    <LongDescription>在{1}中使用equals比较一个{2.simpleClass}和一个{3.simpleClass}。</LongDescription>
    <Details>
<![CDATA[<p>该方法使用 .equals(Object o) 来比较两个数组，但这两个数组的类型不兼容（例如 String[] 和 StringBuffer[]，或者 String[] 和 int[]）。它们永远不会相等。另外，当使用 equals(...) 来比较数组时，它只会检查这两个数组是否是同一个数组，并忽略数组的内容。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="STI_INTERRUPTED_ON_CURRENTTHREAD">
    <ShortDescription>unnecessary 使用 currentThread() 调用，应使用 interrupted() 方法  Unneeded use of currentThread() call, to call interrupted()</ShortDescription>
    <LongDescription>{1} 仅仅为了调用 `interrupted()` 而调用了不必要的 `currentThread()` 方法。</LongDescription>
    <Details>
<![CDATA[<p>该方法调用了 Thread.currentThread()，只是为了调用 interrupted() 方法。由于 interrupted() 是一个静态方法，使用 Thread.interrupted() 更简单且更清晰。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="STI_INTERRUPTED_ON_UNKNOWNTHREAD">
    <ShortDescription>在线程实例上调用静态的 `Thread.interrupted()` 方法  Static Thread.interrupted() method invoked on thread instance</ShortDescription>
    <LongDescription>{1} 在线程实例上调用了静态的 `Thread.interrupted()` 方法。</LongDescription>
    <Details>
<![CDATA[<p>该方法在一个显然不是当前线程的Thread对象上调用了Thread.interrupted()方法。由于interrupted()方法是静态方法，因此实际上调用的是不同的对象而不是作者意图调用的对象。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN">
    <ShortDescription>参数在方法入口处是无效的，但在之后被覆盖了。  A parameter is dead upon entry to a method but overwritten</ShortDescription>
    <LongDescription>参数 {2} 在进入 {1} 时已失效，但被覆盖了</LongDescription>
    <Details>
<![CDATA[<p>此参数的初始值将被忽略，并在此被覆盖。这通常表明误以为对参数的写操作会返回给调用者。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DLS_DEAD_LOCAL_STORE_SHADOWS_FIELD">
    <ShortDescription>遮蔽字段的局部变量的死.store  Dead store to local variable that shadows field</ShortDescription>
    <LongDescription>在{1}中，将值存储到了同名字段{2}而不是直接使用该字段</LongDescription>
    <Details>
<![CDATA[<p>这条指令给局部变量赋值，但该值并未在后续的任何指令中被读取或使用。通常这表示存在错误，因为计算出的值从未被使用过。存在一个同名的字段。您是否应该将值赋予那个变量？ </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DLS_DEAD_LOCAL_STORE">
    <ShortDescription>对局部变量的死存储  Dead store to local variable</ShortDescription>
    <LongDescription>在{1}中对{2}进行了死存储</LongDescription>
    <Details>
<![CDATA[<p>这条指令给局部变量赋值，但该值在后续指令中并未被读取或使用。通常这表明存在错误，因为计算出的值从未被使用。</p>
<p>请注意，Sun的javac编译器经常会为final局部变量生成无效存储。由于SpotBugs是一个基于字节码的工具，因此很难消除这些误报。</p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="DLS_DEAD_LOCAL_STORE_IN_RETURN">
    <ShortDescription>返回语句中的无用赋值  Useless assignment in return statement</ShortDescription>
    <LongDescription>从 {1} 返回时的无用赋值</LongDescription>
    <Details>
      <![CDATA[<p>该语句在一个返回语句中给局部变量进行了赋值。此赋值会有效果，请验证该语句是否正确。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DLS_DEAD_LOCAL_INCREMENT_IN_RETURN">
    <ShortDescription>在返回语句中不必要的递增  Useless increment in return statement</ShortDescription>
    <LongDescription>从{1}返回时的无用增量操作</LongDescription>
    <Details>
      <![CDATA[<p>该语句包含返回表达式如<code>return x++;</code> / <code>return x--;</code>。后缀增量/ decrement 操作不会影响表达式的值，因此此增量/ decrement 无效果。请确认该语句是否正确。</p>]]>
    </Details>
  </BugPattern>



  <BugPattern type="DLS_DEAD_STORE_OF_CLASS_LITERAL">
    <ShortDescription>类字面量的死存储  Dead store of class literal</ShortDescription>
    <LongDescription>在 `{1}` 中检测到对 `{3}.class` 的无效存储。</LongDescription>
    <Details>
<![CDATA[<p>这条指令将一个类字面量赋值给一个变量，但从未使用过它。在Java 1.4和Java 5中此行为有所不同。<a href="http://www.oracle.com/technetwork/java/javase/compatibility-137462.html#literal">在Java 1.4及更早版本中，对`Foo.class`的引用会强制执行`Foo`的静态初始化器（如果尚未执行的话）。而在Java 5及更高版本中，则不会执行。</a></p>
<p>查看Sun关于<a href="http://www.oracle.com/technetwork/java/javase/compatibility-137462.html#literal">Java SE兼容性</a>的文章以获取更多细节和示例，并了解如何在Java 5中强制类初始化的方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DLS_DEAD_LOCAL_STORE_OF_NULL">
    <ShortDescription>对局部变量进行null的死-store检查  Dead store of null to local variable</ShortDescription>
    <LongDescription>在{1}中对{2}进行了空值的死存储</LongDescription>
    <Details>
<![CDATA[<p>代码将null存储到一个局部变量中，但并未读取该值。这种存储可能是为了帮助垃圾回收器，但在Java SE 6.0及更高版本中，这已经不再需要或有用。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MF_METHOD_MASKS_FIELD">
    <ShortDescription>方法定义了一个变量遮蔽了字段  Method defines a variable that obscures a field</ShortDescription>
    <LongDescription>{1} 定义了一个变量，遮蔽了字段 {2.givenClass}</LongDescription>
    <Details>
<![CDATA[<p>此方法定义了一个局部变量，其名称与该类或超类中的一个字段同名。这可能导致方法从字段中读取未初始化的值、使字段保持未初始化状态，或者同时发生这两种情况。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MF_CLASS_MASKS_FIELD">
    <ShortDescription>类定义了字段来遮掩上级类的字段  Class defines field that masks a superclass field</ShortDescription>
    <LongDescription>字段 `{1.givenClass}` 遮盖了超类 `{2.class}` 中的字段</LongDescription>
    <Details>
<![CDATA[<p>此类定义了一个与超类中可见实例字段同名的字段。这可能会引起混淆，并且如果方法更新或访问其中一个字段时本想操作的是另一个字段，则可能会出现错误。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="WMI_WRONG_MAP_ITERATOR">
    <ShortDescription>使用keySet迭代器而非entrySet迭代器导致效率低下  Inefficient use of keySet iterator instead of entrySet iterator</ShortDescription>
    <LongDescription>{1} 不恰当地使用了keySet迭代器而不是entrySet迭代器。</LongDescription>
    <Details>
<![CDATA[<p>该方法使用从 keySet 迭代器检索到的键来访问 Map 入项的值。直接在 map 的 entrySet 上使用迭代器进行遍历会更高效，可以避免进行 Map.get(key) 查找。</p>]]>
        </Details>
  </BugPattern>
  <BugPattern type="ISC_INSTANTIATE_STATIC_CLASS">
    <ShortDescription>只提供静态方法的类不必要的实例化  Needless instantiation of class that only supplies static methods</ShortDescription>
    <LongDescription>{1} 不必要地实例化只提供静态方法的类</LongDescription>
    <Details>
<![CDATA[<p>这个类基于仅提供静态方法的类分配一个对象。不需要创建此对象，可以直接使用类名作为限定符访问其静态方法。</p>]]>
        </Details>
  </BugPattern>
  <BugPattern type="REC_CATCH_EXCEPTION">
    <ShortDescription>当未抛出异常时捕获异常  Exception is caught when Exception is not thrown</ShortDescription>
    <LongDescription>当在{1}中未抛出异常却捕获了异常。</LongDescription>
    <Details>
  <![CDATA[<p>   这个方法使用了 try-catch 块来捕获 Exception 对象，但在 try 块中并没有抛出 Exception，并且没有显式地捕获 RuntimeException。将 try { ... } catch (Exception e) { something } 作为一种简写方式用于捕获多个类型的异常，每个 catch 块的处理逻辑相同，但这种构造也会意外捕获到 RuntimeException，从而掩盖潜在的错误。</p>   <p>更好的方法是显式地捕获具体的抛出的异常，或者显式地捕获 RuntimeException 异常然后重新抛出，再捕获所有非-RuntimeExceptions，如下所示：</p> <pre><code>try {     ... } catch (RuntimeException e) {     throw e; } catch (Exception e) {     ... 处理所有非运行时异常 ... } </code></pre>]]>
     </Details>
  </BugPattern>
  <BugPattern type="FE_TEST_IF_EQUAL_TO_NOT_A_NUMBER">
    <ShortDescription>用于检查与 NaN 等价性的必死测试  Doomed test for equality to NaN</ShortDescription>
    <LongDescription>在{1}中对NaN进行相等性测试，这将是失败的。</LongDescription>
    <Details>
   <![CDATA[<p>    这段代码检查一个浮点值是否等于特殊值“非数字”（例如，<code>if (x == Double.NaN)</code>）。但由于“NaN”的特殊语义，没有任何值等于“NaN”，包括“NaN”本身。因此，<code>x == Double.NaN</code> 总是评估为 false。    要检查变量 <code>x</code> 中的值是否为特殊的“非数字”值，应使用 <code>Double.isNaN(x)</code>（如果 <code>x</code> 是单精度浮点数，则使用 <code>Float.isNaN(x)</code>）。     </p>]]>
     </Details>
  </BugPattern>
  <BugPattern type="FE_FLOATING_POINT_EQUALITY">
    <ShortDescription>测试浮点数相等性  Test for floating point equality</ShortDescription>
    <LongDescription>在{1}中测试浮点数相等性</LongDescription>
    <Details>
   <![CDATA[<p>     此操作用于比较两个浮点值是否相等。     因为浮点运算可能会涉及舍入，     计算得到的 float 和 double 值可能不够准确。     对于必须精确的值（例如货币值），     考虑使用固定精度类型如 BigDecimal。     对于不需要精确的值，可以考虑在某个范围内比较是否相等，例如：     <code>if ( Math.abs(x - y) < .0000001 )</code>。    详见 Java 语言规范，第 4.2.4 节。     </p>]]>
     </Details>
  </BugPattern>
  <BugPattern type="UM_UNNECESSARY_MATH">
    <ShortDescription>方法调用静态Math类的常量值方法  Method calls static Math class method on a constant value</ShortDescription>
    <LongDescription>方法调用常量值的静态Math类方法</LongDescription>
    <Details>
<![CDATA[<p>该方法使用了来自 java.lang.Math 的静态方法对一个常量值进行操作。在这种情况下，此方法的结果可以静态地确定，并且直接使用常量可能更快且更准确。检测到的方法如下：</p>
<table>
    <tr>
        <th>方法</th>
        <th>参数</th>
    </tr>
    <tr>
        <td>abs</td>
        <td>-任意-</td>
    </tr>
    <tr>
        <td>acos</td>
        <td>0.0 或 1.0</td>
    </tr>
    <tr>
        <td>asin</td>
        <td>0.0 或 1.0</td>
    </tr>
    <tr>
        <td>atan</td>
        <td>0.0 或 1.0</td>
    </tr>
    <tr>
        <td>atan2</td>
        <td>0.0</td>
    </tr>
    <tr>
        <td>cbrt</td>
        <td>0.0 或 1.0</td>
    </tr>
    <tr>
        <td>ceil</td>
        <td>-任意-</td>
    </tr>
    <tr>
        <td>cos</td>
        <td>0.0</td>
    </tr>
    <tr>
        <td>cosh</td>
        <td>0.0</td>
    </tr>
    <tr>
        <td>exp</td>
        <td>0.0 或 1.0</td>
    </tr>
    <tr>
        <td>expm1</td>
        <td>0.0</td>
    </tr>
    <tr>
        <td>floor</td>
        <td>-任意-</td>
    </tr>
    <tr>
        <td>log</td>
        <td>0.0 或 1.0</td>
    </tr>
    <tr>
        <td>log10</td>
        <td>0.0 或 1.0</td>
    </tr>
    <tr>
        <td>rint</td>
        <td>-任意-</td>
    </tr>
    <tr>
        <td>round</td>
        <td>-任意-</td>
    </tr>
    <tr>
        <td>sin</td>
        <td>0.0</td>
    </tr>
    <tr>
        <td>sinh</td>
        <td>0.0</td>
    </tr>
    <tr>
        <td>sqrt</td>
        <td>0.0 或 1.0</td>
    </tr>
    <tr>
        <td>tan</td>
        <td>0.0</td>
    </tr>
    <tr>
        <td>tanh</td>
        <td>0.0</td>
    </tr>
    <tr>
        <td>toDegrees</td>
        <td>0.0 或 1.0</td>
    </tr>
    <tr>
        <td>toRadians</td>
        <td>0.0</td>
    </tr>
</table>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CD_CIRCULAR_DEPENDENCY">
    <ShortDescription>测试类之间的循环依赖关系  Test for circular dependencies among classes</ShortDescription>
    <LongDescription>类 {0} 与其他类存在循环依赖关系</LongDescription>
    <Details>
   <![CDATA[<p>     该类与其他类存在循环依赖关系。这使得构建这些类变得困难，因为每个类都依赖于另一个类来正确构建。考虑使用接口来打破这种硬性依赖。     </p>]]>
     </Details>
  </BugPattern>
  <BugPattern type="RI_REDUNDANT_INTERFACES">
    <ShortDescription>类实现与超类相同的接口  Class implements same interface as superclass</ShortDescription>
    <LongDescription>类 {0} 实现了与超类相同的接口</LongDescription>
    <Details>
   <![CDATA[<p>     这个类声明实现了某个接口，而该接口已经被超类所实现。由于一旦超类实现了某个接口，所有子类默认也会继承实现这个接口，因此这是多余的。可能表明自创建此类以来，继承层次结构发生了变化，并且应考虑接口实现的所有权问题。     </p>]]>
     </Details>
  </BugPattern>
  <BugPattern type="MTIA_SUSPECT_STRUTS_INSTANCE_FIELD">
    <ShortDescription>该类扩展了Struts Action类并且使用了实例变量  Class extends Struts Action class and uses instance variables</ShortDescription>
    <LongDescription>类 {0} 扩展了 Struts 行动类，并使用了实例变量</LongDescription>
    <Details>
   <![CDATA[<p>     这个类从一个 Struts Action 类继承，并使用了一个实例成员变量。由于 Struts 框架只会创建一个 Struts Action 类的实例并在多线程环境中使用，这种模式被高度不推荐且很可能存在问题。考虑仅使用方法局部变量。只有在监控之外写入的实例字段才会被报告。</p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="MTIA_SUSPECT_SERVLET_INSTANCE_FIELD">
    <ShortDescription>类扩展了Servlet类并且使用了实例变量  Class extends Servlet class and uses instance variables</ShortDescription>
    <LongDescription>类 {0} 扩展了 Servlet 类并且使用了实例变量</LongDescription>
    <Details>
   <![CDATA[<p>     这个类从Servlet类继承，并使用了一个实例成员变量。由于J2EE框架只会创建一个Servlet类的实例，并以多线程方式使用，因此这种模式强烈不被推荐且很可能存在问题。请考虑仅使用局部方法变量。     </p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="PS_PUBLIC_SEMAPHORES">
    <ShortDescription>类在公共接口中暴露了同步和信号量机制  Class exposes synchronization and semaphores in its public interface</ShortDescription>
    <LongDescription>类 {0} 在其公共接口中暴露了同步和信号量机制</LongDescription>
    <Details>
   <![CDATA[<p>     这个类使用同步，并且利用了自身（this引用）的wait()、notify()或notifyAll()方法。客户端类在使用这个类时，还可能将该类的一个实例用作同步对象。由于两个类共用了同一个对象进行同步，因此多线程正确性值得怀疑。你不应该对公共引用进行同步或将信号量方法应用于其上。考虑使用一个内部的私有成员变量来控制同步。</p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="ICAST_INTEGER_MULTIPLY_CAST_TO_LONG">
    <ShortDescription>整数相乘后的结果强制转换为long类型  Result of integer multiplication cast to long</ShortDescription>
    <LongDescription>在{1}中，整数相乘的结果被强制转换为long类型。</LongDescription>
    <Details>
<![CDATA[<p>这段代码执行整数相乘然后将结果转换为长整型，例如：</p> <pre><code>long convertDaysToMilliseconds(int days) { return 1000*3600*24*days; } </code></pre> <p> 如果使用长整型算术进行乘法运算，可以避免结果溢出的可能性。例如，你可以将上述代码修改为：</p> <pre><code>long convertDaysToMilliseconds(int days) { return 1000L*3600*24*days; } </code></pre> <p> 或者 </p> <pre><code>static final long MILLISECONDS_PER_DAY = 24L*3600*1000; long convertDaysToMilliseconds(int days) { return days * MILLISECONDS_PER_DAY; } </code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_INT_2_LONG_AS_INSTANT">
    <ShortDescription>将整数值转换为长整型，并用作绝对时间值  int value converted to long and used as absolute time</ShortDescription>
    <LongDescription>将int类型转换为long类型，并作为绝对时间传递给{1}中的{2}。</LongDescription>
    <Details>
<![CDATA[<p>这段代码将一个32位的int值转换为64位的long值，然后将该值作为需要绝对时间值的方法参数传递。绝对时间值是从被称为“纪元”的标准基准时间（即1970年1月1日00:00:00 GMT）以来的毫秒数。例如，下面这个意图将从纪元起的秒转换为Date的方法是严重错误的：</p>
<pre><code>Date getDate(int seconds) { return new Date(seconds * 1000); } </code></pre>
<p>这里的乘法使用了32位算术运算，并随后转换为了64位值。当一个32位值被转换为64位并用来表示绝对时间值时，只能表示1969年12月和1970年1月的日期。</p>
<p>上面方法的正确实现如下：</p>
<pre><code>// 对于2038年之后的日期会失败 Date getDate(int seconds) { return new Date(seconds * 1000L); }  // 更好，可以处理所有日期 Date getDate(long seconds) { return new Date(seconds * 1000); } </code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND">
    <ShortDescription>将整数值转换为浮点数，然后传递给 `Math.round` 方法。  int value cast to float and then passed to Math.round</ShortDescription>
    <LongDescription>将`int`值转换为`float`，然后传递给`Math.round`在{1}处</LongDescription>
    <Details>
<![CDATA[<p>这段代码将一个 int 值转换为浮点数，精度为 float，然后将其结果传递给 Math.round() 函数，该函数返回与参数最接近的 int/long。由于将整数转换为浮点数应给出没有小数部分的数字，因此此操作始终应该是无操作的。很可能生成要传递给 Math.round() 的值的操作意图是使用浮点运算来执行。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL">
    <ShortDescription>整数值转换为double类型后再传递给Math.ceil方法  Integral value cast to double and then passed to Math.ceil</ShortDescription>
    <LongDescription>将整数值转换为double类型，然后传给Math.ceil方法在{1}处</LongDescription>
    <Details>
<![CDATA[<p>这段代码将一个整数值（例如，int 或 long）转换为双精度浮点数，然后将其结果传递给 Math.ceil() 函数，该函数会将双精度数值向上舍入到最接近的更高整数。由于将整数转换为双精度浮点数应该得到没有小数部分的数字，此操作总是无操作的。很可能生成要传递给 Math.ceil() 的值的操作本应使用双精度浮点数算术来执行。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_IDIV_CAST_TO_DOUBLE">
    <ShortDescription>整数除法结果强制转换为double或float  Integral division result cast to double or float</ShortDescription>
    <LongDescription>在{1}中，整数除法的结果应强制转换为double或float。</LongDescription>
    <Details>
<![CDATA[<p>这段代码将整数除法（例如，int 或 long 除法）的结果强制转换为 double 或 float。在进行整数除法时，结果会被截断为最接近零的整数值。将结果强制转换为 double 表明应该保留这种精度。这里可能的意思是在进行除法运算之前将一个或两个操作数强制转换为 double。例如：</p>
<pre><code>int x = 2; int y = 5;
// 错误：结果为 0.0
double value1 = x / y;  
// 正确：结果为 0.4
double value2 = x / (double) y; </code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION">
    <ShortDescription>将非序列化的对象存储到HttpSession中  Store of non serializable object into HttpSession</ShortDescription>
    <LongDescription>将非序列化的 {2} 存入 HttpSession 在 {1} 中</LongDescription>
    <Details>
<![CDATA[<p>这段代码似乎将一个非序列化的对象存储到了HttpSession中。如果该会话被被动化或迁移，将会导致错误。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_NONSERIALIZABLE_OBJECT_WRITTEN">
    <ShortDescription>非序列化对象写入到ObjectOutput中  Non serializable object written to ObjectOutput</ShortDescription>
    <LongDescription>非序列化对象 {2} 写入了 {1} 中的 ObjectOutput 流中</LongDescription>
    <Details>
<![CDATA[<p>这段代码似乎将一个非序列化对象传递给了ObjectOutput.writeObject方法。如果该对象确实是非序列化的，将会导致错误。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="VA_FORMAT_STRING_USES_NEWLINE">
    <ShortDescription>格式化字符串应该使用%n 而不是\n  Format string should use %n rather than \n</ShortDescription>
    <LongDescription>格式化字符串应该使用%n 而不是\n 在{1}中</LongDescription>
    <Details>
<![CDATA[<p>该格式字符串包含一个换行字符（\n）。在格式字符串中，通常建议使用%n，这将生成平台特定的分隔符。</p>]]>
     </Details>
  </BugPattern>
  <BugPattern type="VA_PRIMITIVE_ARRAY_PASSED_TO_OBJECT_VARARG">
    <ShortDescription>原始数组传递给期望可变数量对象参数的函数  Primitive array passed to function expecting a variable number of object arguments</ShortDescription>
    <LongDescription>将变量参数方法 `{3}` 中的参数 `{2}` 传递给了 `{1}`。</LongDescription>
    <Details>
<![CDATA[<p>这段代码将一个原始数组传递给一个接受可变数量对象参数的函数。为此，创建了一个长度为一的数组来容纳原始数组，并将其传递给该函数。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS">
    <ShortDescription>equals方法不应该假设其参数的类型。  Equals method should not assume anything about the type of its argument</ShortDescription>
    <LongDescription>{0}的equals方法假设参数为类型{0.givenClass}</LongDescription>
    <Details>
<![CDATA[<p>`equals(Object o)` 方法不应该假设 `o` 的类型。如果 `o` 不是与 `this` 同一类型，就应该返回 false。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_BAD_CAST_TO_ABSTRACT_COLLECTION">
    <ShortDescription>对抽象集合进行了可疑的类型转换  Questionable cast to abstract collection</ShortDescription>
    <LongDescription>在{1}中，从Collection强转到抽象类{3}可能存在疑问。</LongDescription>
    <Details>
<![CDATA[<p>此代码将一个 Collection 转换为抽象集合（如 <code>List</code>、<code>Set</code> 或 <code>Map</code>）。请确保你转换的目标对象确实是你要转换的类型。如果你只需要遍历集合，则不需要将其转换为 Set 或 List。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_IMPOSSIBLE_CAST_PRIMITIVE_ARRAY">
    <ShortDescription>涉及原始数组的不可能转换  Impossible cast involving primitive array</ShortDescription>
    <LongDescription>在 `{1}` 中涉及原始数组的不可能转换。</LongDescription>
    <Details>
<![CDATA[<p>这种转换总是会抛出ClassCastException。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_IMPOSSIBLE_CAST">
    <ShortDescription>不可能的类型转换  Impossible cast</ShortDescription>
    <LongDescription>从 `{2}` 到 `{3}` 的类型转换在 `{1}` 中是不可能的</LongDescription>
    <Details>
<![CDATA[<p>这种转换总是会抛出ClassCastException。SpotBugs 跟踪从 instanceof 检查获得的类型信息，并且还会使用更精确的方法返回值和字段加载值的类型信息。因此，它可能比仅仅变量声明类型拥有更准确的信息，并可以利用这些信息来确定某次转换将在运行时总是抛出异常。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_IMPOSSIBLE_DOWNCAST">
    <ShortDescription>不可能的下转型  Impossible downcast</ShortDescription>
    <LongDescription>从 `{2}` 到 `{3}` 的向下转换在 `{1}` 中是不可能的</LongDescription>
    <Details>
<![CDATA[<p>此强制类型转换总是会抛出ClassCastException。分析认为它知道要强制转换的值的确切类型，将该值向下强制转换为子类型的操作将会始终因抛出ClassCastException而失败。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_IMPOSSIBLE_DOWNCAST_OF_TOARRAY">
    <ShortDescription>将 `toArray()` 方法的结果进行不可能的向下转换  Impossible downcast of toArray() result</ShortDescription>
    <LongDescription>将 `toArray()` 方法的结果向下转型为 `{3}` 在 `{1}` 中是不可能的。</LongDescription>
    <Details>
<![CDATA[<p>这段代码将调用 `Collection&lt;String&gt;` 的 `toArray()` 方法的结果强制转换为比 `Object[]` 更具体的数据类型，如下所示：</p>
<pre><code>String[] getAsArray(Collection&lt;String&gt; c) {     return (String[]) c.toArray(); }
</code></pre>
<p>这通常会通过抛出 `ClassCastException` 而失败。几乎所有的集合的 `toArray()` 方法返回的是 `Object[]`。这是因为 Collection 对象并没有引用集合声明的泛型类型。<p>
正确的做法是从集合中获取特定类型的数组，应该使用 `c.toArray(new String[])` 或 `c.toArray(new String[c.size()])`（后者稍微更高效一些）。
<p>这有一个常见的例外情况。通过 `Arrays.asList(...)` 返回的列表的 `toArray()` 方法会返回一个协变类型数组。例如，`Arrays.asList(new String[] { "a" }).toArray()` 将返回一个 `String []`。SpotBugs 试图检测并抑制这种情况，但可能会遗漏一些。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_INSTANCEOF">
    <ShortDescription>已知的空值被检查是否是某类型的实例  A known null value is checked to see if it is an instance of a type</ShortDescription>
    <LongDescription>在一个已知为null的值在{1}中检查是否是{2}的实例。</LongDescription>
    <Details>
<![CDATA[<p>这个 `instanceof` 测试总是会返回 false，因为检查的值被保证是 null。虽然这是安全的，但请确保这不是某种误解或逻辑错误的指示。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_NULL_INSTANCEOF" deprecated="true"> <!-- deprecated in favor of NP_NULL_INSTANCEOF -->
    <ShortDescription>已知的空值检查是否是某个类型的实例  A known null value is checked to see if it is an instance of a type</ShortDescription>
    <LongDescription>在一个已知为null的值在{1}中被检查是否是{2}的一个实例。</LongDescription>
    <Details>
<![CDATA[<p>这种 `instanceof` 测试将总是返回 false，因为被检查的值已被保证为 null。虽然这是安全的，但请确保这并不是某种误解或逻辑错误的指示。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_IMPOSSIBLE_INSTANCEOF">
    <ShortDescription>instanceof 总是会返回 false  instanceof will always return false</ShortDescription>
    <LongDescription>instanceof 在 {1} 中总是返回 false，因为 {2} 不能是 {3}。</LongDescription>
    <Details>
<![CDATA[<p> 这个 `instanceof` 测试总是会返回假。虽然这是安全的，但确保这不是某种误解或逻辑错误的指示。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_VACUOUS_INSTANCEOF">
    <ShortDescription>instanceof 总是会返回 true  instanceof will always return true</ShortDescription>
    <LongDescription>实例运算符 `instanceof` 在 `{1}` 中对所有非空值总是返回 true，因为所有的 `{2}` 都是 `{3}` 的实例。</LongDescription>
    <Details>
<![CDATA[<p>这种 `instanceof` 测试总是会返回 true（除非被测试的值为 null）。虽然这是安全的，但请确保这并不是某种误解或逻辑错误的指示。如果你真的想测试该值是否为 null，也许进行一个 null 检测会更清晰，而不是使用 `instanceof` 检测。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_UNCONFIRMED_CAST">
    <ShortDescription>未检查/未确认的类型转换  Unchecked/unconfirmed cast</ShortDescription>
    <LongDescription>从{2}到{3}的未检查/未确认转换出现在{1}中</LongDescription>
    <Details>
<![CDATA[<p>该类型的安全转换无法保证总是成功，因为并非所有来源类型的实例都能安全地转换为目标类型。请检查程序逻辑以确保此转换不会失败。</p>]]>
    </Details>
  </BugPattern>
   <BugPattern type="BC_UNCONFIRMED_CAST_OF_RETURN_VALUE">
    <ShortDescription>方法返回值未经检查/未确认的类型转换  Unchecked/unconfirmed cast of return value from method</ShortDescription>
    <LongDescription>从{2}到{3}的未检查/未确认类型转换，发生在方法{1}的返回值中</LongDescription>
    <Details>
<![CDATA[<p>该代码对方法的返回值进行了未检查的类型转换。可能是在某种情况下调用方法时可以保证转换是安全的，但SpotBugs无法验证此转换是否安全。请确保你的程序逻辑能够保证此类转换不会失败。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_BAD_CAST_TO_CONCRETE_COLLECTION">
    <ShortDescription>对具体的集合进行了可疑的类型转换  Questionable cast to concrete collection</ShortDescription>
    <LongDescription>从{2}到{3}的可疑类型转换在{1}中</LongDescription>
    <Details>
<![CDATA[<p>这段代码将一个抽象集合（如Collection、List或Set）强制转换为具体的实现类（如ArrayList或HashSet）。这可能并不正确，并且可能会使你的代码变得脆弱，因为将来切换到其他的具体实现类会更加困难。除非你有特别的理由这样做，否则只需使用抽象集合类。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RE_POSSIBLE_UNINTENDED_PATTERN">
    <ShortDescription>在正则表达式中使用 "." 或 "|"  "." or "|" used for regular expression</ShortDescription>
    <LongDescription>在{1}中使用“.”或“|”进行正则表达式匹配</LongDescription>
    <Details>
<![CDATA[<p>A String函数被调用，并且传递给参数的是"."或"|", 而该参数应该接收一个正则表达式作为参数。这是否是你想要的？例如：</p>
<ul>
<li>`s.replaceAll(".", "/")` 将返回一个字符串，在这个字符串中，<em>每个</em>字符都被替换成了'/'。</li>
<li>`s.split(".")` <em>总是</em> 返回一个空数组。</li>
<li>`"ab|cd".replaceAll("|", "/")` 将返回"/a/b/|/c/d/"。</li>
<li>`"ab|cd".split("|")` 将返回包含六个(!)元素的数组：[, a, b, |, c, d]。</li>
</ul>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION">
    <ShortDescription>无效的正则表达式语法  Invalid syntax for regular expression</ShortDescription>
    <LongDescription>在 {1} 中的正则表达式语法无效</LongDescription>
    <Details>
<![CDATA[<p>这里的代码使用了一个无效的正则表达式，根据正则表达式的语法规范。当执行该语句时，将会抛出PatternSyntaxException异常。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION">
    <ShortDescription>使用 File.separator 用于正则表达式  File.separator used for regular expression</ShortDescription>
    <LongDescription>在 `{1}` 中使用 `File.separator` 进行正则表达式匹配。</LongDescription>
    <Details>
<![CDATA[<p>此处的代码使用了<code>File.separator</code>，但在正则表达式中需要的是普通的分隔符。在Windows平台上，<code>Fileseparator</code>是一个反斜杠，而在正则表达式中反斜杠被解释为转义字符，这会导致失败。作为其他选项之一，你可以使用<code>File.separatorChar=='\\' ? "\\\\" : File.separator</code>来代替<code>File.separator</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DLS_OVERWRITTEN_INCREMENT">
    <ShortDescription>重载增量  Overwritten increment</ShortDescription>
    <LongDescription>在 {1} 中重写了增量操作</LongDescription>
    <Details>
<![CDATA[<p>代码执行了自增/自减操作（例如，<code>i++</code>/<code>i--</code>），然后立即覆写了该值。例如，<code>i = i++</code>/<code>i = i--</code>会立即用原始值覆写增量/ decrement后的值。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT">
    <ShortDescription>无符号右移转换为short/byte  Unsigned right shift cast to short/byte</ShortDescription>
    <LongDescription>将无符号右移转换为short/byte在{1}中</LongDescription>
    <Details>
<![CDATA[<p>该代码执行无符号右移操作，然后将结果转换为short或byte类型，这会丢弃结果的高位。由于高位被丢弃，无符号右移和有符号右移的结果可能没有区别（具体取决于位移量的大小）。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BSHIFT_WRONG_ADD_PRIORITY">
    <ShortDescription>可能的位移操作解析错误  Possible bad parsing of shift operation</ShortDescription>
    <LongDescription>可能在 `{1}` 中存在位移操作的不良解析。</LongDescription>
    <Details>
<![CDATA[<p>该代码执行类似于(x << 8 + y)的操作。虽然这可能是正确的，但可能本应执行(x << 8) + y，但由于位移操作的优先级较低，实际上会被解析为 x << (8 + y)。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_BAD_SHIFT_AMOUNT">
    <ShortDescription>32位整数左移的位数不在-31至31的范围内。  32 bit int shifted by an amount not in the range -31..31</ShortDescription>
    <LongDescription>32位整数向右移动{2}位在{1}中</LongDescription>
    <Details>
<![CDATA[<p>该代码对一个32位int进行固定量的移位操作，而这个固定的量超出了-31..31的范围。这意味着整数值的较低5位将决定移位量（例如，向右移40位与向右移8位效果相同，向右移32位与不移位效果相同）。这可能不是预期的行为，并且至少会让人困惑。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IM_MULTIPLYING_RESULT_OF_IREM">
    <ShortDescription>整数除法结果的整数乘法  Integer multiply of result of integer remainder</ShortDescription>
    <LongDescription>在{1}中的整数余数的整数倍数</LongDescription>
    <Details>
<![CDATA[<p>该代码将取余运算的结果与一个整数常量相乘。确保你没有搞错操作符优先级。例如，i % 60 * 1000 应该是 (i % 60) * 1000，而不是 i % (60 * 1000)。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_INVOKING_HASHCODE_ON_ARRAY">
    <ShortDescription>对数组调用hashCode方法  Invocation of hashCode on an array</ShortDescription>
    <LongDescription>在{1}中对数组调用了hashCode方法</LongDescription>
    <Details>
<![CDATA[<p>该代码对数组调用了hashCode方法。对数组调用hashCode返回的是System.identityHashCode的值，并忽略数组的内容和长度。如果你需要一个依赖于数组内容a的hashCode，请使用java.util.Arrays.hashCode(a)。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_INVOKING_TOSTRING_ON_ARRAY">
    <ShortDescription>对数组调用toString方法  Invocation of toString on an array</ShortDescription>
    <LongDescription>在 {1} 中对 {2.givenClass} 调用了 toString 方法</LongDescription>
    <Details>
<![CDATA[<p>该代码对数组调用了toString方法，这将生成一个相当无用的结果，例如[C@16f0472。建议使用Arrays.toString方法将数组转换为可读的字符串，以显示数组的内容。参见《编程趣题》，第3章，第12个谜题。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_INVOKING_TOSTRING_ON_ANONYMOUS_ARRAY">
    <ShortDescription>对未命名数组调用toString方法  Invocation of toString on an unnamed array</ShortDescription>
    <LongDescription>在{1}中对未命名数组调用toString方法</LongDescription>
    <Details>
<![CDATA[<p>代码调用了匿名数组的toString方法。对数组调用toString会产生类似[C@16f0472这样的无用结果。建议使用Arrays.toString将数组转换为可读字符串，以显示数组的内容。参见《编程趣题》，第3章，第12个谜题。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IM_AVERAGE_COMPUTATION_COULD_OVERFLOW">
    <ShortDescription>平均值计算可能会溢出  Computation of average could overflow</ShortDescription>
    <LongDescription>在 {1} 中，平均值的计算可能会溢出。</LongDescription>
    <Details>
<![CDATA[<p>该代码使用除法或带符号右移来计算两个整数的平均值，然后将结果用作数组的索引。如果被平均的值非常大，这可能会导致溢出（从而计算出一个负均值）。假设结果应该是非负的，你可以使用无符号右移而不是使用 <code>(low+high)/2</code>，即使用 <code>(low+high) &gt;&gt;&gt; 1</code>。 </p>
<p>这个错误存在于许多早期实现的二分查找和合并排序中。Martin Buchholz 在 JDK 库中 <a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6412541">发现了并修复了这个问题</a>，而 Joshua Bloch 则在 <a href="http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html">广泛宣传了这种错误模式</a>。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IM_BAD_CHECK_FOR_ODD">
    <ShortDescription>检查奇偶性判断不能适用于负数  Check for oddness that won't work for negative numbers</ShortDescription>
    <LongDescription>检查在{1}中不会对负数生效的奇偶性判断。</LongDescription>
    <Details>
<![CDATA[<p>使用 x % 2 == 1 来检查一个值是否为奇数，但这不会适用于负数（例如，(-5) % 2 == -1）。如果代码意图检查奇偶性，可以考虑使用 x & 1 == 1 或 x % 2 != 0。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_HARDCODED_ABSOLUTE_FILENAME">
    <ShortDescription>代码中包含对绝对路径名的硬编码引用  Code contains a hard coded reference to an absolute pathname</ShortDescription>
    <LongDescription>在 {1} 中硬编码了绝对路径引用</LongDescription>
    <Details>
<![CDATA[<p>这段代码使用硬编码的绝对路径构造了一个File对象（例如，<code>new File("/home/dannyc/workspace/j2ee/src/share/com/sun/enterprise/deployment");</code>）</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_BAD_MONTH">
    <ShortDescription>无效的月份常量值  Bad constant value for month</ShortDescription>
    <LongDescription>在{1}中传递给{3}的{2}月份值无效</LongDescription>
    <Details>
<![CDATA[<p>该代码将一个超出预期范围（0..11）的常量月份值传递给方法。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_USELESS_SUBSTRING">
    <ShortDescription>对 `substring(0)` 的调用，返回的是原始值。  Invocation of substring(0), which returns the original value</ShortDescription>
    <LongDescription>{1} 调用了 `substring(0)`，这将返回原始值。</LongDescription>
    <Details>
<![CDATA[<p>该代码对一个字符串调用了 substring(0) 方法，这将返回原来的值。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_CALLING_NEXT_FROM_HASNEXT">
    <ShortDescription>`hasNext` 方法调用了 `next` 方法  hasNext method invokes next</ShortDescription>
    <LongDescription>{1} 调用 {2.givenClass}</LongDescription>
    <Details>
<![CDATA[<p>hasNext() 方法调用了 next() 方法。这几乎肯定是不对的，因为 hasNext() 方法不应改变迭代器的状态，而 next 方法应改变迭代器的状态。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SWL_SLEEP_WITH_LOCK_HELD">
    <ShortDescription>持有锁的情况下调用了Thread.sleep()方法  Method calls Thread.sleep() with a lock held</ShortDescription>
    <LongDescription>{1} 在持有锁的情况下调用了Thread.sleep()方法</LongDescription>
    <Details>
      <![CDATA[<p>该方法在持有锁的情况下调用了Thread.sleep()。这可能会导致非常差的性能和扩展性，甚至可能导致死锁，因为其他线程可能正在等待获取该锁。更好的做法是调用wait()方法来释放锁并允许其他线程运行。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="DB_DUPLICATE_BRANCHES">
    <ShortDescription>方法在两个分支中使用了相同的代码段  Method uses the same code for two branches</ShortDescription>
    <LongDescription>{1} 两个分支使用了相同的代码</LongDescription>
    <Details>
      <![CDATA[<p>此方法使用相同的代码实现条件分支的两个分支。确保这不是一个编码错误。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="DB_DUPLICATE_SWITCH_CLAUSES">
    <ShortDescription>方法在同一段代码中为两个 switch 语句块使用了相同的代码。  Method uses the same code for two switch clauses</ShortDescription>
    <LongDescription>{1} 使用相同的代码块为两个switch语句cased</LongDescription>
    <Details>
      <![CDATA[<p>该方法使用相同的代码实现了switch语句的两个分支。这可能是重复代码，但也可能表明存在编码错误。</p>]]>
   </Details>
  </BugPattern>
  <BugPattern type="IMA_INEFFICIENT_MEMBER_ACCESS">
    <ShortDescription>方法访问了所属类的私有成员变量  Method accesses a private member variable of owning class</ShortDescription>
    <LongDescription>{1} 访问了所属类的私有成员变量</LongDescription>
    <Details>
      <![CDATA[<p>这个内类的方法会读取或写入拥有者的私有成员变量，或者调用拥有者的私有方法。编译器必须生成一个特殊的方法来访问这个私有成员，这会导致效率降低。放松对该成员变量或方法的保护级别可以让编译器将其视为正常的访问。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="XFB_XML_FACTORY_BYPASS">
    <ShortDescription>方法直接分配了具体的XML接口实现  Method directly allocates a specific implementation of xml interfaces</ShortDescription>
    <LongDescription>{1} 直接分配了XML接口的具体实现。</LongDescription>
    <Details>
      <![CDATA[<p>该方法分配了一个特定的XML接口实现。最好使用提供的工厂类来创建这些对象，以便可以在运行时更改实现。请参见：</p>
<ul>
    <li>javax.xml.parsers.DocumentBuilderFactory</li>
    <li>javax.xml.parsers.SAXParserFactory</li>
    <li>javax.xml.transform.TransformerFactory</li>
    <li>org.w3c.dom.Document.create<i>XXXX</i></li>
</ul>
<p>以获取详细信息。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="USM_USELESS_SUBCLASS_METHOD">
    <ShortDescription>方法无必要地委托给父类的方法  Method superfluously delegates to parent class method</ShortDescription>
    <LongDescription>{1} 超级无必要地委托给父类的方法</LongDescription>
    <Details>
      <![CDATA[<p>这个派生方法仅仅调用了同一个超类方法，并传递了接收到的相同参数。这个方法可以被移除，因为它没有提供额外的价值。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="USM_USELESS_ABSTRACT_METHOD">
    <ShortDescription>抽象方法已经在实现的接口中定义  Abstract Method is already defined in implemented interface</ShortDescription>
    <LongDescription>抽象方法 `{1}` 已经在实现的接口中定义。</LongDescription>
    <Details>
      <![CDATA[<p>该抽象方法已经在此抽象类所实现的接口中定义。由于它没有提供额外的价值，因此可以删除该方法。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CI_CONFUSED_INHERITANCE">
    <ShortDescription>类是最终类但声明了受保护的字段  Class is final but declares protected field</ShortDescription>
    <LongDescription>类 {0} 是最终类但声明了受保护的字段 {1}</LongDescription>
    <Details>
      <![CDATA[<p>该类被声明为final，但声明了字段为protected。由于该类是final的，无法派生，使用protected访问修饰符令人困惑。应将字段的访问修饰符更改为private或public以准确反映字段的实际用途。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="QBA_QUESTIONABLE_BOOLEAN_ASSIGNMENT">
    <ShortDescription>方法在布尔表达式中赋值布尔字面量  Method assigns boolean literal in boolean expression</ShortDescription>
    <LongDescription>{1} 在布尔表达式中赋予布尔字面量</LongDescription>
    <Details>
      <![CDATA[<p>该方法在一个if或while表达式中为一个布尔变量赋了一个字面量的布尔值（true 或 false）。大多数情况下，这应该是使用 == 进行布尔比较，而不是使用 = 进行赋值。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="VR_UNRESOLVABLE_REFERENCE">
    <ShortDescription>类引用了无法解析的类或方法  Class makes reference to unresolvable class or method</ShortDescription>
    <LongDescription>{0} 对 {1} 的引用无法解析</LongDescription>
    <Details>
      <![CDATA[<p>这个类引用了一个在分析所使用的库中无法解析的类或方法。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="GC_UNCHECKED_TYPE_IN_GENERIC_CALL">
    <ShortDescription>泛型调用中的未检查类型  Unchecked type in generic call</ShortDescription>
    <LongDescription>在{1}中提供了类型为Object的未检查参数，而预期类型应为{3.givenClass}。</LongDescription>
    <Details>
     <![CDATA[<p>这个对泛型集合方法的调用传递了一个编译时类型为 Object 的参数，而预期的是特定的泛型类型参数。因此， neither 标准 Java 类型系统 nor 静态分析 都无法提供有用的信息来判断传递的对象是否是适当类型的。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="GC_UNRELATED_TYPES">
    <ShortDescription>泛型参数与方法参数之间无关联  No relationship between generic parameter and method argument</ShortDescription>
    <LongDescription>在 `{1}` 中，`{2.givenClass}` 与预期的参数类型 `{3.givenClass}` 不兼容。</LongDescription>
    <Details>
     <![CDATA[<p>此对泛型集合方法的调用包含一个与集合参数类型不兼容的参数（即，参数的类型既不是对应泛型类型参数的超类型也不是子类型）。因此，很可能该集合中没有任何对象与此方法使用的参数相等。最可能的情况是向方法传递了错误的值。</p>
<p>一般来说，两个无关类的实例不相等。例如，如果Foo和Bar类之间没有子类型关系，则Foo类的一个实例不应该等于Bar类的一个实例。这样做可能会导致equals方法不具备对称性。例如，如果你定义Foo类使得一个Foo可以等于一个String类的对象，那么你的equals方法就不是对称的，因为一个String对象只能等于另一个String对象。</p>
<p>虽然在极少数情况下人们确实定义了非对称的equals方法并且仍然能让代码正常工作，但通常情况下，如果检查一个Collection&lt;String&gt;是否包含一个Foo，等价性检查会使用参数的equals方法（例如，Foo类的equals方法）来进行。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_COLLECTIONS_SHOULD_NOT_CONTAIN_THEMSELVES">
    <ShortDescription>集合不应包含自身  Collections should not contain themselves</ShortDescription>
    <LongDescription>在调用{2.givenClass}时，集合不应该包含自身。</LongDescription>
    <Details>
     <![CDATA[<p>这种对泛型集合方法的调用只有在集合包含它自己（例如，如果 <code>s.contains(s)</code> 为真）时才有意义。这种情况不太可能成立，并且如果成立会导致问题（例如，哈希码的计算可能会导致无限递归）。很可能传递给参数的是错误的值。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_VACUOUS_SELF_COLLECTION_CALL">
    <ShortDescription>空洞的集合调用  Vacuous call to collections</ShortDescription>
    <LongDescription>对于任何集合 c，调用 c.{2.name}(c) 没有意义。</LongDescription>
    <Details>
     <![CDATA[<p>这个调用没有意义。对于任何集合<c>，调用<c>.containsAll(c) 总是为真，并且<c>.retainAll(c) 应该没有任何效果。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="PZ_DONT_REUSE_ENTRY_OBJECTS_IN_ITERATORS">
    <ShortDescription>不要在迭代器中重用entry对象  Don't reuse entry objects in iterators</ShortDescription>
    <LongDescription>{0}既是Iterator也是一个Map.Entry</LongDescription>
    <Details>
     <![CDATA[<p>`entrySet()` 方法允许返回一个视图，该视图基于底层的 `Map` 并包含 `Iterator` 和 `Map.Entry`。这个巧妙的想法被用在多个 `Map` 实现中，但引入了严重的编码错误的可能性。如果一个映射 `m` 通过 `entrySet` 返回这样的迭代器，那么 `c.addAll(m.entrySet())` 将会出现严重问题。OpenJDK 1.7 中的所有 `Map` 实现都已重写以避免这个问题，你也应该这样做。 </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_ENTRY_SETS_MAY_REUSE_ENTRY_OBJECTS">
    <ShortDescription>由于可能重用 Entry 对象，向_entry_set_添加元素可能会失败。  Adding elements of an entry set may fail due to reuse of Entry objects</ShortDescription>
    <LongDescription>由于在{1}中重用了{2.simpleClass}.Entry对象，向-entry集添加元素可能会失败。</LongDescription>
    <Details>
     <![CDATA[<p>允许 `entrySet()` 方法返回一个视图，其中在迭代过程中会重复使用同一个 Entry 对象。从 Java 1.6 开始，`IdentityHashMap` 和 `EnumMap` 都是如此操作的。当你遍历这样的 Map 时，在迭代到下一个条目之前，Entry 的值是有效的。例如，如果你尝试将这样的 `entrySet` 传递给一个 `addAll` 方法，将会发生错误。 </p>]]>
    </Details>
  </BugPattern>

  <BugPattern type="DMI_USING_REMOVEALL_TO_CLEAR_COLLECTION">
    <ShortDescription>不要使用removeAll来清空集合  Don't use removeAll to clear a collection</ShortDescription>
    <LongDescription>在{1}中，`removeAll` 用于清空集合。</LongDescription>
    <Details>
     <![CDATA[<p>如果你想清空集合 <code>c</code> 中的所有元素，应使用 <code>c.clear()</code> 而不是 <code>c.removeAll(c)</code>。通过调用 <code>c.removeAll(c)</code> 来清除集合不仅不够清晰，容易因为打字错误而出错，而且效率较低，在某些情况下可能会抛出 <code>ConcurrentModificationException</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="STCAL_STATIC_CALENDAR_INSTANCE">
    <ShortDescription>静态日历字段  Static Calendar field</ShortDescription>
    <LongDescription>{1} 是静态字段，类型为 `java.util.Calendar`，这不是线程安全的。</LongDescription>
    <Details>
<![CDATA[<p>虽然JavaDoc中没有提到这一点，但Calendars本质上不适合多线程使用。如果不进行适当的同步，在线程边界共享单个实例会导致应用程序行为异常。在Java 1.4版本中，这类问题似乎出现得不如在Java 5版本中频繁；而在Java 5中，你可能会看到随机的ArrayIndexOutOfBoundsException或IndexOutOfBoundsException错误，这些错误发生在sun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate()方法中。</p>

<p>你也可能遇到序列化问题。</p>

<p>建议使用实例字段。</p>

<p>有关更多信息，请参阅<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6231579">JDK Bug #6231579</a>和<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6178997">JDK Bug #6178997</a>。</p>]]>
</Details>
  </BugPattern>
  <BugPattern type="STCAL_INVOKE_ON_STATIC_CALENDAR_INSTANCE">
    <ShortDescription>调用静态Calendar方法  Call to static Calendar</ShortDescription>
    <LongDescription>在 `{1}` 中调用了静态 `java.util.Calendar` 类的方法。</LongDescription>
    <Details>
<![CDATA[<p>尽管JavaDoc没有提及，但Calendars本质上不适合多线程使用。检测器发现了一处通过静态字段获取的Calendar实例的方法调用，这看起来有些可疑。</p>
<p>更多信息请参见<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6231579">JDK Bug #6231579</a>和<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6178997">JDK Bug #6178997</a>。</p>]]>
</Details>
  </BugPattern>
  <BugPattern type="STCAL_STATIC_SIMPLE_DATE_FORMAT_INSTANCE">
    <ShortDescription>静态的 `DateFormat`  Static DateFormat</ShortDescription>
    <LongDescription>{1} 是一种静态字段，类型为 java.text.DateFormat，并且不是线程安全的。</LongDescription>
    <Details>
<![CDATA[<p>如JavaDoc所述，DateFormats本质上不适合用于多线程环境。如果不通过适当的同步机制就跨越线程边界共享单个实例，将会导致应用程序行为不稳定。</p>
<p>您还可能会遇到序列化问题。</p>
<p>推荐使用实例字段。</p>
<p>有关更多信息，请参见：<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6231579">JDK Bug #6231579</a> 和 <a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6178997">JDK Bug #6178997</a>。</p>]]>
</Details>
  </BugPattern>
  <BugPattern type="STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE">
    <ShortDescription>静态调用DateFormat方法  Call to static DateFormat</ShortDescription>
    <LongDescription>在 `{1}` 中对静态方法 `java.text.DateFormat` 的调用</LongDescription>
    <Details>
<![CDATA[<p>如JavaDoc所述，DateFormats本质上不适合多线程使用。检测器发现了一次对通过静态字段获得的DateFormat实例的调用，这看起来可疑。</p>
<p>更多相关信息，请参见<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6231579">JDK Bug #6231579</a>和<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6178997">JDK Bug #6178997</a>。</p>]]>
</Details>
  </BugPattern>
  <BugPattern type="TQ_COMPARING_VALUES_WITH_INCOMPATIBLE_TYPE_QUALIFIERS">
    <ShortDescription>使用不兼容的类型限定符比较值  Comparing values with incompatible type qualifiers</ShortDescription>
    <LongDescription>标注为具有类型限定符{2.simpleName}的值与从未具有该限定符的值进行了相等性比较。</LongDescription>
    <Details>
      <![CDATA[<p>指定带有类型限定注解的值与从未携带该限定符的值进行比较。</p>
<p>更具体地说，一个带有类型限定注解且其指定 when=ALWAYS 的值会被一个相同类型限定注解但其指定 when=NEVER 的值所比较。</p>
<p>例如，假设 @NonNegative 是 @Negative(when=When.NEVER) 的别名。以下代码会生成警告，因为返回语句要求一个 @NonNegative 值，但实际接收的是标记为 @Negative 的值。</p>
<pre><code>public boolean example(@Negative Integer value1, @NonNegative Integer value2) {     return value1.equals(value2); } </code></pre>]]>
    </Details>
  </BugPattern>


  <BugPattern type="TQ_ALWAYS_VALUE_USED_WHERE_NEVER_REQUIRED">
    <ShortDescription>标注了类型限定符的值用在了必须不携带该限定符的地方  Value annotated as carrying a type qualifier used where a value that must not carry that qualifier is required</ShortDescription>
    <LongDescription>标记为携带类型限定符 {2.simpleName} 的值用于必须不携带该限定符的位置</LongDescription>
    <Details>
      <![CDATA[<p>指定带有类型限定注解的值在需要该值不带此注解的位置被消费。</p>
<p>更精确地说，带有type=ALWAYS指定的类型限定注解的值可以保证到达使用相同类型限定注解且when=NEVER的情况的地方。</p>
<p>例如，假设@NonNegative是一个名为@Negative(when=When.NEVER)的类型限定注解的别名。以下代码将生成警告，因为返回语句需要一个@NonNegative值，但接收的是标记为@Negative的值。</p>
<pre><code>public @NonNegative Integer example(@Negative Integer value) {     return value; } </code></pre>]]>
    </Details>
  </BugPattern>


  <BugPattern type="TQ_UNKNOWN_VALUE_USED_WHERE_ALWAYS_STRICTLY_REQUIRED">
    <ShortDescription>在需要该限定符的值的位置使用了未带类型限定符的值  Value without a type qualifier used where a value is required to have that qualifier</ShortDescription>
    <LongDescription>在需要一个 {2.simpleName} 注解的地方使用了未带类型修饰符的值</LongDescription>
    <Details>
      <![CDATA[<p>   该值的使用方式需要对该值进行类型注解。     由于类型注解是严格的，因此工具会拒绝任何没有适当注解的值。   </p>
<p>   要强制将一个值转换为具有严格注解的值，可以定义一个返回值带有严格注解的身份函数。     这是唯一能够将未注解的值转换为具有严格类型注解的值的方法。   </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="TQ_NEVER_VALUE_USED_WHERE_ALWAYS_REQUIRED">
    <ShortDescription>标注为从未携带类型限定符的值在需要携带该限定符的地方被使用  Value annotated as never carrying a type qualifier used where value carrying that qualifier is required</ShortDescription>
    <LongDescription>标记为从未携带类型限定符 {2.simpleName} 的值用于需要携带该限定符的场合</LongDescription>
    <Details>
      <![CDATA[<p>指定未携带类型限定注解的值保证会在需要该注解的位置或多个位置被消费。</p>
<p>更精确地说，带有type=NEVER限定符的值保证会到达使用该限定符为type=ALWAYS的地方。</p>
<p>TODO：示例</p>]]>
    </Details>
  </BugPattern>




  <BugPattern type="TQ_MAYBE_SOURCE_VALUE_REACHES_ALWAYS_SINK">
    <ShortDescription>可能没有类型修饰符的值总是以需要该类型修饰符的方式使用  Value that might not carry a type qualifier is always used in a way requires that type qualifier</ShortDescription>
    <LongDescription>可能没有携带{2.simpleName}注解的值总是以需要该类型限定符的方式使用。</LongDescription>
    <Details>
      <![CDATA[<p>一个被注解为可能不是由类型限定符表示的值，并且该值保证将以需要使用由该类型限定符表示的值的方式使用。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="TQ_MAYBE_SOURCE_VALUE_REACHES_NEVER_SINK">
    <ShortDescription>可能携带类型限定词的值总是以不允许其具有该类型限定词的方式使用  Value that might carry a type qualifier is always used in a way prohibits it from having that type qualifier</ShortDescription>
    <LongDescription>带{2.simpleName}注解的值总是被用于不允许其具有该类型限定词的方式。</LongDescription>
    <Details>
      <![CDATA[<p>一个被注解为可能实例化为类型限定符所表示的值，并且该值保证将以禁止使用由该类型限定符表示的值的方式被使用。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_NEVER_SINK">
    <ShortDescription>值不需要类型限定符，但标记为未知  Value required to not have type qualifier, but marked as unknown</ShortDescription>
    <LongDescription>值不应为 {2.simpleName}，但被明确注解为未知的 {2.simpleName}。</LongDescription>
    <Details>
      <![CDATA[<p>某个值被使用的方式要求它永远不能带类型限定符，但存在一个明确的注解表明不知道该值在何处禁止带有那种类型限定符。要么是使用方式不正确，要么是注解不正确。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_ALWAYS_SINK">
    <ShortDescription>需要类型限定符的值但标记为未知  Value required to have type qualifier, but marked as unknown</ShortDescription>
    <LongDescription>值必须始终为 {2.simpleName}，但被明确注解为关于 {2.simpleName} 的未知值。</LongDescription>
    <Details>
      <![CDATA[<p>该值的使用方式要求它必须总是带有类型限定符，但存在一个显式的注解表明并不知道该值在何处需要带有这种类型的限定符。要么是该值的使用方式不正确，要么是注解不正确。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IO_APPENDING_TO_OBJECT_OUTPUT_STREAM">
    <ShortDescription>试图向对象输出流追加内容的注定失败的努力  Doomed attempt to append to an object output stream</ShortDescription>
    <LongDescription>在 {1} 中尝试向对象输出流追加操作是注定失败的。</LongDescription>
    <Details>
      <![CDATA[<p>      此代码以追加模式打开文件，然后将结果封装在对象输出流中。这不会允许您追加已存储在文件中的现有对象输出流。如果您希望能够追加到对象输出流，则需要保持对象输出流的打开状态。</p>
<p>唯一可以使在追加模式下打开文件并写入对象输出流生效的情况是在读取文件时计划以随机访问模式打开文件，并跳转到追加操作开始的字节偏移量。</p>
<p>TODO：示例。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="WL_USING_GETCLASS_RATHER_THAN_CLASS_LITERAL">
    <ShortDescription>而不是使用类字面量，在getClass上进行同步  Synchronization on getClass rather than class literal</ShortDescription>
    <LongDescription>在{1}处，使用getClass进行同步而不是类字面量。</LongDescription>
    <Details>
      <![CDATA[<p>      这个实例方法在 <code>this.getClass()</code> 上进行同步。如果此类被子类化，子类将在此子类的类对象上进行同步，这可能不是预期的行为。例如，考虑 `java.awt.Label` 中的这段代码：</p>
<pre><code>private static final String base = "label"; private static int nameCounter = 0;  String constructComponentName() {     synchronized (getClass()) {         return base + nameCounter++;     } } </code></pre>
<p>`Label` 的子类不会在此相同的类对象上进行同步，从而导致数据竞争。相反，这段代码应该在 `Label.class` 上进行同步：</p>
<pre><code>private static final String base = "label"; private static int nameCounter = 0;  String constructComponentName() {     synchronized (Label.class) {         return base + nameCounter++;     } } </code></pre>
<p>错误模式由 Jason Mehrens 提交</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="OBL_UNSATISFIED_OBLIGATION">
    <ShortDescription>方法可能会导致流或资源未能正确清理  Method may fail to clean up stream or resource</ShortDescription>
    <LongDescription>{1} 可能无法清理掉 {2}</LongDescription>
    <Details>
          <![CDATA[<p>     这个方法可能无法正确清理（关闭、处理）流、数据库对象或其他需要显式清理操作的资源。     </p>      <p>     通常来说，如果一个方法打开了一个流或其他资源，那么该方法应该使用 try/finally 块来确保在方法返回之前已经正确清理了该流或资源。     </p>      <p>     这种错误模式本质上与 OS_OPEN_STREAM 和 ODR_OPEN_DATABASE_RESOURCE 错误模式相同，但基于不同的（希望更好）静态分析技术。我们对这个错误模式的有用性很感兴趣。如有反馈，请参阅：     </p>     <ul> <li><a href="https://github.com/spotbugs/spotbugs/blob/master/CONTRIBUTING.md">贡献指南</a></li> <li><a href="https://github.com/spotbugs/discuss/issues?q=">讨论列表</a></li>     </ul>      <p>     特别是，     关于这个错误模式的假阳性抑制启发式规则尚未进行广泛调优，因此关于假阳性的报告对我们很有帮助。     </p>      <p>     请参阅 Weimer 和 Necula 的《发现和预防运行时错误处理错误》，以了解分析技术的描述。     </p>]]>
      </Details>
  </BugPattern>




  <BugPattern type="OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE">
    <ShortDescription>方法可能在处理Checked异常时未能清理流或资源。  Method may fail to clean up stream or resource on checked exception</ShortDescription>
    <LongDescription>在处理检查异常时，{1} 可能无法清理 {2}。</LongDescription>
    <Details>
          <![CDATA[<p>     此方法可能未能清理（关闭、处置）流、数据库对象或其他需要显式清理操作的资源。     </p>      <p>     通常来说，如果方法打开了一个流或其它资源，该方法应该使用 try/finally 块来确保在返回之前已经对流或资源进行了清理。     </p>      <p>     此错误模式实质上与 OS_OPEN_STREAM 和 ODR_OPEN_DATABASE_RESOURCE 错误模式相同，但基于不同的（希望更好的）静态分析技术。我们对这个错误模式的有用性很感兴趣。如果您想提供反馈，请参阅：     </p>     <ul> <li><a href="https://github.com/spotbugs/spotbugs/blob/master/CONTRIBUTING.md">贡献指南</a></li> <li><a href="https://github.com/spotbugs/discuss/issues?q=">邮件列表</a></li>     </ul>      <p>     特别是，此错误模式的假阳性抑制启发式规则尚未经过广泛调优，因此关于假阳性的报告对我们很有帮助。     </p>      <p>     有关此分析技术的描述，请参见 Weimer 和 Necula 的《发现和预防运行时错误处理错误》一文。     </p>]]>
      </Details>
  </BugPattern>















  <BugPattern type="FB_UNEXPECTED_WARNING">
    <ShortDescription>来自SpotBugs的意外/不必要的警告  Unexpected/undesired warning from SpotBugs</ShortDescription>
    <LongDescription>在{1}中发现了意外/不必要的{2} SpotBugs 警告</LongDescription>
    <Details>
          <![CDATA[<p>SpotBugs生成了一个警告，根据@NoWarning注解，这个警告是意外的或不必要的。</p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="FB_MISSING_EXPECTED_WARNING">
    <ShortDescription>缺少SpotBugs期望或所需的警告提示  Missing expected or desired warning from SpotBugs</ShortDescription>
    <LongDescription>在{1}中缺少预期或必要的{2}SpotBugs警告</LongDescription>
    <Details>
          <![CDATA[<p>SpotBugs没有生成根据@ExpectedWarning注解预期或希望的警告。</p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="RV_RETURN_VALUE_OF_PUTIFABSENT_IGNORED">
    <ShortDescription>putIfAbsent 的返回值被忽略，传递给 putIfAbsent 的值被重复使用  Return value of putIfAbsent ignored, value passed to putIfAbsent reused</ShortDescription>
    <LongDescription>putIfAbsent 的返回值被忽略，但 {4} 在 {1} 中被重复使用</LongDescription>
    <Details>
          <![CDATA[`putIfAbsent` 方法通常用于确保给定键关联一个单一值（如果 `put if absent` 成功，则为该键设置第一个值）。如果你忽略返回值并保留传入值的引用，你可能会保留与该键在映射中不对应的值。如果你使用的是未存储在映射中的那个值，并且这对你来说很重要，那么你的程序将行为错误。]]>
      </Details>
  </BugPattern>
  <BugPattern type="LG_LOST_LOGGER_DUE_TO_WEAK_REFERENCE">
    <ShortDescription>由于弱引用在OpenJDK中的使用，可能导致潜在的日志记录器更改丢失。  Potential lost logger changes due to weak reference in OpenJDK</ShortDescription>
    <LongDescription>在 `{1}` 中对日志记录器的更改可能会丢失。</LongDescription>
    <Details>
          <![CDATA[<p>OpenJDK 引入了一个潜在的不兼容性。特别是，java.util.logging.Logger 的行为已经改变。它现在内部使用弱引用而不是强引用。这是一个合理的更改，但不幸的是，有些代码依赖于旧的行为 - 在更改日志记录器配置时，它只是丢弃了日志记录器引用。这意味着垃圾回收器可以自由地收回该内存，从而导致日志记录器配置丢失。例如，请考虑以下代码： </p> <pre><code>public static void initLogging() throws Exception {     Logger logger = Logger.getLogger("edu.umd.cs");     logger.addHandler(new FileHandler()); // 调用更改日志记录器配置     logger.setUseParentHandlers(false); // 另一个更改日志记录器配置的调用 } </code></pre> <p>在方法结束时丢失了日志记录器引用（它没有逃出该方法），因此如果在 initLogging 调用之后刚好发生垃圾回收周期，那么日志记录器配置将会丢失（因为 Logger 只保持弱引用）。 </p> <pre><code>public static void main(String[] args) throws Exception {     initLogging(); // 为日志记录器添加文件处理程序     System.gc(); // 日志记录器配置丢失     Logger.getLogger("edu.umd.cs").info("Some message"); // 这不会如预期那样将消息写入文件 </code></pre> <p><em>Ulf Ochsenfahrt 和 Eric Fellheimer</em></p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="AT_OPERATION_SEQUENCE_ON_CONCURRENT_ABSTRACTION">
    <ShortDescription>对并发抽象的调用序列可能不是原子操作  Sequence of calls to concurrent abstraction may not be atomic</ShortDescription>
    <LongDescription>在{1}中，对{2}的连续调用可能不是原子操作。</LongDescription>
    <Details>
          <![CDATA[这段代码包含对并发抽象（如并发哈希映射）的一系列调用。这些调用不会被原子执行。]]>
      </Details>
  </BugPattern>
  <BugPattern type="DM_DEFAULT_ENCODING">
    <ShortDescription>依赖默认编码  Reliance on default encoding</ShortDescription>
    <LongDescription>在 {1} 中发现依赖默认编码：{2}</LongDescription>
    <Details>
<![CDATA[<p>发现了一个将字节转换为字符串（或字符串转换为字节）的方法调用，并且会假设默认平台编码是合适的。这会导致应用程序的行为在不同平台上有所不同。请使用替代API，并显式指定字符集名称或字符集对象。</p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="NP_METHOD_PARAMETER_RELAXING_ANNOTATION">
    <ShortDescription>方法收紧了参数的非空注解  Method tightens nullness annotation on parameter</ShortDescription>
    <LongDescription>方法 `{1}` 覆写了空值注解，从而放松了对其参数的祖先方法的要求。</LongDescription>
    <Details>
        <![CDATA[<p>   方法应当始终实现其覆盖方法的契约。因此，如果一个方法接收一个标记为 @Nullable 的参数，你不应该在子类中用一个该参数标记为 @Nonnull 的方法来覆盖它。这样做会违反该方法处理空参数的契约。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_METHOD_PARAMETER_TIGHTENS_ANNOTATION">
    <ShortDescription>方法收紧了参数的空值注解  Method tightens nullness annotation on parameter</ShortDescription>
    <LongDescription>方法 `{1}` 以不兼容的方式覆盖了参数 `{2}` 的非空性注解</LongDescription>
    <Details>
        <![CDATA[<p>一个方法在覆盖父类的方法时，应该始终实现该方法的契约。因此，如果一个方法接收一个标记为 @Nullable 的参数，你不应该在子类中用一个参数标记为 @Nonnull 的方法来覆盖它。这样做违反了该方法应处理空参数的契约。</p>]]>
      </Details>
  </BugPattern>

  <BugPattern type="NP_METHOD_RETURN_RELAXING_ANNOTATION">
    <ShortDescription>方法放松了返回值的非空注解  Method relaxes nullness annotation on return value</ShortDescription>
    <LongDescription>方法 `{1}` 以不兼容的方式覆写了返回值的空值注解。</LongDescription>
    <Details>
        <![CDATA[<p>一个方法在覆盖父类的方法时，应该始终实现该方法的合约。因此，如果一个方法被注解为返回@Nonnull值，你不应在子类中用一个被注解为返回@Nullable或@CheckForNull值的方法来覆盖它。这样做会违反该方法不应返回null的合约。</p>]]>
      </Details>
  </BugPattern>

  <BugPattern type="EOS_BAD_END_OF_STREAM_CHECK">
    <ShortDescription>数据读取在比较之前被转换为-1  Data read is converted before comparison to -1</ShortDescription>
    <LongDescription>在方法 {1} 中，{2} 的返回值在与 {4} 进行比较之前被转换为 {3}。</LongDescription>
    <Details>
      <![CDATA[<p>方法 `java.io.FileInputStream.read()` 返回一个 int。如果将这个 int 转换为 byte，则 -1（表示文件结束符 EOF）和字节 0xFF 就无法区分，将转换后的结果与 -1 进行比较会导致在遇到字符 0xFF 时循环提前终止。同样地，方法 `java.io.FileReader.read()` 也返回一个 int。如果将其转换为 char，则 -1 变为 0xFFFF，即 `Character.MAX_VALUE`。将结果与 -1 进行比较是没有意义的，因为在 Java 中字符是无符号的。如果使用 EOF 的检查作为循环条件，则该循环会无限执行。</p>]]>
    </Details>
  </BugPattern>
  <!--
  **********************************************************************
   BugCodes
  **********************************************************************
   -->
  <BugCode abbrev="FS">格式字符串问题  Format string problem</BugCode>
  <BugCode abbrev="SKIPPED">分析跳过  Analysis skipped</BugCode>
  <BugCode abbrev="IL">无限循环  Infinite Loop</BugCode>
  <BugCode abbrev="VO">使用volatile关键字  Use of volatile</BugCode>
  <BugCode abbrev="UI">不安全的继承  Unsafe inheritance</BugCode>
  <BugCode abbrev="FL">浮点精度的使用  Use of floating point precision</BugCode>
  <BugCode abbrev="TEST">测试原型和未完成的错误模式  Testing prototype and incomplete bug pattern</BugCode>
  <BugCode abbrev="IMSE">可疑的对IllegalMonitorStateException的捕获  Dubious catching of IllegalMonitorStateException</BugCode>
  <BugCode abbrev="CN">克隆模式的不良实现  Bad implementation of cloneable idiom</BugCode>
  <BugCode abbrev="CAA">协变数组赋值  Covariant array assignment</BugCode>
  <BugCode abbrev="AT">可能的原子性违规  Possible atomicity violation</BugCode>
  <BugCode abbrev="FI">finalizer的不当使用  Incorrect use of finalizers</BugCode>
  <BugCode abbrev="ES">使用 == 或 != 检查 String 的相等性  Checking String equality using == or !=</BugCode>
  <BugCode abbrev="ML">在更新字段时进行同步（可变锁）  Synchronization on updated field (Mutable Lock)</BugCode>
  <BugCode abbrev="UG">未同步的get方法，同步的set方法  Unsynchronized get method, synchronized set method</BugCode>
  <BugCode abbrev="IO">输入/输出问题  Input/Output problem</BugCode>
  <BugCode abbrev="IC">初始化循环依赖  Initialization circularity</BugCode>
  <BugCode abbrev="SI">可疑的静态初始化器  Suspicious static initializer</BugCode>
  <BugCode abbrev="MSF">可变的servlet字段  Mutable servlet field</BugCode>
  <BugCode abbrev="IS">不一致的同步  Inconsistent synchronization</BugCode>
  <BugCode abbrev="Eq">equals() 方法的实现问题  Problems with implementation of equals()</BugCode>
  <BugCode abbrev="Co">Comparable接口的实现问题  Problems with implementation of compareTo()</BugCode>
  <BugCode abbrev="HE">相等的对象必须具有相同的哈希码  Equal objects must have equal hashcodes</BugCode>
  <BugCode abbrev="AM">API 使用不当  API misuse</BugCode>
  <BugCode abbrev="Dm">可疑的方法使用  Dubious method used</BugCode>
  <BugCode abbrev="Bx">原始值的可疑装箱  Questionable Boxing of primitive value</BugCode>
  <BugCode abbrev="UR">在构造函数中读取未初始化的字段  Uninitialized read of field in constructor</BugCode>
  <BugCode abbrev="RR">方法忽略了InputStream.read()的方法结果。  Method ignores results of InputStream.read()</BugCode>
  <BugCode abbrev="NN">裸露的通知  Naked notify</BugCode>
  <BugCode abbrev="UW">无条件等待  Unconditional wait</BugCode>
  <BugCode abbrev="SP">方法在字段上旋转  Method spins on field</BugCode>
  <BugCode abbrev="DC">双检模式  Double check pattern</BugCode>
  <BugCode abbrev="Wa">不在循环中等待  Wait not in loop</BugCode>
  <BugCode abbrev="No">使用 `notify()` 而不是 `notifyAll()`  Using notify() rather than notifyAll()</BugCode>
  <BugCode abbrev="DE">抛出或忽略的异常  Dropped or ignored exception</BugCode>
  <BugCode abbrev="Ru">方法调用run()  Method invokes run()</BugCode>
  <BugCode abbrev="It">迭代器的定义不正确  Incorrect definition of Iterator</BugCode>
  <BugCode abbrev="SnVI">序列化类缺少版本ID  Serializable class with no Version ID</BugCode>
  <BugCode abbrev="Se">序列化类的定义不正确  Incorrect definition of Serializable class</BugCode>
  <BugCode abbrev="WS">类的 `writeObject()` 方法是同步的，但其他方法都不是。  Class's writeObject() method is synchronized but nothing else is</BugCode>
  <BugCode abbrev="RS">class的readObject()方法是同步的  Class's readObject() method is synchronized</BugCode>
  <BugCode abbrev="SC">构造函数调用了Thread.start()方法  Constructor invokes Thread.start()</BugCode>
  <BugCode abbrev="MS">可变的静态字段  Mutable static field</BugCode>
  <BugCode abbrev="ME">可变枚举字段  Mutable enum field</BugCode>
  <BugCode abbrev="EI">方法返回数组可能会暴露内部表示。  Method returning array may expose internal representation</BugCode>
  <BugCode abbrev="Nm">混淆的方法名称  Confusing method name</BugCode>
  <BugCode abbrev="SS">未读字段应为静态的  Unread field should be static</BugCode>
  <BugCode abbrev="UuF">未使用字段  Unused field</BugCode>
  <BugCode abbrev="UrF">未读字段  Unread field</BugCode>
  <BugCode abbrev="UwF">未定义字段  Unwritten field</BugCode>
  <BugCode abbrev="SIC">内部类可以声明为静态类  Inner class could be made static</BugCode>
  <BugCode abbrev="TLW">持有两个锁进行等待  Wait with two locks held</BugCode>
  <BugCode abbrev="RANGE">范围检查  Range checks</BugCode>
  <BugCode abbrev="RV">方法返回值的误用  Bad use of return value from method</BugCode>
  <BugCode abbrev="LG">日志问题  Logger problem</BugCode>
  <BugCode abbrev="IA">含糊的调用  Ambiguous invocation</BugCode>
  <BugCode abbrev="HSC">巨大的字符串常量  Huge String constants</BugCode>
  <BugCode abbrev="HRS">HTTP响应拆分漏洞  HTTP Response splitting vulnerability</BugCode>
  <BugCode abbrev="PT">路径遍历  Path traversal</BugCode>
  <BugCode abbrev="XSS">跨站脚本漏洞  Cross site scripting vulnerability</BugCode>
  <BugCode abbrev="NP">空指针解引用  Null pointer dereference</BugCode>
  <BugCode abbrev="NOISE">无效的随机警告  Bogus random warning</BugCode>
  <BugCode abbrev="RpC">重复的条件判断  Repeated conditional test</BugCode>
  <BugCode abbrev="OS">在所有路径上未关闭流  Stream not closed on all paths</BugCode>
  <BugCode abbrev="PZLA">prefer 为空数组来指示没有结果而不是使用null  Prefer zero length arrays to null to indicate no results</BugCode>
  <BugCode abbrev="UCF">无用的控制流  Useless control flow</BugCode>
  <BugCode abbrev="RCN">对空值的冗余比较  Redundant comparison to null</BugCode>
  <BugCode abbrev="UL">锁在所有路径上均未释放  Lock not released on all paths</BugCode>
  <BugCode abbrev="RC">使用引用相等性而非调用equals方法可能存在疑问  Questionable use of reference equality rather than calling equals</BugCode>
  <BugCode abbrev="EC">比较不兼容的类型是否相等  Comparing incompatible types for equality</BugCode>
  <BugCode abbrev="MWN">不匹配的wait()或notify()  Mismatched wait() or notify()</BugCode>
  <BugCode abbrev="SA">无用的自我操作  Useless self-operation</BugCode>
  <BugCode abbrev="INT">可疑的整数表达式  Suspicious integer expression</BugCode>
  <BugCode abbrev="BIT">可疑的位运算逻辑表达式  Suspicious bitwise logical expression</BugCode>
  <BugCode abbrev="LI">未同步的懒加载初始化  Unsynchronized Lazy Initialization</BugCode>
  <BugCode abbrev="JLM">对 java.util.concurrent 中的对象进行同步  Synchronization on java.util.concurrent objects</BugCode>
  <BugCode abbrev="UPM">私有方法从未被调用  Private method is never called</BugCode>
  <BugCode abbrev="UMAC">匿名类中的不可调用方法  Uncallable method of anonymous class</BugCode>
  <BugCode abbrev="EI2">存储对可变对象的引用  Storing reference to mutable object</BugCode>
  <BugCode abbrev="NS">非短路布尔运算符的可疑使用  Suspicious use of non-short-circuit boolean operator</BugCode>
  <BugCode abbrev="ODR">数据库资源在所有路径中未关闭  Database resource not closed on all paths</BugCode>
  <BugCode abbrev="SBSC">在循环中使用+操作符进行字符串连接  String concatenation in loop using + operator</BugCode>
  <BugCode abbrev="IIL">可以在循环外部移动的低效代码  Inefficient code which can be moved outside of the loop</BugCode>
  <BugCode abbrev="IIO">无效使用String.indexOf(String)或String.lastIndexOf(String)  Inefficient use of String.indexOf(String) or String.lastIndexOf(String)</BugCode>
  <BugCode abbrev="ITA">对集合使用 `toArray(new Foo[0])` 的方式不够高效。  Inefficient use of collection.toArray(new Foo[0])</BugCode>
  <BugCode abbrev="SW"> Swing编码规范  Swing coding rules</BugCode>
  <BugCode abbrev="IJU">未正确实现的JUnit测试案例  Improperly implemented JUnit TestCase</BugCode>
  <BugCode abbrev="BOA">错误覆盖适配器  Badly Overridden Adapter</BugCode>
  <BugCode abbrev="SF">switch-case 会直接向下执行（即发生跳转）  Switch case falls through</BugCode>
  <BugCode abbrev="SIO">多余的 instanceof 检查  Superfluous instanceof</BugCode>
  <BugCode abbrev="BAC">不良的Applet构造函数  Bad Applet Constructor</BugCode>
  <BugCode abbrev="UOE">使用对象的 equals 方法  Use Object Equals</BugCode>
  <BugCode abbrev="STI">可疑的线程中断  Suspicious Thread Interrupted</BugCode>
  <BugCode abbrev="DLS">死掉的局部变量存储  Dead local store</BugCode>
  <BugCode abbrev="IP">被忽略的参数  Ignored parameter</BugCode>
  <BugCode abbrev="MF">遮掩字段  Masked Field</BugCode>
  <BugCode abbrev="WMI">不高效的Map迭代器使用  Inefficient Map Iterator</BugCode>
  <BugCode abbrev="ISC">实例化静态类  Instantiated Static Class</BugCode>
  <BugCode abbrev="REC">异常运行时捕获  RuntimeException capture</BugCode>
  <BugCode abbrev="FE">测试浮点数相等性  Test for floating point equality</BugCode>
  <BugCode abbrev="UM">不必要的数学运算常量上  Unnecessary Math on constants</BugCode>
  <BugCode abbrev="UC">无用的代码  Useless code</BugCode>
  <BugCode abbrev="CNT">已知常量的粗略值  Rough value of known constant</BugCode>
  <BugCode abbrev="CD">循环依赖  Circular Dependencies</BugCode>
  <BugCode abbrev="RI">冗余接口  Redundant Interfaces</BugCode>
  <BugCode abbrev="MTIA">多线程实例访问  Multithreaded Instance Access</BugCode>
  <BugCode abbrev="PS">公共信号量  Public Semaphores</BugCode>
  <BugCode abbrev="BSHIFT">不良的位移操作  Bad shift</BugCode>
  <BugCode abbrev="ICAST">从整数值进行类型转换  Casting from integer values</BugCode>
  <BugCode abbrev="RE">正则表达式  Regular expressions</BugCode>
  <BugCode abbrev="SQL">潜在的SQL问题  Potential SQL Problem</BugCode>
  <BugCode abbrev="WL">可能在错误的对象上加锁  Possible locking on wrong object</BugCode>
  <BugCode abbrev="ESync">空的同步块  Empty Synchronized blocks</BugCode>
  <BugCode abbrev="QF">可疑的循环  Questionable for loops</BugCode>
  <BugCode abbrev="VA">变量参数问题  Vararg problems</BugCode>
  <BugCode abbrev="BC">对象引用的不良转换  Bad casts of object references</BugCode>
  <BugCode abbrev="IM">可疑的整数运算  Questionable integer math</BugCode>
  <BugCode abbrev="ST">静态字段的误用  Misuse of static fields</BugCode>
  <BugCode abbrev="JCIP">违反net.jcip注解  Violation of net.jcip annotations</BugCode>
  <BugCode abbrev="USELESS_STRING">生成的字符串无用/不具信息性  Useless/non-informative string generated</BugCode>
  <BugCode abbrev="DMI">可疑的方法调用  Dubious method invocation</BugCode>
  <BugCode abbrev="PZ">警告灵感来自于Joshua Bloch和Neal Gafter的Programming Puzzlers  Warning inspired by Joshua Bloch's and Neal Gafter's Programming Puzzlers</BugCode>
  <BugCode abbrev="SWL">带锁睡眠  Sleep with lock held</BugCode>
  <BugCode abbrev="J2EE">Java 2 Enterprise Edition 错误  J2EE error</BugCode>
  <BugCode abbrev="DB">重复分支  Duplicate Branches</BugCode>
  <BugCode abbrev="IMA">不高效的成员访问  Inefficient Member Access</BugCode>
  <BugCode abbrev="XFB">XML工厂绕过  XML Factory Bypass</BugCode>
  <BugCode abbrev="USM">无用的子类方法  Useless Subclass Method</BugCode>
  <BugCode abbrev="CI">混淆继承  Confused Inheritance</BugCode>
  <BugCode abbrev="QBA">可疑的布尔赋值  Questionable Boolean Assignment</BugCode>
  <BugCode abbrev="VR">版本兼容性问题  Version compatibility issue</BugCode>
  <BugCode abbrev="DP">使用 doPrivileged 方法  Use doPrivileged</BugCode>
  <BugCode abbrev="GC">泛型集合方法的可疑调用  Suspicious calls to generic collection methods</BugCode>
  <BugCode abbrev="STCAL">静态使用类型 Calendar 或 DateFormat  Static use of type Calendar or DateFormat</BugCode>
  <BugCode abbrev="TQ">类型限定注解使用不一致  Inconsistent use of type qualifier annotations</BugCode>
  <BugCode abbrev="OBL">未满足清理流或资源的义务  Unsatisfied obligation to clean up stream or resource</BugCode>
  <BugCode abbrev="FB">SpotBugs 在一个方法上没有产生预期的警告  SpotBugs did not produce the expected warnings on a method</BugCode>
  <BugCode abbrev="DL">由于在共享对象上锁可能导致无意中的竞态条件或死锁风险  Unintended contention or possible deadlock due to locking on shared objects</BugCode>
  <BugCode abbrev="JUA">JUnit断言中的问题  Problems in JUnit Assertions</BugCode>
  <BugCode abbrev="EOS">错误的流结束检查  Bad End of Stream check</BugCode>
</MessageCollection>
