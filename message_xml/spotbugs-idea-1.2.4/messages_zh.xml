<?xml version="1.0" encoding="UTF-8"?>
<MessageCollection xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="messagecollection.xsd">
  <!--
  **********************************************************************
  Plugin information
  **********************************************************************
  -->
  <Plugin>
    <ShortDescription>Core SpotBugs plugin</ShortDescription>
    <Details>
<![CDATA[
<p>
This plugin contains all of the standard SpotBugs detectors.
</p>
]]>
    </Details>
    <BugsUrl>https://spotbugs.readthedocs.io/en/latest/bugDescriptions.html</BugsUrl>
    <AllBugsUrl>https://spotbugs.readthedocs.io/en/latest/bugDescriptions.html</AllBugsUrl>
  </Plugin>
  <FindBugsMain cmd="addMessages" class="edu.umd.cs.findbugs.AddMessages">
    <Description>将错误描述（例如，文本形式的bug说明）添加到分析结果中  Add msgs (e.g., textual descriptions of bugs) to analysis results</Description>
  </FindBugsMain>
  <FindBugsMain cmd="analyze" class="edu.umd.cs.findbugs.FindBugs2">
    <Description>执行SpotBugs分析  Perform SpotBugs Analysis</Description>
  </FindBugsMain>
  <FindBugsMain cmd="gui" class="edu.umd.cs.findbugs.gui2.Driver">
    <Description>启动SpotBugs图形界面  Launch SpotBugs GUI</Description>
  </FindBugsMain>
  <FindBugsMain cmd="list" class="edu.umd.cs.findbugs.PrintingBugReporter">
    <Description>将分析结果转换为文本形式  Convert analysis results to textual form</Description>
  </FindBugsMain>
  <FindBugsMain cmd="help" class="edu.umd.cs.findbugs.ShowHelp">
    <Description>提供命令帮助  Provide help for commands</Description>
  </FindBugsMain>
  <FindBugsMain cmd="version" class="edu.umd.cs.findbugs.Version">
    <Description>列出SpotBugs版本  List SpotBugs version</Description>
  </FindBugsMain>
  <FindBugsMain cmd="filter" class="edu.umd.cs.findbugs.workflow.Filter">
    <Description>过滤分析结果  Filter analysis results</Description>
  </FindBugsMain>
  <FindBugsMain cmd="set" class="edu.umd.cs.findbugs.workflow.SetBugDatabaseInfo">
    <Description>设置项目配置/选项  Set project configuration/options</Description>
  </FindBugsMain>
  <FindBugsMain cmd="history" class="edu.umd.cs.findbugs.workflow.MineBugHistory">
    <Description>多版本分析结果中的详细信息列表  List details from multi-version analysis results</Description>
  </FindBugsMain>
  <FindBugsMain cmd="union" class="edu.umd.cs.findbugs.workflow.UnionResults">
    <Description>合并不连续组件的分析结果  Merge analysis results from disjoint components</Description>
  </FindBugsMain>
  <FindBugsMain cmd="merge" class="edu.umd.cs.findbugs.workflow.Update">
    <Description>将不同版本软件的分析结果结合起来生成多版本分析结果  Combine analysis results from different versions of software to produce multi-version analysis results</Description>
  </FindBugsMain>

  <FindBugsMain cmd="dis" class="edu.umd.cs.findbugs.workflow.PrintClass">
    <Description>反编译一个类文件  Disassemble a class file</Description>
  </FindBugsMain>
  <FindBugsMain cmd="errors" class="edu.umd.cs.findbugs.workflowListErrors">
    <Description>列出存储在结果文件中的分析错误  List analysis errors stored in results file</Description>
  </FindBugsMain>

  <!-- On changing this, please also update default cloud id in FindbugsPlugin -->
  <Cloud id="edu.umd.cs.findbugs.cloud.doNothingCloud">
    <Description>(cloud disabled)</Description>
    <Details>Bug reviews are disabled when using this plugin.</Details>
  </Cloud>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.SuppressMultithreaded">
    <Description>抑制多线程正确性问题  Suppress multithreaded correctness issues</Description>
    <Details>抑制所有多线程正确性问题  Suppress all multithreaded correctness issues</Details>
  </PluginComponent>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.SuppressI18N">
    <Description>抑制国际化问题  Suppress internationalization issues</Description>
    <Details>抑制所有国际化问题  Suppress all internationalization issues</Details>
  </PluginComponent>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.SelectivelySuppressI18N">
    <Description>抑制所有但选定包的国际化问题  Suppress internationalization issues in all but selected packages</Description>
    <Details>抑制所有国际化问题，除非是在i18n.properties资源中指定的那些问题。  Suppress all internationalization issues except those specified in the i18n.properties resource</Details>
  </PluginComponent>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.MaxRank14">
    <Description>抑制排名高于14的所有问题  Suppress all issues with rank higher than 14</Description>
    <Details>压制等级高于14的所有问题  Suppress all issues with rank higher than 14</Details>
  </PluginComponent>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.SuppressMalicious">
    <Description>抑制关于恶意代码的警告提示  Suppress warnings about vulnerabilities to malicious code</Description>
    <Details>抑制关于恶意代码的警告提示  Suppress warnings about vulnerabilities to malicious code</Details>
  </PluginComponent>
  <!--
  **********************************************************************
  Categories (replacing the BugCategoryDescriptions.properties file)
  **********************************************************************
   -->
  <BugCategory category="CORRECTNESS">
    <Description>正确性  Correctness</Description>
    <Abbreviation>C</Abbreviation>
    <Details>可能的bug - 似乎是编码时出现的错误，导致代码很可能并非开发人员原意实现的功能。我们力求将误报率保持在较低水平。  Probable bug - an apparent coding mistake resulting in code that was probably not what the developer intended. We strive for a low false positive rate.</Details>
  </BugCategory>
  <BugCategory category="NOISE">
    <Description>虚假随机噪声  Bogus random noise</Description>
    <Abbreviation>N</Abbreviation>
    <Details>虚假随机噪声：旨在作为数据挖掘实验中的控制变量，而不是用于发现软件中的实际漏洞  Bogus random noise: intended to be useful     as a control in data mining experiments, not in finding actual bugs in software</Details>
  </BugCategory>
  <BugCategory category="SECURITY">
    <Description>安全  Security</Description>
    <Abbreviation>S</Abbreviation>
    <Details>一种使用不受信任的输入的方式，可能会创建一个远程可利用的安全漏洞。  A use of untrusted input in a way that could create a remotely exploitable security vulnerability.</Details>
  </BugCategory>
  <BugCategory category="BAD_PRACTICE">
    <Description>不良做法  Bad practice</Description>
    <Abbreviation>B</Abbreviation>
    <Details>违反推荐和必要的编码实践。例如，哈希码和equals问题、可克隆模式问题、丢失异常、Serializable问题以及滥用finalize方法。我们力求使这一分析准确，尽管某些团队可能并不关心其中的一些不良实践。  Violations of recommended and essential coding practice. Examples include hash code and equals problems, cloneable idiom, dropped exceptions, Serializable problems, and misuse of finalize. We strive to make this analysis accurate, although some groups may not care about some of the bad practices.</Details>
  </BugCategory>
  <BugCategory category="STYLE">
    <Description>可疑的代码  Dodgy code</Description>
    <Abbreviation>D</Abbreviation>
    <Details>代码混乱、异常或者容易引发错误的代码。例如，死掉的局部存储、switch语句穿透、未确认的类型转换以及对已知为null的值进行冗余的非空检查。在SpotBugs的 previous versions 中，这一类别被称为Style。  code that is confusing, anomalous, or written in a way that leads itself to errors. Examples include dead local stores, switch fall through, unconfirmed casts, and redundant null check of value known to be null. More false positives accepted. In previous versions of SpotBugs, this category was known as Style.</Details>
  </BugCategory>
  <BugCategory category="PERFORMANCE">
    <Description>绩效  Performance</Description>
    <Abbreviation>P</Abbreviation>
    <Details>代码可能是不必然错误但可能不够高效  code that is not necessarily incorrect but may be inefficient</Details>
  </BugCategory>
  <BugCategory category="MALICIOUS_CODE">
    <Description>恶意代码漏洞  Malicious code vulnerability</Description>
    <Abbreviation>V</Abbreviation>
    <Details>来自不受信任代码的攻击易受攻击的代码  code that is vulnerable to attacks from untrusted code</Details>
  </BugCategory>
  <BugCategory category="MT_CORRECTNESS">
    <Description>多线程正确性  Multithreaded correctness</Description>
    <Abbreviation>M</Abbreviation>
    <Details>与线程、锁和volatile相关的代码缺陷  code flaws having to do with threads, locks, and volatiles</Details>
  </BugCategory>
  <BugCategory category="I18N">
    <Description>国际化  Internationalization</Description>
    <Abbreviation>I</Abbreviation>
    <Details>与国际化和区域设置相关的代码缺陷  code flaws having to do with internationalization and locale</Details>
    <!-- DM_CONVERT_CASE is the only core bug pattern in this category -->
  </BugCategory>
  <BugCategory category="EXPERIMENTAL">
    <Description>实验性的  Experimental</Description>
    <Abbreviation>X</Abbreviation>
    <Details>未经充分验证的实验性bug模式  Experimental and not fully vetted bug patterns</Details>
    <!-- DM_CONVERT_CASE is the only core bug pattern in this category -->
  </BugCategory>

  <!--
  **********************************************************************
  Detectors
  **********************************************************************
   -->
  <Detector class="edu.umd.cs.findbugs.detect.OverridingMethodsMustInvokeSuperDetector">
    <Details>
<![CDATA[<p>查找必须调用super的方法重写。</p>  <p> Finds overriding methods that must call super. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindRoughConstants">
    <Details>
<![CDATA[<p>找到大约（但不精确等于）已知值如Math.PI的常数。</p>  <p> Finds constants which roughly (but not precisely) equal to known values like Math.PI. </p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InitializeNonnullFieldsInConstructor">
    <Details>
<![CDATA[<p>查找非空字段，这些字段在构造函数中未被写入。</p>  <p> Finds non-null fields that are not written to in constructors. </p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.IntCast2LongAsInstant">
    <Details>
<![CDATA[<p>查找用于描述自纪元以来毫秒的32位值的用法。 </p>  <p> Finds uses of 32-bit values to describe milliseconds since the epoch. </p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainLongInstantfParams">
    <Details>
<![CDATA[<p>构建一个参数数据库，这些参数采用64位值来描述自纪元以来的毫秒数。</p>  <p> Builds database of parameters that take a 64 bit value describing milliseconds since the epoch.</p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InconsistentAnnotations">
    <Details>
<![CDATA[这个检测器会找出直接应用于方法参数的类型限定符与这些方法参数使用之间的不一致之处。  <p> This detector finds inconsistencies between type qualifiers directly applied to method parameters and uses of those method parameters. </p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.AtomicityProblem">
    <Details>
<![CDATA[找出在并发抽象上不会原子执行的一系列操作（例如，get/put）。  <p> Finds sequences of operations (e.g., get/put) on a concurrent abstraction     that will not be executed atomically.     </p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SynchronizationOnSharedBuiltinConstant">
    <Details>
<![CDATA[这个检测器会在共享的内置常量（如String）上查找同步情况。  <p> This detector looks for synchronization on a shared built-in constant (such as a String).</p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SynchronizeAndNullCheckField">
    <Details>
<![CDATA[这个检测器寻找一个同步启用的字段，然后对其进行空检查。  <p> This detector looks for a field that is synchronized on and then null checked.</p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckImmutableAnnotation">
    <Details>
<![CDATA[查找被注解为net.jcip.annotations.Immutable或javax.annotation.concurrentImmutable的类违反规则的情况。  <p> Looks for violations of the rules for classes annotated as net.jcip.annotations.Immutable or javax.annotation.concurrent.Immutable.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.VarArgsProblems">
    <Details>
<![CDATA[<p>查找来自Java 1.5可变参数的问题。</p>  <p> Looks for problems with arising from Java 1.5 varargs.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteJCIPAnnotation">
    <Details>
<![CDATA[<p>记录来自net.jcip.annotations包的注解。</p>  <p> Record annotations from the net.jcip.annotations package.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteDirectlyRelevantTypeQualifiers">
    <Details>
<![CDATA[注意与分析方法相关的类型限定词。  <p> Note the type qualifiers relevant to analyzing a method.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BuildInterproceduralCallGraph">
    <Details>
      <![CDATA[构建程序间调用图。  <p>Builds the interprocedural call graph.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BuildObligationPolicyDatabase">
    <Details>
          <![CDATA[构建FindUnsatisfiedObligation检测器使用的义务类型和方法的数据库。  <p>Builds the database of obligation types and methods used by the FindUnsatisfiedObligation detector.]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteSuppressedWarnings">
    <Details>
<![CDATA[基于使用edu.umd.cs.findbugs.annotations.NoteSuppressWarnings注解来抑制警告。  <p> Suppresses warnings based on use of the edu.umd.cs.findbugs.annotations.NoteSuppressWarnings annotation.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteAnnotationRetention">
    <Details>
<![CDATA[记录注释保留。  <p> Records annotation retention.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteSyntheticElements">
    <Details>
      <![CDATA[<p>记录合成类、方法、字段等。</p>  <p>Records synthetic classes, methods, fields, etc.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.Methods">
    <Details>
<![CDATA[<p>构建所有分析类中定义的方法数据库，供其他检测器使用。</p>  <p> Builds a database of all methods defined in analyzed classes, for use by other detectors.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ReflectiveClasses">
    <Details>
<![CDATA[尝试确定哪些类具有对其.class对象的常量引用。  <p> Try to determine which classes have constant references to their .class objects.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CalledMethods">
    <Details>
<![CDATA[<p>构建所有分析类中调用的方法的数据库，供其他检测器使用。</p>  <p> Builds a database of all methods invoked in analyzed classes, for use by other detectors.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNoSideEffectMethods">
    <Details>
<![CDATA[查找没有副作用，仅仅返回一些值的方法。  <p> Looks for the methods which have no side effect, just return some value.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BuildStringPassthruGraph">
    <Details>
<![CDATA[<p>构建数据库，保存从一个方法传递到另一个方法的字符串参数，并保持不变。</p>  <p> Builds the database of string parameters passed from method to method unchanged.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FunctionsThatMightBeMistakenForProcedures">
    <Details>
<![CDATA[查找具有返回该类新实例方法的不可变类，以防人们错误地认为这些方法会mutation调用它们的方法所引用的实例。  <p> Looks for immutable classes with methods that return new instances of that class, where people might accidentally think those methods mutate the instance they are invoked on. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ConfusionBetweenInheritedAndOuterMethod">
    <Details>
<![CDATA[<p>查找可能引起混淆的继承方法和外部方法。</p>  <p> Looks for potential confusion between inherited and outer methods.</p>]]>
    </Details>
  </Detector>
    <Detector class="edu.umd.cs.findbugs.detect.NoteCheckReturnValueAnnotations">
    <Details>
<![CDATA[<p> 查找注解以检查方法的返回值。 </p>  <p> Looks for annotations to check return values of a method. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SynchronizeOnClassLiteralNotGetClass">
    <Details>
      <![CDATA[查找同步代码，该代码使用getClass的结果而不是类字面量。  <p> Looks for code that synchronizes on the results of getClass rather than on class literals. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FieldItemSummary">
    <Details>
      <![CDATA[这个检测器生成有关存储在字段中的信息的摘要。  <p>     This detector produces summary information for what is stored     into fields. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteNonNullAnnotations">
    <Details>
      <![CDATA[查找方法、字段和参数上的@Nonnull注解。这些可以被FindNullDeref检测器用于生成警告，当可能为null的值在只能使用非null值的上下文中使用时。  <p> Looks for @Nonnull annotations on methods, fields, and parameters. These can be used by the FindNullDeref detector to generate warnings when a possibly-null value is used in a context where only non-null values should be used. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteUnconditionalParamDerefs">
    <Details>
      <![CDATA[分析应用程序中的所有方法，确定哪些方法无条件地解引用参数。这些信息在后续的分析过程中用于找到可能传递空值的调用点。  
这是一个运行较慢的检测器。  <p> Analyze all methods in the application to determine which dereference parameters unconditionally.  This information is used in a later analysis pass to find call sites where null values may be passed to those methods. </p> <p> This is a slow detector. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteNonnullReturnValues">
    <Details>
      <![CDATA[分析应用程序中的所有方法，确定哪些方法始终返回非空值。  <p> Analyze all methods in the application to determine which     methods always return non-null values. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BooleanReturnNull">
    <Details>
<![CDATA[查找返回布尔类型且明确返回空值的方法。  <p> Looks for methods with Boolean return type that return explicit null values.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.OptionalReturnNull">
    <Details>
<![CDATA[查找返回类型为Optional且Explicitly返回null值的方法。  <p> Looks for methods with Optional return type that return explicit null values.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUselessObjects">
    <Details>
<![CDATA[<p> 查找无用的对象。</p>  <p> Looks for useless objects.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MutableEnum">
    <Details>
          <![CDATA[<p>检查并警告关于可变枚举字段。</p>  <p> Looks and warns about mutable enum fields.</p>]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BadUseOfReturnValue">
    <Details>
<![CDATA[查找函数检查非空后直接丢弃返回值的情况。  <p> Looks for cases where the return value of a function is discarded after being checked for non-null.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InheritanceUnsafeGetResource">
    <Details>
<![CDATA[查找对 `this.getClass().getResource(...)` 的使用，如果该类被另一个包中的类扩展，则可能会导致意外的结果。  <p> Looks for uses of this.getClass().getResource(...), which can give unexpected results if the class is extended by a class in another package. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InfiniteRecursiveLoop">
    <Details>
<![CDATA[查找无限递归循环。  <p> Looks for an infinite recursive loop. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InfiniteLoop">
    <Details>
<![CDATA[<p> 寻找无限循环。 </p>  <p> Looks for an infinite loop. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.VolatileUsage">
    <Details>
<![CDATA[查找volatile字段使用中的bug模式。  <p> Looks for bug patterns in the usage of volatile fields. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.EmptyZipFileEntry">
    <Details>
<![CDATA[这用于查找创建空的zip文件条目。它是一个中等速度的检测器。  <p> This looks for creation of empty zip file entries. It is a moderately fast detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.UncallableMethodOfAnonymousClass">
    <Details>
<![CDATA[这个检测器寻找定义了可能意图覆盖超类中方法但实际上并未覆盖的方法的匿名内部类。  <p> This detector looks for anonymous inner classes that define methods that are probably intended to but do not override methods in a superclass. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DontUseEnum">
    <Details>
<![CDATA[检查字段和方法不要使用assert或enum作为名称，因为它们是Java 5中的关键字。  <p>Checks that fields and methods don't use the name assert or enum as they are keywords in Java 5.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.URLProblems">
    <Details>
<![CDATA[`java.net.URL` 的 `equals` 和 `hashCode` 方法会解析域名。因此，这些操作可能会非常昂贵，这个检测器会寻找那些可能调用这些方法的地方。  <p> The equals and hashCode method on <code>java.net.URL</code> resolve the domain name. As a result, these operations can be very expensive, and this detector looks for places where those methods might be invoked. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FinalizerNullsFields">
    <Details>
<![CDATA[这个检测器寻找会清空类字段最终化器。这并不会帮助垃圾回收器，清空字段并没有任何效果。  <p> This detector looks for finalizers that null out fields of a class. This does not help the garbage collector in any way, the nulling out of fields has no effect. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CrossSiteScripting">
    <Details>
<![CDATA[这个检测器寻找明显的跨站脚本漏洞案例。  <p> This detector looks for obvious/blatant cases of cross site scripting vulnerabilities.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.RepeatedConditionals">
    <Details>
<![CDATA[这个检测器寻找包含重复条件检查的代码，例如(x == 5 || x == 5)。  <p> This detector looks for code containing repeated conditional tests, such as (x == 5 || x == 5).]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.RedundantConditions">
    <Details>
<![CDATA[这个检测器寻找包含无用条件的代码，比如这个表达式中的第二个条件：(x >= 10 && x >= 5)。  <p> This detector looks for code containing useless conditions like the second condition in this expression: (x >= 10 && x >= 5).]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CallToUnsupportedMethod">
    <Details>
<![CDATA[这个检测器寻找对不支持方法的调用。  <p> This detector looks for calls to methods that are unsupported.]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FormatStringChecker">
    <Details>
<![CDATA[检查不正确的格式字符串。  <p> Checks for incorrect format strings. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.EqualsOperandShouldHaveClassCompatibleWithThis">
    <Details>
<![CDATA[检查equals方法，这些方法用于检查其操作数是否为与定义equals方法的类不兼容的类的实例。  <p> Checks for equals methods that check for their operand being an instance of a class that is not compatible with the class defining the equals method. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestingGround">
    <Details>
<![CDATA[这个检测器只是一个测试新检测器的钩子。通常情况下，这个检测器什么也不做。  <p> This detector is just a hook for testing new detectors. Normally, this detector does nothing.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestingGround2">
    <Details>
<![CDATA[这个检测器只是一个用于测试新检测器的钩子。通常情况下，这个检测器什么也不做。  <p> This detector is just a hook for testing new detectors. Normally, this detector does nothing.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.LostLoggerDueToWeakReference">
    <Details>
<![CDATA[这个检测器会找到在使用弱引用holding Logger时，在OpenJDK 1.6下行为不同的代码。  <p> This detector finds code that behaves differently under OpenJDK 1.6, where weak references are used to hold onto Loggers. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestingGround2">
    <Details>
<![CDATA[这个检测器只是一个测试新检测器的钩子。通常情况下，这个检测器什么也不做。  <p> This detector is just a hook for testing new detectors. Normally, this detector does nothing.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.Noise">
    <Details>
<![CDATA[这个检测器生成一个随机信号：这些警告仅仅是基于方法执行的操作的哈希值。这些警告是虚假的随机噪声，旨在作为数据挖掘实验中的控制变量，并不是用来查找软件中的实际漏洞。这个检测器只是一个测试新检测器的钩子。通常情况下，这个检测器什么也不做。  <p> This detector generates a random signal: warnings that are just based on hash values of the operations performed by methods. These warnings are bogus random noise, intended to be useful   as a control in data mining experiments, not in finding actual bugs in software.   This detector is just a hook for testing new detectors. Normally, this detector does nothing.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoiseNullDeref">
    <Details>
<![CDATA[<p>无噪音检测器用于空指针取消引用。旨在作为关于警告的有效性或预测能力的实验中的控制变量使用，而不是用来查找代码中的问题。</p>  <p> Noisy detector for null dereferences. Intended to be used as a control in experiments about the validity or predictive ability of warnings, not as a way to find problems in code. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.HugeSharedStringConstants">
    <Details>
<![CDATA[这个检测器寻找在多个类文件中重复的字符串常量。  <p> This detector looks for string constants that are duplicated across multiple classfiles. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DoInsideDoPrivileged">
    <Details>
<![CDATA[<p>查找应在doPrivileged块内执行的代码。</p>  <p> Looks for code that should be executed inside doPrivileged blocks.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ResolveAllReferences">
    <Details>
<![CDATA[检查所有引用是否可以解析。  <p> Checks that all references call be resolved.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SwitchFallthrough">
    <Details>
<![CDATA[这个检测器寻找包含“fall through”的switch语句。  <p> This detector looks for switch statements containing fall through. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindFieldSelfAssignment">
    <Details>
<![CDATA[这个检测器查找字段被赋值的地方，具体是通过读取同一个字段的值来完成的。  <p> This detector looks for places where a field is assigned by reading the value of the same field.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSelfComparison">
    <Details>
<![CDATA[这个检测器寻找值与自身进行比较的地方。  <p> This detector looks for places where a value is compared with itself.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSelfComparison2">
    <Details>
<![CDATA[这个检测器寻找值与其自身的比较位置。  <p> This detector looks for places where a value is compared with itself.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNonShortCircuit">
    <Details>
<![CDATA[这个检测器查找非短路布尔运算符（使用 `|` 和 `&` 而不是 `||` 和 `&&` 的）可疑用法。  <p> This detector looks for suspicious uses of non-short-circuiting boolean operators (<code>|</code> and <code>&amp;</code> instead of <code>||</code> and <code>&amp;&amp;</code>).</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DontCatchIllegalMonitorStateException">
    <Details>
<![CDATA[这个检测器查找捕获IllegalMonitorStateException的try-catch块。  <p> This detector looks for try-catch blocks that catch an IllegalMonitorStateException.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindFloatMath">
    <Details>
<![CDATA[这个检测器用于查找使用浮点数学运算的情况。它是一个中等速度的检测器。  <p> This detector looks for uses of floating point math. It is a moderately fast detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CloneIdiom">
    <Details>
<![CDATA[这个检测器用于查找编写克隆类时违反的惯用法。  <p> This detector looks for violations of the idioms for writing cloneable classes. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ComparatorIdiom">
    <Details>
<![CDATA[这个检测器用于查找实现`Comparator`接口的类写的不符合约定的违规情况。  <p> This detector looks for violations of the idioms for writing classes that implement <code>Comparator</code>. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DroppedException">
    <Details>
<![CDATA[这个检测器寻找这样的代码：捕获了异常但没有对异常进行处理。  <p> This detector looks for code where an exception is caught, but nothing is done to handle the exception.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.LoadOfKnownNullValue">
    <Details>
<![CDATA[<p> 查找许多已知为空值的值。 </p>  <p> Looks for loads of values known to be null. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DumbMethodInvocations">
    <Details>
<![CDATA[这个检测器寻找被传递给方法的不良参数（例如，substring(0)）。  <p> This detector looks for bad arguments being passed to methods (e.g., substring(0)). </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DumbMethods">
    <Details>
<![CDATA[这个检测器会寻找调用无意义方法的情况，比如无参数的String构造函数。  <p> This detector looks for calls to pointless methods, such as the no-argument String constructor. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CovariantArrayAssignment">
    <Details>
<![CDATA[这个检测器寻找类似 `Object[] array = new String[10]` 的协变数组赋值，可能会在运行时导致 `ArrayStoreException`。  <p> This detector looks for covariant array assignments like Object[] array = new String[10] which may cause ArrayStoreException at runtime. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NumberConstructor">
    <Details>
<![CDATA[查找带有原始参数的Number构造函数调用。  <p> Looks for calls to Number constructors with primitive arguments. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindDoubleCheck">
    <Details>
<![CDATA[这个检测器寻找双重检查锁机制的实例。  <p> This detector looks for instances of double checked locking. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindFinalizeInvocations">
    <Details>
<![CDATA[这个检测器寻找对 finalize() 的调用以及其他与最终化相关的问题。  <p> This detector looks for calls to finalize() and other finalizer-related issues.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindHEmismatch">
    <Details>
<![CDATA[这个检测器寻找hashCode()方法和equals()方法定义中的问题。  <p> This detector looks for problems in the definition of the hashCode() and equals() methods.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.OverridingEqualsNotSymmetrical">
    <Details>
<![CDATA[查找覆盖超类中equals方法的equals方法，其中等价关系可能不是对称的。  <p> Looks for equals methods that override equals methods in a superclass where the equivalence relationship might not be symmetrical. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNakedNotify">
    <Details>
<![CDATA[这个检测器寻找看起来不修改可变对象状态的notify()调用。  <p> This detector looks for calls to notify() that don't seem to modify mutable object state.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindReturnRef">
    <Details>
<![CDATA[这个检测器寻找返回可变静态数据的方法。  <p> This detector looks for methods that return mutable static data. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindRunInvocations">
    <Details>
<![CDATA[这个检测器查找对Thread.run()的调用。它是一个快速的检测器。  <p> This detector looks for calls to Thread.run().  It is a fast detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSpinLoop">
    <Details>
<![CDATA[这个检测器寻找从字段读取的循环。  <p> This detector looks for loops that spin reading from a field. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindTwoLockWait">
    <Details>
<![CDATA[这个检测器会查找持有两个（或更多）锁的情况下调用wait()的情况。它是一个较慢的检测器。  <p> This detector looks for calls to wait() with two (or more) locks held. It is a slow detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnconditionalWait">
    <Details>
<![CDATA[这个检测器寻找不在条件语句或循环中的wait()调用。  <p> This detector looks for calls to wait() not in a conditional or loop. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUninitializedGet">
    <Details>
<![CDATA[这个检测器会在构造函数中查找未初始化字段的读取。  <p> This detector looks for reads of uninitialized fields in constructors. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnsyncGet">
    <Details>
<![CDATA[这个检测器查找那些get方法未同步而set方法已同步的get和set方法对。  <p> This detector looks for get and set methods where the get is unsynchronized while the set is synchronized.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InitializationChain">
    <Details>
<![CDATA[这个检测器寻找可能存在环形的类初始化依赖关系。  <p> This detector looks for potentially circular class initialization dependencies.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.IteratorIdioms">
    <Details>
<![CDATA[这个检测器用于查找Iterator类定义中的问题。  <p> This detector looks for problems in how Iterator classes are defined. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.LockedFields">
    <Details>
<![CDATA[这个检测器寻找以不一致方式访问的字段（特别是与加锁相关的）。  <p> This detector looks for fields that are accessed in an inconsistent manner with respect to locking.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.EqStringTest">
    <Details>
<![CDATA[这个检测器查找使用 == 或 != 运算符比较 String 对象的情况。  <p> This detector looks for comparisons of String objects using the == or != operators.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MutableLock">
    <Details>
<![CDATA[这个检测器会在修改过的字段中读取对象，并寻找同步。  <p> This detector looks for synchronization on objects read from modified fields.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SynchronizingOnContentsOfFieldToProtectField">
    <Details>
<![CDATA[这个检测器寻找看起来用于同步某个字段以保护对该字段更新的代码。  <p> This detector looks for code that seems to be synchronizing on a field in order to guard updates of that field. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MutableStaticFields">
    <Details>
<![CDATA[这个检测器寻找可能被恶意代码修改的静态字段。  <p> This detector looks for static fields that may be modified by malicious code.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.Naming">
    <Details>
<![CDATA[这个检测器寻找命名可疑的方法。  <p> This detector looks for suspiciously-named methods.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ReadReturnShouldBeChecked">
    <Details>
<![CDATA[这个检测器寻找对InputStream.read()或InputStream.skip()的调用，其中返回值被忽略了。  <p> This detector looks for calls to InputStream.read() or InputStream.skip() where the return value is ignored.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SerializableIdiom">
    <Details>
<![CDATA[这个检测器用于查找序列化类实现中的潜在问题。  <p> This detector looks for potential problems in the implementation of Serializable classes.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.StartInConstructor">
    <Details>
<![CDATA[这个检测器寻找启动线程的构造函数。  <p> This detector looks for constructors that start threads.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindBadForLoop">
    <Details>
<![CDATA[这个检测器查找错误的for循环。  <p> This detector looks for incorrect for loops. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ExplicitSerialization">
    <Details>
<![CDATA[<p> 寻找对 `readObject` 和 `writeObject` 的显式序列化调用，以证明该类确实进行了序列化。 </p>  <p> Looks for explicit serialization via readObject and     writeObject as evidence that this class is, indeed, serialized. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.UnreadFields">
    <Details>
<![CDATA[这个检测器查找那些值从未被读取的字段。  <p> This detector looks for fields whose value is never read.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.WaitInLoop">
    <Details>
<![CDATA[这个检测器寻找不在循环中的wait()调用。  <p> This detector looks for calls to wait() that are not in a loop. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BCPMethodReturnCheck">
    <Details>
<![CDATA[这个检测器会查找调用方法中返回值被可疑地忽略的情况。它是一个较慢的检测器。  <p> This detector looks for calls to methods where the return value is suspiciously ignored.  It is a slow detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindComparatorProblems">
    <Details>
<![CDATA[这个检测器寻找Comparator.compare或Comparable.compareTo实现中的问题。  <p> This detector looks for problems in Comparator.compare or Comparable.compareTo implementation.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNullDeref">
    <Details>
<![CDATA[这个检测器会寻找可能发生空指针异常的地方，还会检查是否存在多余的将引用值与null进行比较的情况。它是一个运行较慢的检测器。  <p> This detector looks for places where a null pointer exception might occur.  It also looks for redundant comparisons of reference values against null.  It is a slow detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNullDerefsInvolvingNonShortCircuitEvaluation">
    <Details>
<![CDATA[这个检测器寻找可能会发生空指针异常的地方，并且非短路评估的使用使得常规的技术失效。  <p> This detector looks for places where a null pointer exception might occur, and the use of non-short-circuit evaluation causes the usual techniques to fail. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindOpenStream">
    <Details>
<![CDATA[这个检测器寻找不会从方法中逃逸的IO流对象，并且不在所有离开方法的路径上看起来被关闭的对象。它是一个较慢的检测器。  <p> This detector looks for IO stream objects which do not escape the method and do not appear to be closed on all paths out of the method. It is a slow detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.PreferZeroLengthArrays">
    <Details>
<![CDATA[这个检测器寻找返回数组或明确的空引用的方法。在这种情况下，返回一个空数组通常比返回空引用更优选。  <p> This detector looks for methods that return either arrays or an explicit null reference. Returning a zero length array is generally preferred in this context to returning a null reference. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUselessControlFlow">
    <Details>
<![CDATA[这个检测器寻找没有任何效果的控制流语句。  <p> This detector looks for control flow statements which have no effect. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnreleasedLock">
    <Details>
<![CDATA[这个检测器查找在方法中获取但未在所有路径上释放的JSR-166（`java.util.concurrent`）锁。这是一个较快的检测器。请注意，为了使用此检测器，您需要在辅助类路径中包含`java.util.concurrent`包（或者正在分析该包本身）。  <p> This detector looks for JSR-166 (<code>java.util.concurrent</code>) locks which are acquired, but not released on all paths out of the method.&nbsp; It is a moderately fast detector.&nbsp; Note that in order to use this detector, you need to have the <code>java.util.concurrent</code> package in the auxiliary classpath (or be analyzing the package itself).</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindRefComparison">
    <Details>
<![CDATA[这个检测器寻找使用 `==` 或 `!=` 运算符比较两个引用值的地方，并且该类是某种类型（例如 `<code>java.lang.String</code>`），在这种情况下，比较引用值通常是错误的。这是一个较慢的检测器。  <p> This detector looks for places where two reference values are compared with the == or != operator, and the class is of a type (such as <code>java.lang.String</code>) where comparing reference values is generally an error.  It is a slow detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindMismatchedWaitOrNotify">
    <Details>
<![CDATA[这个检测器会查找对wait()、notify()或notifyAll()的调用，这些调用似乎没有在当前被锁定的对象上进行。这是一个较快的检测器。**由于该检测器仍在开发中，并产生太多误报，因此已禁用此检测器。**  <p> This detector looks for calls to wait(), notify(), or notifyAll() which do not appear to be made on an object which is currently locked.&nbsp; It is a moderately fast detector.&nbsp; <b>This detector is disabled because it is still under development, and produces too many false positives.</b></p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindEmptySynchronizedBlock">
    <Details>
<![CDATA[这个检测器寻找空的同步块。  <p> This detector looks for empty synchronized blocks.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindInconsistentSync2">
    <Details>
<![CDATA[这个检测器寻找以不一致方式访问的字段，特别是与加锁相关的部分。它是一个运行较慢的检测器。  <p> This detector looks for fields that are accessed in an inconsistent manner with respect to locking.  It is a slow detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindLocalSelfAssignment2">
    <Details>
<![CDATA[这个检测器寻找局部变量的自我赋值。  <p> This detector looks for self assignments of local variables. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.IncompatMask">
    <Details>
<![CDATA[这个检测器寻找可疑的位级逻辑表达式。  <p> This detector looks for suspicious bitwise logical expressions. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.LazyInit">
    <Details>
<![CDATA[这个检测器用于查找非volatile字段的懒初始化情况。它是一个中等速度的检测器。  <p> This detector looks for lazy field initialization where the field is not volatile.  It is a moderately fast detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindJSR166LockMonitorenter">
    <Details>
<![CDATA[这个检测器用于查找在JSR166锁上进行的普通同步。它是一个中等速度的检测器。  <p> This detector looks for ordinary synchronization performed on JSR166 locks.  It is a moderately fast detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUncalledPrivateMethods">
    <Details>
<![CDATA[这个检测器查找从未被调用的私有方法。  <p> This detector looks for private methods that are never called. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.StringConcatenation">
    <Details>
<![CDATA[这个检测器会在循环中查找使用+进行字符串连接的情况。  <p> This detector looks for String concatenation in loops using +. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InefficientInitializationInsideLoop">
    <Details>
<![CDATA[这个检测器寻找在循环中初始化的对象，将其移出循环可以提高性能。  <p> This detector looks for objects initialized within loop which can be moved outside for better performance. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InefficientIndexOf">
    <Details>
<![CDATA[这个检测器寻找使用 `String.indexOf(String)` 或 `String.lastIndexOf(String)`，并且传递的常量字符串长度为1的代码。建议使用更高效的整数实现。这是一个快速的检测器。  <p> This detector looks for code that uses String.indexOf(String) or String.lastIndexOf(String), passing a constant string of length 1. It is recommended to use the more efficient integer implementations. A fast detector. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InefficientToArray">
    <Details>
<![CDATA[这个检测器寻找将集合转换为数组的代码，具体是使用带原型数组的`toArray()`方法，并传递一个空数组作为参数。  <p> This detector looks for code that converts Collections to arrays using the toArray() method that takes a prototype array, passing an array argument which is zero-length. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InvalidJUnitTest">
    <Details>
<![CDATA[这个检测器寻找格式错误的JUnit测试。  <p> This detector looks for JUnit tests that are malformed. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BadlyOverriddenAdapter">
    <Details>
<![CDATA[这个检测器会查找扩展了Adapter类并用错误的签名重写了Listener方法的代码。  <p> This detector looks for code that extends an Adapter class and overrides a Listener method with the wrong signature. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BadResultSetAccess">
    <Details>
<![CDATA[这个检测器查找对结果集getXXX或setXXX方法的调用，其中字段索引为0。由于ResultSet中的字段从索引1开始，这总是错误的。  <p> This detector looks for calls to getXXX or setXXX methods of a result set where the field index is 0. As ResultSet fields start at index 1, this is always a mistake. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SuperfluousInstanceOf">
    <Details>
<![CDATA[这个检测器寻找使用instanceof运算符进行类型检查的地方，而这种确定可以静态完成。  <p> This detector looks for type checks using the instanceof operator where the determination can be done statically. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BadAppletConstructor">
    <Details>
<![CDATA[这个检测器会查找调用父Applet中依赖于Applet桩的方法的Applet构造函数。由于这个桩直到init方法执行前不久才会被初始化，因此这些方法会在构造函数中失败。  <p> This detector looks for Applet constructors that call methods in the parent Applet that rely on the Applet stub. Since this stub isn't initialized until just before the init() method, these methods will fail in the constructor. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SuspiciousThreadInterrupted">
    <Details>
<![CDATA[这个检测器会查找从非静态上下文调用Thread.interrupted()的情况。如果它是从Thread.currentThread().interrupted()中调用的，那么这只是一个无用的操作，直接使用Thread.interrupted()即可。然而，如果它在任意线程对象上调用，则大多数情况下是一个错误，因为always是在线程自身上调用interrupted()方法。  <p> This detector looks for calls to Thread.interrupted() from a non-static context. If it is called from Thread.currentThread().interrupted(), then it is just a useless exercise, just use Thread.interrupted(). However if it is called on an arbitrary thread object, it is most probably an error, as interrupted() is always called on the current thread. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSqlInjection">
    <Details>
<![CDATA[这个检测器使用数据流分析来查找在SQL语句中传入的参数不是常量字符串时对execute方法的调用。  <p> This detector uses data flow analysis to look for invocations of execute methods on SQL statements in which something other than a constant string is passed as an argument. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindDeadLocalStores">
    <Details>
<![CDATA[这个检测器会查找从未被后续代码读取的局部变量赋值。它是一个中等速度的检测器。  <p> This detector looks for assignments to local variables that are never subsequently read. It is a moderately fast detector. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindMaskedFields">
    <Details>
<![CDATA[这个检测器查找在方法中定义的局部字段掩盖了类级别字段的情况。  <p> This detector looks for class level fields that are masked by local fields defined in methods. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.WrongMapIterator">
    <Details>
<![CDATA[这个检测器查找通过键集迭代器获取的键来访问Map条目的值。  <p> This detector looks for accessing the value of a Map entry, using a key that was retrieved from a keySet iterator. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InstantiateStaticClass">
    <Details>
<![CDATA[这个检测器寻找基于只定义了静态方法的类来创建对象的代码。  <p> This detector looks for code that creates objects based on classes that only define static methods. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.RuntimeExceptionCapture">
    <Details>
<![CDATA[这个检测器寻找捕获Exception异常的catch子句，但该块中并没有抛出Exception异常的代码。  <p> This detector looks for catch clauses that catch Exception, when no code in the block throws Exception. </p>]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindFloatEquality">
    <Details>
<![CDATA[查找浮点等式表达式。快速检测器。  <p> Looks for floating point equality expressions. A fast detector. </p>]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnsatisfiedObligation">
    <Details>
<![CDATA[这个检测器会查找在方法的所有出口路径中未清理的I/O流和数据库资源。这是一个较慢的检测器。  <p>This detector looks for I/O streams and database resources that are not cleaned up on all paths out of a method.  This is a slow detector.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.UnnecessaryMath">
    <Details>
<![CDATA[这个检测器会查找调用java.lang.Math静态方法并对常量值进行操作的代码，其中结果值是静态已知的常量。直接使用常量而不是调用静态方法有时更快且更准确。  <p>This detector looks for code that calls java.lang.Math static methods on constant values, where the resultant value is a statically known constant. It is faster, and sometimes more accurate, to use the constant instead.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindCircularDependencies">
    <Details>
<![CDATA[这个检测器用于查找类之间的循环依赖关系。  <p>This detector looks for circular dependencies among classes. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.RedundantInterfaces">
    <Details>
<![CDATA[这个检测器寻找声明实现与其父类相同接口的类。如果父类实现了某个接口，那么子类也会继承并实现该接口，这是多余的。  <p>This detector looks for classes that declare they implement the same interface as a super class. This is redundant, if a superclass implements an interface, so does the subclass.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MultithreadedInstanceAccess">
    <Details>
<![CDATA[这个检测器用于查找实现Struts框架时可能出现的问题。  <p>This detector looks for potential problems in implementing the Struts framework. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.PublicSemaphores">
    <Details>
<![CDATA[这个检测器寻找公开类中使用synchronize并调用wait()、notify()或notifyAll()的方法。这将同步实现暴露为类的公共构件。类的客户端可能会将该类的一个实例用作其自身的同步对象，并导致基础实现出现混乱。  <p>This detector looks for public classes that synchronize and use wait(), notify() or notifyAll() on <b>this</b>. This exposes a synchronization implementation as a public artifact of the class. Clients of the class may use an instance of the class as its own synchronizing object, and cause havoc to the base implementation. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MethodReturnCheck">
    <Details>
<![CDATA[这个检测器会查找调用方法，其中返回值被可疑地忽略了。  <p> This detector looks for calls to methods where the return value is suspiciously ignored.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.IDivResultCastToDouble">
    <Details>
<![CDATA[这个检测器寻找将整数除法的结果转换为双精度浮点数的情况。通常，本意应该是将整数操作数转换为双精度浮点数后再进行除法运算。  <p> This detector looks for places where the result of integer division is cast to double. Often, what was meant was to cast the integer operands to double and then perform the division. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindBadCast2">
    <Details>
<![CDATA[这个检测器使用数据流分析寻找对象引用的不良铸型。  <p> This detector looks for bad casts of object references using data flow analysis. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNonSerializableStoreIntoSession">
    <Details>
<![CDATA[这个检测器会查找非序列化对象存储在HTTP会话中的情况。  <p> This detector looks for stores of non Serializable objects into HTTP sessions. </p>]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindUseOfNonSerializableValue">
    <Details>
<![CDATA[这个检测器会在需要序列化的上下文中查找非可序列化对象的使用情况。  <p> This detector looks for uses of non Serializable objects in contexts that require them to be serializable. </p>]]>
    </Details>
  </Detector>


  <Detector class="edu.umd.cs.findbugs.detect.FindNonSerializableValuePassedToWriteObject">
    <Details>
<![CDATA[这个检测器会在对象输出的writeObject方法中寻找非序列化对象。  <p> This detector looks for non Serializable objects passed to the writeObject method of an ObjectOutput. </p>]]>
    </Details>
  </Detector>



  <Detector class="edu.umd.cs.findbugs.detect.BadSyntaxForRegularExpression">
    <Details>
<![CDATA[这个检测器查找无效语法的正则表达式。  <p> This detector looks for regular expressions that have invalid syntax.  </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindPuzzlers">
    <Details>
<![CDATA[这个检测器寻找由约书亚·布洛和尼尔·加佛在《编程谜题》工作中提到的各类小错误。  <p> This detector looks for miscellaneous small errors mentioned by Joshua Bloch and Neal Gafter in their work on Programming Puzzlers.   </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSleepWithLockHeld">
    <Details>
      <![CDATA[这个检测器会在持有锁的情况下寻找对Thread.sleep()的调用。它是一个较慢的检测器。  <p>    This detector looks for calls to Thread.sleep() made with    a lock held.  It is a slow detector. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DuplicateBranches">
    <Details>
<![CDATA[这个检测器会查找包含if/else或switch语句的情况，如果两个分支的代码相同，则会使测试变得无效。这种情况通常是由复制粘贴两个分支引起的，导致一个分支的逻辑错误。  <p> This detector looks for if/else or switch statements that have the same code for two branches, thus rendering the test useless. This often is caused by copying and pasting the two branches, causing incorrect logic for the one branch.</p><p></p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InefficientMemberAccess">
    <Details>
<![CDATA[这个检测器寻找内部类写入拥有类的私有成员变量的情况。在这种情况下，需要使用特殊编译器生成的访问者方法来写入该变量。将可见性放宽到protected级别可以让字段可以直接被写入。  <p> This detector looks for internal classes that write to member variables of the owning class, when that member variable is private. In this case, a special compiler generated accessor method needs to be used to write to this variable. Relaxing the visibility to protected will allow the field to be directly written.</p> <p></p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.XMLFactoryBypass">
    <Details>
<![CDATA[这个检测器寻找对XML接口实现的直接分配。这将代码绑定到特定的实现，而不是使用提供的工厂模式来创建这些对象。  <p> This detector looks for direct allocations of implementations of XML interfaces. This ties the code to a specific implementation, rather than using the supplied factory pattern to create these objects.</p> <p></p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.UselessSubclassMethod">
    <Details>
      <![CDATA[这个检测器寻找在子类中实现由超类定义的方法，这些方法只是原封不动地传递参数给父类的方法。这些方法可以直接删除。  <p> This detector looks for subclasses that implement methods defined in the super class, that only pass the parameters untouched to the parent class method. These methods can just be removed. </p> <p></p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ConfusedInheritance">
    <Details>
      <![CDATA[这个检测器查找最终类中声明了protected成员的情况。由于该类不能被派生，因此成员的访问权限使用protected是不正确的。应将成员的访问权限更改为public或private以正确表示字段的意图。这可能是由于对该类使用方式的更改而引起的，但并未完全将整个类转换为新的范式。  <p> This detector looks for final classes that declare protected members. As this class can not be derived from, the use of protected access for members is incorrect. The access should be changed to public or private to represent the correct intention of the field. This was probably caused by a change in use for this class, without completely changing all of the class to the new paradigm. </p> <p></p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.QuestionableBooleanAssignment">
    <Details>
      <![CDATA[这个检测器会在条件表达式中查找将字面布尔值简单赋给变量的情况。  <p> This detector looks for simple assignments of literal boolean values to variables in conditional expressions. </p> <p></p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainNullReturnValues">
    <Details>
      <![CDATA[TrainNullReturnValues确定哪些方法可能返回null，并将这些信息保存到一个文件中。生成的文件可以在后续处理中使用，以提高空指针检测器的精度。由于这只是训练过程，因此不会报告任何警告。  
这个检测器运行速度较慢。  <p> TrainNullReturnValues determines which methods may return null and saves them to a file.  The resulting file may be used in a subsequent pass to improve the precision of the null-dereference detector. Since this is just a training pass, no warnings are reported. </p> <p> This is a slow detector. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainUnconditionalDerefParams">
    <Details>
      <![CDATA[<p> TrainUnconditionalParamDerefs 确定哪些方法可以无条件地解引用参数，并将它们保存到一个文件中。生成的文件可以在后续处理中使用，以提高空指针解引用检测器的精度。由于这只是训练过程，因此不会报告任何警告。</p>
<p> 这是一个速度较慢的检测器。</p>  <p> TrainUnconditionalParamDerefs determines which methods may unconditionally dereference parameters and saves them to a file. The resulting file may be used in a subsequent pass to improve the precision of the null-dereference detector. Since this is just a training pass, no warnings are reported. </p> <p> This is a slow detector. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainFieldStoreTypes">
    <Details>
      <![CDATA[<p>TrainFieldStoreTypes分析存储在字段中的类型，并将它们存储到数据库中。该数据库可能在后续处理中用于使类型分析更加精确。</p>
<p>这是一个较慢的检测器。</p>  <p> TrainFieldStoreTypes analyzes the types stored into fields and stores them to a database.  The database may be used in a later pass to make type analysis more precise. </p> <p> This is a slow detector. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainNonNullAnnotations">
    <Details>
      <![CDATA[TrainNonNullAnnotations 收集 @Nonnull 和 @PossiblyNull 注解，并将其存储到数据库文件中。这是一个快速检测器。  <p> TrainNonNullAnnotations collects @Nonnull and @PossiblyNull annotations and stores them to database files.  This is a fast detector. </p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckCalls">
    <Details>
      <![CDATA[这个检测器仅用于调试SpotBugs的方法调用解析，请不要启用它。  <p>This detector is just for debugging method call resolution in SpotBugs. Don't enable it.</p>]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindBugsSummaryStats">
    <Details>
<![CDATA[这个检测器只是收集分析过程的汇总统计信息。  <p> This detector just collects summary statistics information about the analysis process. </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestASM">
    <Details>
    <![CDATA[这个检测器是一个代码示例，展示了如何使用ASM字节码分析框架编写一个SpotBugs检测器。  <p>     This detector is a code example showing how to write a SpotBugs     detector using the ASM bytecode analysis framework.     </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnrelatedTypesInGenericContainer">
    <Details>
    <![CDATA[这个检测器会检查调用泛型集合方法时传入的`java.lang.Object`参数，看看该参数的类型是否与集合的参数相关。如果参数的类类型与其不相关，则该参数永远不会在集合中出现。例如，如果`foo`是`List<String>`而`bar`是`StringBuffer`，那么调用`foo.contains(bar)`总是会返回false。这是一个快速的检测器。  <p> This detector looks at the arguments of calls to generic     collection methods that receive a <code>java.lang.Object</code>     to see if the argument's type is related to the collection's     parameter. Arguments with unrelated class types are never going     to be in the collection. For example, if <code>foo</code> is a     <code>List&lt;String&gt;</code> and <code>bar</code> is a     <code>StringBuffer</code>, the call <code>foo.contains(bar)</code>     will always return false. This is a fast detector.     </p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.StaticCalendarDetector">
    <Details>
<![CDATA[这个检测器会警告关于类型为java.util.Calendar或java.text.DateFormat（及其子类）的静态字段，因为Calendars本质上不适合多线程使用。  <p>This detector warns about static fields of type java.util.Calendar or java.text.DateFormat (and subclasses) because  Calendars are inherently unsafe for multithreaded use. </p>]]>
</Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestDataflowAnalysis">
    <Details>
      <![CDATA[这是一个内部检测器，仅用于测试数据流分析。它默认是不启用的。  <p>This is an internal detector used only for testing dataflow analyses.     It is not enabled by default.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckTypeQualifiers">
    <Details>
      <![CDATA[检查由JSR-305类型注解指定的属性违规情况。  <p>Check for violations of properties specified by JSR-305   type qualifier annotations.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.AppendingToAnObjectOutputStream">
    <Details>
      <![CDATA[<p>查找向对象输出流追加的尝试。</p>  <p>Looks for an attempt to append to an object output stream.</p>]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckExpectedWarnings">
    <Details>
          <![CDATA[检查@ExpectedWarning和@NoWarning注解。此检测器仅用于测试SpotBugs。  <p>Checks @ExpectedWarning and @NoWarning annotations.     This detector is used only for testing SpotBugs.</p>]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DontIgnoreResultOfPutIfAbsent">
    <Details>
          <![CDATA[检查如果将putIfAbsent的结果忽略，那么作为第二个参数传递的值不会被重复使用。  <p>Checks that if the result of putIfAbsent is ignored, the value passed as the second argument is not reused. </p>]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ReadOfInstanceFieldInMethodInvokedByConstructorInSuperclass">
    <Details>
          <![CDATA[检查从超类构造函数中调用的方法。  <p>Checks for methods invoked from constructors for superclasses.  </p>]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DefaultEncodingDetector">
    <Details>
<![CDATA[检查调用了将字节转换为字符串（或字符串转换为字节）的方法，这些方法使用的是用户的默认平台编码。这可能导致应用程序在不同平台上表现出不同的行为。  <p> Checks for calls to methods which perform a byte to String (or String to byte) conversion using the user's default  platform encoding. This can cause the application behaviour to vary between platforms.  </p>]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckRelaxingNullnessAnnotation">
    <Details>
      <![CDATA[检查重写的方法不要放松@Nonnull（改为@CheckForNull）的返回值或@CheckForNull（改为@Nonnull）的参数。  <p>Checks that overriding methods do not relax @Nonnull (made @CheckForNull) on return values   or @CheckForNull (made @Nonnull) on parameters.</p>]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DontAssertInstanceofInTests">
    <Details>
      <![CDATA[<p>JUnit测试中用于检测对象类型是否通过assertInstanceof操作符进行检查的模式检测器。</p>
<p>应避免使用这种方式，因为不正确的类型转换可能会引发ClassCastException，提供的错误原因信息可能比assertInstanceof操作符结果产生的“false is not true”消息更详细。</p>
<p>这是一个快速检测器。</p>  <p>Detector for patterns in JUnit tests where the type of an object    is checked by asserting the instanceof operator.</p> <p>    This should be avoided as the ClassCastException that would result    from an improper cast may provide more information regarding the    cause of the error than a "false is not true" message which would    result from asserting the result of the instanceof operator. </p>    <p>It is a fast detector</p>]]>
    </Details>
  </Detector>
  <!--
  **********************************************************************
  BugPatterns
  **********************************************************************
   -->

  <BugPattern type="JUA_DONT_ASSERT_INSTANCEOF_IN_TESTS">
    <ShortDescription>在测试中断言instanceof的值不被推荐。  Asserting value of instanceof in tests is not recommended.</ShortDescription>
    <LongDescription>在{3}处声明类型为{0}的信息可能会掩盖掉有关为何会发生类型转换失败的有用信息。</LongDescription>
    <Details>
      <![CDATA[断言类型检查在测试中不推荐使用，因为类转换异常信息可能比`instanceof`断言更能说明为什么使用了错误类型的实例。当调试因不良转换而失败的测试时，观察由此引发的`ClassCastException`输出可能会提供更多关于实际遇到类型的有用信息。而在转换前进行类型断言则会得到一个不那么有信息量的`"false is not true"`消息。

如果使用JUnit和hamcrest，可以改用hamcrest提供的<code>IsInstanceOf</code>类。]]>
    </Details>
  </BugPattern>

  <BugPattern type="OVERRIDING_METHODS_MUST_INVOKE_SUPER">
    <ShortDescription>super方法被标注了@OverridingMethodsMustInvokeSuper注解，但覆盖的方法并未调用超类方法。  Super method is annotated with @OverridingMethodsMustInvokeSuper, but the overriding method isn't calling the super method.</ShortDescription>
    <LongDescription>超类方法被标注了@OverridingMethodsMustInvokeSuper，但{1}并没有调用超类方法。</LongDescription>
    <Details>
      <![CDATA[<p>该超类方法被标注了@OverridingMethodsMustInvokeSuper注解，但覆盖方法并没有调用super方法。</p>]]>
    </Details>  </BugPattern>
  <BugPattern type="CNT_ROUGH_CONSTANT_VALUE">
    <ShortDescription>已知常数的粗略值找到  Rough value of known constant found</ShortDescription>
    <LongDescription>找到近似值：{2}</LongDescription>
    <Details>
      <![CDATA[建议使用预定义的库常量以提高代码清晰度和精度。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SKIPPED_CLASS_TOO_BIG">
    <ShortDescription>分析的类太大了  Class too big for analysis</ShortDescription>
    <LongDescription>{0} 对分析来说太大了</LongDescription>
    <Details>
      <![CDATA[这个类太大了，无法有效处理，并且没有完全分析错误。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NOISE_NULL_DEREFERENCE">
    <ShortDescription>虚假的空指针解引用警告  Bogus warning about a null pointer dereference</ShortDescription>
    <LongDescription>关于空指针解引用的虚假警告在{1}</LongDescription>
    <Details>
      <![CDATA[虚假警告。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NOISE_METHOD_CALL">
    <ShortDescription>关于方法调用的虚假警告  Bogus warning about a method call</ShortDescription>
    <LongDescription>在{1}中关于方法调用{2}的虚假警告</LongDescription>
    <Details>
      <![CDATA[虚假警告。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NOISE_FIELD_REFERENCE">
    <ShortDescription>虚假的字段引用警告  Bogus warning about a field reference</ShortDescription>
    <LongDescription>关于{1}中引用{2}的虚假警告</LongDescription>
    <Details>
      <![CDATA[虚假警告。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NOISE_OPERATION">
    <ShortDescription>虚假操作警告  Bogus warning about an operation</ShortDescription>
    <LongDescription>关于操作{1}的虚假警告</LongDescription>
    <Details>
      <![CDATA[虚假警告。]]>
    </Details>
  </BugPattern>
    <BugPattern type="DMI_BIGDECIMAL_CONSTRUCTED_FROM_DOUBLE">
        <ShortDescription>从double构造的BigDecimal，但double不能精确表示  BigDecimal constructed from double that isn't represented precisely</ShortDescription>
        <LongDescription>由{1}构造的BigDecimal来自{4}</LongDescription>
        <Details>
      <![CDATA[这段代码从一个不能很好地转换为十进制数的double值创建一个BigDecimal。例如，人们可能会认为在Java中写new BigDecimal(0.1)会创建一个等于0.1（未缩放值为1，比例为1）的BigDecimal，但实际上它等于0.1000000000000000055511151231257827021181583404541015625。你可能希望使用BigDecimal.valueOf(double d)方法，该方法使用double的字符串表示来创建BigDecimal（例如，BigDecimal.valueOf(0.1)给出的是0.1）。]]>
    </Details>
    </BugPattern>

    <BugPattern type="DMI_DOH">
        <ShortDescription>哦豁！一个无意义的方法调用  D'oh! A nonsensical method invocation</ShortDescription>
        <LongDescription>啊哦！在{1}中无意义地调用了{2.nameAndSignature}</LongDescription>
        <Details>
      <![CDATA[这个部分的方法调用没有意义，原因通过检查就能明显看出。]]>
    </Details>
    </BugPattern>

  <BugPattern type="DMI_VACUOUS_CALL_TO_EASYMOCK_METHOD">
    <ShortDescription>无用/空洞的EasyMock方法调用  Useless/vacuous call to EasyMock method</ShortDescription>
    <LongDescription>在{1}中对{2}进行的空洞/无用调用</LongDescription>
    <Details>
      <![CDATA[这个调用没有向EasyMock方法传递任何对象，所以该调用什么也不做。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_SCHEDULED_THREAD_POOL_EXECUTOR_WITH_ZERO_CORE_THREADS">
    <ShortDescription>创建核心线程数为零的ScheduledThreadPoolExecutor  Creation of ScheduledThreadPoolExecutor with zero core threads</ShortDescription>
    <LongDescription>在{1}中创建核心线程数为零的ScheduledThreadPoolExecutor</LongDescription>
    <Details>
      <![CDATA[(Javadoc) 一个核心线程数为零的ScheduledThreadPoolExecutor 将不会执行任何任务；对最大线程池大小的更改将被忽略。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_FUTILE_ATTEMPT_TO_CHANGE_MAXPOOL_SIZE_OF_SCHEDULED_THREAD_POOL_EXECUTOR">
    <ShortDescription>试图更改ScheduledThreadPoolExecutor的最大池大小是徒劳的尝试  Futile attempt to change max pool size of ScheduledThreadPoolExecutor</ShortDescription>
    <LongDescription>试图在{1}中更改ScheduledThreadPoolExecutor的最大池大小无济于事</LongDescription>
    <Details>
      <![CDATA[（来自Javadoc）虽然ScheduledThreadPoolExecutor继承自ThreadPoolExecutor，但其中一些继承来的调优方法对其并不适用。特别是，由于它作为一个固定大小的线程池使用corePoolSize个线程和一个无界队列工作，因此对maximumPoolSize的调整没有任何有用的效果。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_UNSUPPORTED_METHOD">
    <ShortDescription>调用不支持的方法  Call to unsupported method</ShortDescription>
    <LongDescription>在{1}中调用了不支持的方法{2}</LongDescription>
    <Details>
      <![CDATA[所有对此方法调用的目标都会抛出一个UnsupportedOperationException。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_EMPTY_DB_PASSWORD">
    <ShortDescription>空的数据库密码  Empty database password</ShortDescription>
    <LongDescription>在{1}中数据库密码为空</LongDescription>
    <Details>
      <![CDATA[这段代码使用空密码创建数据库连接，这表明该数据库没有设置密码进行保护。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_CONSTANT_DB_PASSWORD">
    <ShortDescription>硬编码的常量数据库密码  Hardcoded constant database password</ShortDescription>
    <LongDescription>在{1}中硬编码了数据库密码</LongDescription>
    <Details>
      <![CDATA[这段代码使用硬编码的常量密码创建数据库连接。任何获得源代码或编译后代码访问权限的人都可以轻松得知密码。]]>
    </Details>
  </BugPattern>
  <BugPattern type="HRS_REQUEST_PARAMETER_TO_COOKIE">
    <ShortDescription>来自不受信任输入的HTTPcookie  HTTP cookie formed from untrusted input</ShortDescription>
    <LongDescription>来自不受信任输入{1}的HTTP_cookie</LongDescription>
    <Details>
      <![CDATA[这段代码使用了不可信的HTTP参数构造了一个HTTP Cookie。如果将这个Cookie添加到HTTP响应中，将会导致HTTP响应拆分漏洞。更多详情请参见[http://en.wikipedia.org/wiki/HTTP_response_splitting]。

SpotBugs 只会查找最明显的HTTP响应拆分案例。如果SpotBugs发现了任何此类情况，你几乎肯定还有其他未被报告的漏洞。如果你担心HTTP响应拆分问题，你应该考虑使用商业静态分析或渗透测试工具来认真检查。]]>
    </Details>
  </BugPattern>
  <BugPattern type="HRS_REQUEST_PARAMETER_TO_HTTP_HEADER">
    <ShortDescription>HTTP响应拆分漏洞  HTTP Response splitting vulnerability</ShortDescription>
    <LongDescription>在{1}中，HTTP参数直接写入HTTP头部输出</LongDescription>
    <Details>
            <![CDATA[这段代码直接将HTTP参数写入HTTP标头，这允许发生HTTP响应拆分漏洞。更多信息，请参阅[http://en.wikipedia.org/wiki/HTTP_response_splitting]。

SpotBugs 只查找最明显、最直接的HTTP响应拆分案例。如果 SpotBugs 发现了任何此类情况，你几乎可以肯定还有其他未被报告的漏洞。如果你担心HTTP响应拆分问题，你应该认真考虑使用商业静态分析或渗透测试工具。]]>
        </Details>
  </BugPattern>



  <BugPattern type="PT_RELATIVE_PATH_TRAVERSAL">
    <ShortDescription>相对路径遍历在Servlet中  Relative path traversal in servlet</ShortDescription>
    <LongDescription>相对路径遍历在{1}</LongDescription>
    <Details>
<![CDATA[该软件使用HTTP请求参数构造路径名，应位于一个受限目录内，但并未妥善中和诸如 ".." 这样的序列，这些序列可能导致位置超出该目录。有关更多信息，请参阅 [http://cwe.mitre.org/data/definitions/23.html](http://cwe.mitre.org/data/definitions/23.html)。

SpotBugs 只查找最明显、最容易发现的相对路径遍历情况。如果 SpotBugs 发现了任何此类情况，你很可能还有其他未被报告的漏洞。如果你关心相对路径遍历问题，你应该认真考虑使用商业静态代码分析工具或渗透测试工具。]]>
    </Details>
  </BugPattern>
  <BugPattern type="PT_ABSOLUTE_PATH_TRAVERSAL">
    <ShortDescription>在Servlet中的绝对路径遍历  Absolute path traversal in servlet</ShortDescription>
    <LongDescription>在{1}中进行绝对路径遍历</LongDescription>
    <Details>
<![CDATA[该软件使用HTTP请求参数构建路径名称，理论上应位于受限目录内，但未能妥善中和如“/abs/path”这样的绝对路径序列，这些路径可能解析到超出该目录的位置。有关更多信息，请参阅[http://cwe.mitre.org/data/definitions/36.html](http://cwe.mitre.org/data/definitions/36.html)。

SpotBugs仅查找最明显的绝对路径遍历案例。如果SpotBugs发现了任何此类情况，你几乎可以确定还有更多未被报告的漏洞。如果你担心绝对路径遍历问题，你应该考虑使用商业静态分析或渗透测试工具进行更深入的安全检查。]]>
    </Details>
  </BugPattern>

  <BugPattern type="XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER">
    <ShortDescription>Servlet反射跨站脚本漏洞  Servlet reflected cross site scripting vulnerability</ShortDescription>
    <LongDescription>在{1}中，HTTP参数被写入Servlet输出</LongDescription>
    <Details>
<![CDATA[这段代码直接将HTTP参数写入Servlet输出，这允许发生反射型跨站脚本漏洞。更多信息请参见[跨站脚本](http://en.wikipedia.org/wiki/Cross-site_scripting)。

SpotBugs 只查找最明显、最明显的跨站脚本案例。如果 SpotBugs 发现了任何这样的情况，你几乎可以肯定还有其他未被报告的跨站脚本漏洞。如果你担心跨站脚本问题，你应该认真考虑使用商业静态分析或渗透测试工具。]]>
    </Details>
  </BugPattern>


  <BugPattern type="XSS_REQUEST_PARAMETER_TO_SEND_ERROR">
    <ShortDescription>在错误页面中反射型跨站脚本漏洞  Servlet reflected cross site scripting vulnerability in error page</ShortDescription>
    <LongDescription>在{1}中，HTTP参数被写入Servlet错误页面</LongDescription>
    <Details>
<![CDATA[这段代码直接将HTTP参数写入服务器错误页面（使用HttpServletResponse.sendError）。回显这种不可信的输入会导致反射型跨站脚本漏洞。有关更多信息，请参阅[http://en.wikipedia.org/wiki/Cross-site_scripting]。

SpotBugs 只查找最明显的跨站脚本漏洞案例。如果 SpotBugs 发现了任何这类问题，你几乎可以肯定还有其他跨站脚本漏洞而 SpotBugs 并未报告。如果你担心跨站脚本攻击，你应该认真考虑使用商业静态代码分析或渗透测试工具。]]>
    </Details>
  </BugPattern>
  <BugPattern type="XSS_REQUEST_PARAMETER_TO_JSP_WRITER">
    <ShortDescription>JSP反射跨站脚本漏洞  JSP reflected cross site scripting vulnerability</ShortDescription>
    <LongDescription>HTTP参数直接写入JSP输出，导致在{1.class}中存在反射型XSS漏洞</LongDescription>
    <Details>
<![CDATA[这段代码直接将HTTP参数写入JSP输出，这允许跨站脚本漏洞。更多信息请参阅[跨站脚本](http://en.wikipedia.org/wiki/Cross-site_scripting)。

SpotBugs 只寻找最明显、最直观的跨站脚本案例。如果 SpotBugs 发现了任何这种情况，你几乎可以肯定还有其他未被报告的跨站脚本漏洞。如果你担心跨站脚本问题，你应该认真考虑使用商业静态分析或渗透测试工具。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SW_SWING_METHODS_INVOKED_IN_SWING_THREAD">
    <ShortDescription>某些swing方法需要在swing线程中调用  Certain swing methods needs to be invoked in Swing thread</ShortDescription>
    <LongDescription>在 `{1}` 中需要调用摆动方法，这需要在Swing事件线程中进行。</LongDescription>
    <Details>
<![CDATA[（来自JDC技术提示）：Swing方法`show()`、`setVisible()`和`pack()`会为框架创建相应的同级。在创建同级的同时，系统还会创建事件分派线程。这使得情况变得复杂，因为事件分派线程可能会在`pack`和`validate`处理过程中通知监听器。这种情况可能导致两个线程同时遍历Swing基于组件的GUI界面——这是一个严重的缺陷，可能会导致死锁或其他相关线程问题。调用`pack`会使得组件被实现。当它们正在被实现（即不一定可见）时，可能会在事件分派线程上触发监听器通知。]]>
    </Details>
  </BugPattern>
  <BugPattern type="IL_INFINITE_LOOP">
    <ShortDescription>一个明显的无限循环  An apparent infinite loop</ShortDescription>
    <LongDescription>在{1}中有明显的无限循环。</LongDescription>
    <Details>
<![CDATA[这个循环似乎没有终止的方式（除了可能抛出异常外）。]]>
    </Details>
  </BugPattern>
  <BugPattern type="IL_INFINITE_RECURSIVE_LOOP">
    <ShortDescription>一个明显的无限递归循环  An apparent infinite recursive loop</ShortDescription>
    <LongDescription>在{1}中有一个明显的无限递归循环。</LongDescription>
    <Details>
<![CDATA[这种方法无条件地调用自身。这似乎表明会出现无限递归循环，最终导致栈溢出。]]>
    </Details>
  </BugPattern>
  <BugPattern type="IL_CONTAINER_ADDED_TO_ITSELF">
    <ShortDescription>一个集合被添加到它自己上  A collection is added to itself</ShortDescription>
    <LongDescription>一个集合被添加到它自己在{1}</LongDescription>
    <Details>
<![CDATA[一个集合被添加到自身中。因此，计算这个集合的hashCode将会抛出StackOverflowException异常。]]>
    </Details>
  </BugPattern>
  <BugPattern type="VO_VOLATILE_REFERENCE_TO_ARRAY">
    <ShortDescription>一个易变引用指向的数组不会将数组元素视为易变的。  A volatile reference to an array doesn't treat the array elements as volatile</ShortDescription>
    <LongDescription>{1} 是一个易失性引用指向一个数组；数组元素是非易失性的。</LongDescription>
    <Details>
<![CDATA[这声明了一个对数组的volatile引用，这可能不是你想要的效果。带有volatile引用的数组，对该引用的读写会被视为volatile操作，但数组元素本身是非volatile的。如果你想让数组元素也具有volatile特性，你需要使用Java.util.concurrent中的原子数组类（从Java 5.0开始提供）。]]>
    </Details>
  </BugPattern>
  <BugPattern type="VO_VOLATILE_INCREMENT">
    <ShortDescription>对易变字段的增量操作不是原子性的  An increment to a volatile field isn't atomic</ShortDescription>
    <LongDescription>在{1}中增量更新可变字段{2}</LongDescription>
    <Details>
<![CDATA[这段代码会递增一个易变字段。易变字段的递增操作不是原子性的。如果有多个线程同时递增该字段，可能会丢失某些递增操作。]]>
    </Details>
  </BugPattern>
  <BugPattern type="UI_INHERITANCE_UNSAFE_GETRESOURCE">
    <ShortDescription>使用GetResource可能不安全，如果类被扩展了。  Usage of GetResource may be unsafe if class is extended</ShortDescription>
    <LongDescription>在{1}中使用GetResource可能不安全，如果该类被扩展了。</LongDescription>
    <Details>
<![CDATA[调用 `this.getClass().getResource(...)` 可能不会得到预期的结果，特别是如果该类被另一个包中的类扩展时。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_BOOLEAN_RETURN_NULL">
    <ShortDescription>方法带有布尔返回类型，但显式返回了null  Method with Boolean return type returns explicit null</ShortDescription>
    <LongDescription>{1} 有布尔返回类型，并且明确返回空值</LongDescription>
    <Details>
       <![CDATA[一个返回Boolean.TRUE、Boolean.FALSE或null的方法是一个事故等待发生的例子。这个方法可以像返回boolean类型值一样被调用，编译器会自动将Boolean值拆箱。如果返回null值，这将会导致NullPointerException。]]>
       </Details>
  </BugPattern>
  <BugPattern type="NP_OPTIONAL_RETURN_NULL">
    <ShortDescription>方法带有可选返回类型，显式返回null  Method with Optional return type returns explicit null</ShortDescription>
    <LongDescription>{1} 有可选的返回类型，并显式返回null</LongDescription>
    <Details>
       <![CDATA[Optional返回类型（java.util.Optional或com.google.common.base.Optional）的使用总是意味着设计上不希望显式返回null值。在这种情况下返回null值会违反契约，并很可能会破坏客户端代码。]]>
       </Details>
  </BugPattern>
  <BugPattern type="NP_NONNULL_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR">
    <ShortDescription>非空字段未初始化  Non-null field is not initialized</ShortDescription>
    <LongDescription>非空字段 {2.name} 未被 {1} 初始化</LongDescription>
    <Details>
       <![CDATA[该字段被标记为非空，但构造函数并未写入。该字段可能在构造函数的其他地方进行了初始化，或者总是在使用前进行初始化。]]>
       </Details>
  </BugPattern>
  <BugPattern type="NP_SYNC_AND_NULL_CHECK_FIELD">
    <ShortDescription>在同一字段上进行同步和空值检查。  Synchronize and null check on the same field.</ShortDescription>
    <LongDescription>在{1}中，字段{2.givenClass}会被同步检查是否为空。</LongDescription>
    <Details>
<![CDATA[由于该字段已同步，似乎不太可能为空。如果它是空的并随后进行同步，则会抛出NullPointerException，而这种检查就没有意义了。最好同步另一个字段。]]>
     </Details>
  </BugPattern>
  <BugPattern type="RpC_REPEATED_CONDITIONAL_TEST">
    <ShortDescription>重复的条件测试  Repeated conditional tests</ShortDescription>
    <LongDescription>在{1}中重复条件测试</LongDescription>
    <Details>
<![CDATA[代码中包含一个条件测试被连续进行了两次（例如，`x == 0 || x == 0`）。也许第二次出现的是其他内容（例如，`x == 0 || y == 0`）。]]>
    </Details>
  </BugPattern>
  <BugPattern type="TESTING">
    <ShortDescription>测试  Testing</ShortDescription>
    <LongDescription>测试警告生成在{1}</LongDescription>
    <Details>
<![CDATA[这个错误模式只有由新的、未完全实现的bug检测器生成。]]>
    </Details>
  </BugPattern>
  <BugPattern type="TESTING1">
    <ShortDescription>测试 1  Testing 1</ShortDescription>
    <LongDescription>在{1}生成了测试警告1</LongDescription>
    <Details>
<![CDATA[这个bug模式仅由新的、不完全实现的bug检测器生成。]]>
    </Details>
  </BugPattern>
  <BugPattern type="TESTING2">
    <ShortDescription>测试 2  Testing 2</ShortDescription>
    <LongDescription>在{1}生成了测试警告2</LongDescription>
    <Details>
<![CDATA[这个错误模式只由新的、不完全实现的bug检测器生成。]]>
    </Details>
  </BugPattern>
  <BugPattern type="TESTING3">
    <ShortDescription>测试 3  Testing 3</ShortDescription>
    <LongDescription>在{1}生成了测试警告3</LongDescription>
    <Details>
<![CDATA[这个错误模式仅由新开发的、未完全实现的Bug检测器生成。]]>
    </Details>
  </BugPattern>
  <BugPattern type="UNKNOWN">
    <ShortDescription>未知的bug模式  Unknown bug pattern</ShortDescription>
    <LongDescription>未知的错误模式BUG_PATTERN 在 {1} 中</LongDescription>
    <Details>
<![CDATA[记录了一个警告，但SpotBugs无法找到该错误模式的描述因此也无法对其进行说明。这种情况仅应在SpotBugs本身或其配置存在 Bug、或者分析是通过一个当前未加载的插件生成的情况下出现。]]>
    </Details>
  </BugPattern>
  <BugPattern type="AM_CREATES_EMPTY_ZIP_FILE_ENTRY">
    <ShortDescription>创建一个空的zip文件条目  Creates an empty zip file entry</ShortDescription>
    <LongDescription>在{1}中创建了空的zip文件条目</LongDescription>
    <Details>
<![CDATA[代码调用了`putNextEntry()`，紧接着调用了`closeEntry()`。这会导致一个空的Zip文件条目。应该在调用`putNextEntry()`和`closeEntry()`之间向Zip文件写入条目的内容。]]>
    </Details>
  </BugPattern>
  <BugPattern type="AM_CREATES_EMPTY_JAR_FILE_ENTRY">
    <ShortDescription>创建一个空的jar文件条目  Creates an empty jar file entry</ShortDescription>
    <LongDescription>在{1}创建了空的jar文件条目</LongDescription>
    <Details>
<![CDATA[代码调用了`putNextEntry()`，紧接着立即调用了`closeEntry()`。这会导致一个空的Jar文件条目。应在`putNextEntry()`和`closeEntry()`之间写入条目的内容。]]>
    </Details>
  </BugPattern>
  <BugPattern type="IMSE_DONT_CATCH_IMSE">
    <ShortDescription>可疑的捕获IllegalMonitorStateException  Dubious catching of IllegalMonitorStateException</ShortDescription>
    <LongDescription>在{1}中捕获IllegalMonitorStateException存疑</LongDescription>
    <Details>
<![CDATA[非法监视状态异常一般只会在你的代码设计缺陷的情况下抛出（例如，在你不持有锁的对象上调用wait或notify方法时）。]]>
    </Details>
  </BugPattern>
  <BugPattern type="FL_MATH_USING_FLOAT_PRECISION">
    <ShortDescription>方法使用浮点精度进行数学计算  Method performs math using floating point precision</ShortDescription>
    <LongDescription>{1} 使用浮点精度进行数学运算</LongDescription>
    <Details>
<![CDATA[该方法使用浮点精度进行数学运算。浮点精度非常不精确。例如，16777216.0f + 1.0f = 16777216.0f。建议使用双精度数学运算代替。]]>
    </Details>
  </BugPattern>
  <BugPattern type="CAA_COVARIANT_ARRAY_FIELD">
    <ShortDescription>协变数组分配给一个字段  Covariant array assignment to a field</ShortDescription>
    <LongDescription>类型为{2}的数组被分配给类型为{3}的字段</LongDescription>
    <Details>
<![CDATA[协变数组类型被分配给一个字段。这可能会导致混淆，并且如果稍后在该数组中存储其他类型的引用（如以下代码所示），会在运行时引发ArrayStoreException：

```java
Number[] arr = new Integer[10]; 
arr[0] = 1.0;
```

考虑更改创建的数组类型或字段类型。]]>
    </Details>
  </BugPattern>
  <BugPattern type="CAA_COVARIANT_ARRAY_LOCAL">
    <ShortDescription>共变数组赋值给局部变量  Covariant array assignment to a local variable</ShortDescription>
    <LongDescription>数组类型为{2}被分配给类型为{3}的变量</LongDescription>
    <Details>
<![CDATA[协变数组类型被赋值给一个局部变量。这可能会导致混淆，并且如果稍后在该数组中存储其他类型的引用（如以下代码所示），会在运行时引发ArrayStoreException：

```java
Number[] arr = new Integer[10]; 
arr[0] = 1.0;
```

考虑更改创建的数组类型或局部变量的类型。]]>
    </Details>
  </BugPattern>
  <BugPattern type="CAA_COVARIANT_ARRAY_RETURN">
    <ShortDescription>协变数组是从方法中返回的  Covariant array is returned from the method</ShortDescription>
    <LongDescription>数组类型为{2}的数组是由返回类型为{3}的方法返回的</LongDescription>
    <Details>
<![CDATA[<p>协变类型数组是从方法中返回的。这可能会导致混淆，并且如果调用代码尝试将其他类型的引用存储在返回的数组中，可能会在运行时引发ArrayStoreException。</p>
<p>考虑更改创建的数组类型或方法的返回类型。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CAA_COVARIANT_ARRAY_ELEMENT_STORE">
    <ShortDescription>可能不兼容的元素存储在协变数组中  Possibly incompatible element is stored in covariant array</ShortDescription>
    <LongDescription>值的类型为{2}被存储到元素类型为{3}的数组中</LongDescription>
    <Details>
<![CDATA[值被存储到数组中，但值的类型与数组类型不符。分析表明实际数组类型比其变量或字段声明的类型更窄，这种赋值不满足原始数组类型的要求。此赋值可能在运行时导致ArrayStoreException。]]>
    </Details>
  </BugPattern>
  <BugPattern type="CN_IDIOM">
    <ShortDescription>类实现了Cloneable接口，但并未定义或使用clone方法。  Class implements Cloneable but does not define or use clone method</ShortDescription>
    <LongDescription>类 {0} 实现了 Cloneable 但未定义或使用 clone 方法</LongDescription>
    <Details>
<![CDATA[类实现了Cloneable接口，但未定义或使用clone方法。]]>
    </Details>
  </BugPattern>
  <BugPattern type="CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE">
    <ShortDescription>类定义了clone() 但未实现Cloneable接口  Class defines clone() but doesn't implement Cloneable</ShortDescription>
    <LongDescription>{0}定义了clone()方法但没有实现Cloneable接口</LongDescription>
    <Details>
<![CDATA[这个类定义了一个 `clone()` 方法，但该类并没有实现 `Cloneable`。在某些情况下这样做是可以的（例如，你希望控制子类如何克隆自己），但一定要确保这是你的意图。]]>
    </Details>
  </BugPattern>
  <BugPattern type="CN_IDIOM_NO_SUPER_CALL">
    <ShortDescription>克隆方法没有调用super.clone()  clone method does not call super.clone()</ShortDescription>
    <LongDescription>{1} 没有调用super.clone()</LongDescription>
    <Details>
<![CDATA[这个非最终类定义了一个 `clone()` 方法，该方法没有调用 `super.clone()`。如果该类（记作 `<A>`）被子类（记作 `<B>`）继承，并且子类 `<B>` 调用了 `super.clone()`，那么 `<B>` 的 `clone()` 方法很可能会返回一个类型为 `<A>` 的对象，这违反了 `clone()` 标准合约。

如果所有 `clone()` 方法都调用 `super.clone()`，则可以确保它们使用 `Object.clone()`，而 `Object.clone()` 总是会返回正确类型的对象。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_FUTURE_KEYWORD_USED_AS_IDENTIFIER">
    <ShortDescription>在较新的Java版本中使用关键字作为标识符  Use of identifier that is a keyword in later versions of Java</ShortDescription>
    <LongDescription>{1} 使用了 {2} 作为变量名，在后来版本的 Java 中 {2} 是一个关键字</LongDescription>
    <Details>
<![CDATA[标识符是Java后期版本中保留的关键字，在后续版本的Java中，您的代码需要进行更改以使其能够编译。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_FUTURE_KEYWORD_USED_AS_MEMBER_IDENTIFIER">
    <ShortDescription>在较新的Java版本中使用关键字作为标识符  Use of identifier that is a keyword in later versions of Java</ShortDescription>
    <LongDescription>{1} 与较新版本Java中的一个关键字冲突</LongDescription>
    <Details>
<![CDATA[这个标识符在Java的较新版本中被用作关键字。此代码以及任何引用该API的代码都需要进行修改，以便在较新版本的Java中编译。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DE_MIGHT_DROP">
    <ShortDescription>方法可能会抛出异常  Method might drop exception</ShortDescription>
    <LongDescription>{1}可能会掉出{2}</LongDescription>
    <Details>
<![CDATA[这种方法可能会抛出异常。一般来说，异常应该以某种方式处理或报告，或者应该从方法中抛出。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DE_MIGHT_IGNORE">
    <ShortDescription>方法可能会忽略异常  Method might ignore exception</ShortDescription>
    <LongDescription>{1}可能会忽略{2}</LongDescription>
    <Details>
<![CDATA[这个方法可能会忽略异常。一般来说，异常应该以某种方式处理或报告，或者从方法中抛出。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DP_DO_INSIDE_DO_PRIVILEGED">
    <ShortDescription>应该只在doPrivileged块中调用的方法在此处被调用  Method invoked that should be only be invoked inside a doPrivileged block</ShortDescription>
    <LongDescription>在{1}中调用了应当在doPrivileged块内调用的{2}</LongDescription>
    <Details>
<![CDATA[这段代码调用了一个需要进行安全权限检查的方法。如果这段代码会被授予安全权限，但可能被未获得安全权限的代码调用，则该调用需要发生在`doPrivileged`块内。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DP_DO_INSIDE_DO_PRIVILEDGED"> <!-- misspelled for backward compatibility -->
    <ShortDescription>应该只在`doPrivileged`块中调用的方法在此处被调用。  Method invoked that should be only be invoked inside a doPrivileged block</ShortDescription>
    <LongDescription>在{1}中调用了应在doPrivileged块内调用的{2}</LongDescription>
    <Details>
<![CDATA[这段代码调用了需要进行安全权限检查的方法。如果该代码会被授予安全权限，但可能由未获得安全权限的代码调用，则该调用需要发生在`doPrivileged`块中。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED">
    <ShortDescription>类加载器应该只在doPrivileged块中创建  Classloaders should only be created inside doPrivileged block</ShortDescription>
    <LongDescription>{1} 创建了一个 {2} 类加载器，这应该在一个 doPrivileged 块中执行。</LongDescription>
    <Details>
<![CDATA[这段代码创建了一个类加载器，如果安装了安全管理器，则需要相应的权限。如果此代码可能由没有安全权限的代码调用，那么类加载器的创建需要发生在`doPrivileged`块中。]]>
    </Details>
  </BugPattern>
  <BugPattern type="JCIP_FIELD_ISNT_FINAL_IN_IMMUTABLE_CLASS">
    <ShortDescription>不可变类的字段应为final类型  Fields of immutable classes should be final</ShortDescription>
    <LongDescription>{1.givenClass} 应该是 final 的，因为 {0} 被标记为 Immutable。</LongDescription>
    <Details>
<![CDATA[该类被注释为 `net.jcip.annotations.Immutable` 或 `javax.annotation.concurrent.Immutable`，而这些注解的规则要求所有的字段都是 final 的。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_THREAD_PASSED_WHERE_RUNNABLE_EXPECTED">
    <ShortDescription>线程错误，期望的是Runnable接口实例  Thread passed where Runnable expected</ShortDescription>
    <LongDescription>在{1}处使用了Thread，但预期是Runnable接口。</LongDescription>
    <Details>
<![CDATA[一个Thread对象被传递给一个期望接收Runnable参数的方法中。这相当不寻常，可能表明存在逻辑错误或导致意外的行为。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_COLLECTION_OF_URLS">
    <ShortDescription>地图和URL集合可能会占用大量性能  Maps and sets of URLs can be performance hogs</ShortDescription>
    <LongDescription>{1} 使用地图或URL集合，这可能会占用大量性能资源。</LongDescription>
    <Details>
<![CDATA[这个方法或字段使用了URL的Map或Set。由于URL的equals和hashCode方法会进行域名解析，这可能会导致性能下降。更多详情请参见[http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html](http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html)。考虑使用`java.net.URI`代替。   ]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_BLOCKING_METHODS_ON_URL">
    <ShortDescription>URL的equals和hashCode方法是阻塞的  The equals and hashCode methods of URL are blocking</ShortDescription>
    <LongDescription>在{1}中调用{2}，该调用阻止进行域名解析</LongDescription>
    <Details>
<![CDATA[The `equals` 和 `hashCode` 方法在 URL 中会进行域名解析，这可能会导致性能下降。更多信息可以参考 <a href="http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html">http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html</a>。考虑使用 <code>java.net.URI</code> 代替。   ]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION">
    <ShortDescription>不能使用反射检查注解的存在性，除非该注解具有运行时保留属性  Can't use reflection to check for presence of annotation without runtime retention</ShortDescription>
    <LongDescription>使用反射检查{1}中是否存在没有运行时保留的注解{3}</LongDescription>
    <Details>
<![CDATA[除非一个注解本身被标记为 {@code @Retention(RetentionPolicy.RUNTIME)}，否则无法通过反射（例如，使用 {@code isAnnotationPresent} 方法）观察到该注解。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_EXIT">
    <ShortDescription>方法调用了System.exit(...)  Method invokes System.exit(...)</ShortDescription>
    <LongDescription>{1} 调用了 `System.exit(...)`，这会关闭整个虚拟机。</LongDescription>
    <Details>
<![CDATA[调用System.exit会关闭整个Java虚拟机。这只有在适当的情况下才应该这样做。这样的调用会使你的代码很难或无法被其他代码调用。考虑抛出一个RuntimeException替代。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_RUN_FINALIZERS_ON_EXIT">
    <ShortDescription>方法调用了危险的方法runFinalizersOnExit  Method invokes dangerous method runFinalizersOnExit</ShortDescription>
    <LongDescription>{1} 调用了危险的方法 runFinalizersOnExit</LongDescription>
    <Details>
<![CDATA[<em>请不要出于任何原因调用System.runFinalizersOnExit或Runtime.runFinalizersOnExit：它们是Java库中最危险的方法之一。——约书亚·布洛赫</em>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_STRING_CTOR">
    <ShortDescription>方法调用了无效的 `new String(String)` 构造函数  Method invokes inefficient new String(String) constructor</ShortDescription>
    <LongDescription>{1} 调用了无效的 new String(String) 构造函数</LongDescription>
    <Details>
<![CDATA[使用 `java.lang.String(String)` 构造函数会浪费内存，因为这样构造的对象将在功能上与作为参数传递的 `String` 完全相同。直接使用参数 `String` 即可。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_STRING_VOID_CTOR">
    <ShortDescription>方法调用了效率低的new String()构造函数  Method invokes inefficient new String() constructor</ShortDescription>
    <LongDescription>{1} 调用了低效的 new String() 构造函数</LongDescription>
    <Details>
<![CDATA[创建一个新的 `java.lang.String` 对象使用无参构造函数会浪费内存，因为这样创建的对象在功能上将与空字符串常量 `""` 无法区分。Java 保证相同的字符串常量将由同一个 `String` 对象表示。因此，你应该直接使用空字符串常量。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_STRING_TOSTRING">
    <ShortDescription>方法调用了String的toString()方法  Method invokes toString() method on a String</ShortDescription>
    <LongDescription>{1} 调用了 String 的 toString 方法</LongDescription>
    <Details>
<![CDATA[调用 `String.toString()` 只是一个多余的操作。直接使用字符串即可。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_GC">
    <ShortDescription>显式的垃圾回收；除了在基准测试代码中以外，效果极其可疑  Explicit garbage collection; extremely dubious except in benchmarking code</ShortDescription>
    <LongDescription>{1} 强制垃圾回收；除了在基准代码中，否则极其可疑</LongDescription>
    <Details>
<![CDATA[代码显式调用了垃圾回收。除了在基准测试中特定使用外，这非常可疑。
在过去，人们在关闭或finalize方法等常规中显式调用垃圾收集器的情况导致了巨大的性能瓶颈。垃圾收集可能非常昂贵。任何会导致数百次或数千次垃圾收集的情況都会使机器几乎无法运行。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_BOOLEAN_CTOR">
    <ShortDescription>方法调用了低效的布尔构造函数；请使用Boolean.valueOf(...)代替。  Method invokes inefficient Boolean constructor; use Boolean.valueOf(...) instead</ShortDescription>
    <LongDescription>{\{1\}} 调用了低效的布尔构造函数；请使用 Boolean.valueOf(...) 代替。</LongDescription>
    <Details>
<![CDATA[创建新的 `java.lang.Boolean` 实例会浪费内存，因为 `Boolean` 对象是不可变的，并且这种类型只有两种有用的价值。应该使用 `Boolean.valueOf()` 方法（或 Java 1.5 的自动装箱）来代替创建 `Boolean` 对象。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_NUMBER_CTOR">
    <ShortDescription>方法调用了效率低的Number构造函数；改为使用静态valueOf方法instead  Method invokes inefficient Number constructor; use static valueOf instead</ShortDescription>
    <LongDescription>{1} 调用了低效的 {2} 构造函数；使用 {3} 代替即可</LongDescription>
    <Details>
      <![CDATA[使用 `new Integer(int)` 总是会创建一个新的对象，而 `Integer.valueOf(int)` 允许编译器、类库或 JVM 缓存值。使用缓存的值可以避免对象分配并使代码更快。

-128 到 127 之间的值都有对应的缓存实例，并且使用 `valueOf` 比构造函数快约 3.5 倍。对于超出常量范围的值，两种风格的性能相同。

除非类必须与早于 Java 1.5 的 JVM 兼容，在创建 `Long`、`Integer`、`Short`、`Character` 和 `Byte` 的实例时，请使用自动装箱或 `valueOf()` 方法。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_FP_NUMBER_CTOR">
    <ShortDescription>方法调用了效率低的浮点数Number构造函数；改为使用静态valueOf方法instead  Method invokes inefficient floating-point Number constructor; use static valueOf instead</ShortDescription>
    <LongDescription>{1} 调用了低效的 {2} 构造函数；使用 {3} 代替即可。</LongDescription>
    <Details>
      <![CDATA[使用 `new Double(double)` 可以保证总是创建一个新的对象，而 `Double.valueOf(double)` 允许编译器、类库或 JVM 对值进行缓存。使用缓存的值可以避免对象分配，代码运行会更快。  
除非类必须兼容早于 Java 1.5 的 JVM，否则在创建 `Double` 和 `Float` 实例时，请使用自动装箱或 `valueOf()` 方法。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_CONVERT_CASE">
    <ShortDescription>考虑使用Locale参数化的调用方法  Consider using Locale parameterized version of invoked method</ShortDescription>
    <LongDescription>在{1}中使用未本地化的String.toUpperCase()或String.toLowerCase()方法</LongDescription>
    <Details>
<![CDATA[<p>字符串正在使用平台的默认编码转换为大写或小写。这可能会在使用国际字符时导致不正确的转换。应该使用以下版本：</p>
<ul>
    <li>String.toUpperCase(Locale l)</li>
    <li>String.toLowerCase(Locale l)</li>
</ul>
<p>代替。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR">
    <ShortDescription>原始值被拆箱并强制转换以供三元运算符使用  Primitive value is unboxed and coerced for ternary operator</ShortDescription>
    <LongDescription>原始值在{1}中被拆箱并强制转换为三元运算符的操作数。</LongDescription>
    <Details>
<![CDATA[一个包装的原始值在条件三元运算符（`b ? e1 : e2` 运算符）的评估过程中被拆箱并转换为另一种原始类型。Java 的语义规定，如果 `e1` 和 `e2` 是包装数值类型，那么这些值会被拆箱并转换/强制转换为其共同类型（例如，如果 `e1` 类型是 `Integer` 而 `e2` 类型是 `Float`，那么 `e1` 会被拆箱、转换为浮点值然后被重新封装。参见 JLS 第 15.25 条。）]]>
    </Details>
  </BugPattern>
  <BugPattern type="BX_BOXING_IMMEDIATELY_UNBOXED">
    <ShortDescription>原始值被装箱然后立即拆箱  Primitive value is boxed and then immediately unboxed</ShortDescription>
    <LongDescription>原始值被装箱然后立即被拆箱在{1}中</LongDescription>
    <Details>
<![CDATA[一个原始类型被装箱，然后立即拆箱。这可能是由于在一个需要未装箱值的地方手动进行了装箱，从而迫使编译器立即取消了装箱的操作。]]>
    </Details>
  </BugPattern>
  <BugPattern type="BX_UNBOXING_IMMEDIATELY_REBOXED">
    <ShortDescription>boxed值被拆箱，然后立即再次装箱  Boxed value is unboxed and then immediately reboxed</ShortDescription>
    <LongDescription>盒装值被解装，然后立即重新盒装在{1}中</LongDescription>
    <Details>
<![CDATA[一个封装值被解封装，然后立即再进行封装。]]>
    </Details>
  </BugPattern>
  <BugPattern type="BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION">
    <ShortDescription>原始值被装箱然后拆箱以执行原始类型转换  Primitive value is boxed then unboxed to perform primitive coercion</ShortDescription>
    <LongDescription>原始值被装箱然后拆箱以在{1}中执行原生类型转换</LongDescription>
    <Details>
<![CDATA[<p>构建一个原始封装值，然后立即转换为不同的原始类型（例如，<code>new Double(d).intValue()</code>)。直接进行原始类型的强制转换即可（例如，<code>(int) d</code>)。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_BOXED_PRIMITIVE_TOSTRING">
    <ShortDescription>方法分配了一个装箱的原始类型仅仅是为了调用toString方法  Method allocates a boxed primitive just to call toString</ShortDescription>
    <LongDescription>原始对象只是为了调用toString方法在{1}中</LongDescription>
    <Details>
<![CDATA[一个包含原始类型的包装对象仅仅为了调用toString()方法。直接使用接受原始值的静态toString形式会更有效。因此，可以这样替换：

| 替换... | 用这个... |
| --- | --- |
| new Integer(1).toString() | Integer.toString(1) |
| new Long(1).toString() | Long.toString(1) |
| new Float(1.0).toString() | Float.toString(1.0) |
| new Double(1.0).toString() | Double.toString(1.0) |
| new Byte(1).toString() | Byte.toString(1) |
| new Short(1).toString() | Short.toString(1) |
| new Boolean(true).toString() | Boolean.toString(true) |]]>
    </Details>
  </BugPattern>
    <BugPattern type="DM_BOXED_PRIMITIVE_FOR_PARSING">
    <ShortDescription> Boxing/拆箱用于解析原始类型  Boxing/unboxing to parse a primitive</ShortDescription>
    <LongDescription>将原始类型进行装箱/拆箱解析 {1}</LongDescription>
    <Details>
<![CDATA[一个包含原始类型的对象是从String创建的，只是为了提取未包装的原始值。直接调用静态parseXXX方法更高效。]]>
    </Details>
  </BugPattern>
    <BugPattern type="DM_BOXED_PRIMITIVE_FOR_COMPARE">
    <ShortDescription>将原始类型装箱后进行比较  Boxing a primitive to compare</ShortDescription>
    <LongDescription>原始类型被装箱以调用 {2}：请使用 {3} 代替</LongDescription>
    <Details>
<![CDATA[一个包含的原始类型只是为了调用compareTo方法。直接使用静态compare方法（对于double和float从Java 1.4开始，对于其他原始类型从Java 1.7开始）可以直接作用于原始类型，更加高效。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_NEW_FOR_GETCLASS">
    <ShortDescription>方法分配了一个对象，只是为了获取类对象  Method allocates an object, only to get the class object</ShortDescription>
    <LongDescription>{1} 分配了一个对象，结果只得到了类对象</LongDescription>
    <Details>
<![CDATA[这种方法只是为了调用对象的getClass()方法来获取其Class对象而分配了一个对象。直接访问类的.class属性更为简单。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_MONITOR_WAIT_ON_CONDITION">
    <ShortDescription>在Condition上调用了monitor的wait()方法  Monitor wait() called on Condition</ShortDescription>
    <LongDescription>在{1}中，监视器的wait()方法被Condition调用</LongDescription>
    <Details>
      <![CDATA[这个方法在一个 `java.util.concurrent.locks.Condition` 对象上调用了 `wait()` 方法。通过 `Condition` 接口定义的 `await()` 方法应该用于等待一个 `Condition`。]]>
   </Details>
  </BugPattern>
  <BugPattern type="RV_01_TO_INT">
    <ShortDescription>从0到1之间的随机值会被强制转换为整数0  Random value from 0 to 1 is coerced to the integer 0</ShortDescription>
    <LongDescription>{1} 使用生成一个0到1之间的随机值，然后将该值强制转换为整数0。</LongDescription>
    <Details>
<![CDATA[一个介于0到1之间的随机值被强制转换为整数0。你可能希望在将其强制转换为整数之前将随机值乘以某个其他值，或者使用`Random.nextInt(n)`方法。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_INVALID_MIN_MAX">
    <ShortDescription>Math.max和Math.min的错误组合  Incorrect combination of Math.max and Math.min</ShortDescription>
    <LongDescription>错误使用Math.max和Math.min：这段代码总是返回{2}</LongDescription>
    <Details>
<![CDATA[这段代码尝试使用类似 `Math.min(0, Math.max(100, value))` 的构造来限制值的范围。然而，常量的顺序是不正确的：应该为 `Math.min(100, Math.max(0, value))`。因此，这段代码总是会产生相同的结果（或者如果值是 NaN，则产生 NaN）。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_NEXTINT_VIA_NEXTDOUBLE">
    <ShortDescription>使用Random的nextInt方法而不是nextDouble来生成随机整数  Use the nextInt method of Random rather than nextDouble to generate a random integer</ShortDescription>
    <LongDescription>{1} 使用Random的nextDouble方法生成随机整数；使用nextInt更为高效</LongDescription>
    <Details>
<![CDATA[如果 `r` 是一个 `java.util.Random`，你可以使用 `r.nextInt(n)` 生成从 `0` 到 `n-1` 的随机数，而不是使用 `(int)(r.nextDouble() * n)`。  
nextInt 方法的参数必须为正数。例如，如果你想生成从 -99 到 0 的随机值，可以使用 `-r.nextInt(100)`。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE">
    <ShortDescription>非常量字符串传递给SQL语句的execute或addBatch方法  Nonconstant string passed to execute or addBatch method on an SQL statement</ShortDescription>
    <LongDescription>{1} 将一个非常量的字符串传递给SQL语句的 execute 或 addBatch 方法</LongDescription>
    <Details>
<![CDATA[该方法在SQL语句上调用了execute或addBatch方法，并且字符串似乎是动态生成的。建议使用预编译语句（PreparedStatement）代替。这样既更高效，又更能防止SQL注入攻击。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING">
    <ShortDescription>一个预编译语句是从一个非常量字符串生成的。  A prepared statement is generated from a nonconstant String</ShortDescription>
    <LongDescription>一个预处理语句是从非常量字符串{1}生成的</LongDescription>
    <Details>
<![CDATA[代码从一个非常量字符串创建了一个SQL预处理语句。如果不加以检查，用户提供的污染数据会被用于构建这个字符串，从而可能利用SQL注入使预处理语句执行意想不到且不希望的结果。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_USELESS_THREAD">
    <ShortDescription>一个线程是使用默认的空运行方法创建的。  A thread was created using the default empty run method</ShortDescription>
    <LongDescription>{1} 使用默认的空run方法创建一个线程</LongDescription>
    <Details>
<![CDATA[这个方法创建一个线程，既不指定run方法，也不从Thread类派生，而是通过传递Runnable对象。这样的线程只是浪费时间，并没有实际执行任何任务。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DC_DOUBLECHECK">
    <ShortDescription>可能的现场双重检查  Possible double check of field</ShortDescription>
    <LongDescription>在{1}中可能需要双核检查{2}</LongDescription>
    <Details>
<![CDATA[这种方法可能包含双重锁定实例。根据Java内存模型的语义，这种用法是不正确的。更多信息，请参阅网页 <https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html>。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DC_PARTIALLY_CONSTRUCTED">
    <ShortDescription>部分初始化的对象暴露风险  Possible exposure of partially initialized object</ShortDescription>
    <LongDescription>可能在{1}中暴露了部分初始化的对象</LongDescription>
    <Details>
<![CDATA[这段代码使用了懒初始化和双检锁的方法。虽然字段被正确声明为volatile，但在字段赋值后，对象的内部结构可能会发生变化，因此其他线程可能看到的是一个部分初始化的对象。

为了修复这个问题，可以先将对象存储到局部变量中，只有在完全构造完成后才将其保存到volatile字段中。]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_FINALIZER_NULLS_FIELDS">
    <ShortDescription>最终化器清空字段  Finalizer nulls fields</ShortDescription>
    <LongDescription>在 `{1.class}` 中的 `finalize` 方法中将 `{3}` 设置为 `null`</LongDescription>
    <Details>
<![CDATA[这个终结器会清空字段。这通常是一个错误，因为它无助于垃圾回收，而且对象很快就会被垃圾回收器回收。]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_FINALIZER_ONLY_NULLS_FIELDS">
    <ShortDescription>最终化器只清空字段  Finalizer only nulls fields</ShortDescription>
    <LongDescription>{1} 仅为空的字段</LongDescription>
    <Details>
<![CDATA[这个最终化器除了将字段置为null之外没有任何作用。这完全是多余的，并且需要对象被垃圾回收、最终化，然后再被垃圾回收一次。你应该直接移除finalizer方法。]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_PUBLIC_SHOULD_BE_PROTECTED">
    <ShortDescription>最终化方法应该受保护，而不是公开的  Finalizer should be protected, not public</ShortDescription>
    <LongDescription>{1}是公共的；应该被保护</LongDescription>
    <Details>
<![CDATA[<p>一个类的 `<code>finalize()</code>` 方法应该具有保护访问权限，而不是公共访问权限。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_EMPTY">
    <ShortDescription>空的finalize方法应当被删除  Empty finalizer should be deleted</ShortDescription>
    <LongDescription>{1} 是空的，应该被删除</LongDescription>
    <Details>
<![CDATA[空的 `finalize()` 方法是没有用的，所以应该删除它们。]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_NULLIFY_SUPER">
    <ShortDescription>最终化器消除了超类的最终化器  Finalizer nullifies superclass finalizer</ShortDescription>
    <LongDescription>`{1}` 是在取消 `{2}.finalize()`。这是有意的吗？</LongDescription>
    <Details>
<![CDATA[这个空的`finalize()`方法显式地否定了其超类定义的任何最终化效果。由超类定义的任何最终化动作将不会被执行。除非这是有意图的，否则请删除该方法。]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_USELESS">
    <ShortDescription>最终izers除了调用超类的finalizer之外什么也不做。  Finalizer does nothing but call superclass finalizer</ShortDescription>
    <LongDescription>{1} 除了调用 `super.finalize()` 之外什么也不做，可以删除它。</LongDescription>
    <Details>
<![CDATA[这个 `finalize()` 方法唯一做的就是调用超类的 `finalize()` 方法，使其变得多余。删除它。]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_MISSING_SUPER_CALL">
    <ShortDescription>.finalizer 不会调用超类的 .finalizer  Finalizer does not call superclass finalizer</ShortDescription>
    <LongDescription>缺少对 `super.finalize()` 的调用，因此 `{2}.finalize()` 也不会被调用。</LongDescription>
    <Details>
<![CDATA[这个 `finalize()` 方法没有调用其超类的 `finalize()` 方法。因此，任何为超类定义的最后释放操作将不会执行。请添加对 `super.finalize()` 的调用。]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_EXPLICIT_INVOCATION">
    <ShortDescription>显式调用终结器  Explicit invocation of finalizer</ShortDescription>
    <LongDescription>在{1}中显式调用{2}</LongDescription>
    <Details>
<![CDATA[这种方法包含对对象显式调用`finalize()`方法。因为finalizer方法应该只执行一次，并且仅由VM执行，所以这是一个不好的做法。

如果一组相关的对象开始进行最终化处理，那么VM将会在同一时间在不同的线程中对所有可最终化的对象调用 finalize 方法。因此，在类X的 finalize 方法中引用的对象 X 调用 finalize 方法是一个特别糟糕的想法，因为它们可能已经在单独的线程中被进行最终化处理了。]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS">
    <ShortDescription>等于运算检查不兼容的操作数  Equals checks for incompatible operand</ShortDescription>
    <LongDescription>{1} 检查操作数是否为 {2.givenClass}</LongDescription>
    <Details>
<![CDATA[这个equals方法是在检查参数是否为某种不兼容类型（即既不是定义equals方法的类的父类也不是子类）。例如，Foo类的equals方法可能看起来像这样：

```java
public boolean equals(Object o) {
    if (o instanceof Foo)
        return name.equals(((Foo)o).name);
    else if (o instanceof String)
        return name.equals(o);
    else return false;
}
```

这种方法被认为是一种不良实践，因为它使得实现对称性和传递性的equals方法变得非常困难。缺乏这些性质会导致可能出现非常意想不到的行为。]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_DONT_DEFINE_EQUALS_FOR_ENUM">
    <ShortDescription>枚举中定义的covariant equals()方法  Covariant equals() method defined for enum</ShortDescription>
    <LongDescription>枚举 {0} 定义了 equals({0.givenClass})</LongDescription>
    <Details>
<![CDATA[这个类定义了一个枚举，枚举之间的相等性是基于对象身份来定义的。为一个枚举值定义协变的equals方法是一种非常糟糕的做法，因为这可能会导致使用协变枚举方法比较两个不同的枚举值时它们被认为是相等的，而在正常情况下比较时又不相等。不要这样做。]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_SELF_USE_OBJECT">
    <ShortDescription>协变equals()方法定义，Object.equals(Object)继承而来  Covariant equals() method defined, Object.equals(Object) inherited</ShortDescription>
    <LongDescription>{0} 定义了 equals({0.givenClass}) 方法，并使用了 Object.equals(Object) 方法。</LongDescription>
    <Details>
<![CDATA[这个类定义了一个协变版本的 `equals()` 方法，但继承了基类 `java.lang.Object` 中定义的正常 `equals(Object)` 方法。该类很可能应该定义一个 `boolean equals(Object)` 方法。]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_OTHER_USE_OBJECT">
    <ShortDescription>定义了一个equals()方法，但没有重写Object.equals(Object)方法  equals() method defined that doesn't override Object.equals(Object)</ShortDescription>
    <LongDescription>{0}定义了{1.givenClass}方法，并使用了Object.equals(Object)方法</LongDescription>
    <Details>
<![CDATA[这个类定义了一个`equals()`方法，这个方法没有覆盖基础的`java.lang.Object`类中定义的`equals(Object)`方法。 类应该可能定义一个`boolean equals(Object)`方法。]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_OTHER_NO_OBJECT">
    <ShortDescription>定义了equals()方法但未重写equals(Object)方法  equals() method defined that doesn't override equals(Object)</ShortDescription>
    <LongDescription>{0} 定义了 {1.givenClass} 方法，但没有重写 equals(Object) 方法。</LongDescription>
    <Details>
<![CDATA[这个类定义了一个 `equals()` 方法，这个方法没有覆盖基类 `java.lang.Object` 中定义的正常 `equals(Object)` 方法。相反，它继承了一个来自超类的 `equals(Object)` 方法。这个类应该 probably 定义一个 `boolean equals(Object)` 方法。]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_DOESNT_OVERRIDE_EQUALS">
    <ShortDescription>类没有覆盖超类的equals方法  Class doesn't override equals in superclass</ShortDescription>
    <LongDescription>{0} 没有覆盖 {2.givenClass}</LongDescription>
    <Details>
<![CDATA[这个类扩展了一个定义了equals方法的类，并增加了字段，但自身没有定义equals方法。因此，此类实例的相等性将忽略子类的身份和增加的字段。请确保这是预期的行为，并且你不需要覆盖equals方法。即使你不需要覆盖equals方法，也考虑覆盖它以记录子类的equals方法只是返回调用super.equals(o)的结果。]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_SELF_NO_OBJECT">
    <ShortDescription>协变equals()方法定义  Covariant equals() method defined</ShortDescription>
    <LongDescription>{0} 定义了 equals({0.givenClass}) 方法，但没有定义 equals(Object) 方法。</LongDescription>
    <Details>
<![CDATA[这个类定义了一个协变版本的 `equals()`。为了正确重写 `java.lang.Object` 中的 `equals()` 方法，`equals()` 的参数必须是 `java.lang.Object` 类型。]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_OVERRIDING_EQUALS_NOT_SYMMETRIC">
    <ShortDescription>equals方法会在超类的equals方法上进行覆盖，因此可能不具有对称性。  equals method overrides equals in superclass and may not be symmetric</ShortDescription>
    <LongDescription>在`{1.class}`中重写了`equals`方法，在`{2.class.givenClass}`中可能没有对称性。</LongDescription>
    <Details>
<![CDATA[这个类定义了一个equals方法，该方法覆盖了超类中的equals方法。两个equals方法都使用`instanceof`来确定两个对象是否相等。这存在很大的风险，因为equals方法必须对称（换句话说，`a.equals(b) == b.equals(a)`）。如果B是A的子类型，并且A的equals方法检查参数是否为A的实例，而B的equals方法检查参数是否为B的实例，那么这些方法定义的等价关系很可能不是对称的。]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_GETCLASS_AND_CLASS_CONSTANT">
    <ShortDescription>equals方法对于子类型会失效  equals method fails for subtypes</ShortDescription>
    <LongDescription>{1} 对于子类型不成立</LongDescription>
    <Details>
<![CDATA[这个类有一个equals方法，如果被子类继承，则该方法可能会失效。它会将类字面量与参数的类进行比较（例如，在`Foo`类中，它可能会检查`Foo.class == o.getClass()`）。更好的做法是检查`this.getClass() == o.getClass()`。]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_UNUSUAL">
    <ShortDescription>非同寻常的equals方法  Unusual equals method</ShortDescription>
    <LongDescription>{1} 很不寻常</LongDescription>
    <Details>
<![CDATA[这个类并没有使用我们识别出的任何模式来检查参数类型是否与`this`对象的类型兼容。这段代码可能没有问题，但值得对其进行审查。]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_COMPARING_CLASS_NAMES">
    <ShortDescription>equals方法比较的是类名而不是类对象  equals method compares class names rather than class objects</ShortDescription>
    <LongDescription>{1} 比较类名而不是类对象</LongDescription>
    <Details>
<![CDATA[这种方法通过检查两个对象的类名是否相同来确定它们是否为同一类。即使是由不同的类加载器加载，也可以有同名的类。你只需检查类对象是否相同即可。]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_ALWAYS_TRUE">
    <ShortDescription>equals方法总是返回true  equals method always returns true</ShortDescription>
    <LongDescription>{1} 总是返回真</LongDescription>
    <Details>
<![CDATA[这个类定义了一个总是返回true的equals方法。这虽然是个有趣的创意，但并不聪明。而且，这意味着equals方法不是对称的。]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_ALWAYS_FALSE">
    <ShortDescription>equals方法总是返回false  equals method always returns false</ShortDescription>
    <LongDescription>{1} 总是返回 false</LongDescription>
    <Details>
<![CDATA[这个类定义了一个始终返回false的equals方法。这意味着对象不等于自身，并且无法创建此类的对象有用的Maps或Sets。从根本上说，这意味着equals不是自反性的，这是equals方法的一个要求。

你可能希望覆盖的是从其他超类继承而来的equals方法，其预期语义是对象身份：一个对象等于它自己。这可以使用以下代码实现：

```java
public boolean equals(Object o) {
    return this == o;
}
```]]>
    </Details>
  </BugPattern>
  <BugPattern type="HSC_HUGE_SHARED_STRING_CONSTANT">
    <ShortDescription>巨大的字符串常量在多个类文件中被重复定义  Huge string constants is duplicated across multiple class files</ShortDescription>
    <LongDescription>{1} 被初始化为一个长度为 {2} 的字符串常量，并且在其他 {3} 个类文件中也被复制。</LongDescription>
    <Details>
      <![CDATA[一个大的字符串常量被分散到多个类文件中。这很可能是因为一个final字段初始化为一个字符串常量，而Java语言要求从其他类引用final字段的所有内容都被内联到该类文件中。请参阅[JDK bug 6447475](http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6447475)了解此错误在JDK中的一个实例以及解决它如何减少了JDK的大小1兆字节。]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_ARGUMENT_MIGHT_BE_NULL">
    <ShortDescription>方法未检查空值参数  Method does not check for null argument</ShortDescription>
    <LongDescription>{1} 不检查空参数</LongDescription>
    <Details>
      <![CDATA[该方法的一个参数已被识别为一个应该始终检查是否为空的值，但在这个过程中没有进行前置空值检查就进行了去引用操作。]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT">
    <ShortDescription>equals()方法不会检查空参数  equals() method does not check for null argument</ShortDescription>
    <LongDescription>{1} 不检查空参数</LongDescription>
    <Details>
      <![CDATA[这个equals(Object)的实现违反了java.lang.Object.equals()定义的合同，因为它没有检查传递进来的参数是否为null。所有的equals()方法如果传入null值都应该返回false。]]>
   </Details>
  </BugPattern>
  <BugPattern type="RV_NEGATING_RESULT_OF_COMPARETO">
    <ShortDescription>否定compareTo()/compare()的方法结果  Negating the result of compareTo()/compare()</ShortDescription>
    <LongDescription>{1} 取消了 {2} 的返回值</LongDescription>
    <Details>
<![CDATA[这段代码会取compareTo或compare方法返回值的相反数。这是一种值得商榷甚至糟糕的编程实践，因为如果返回值是Integer.MIN_VALUE，取相反数不会改变结果的符号。你可以通过反转操作数的顺序而不是取相反数来实现相同的目的。]]>
    </Details>
  </BugPattern>
  <BugPattern type="CO_COMPARETO_RESULTS_MIN_VALUE">
    <ShortDescription>`compareTo()`/`compare()` 方法返回 `Integer.MIN_VALUE`  compareTo()/compare() returns Integer.MIN_VALUE</ShortDescription>
    <LongDescription>{1}返回Integer.MIN_VALUE，这个值无法被取反。</LongDescription>
    <Details>
<![CDATA[在某些情况下，`compareTo` 或 `compare` 方法返回常量 `Integer.MIN_VALUE`，这是一种非常糟糕的实践。返回值的唯一重要之处在于其符号。但是，人们有时会取 `compareTo` 返回值的负数，期望这样可以改变结果的符号。这在大多数情况下是正确的，但有一个例外，即当返回值为 `Integer.MIN_VALUE` 时。因此，直接返回 `-1` 而不是 `Integer.MIN_VALUE` 更安全。]]>
    </Details>
  </BugPattern>
  <BugPattern type="CO_COMPARETO_INCORRECT_FLOATING">
    <ShortDescription>`compareTo()`/`compare()` 不正确处理浮点值或双精度值  compareTo()/compare() incorrectly handles float or double value</ShortDescription>
    <LongDescription>{1}错误处理了{2}值</LongDescription>
    <Details>
<![CDATA[这种方法使用类似于 `val1 > val2 ? 1 : val1 < val2 ? -1 : 0` 的模式来比较 double 或 float 值。这种模式在处理 -0.0 和 NaN 值时会出错，可能导致排序结果不正确或集合损坏（如果比较值用作键）。建议使用 `Double.compare` 或 `Float.compare` 静态方法，这些方法可以正确处理所有特殊情况。]]>
    </Details>
  </BugPattern>
  <BugPattern type="CO_SELF_NO_OBJECT">
    <ShortDescription>协变compareTo()方法定义  Covariant compareTo() method defined</ShortDescription>
    <LongDescription>{0} 定义了 `compareTo({0.givenClass})` 方法，但没有定义 `compareTo(Object)` 方法。</LongDescription>
    <Details>
<![CDATA[这个类定义了一个协变版本的 `compareTo()`。为了正确重写 `Comparable` 接口中的 `compareTo()` 方法，`compareTo()` 的参数必须是 `java.lang.Object` 类型。]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_SIGNATURE_DECLARES_HASHING_OF_UNHASHABLE_CLASS">
    <ShortDescription>签名声明在哈希构造中使用了不可哈希的类  Signature declares use of unhashable class in hashed construct</ShortDescription>
    <LongDescription>{2} 没有定义hashCode()方法，但在{1}中被用于哈希上下文中。</LongDescription>
    <Details>
<![CDATA[一个方法、字段或类声明了泛型签名，在其中使用了一个不可哈希的类，而该上下文要求使用可哈希的类。如果一个类声明了 `equals` 方法但继承了 `Object` 类中的 `hashCode()` 方法，则该类是不可哈希的，因为它没有满足相等对象具有相同哈希码的要求。]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_USE_OF_UNHASHABLE_CLASS">
    <ShortDescription>在哈希数据结构中使用没有hashCode()方法的类  Use of class without a hashCode() method in a hashed data structure</ShortDescription>
    <LongDescription>{2} 没有定义hashCode()方法，但在{1}中的哈希数据结构中被使用了。</LongDescription>
    <Details>
<![CDATA[一个类定义了equals(Object) 方法但没有定义hashCode() 方法，因此未能满足相等对象具有相同哈希码的要求。如果该类的实例被用于哈希数据结构中，则修复此问题尤为重要。]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_HASHCODE_USE_OBJECT_EQUALS">
    <ShortDescription>类定义了hashCode()方法，并使用Object的equals()方法  Class defines hashCode() and uses Object.equals()</ShortDescription>
    <LongDescription>{0} 定义了 hashCode 并使用了 Object.equals() 方法。</LongDescription>
    <Details>
<![CDATA[这个类定义了 `hashCode()` 方法，但继承了从 `java.lang.Object` 继承的 `equals()` 方法（该方法通过比较对象引用定义相等性）。尽管这可能满足相等的对象必须具有相同哈希码的合同要求，但这很可能不是覆盖 `hashCode()` 方法时所期望的结果。（覆盖 `hashCode()` 方法意味着对象的身份是基于比简单引用相等更复杂的标准。）

如果你不认为这个类的实例会被插入到 HashMap/HashTable 中，推荐使用的 `hashCode` 实现如下：

```java
public int hashCode() {
    assert false : "hashCode not designed";
    return 42; // 任何任意常量都可以
}
```]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_COMPARETO_USE_OBJECT_EQUALS">
    <ShortDescription>类定义了compareTo(...)方法，并使用了Object.equals()方法  Class defines compareTo(...) and uses Object.equals()</ShortDescription>
    <LongDescription>{0}定义了{1.givenClass}并使用了Object.equals()方法</LongDescription>
    <Details>
<![CDATA[这个类定义了一个 `compareTo(...)` 方法，但继承了从 `java.lang.Object` 继承的 `equals()` 方法。通常情况下，当 `equals` 返回真时，`compareTo` 应该返回零。如果违反这一点，诸如 `PriorityQueue` 这样的类将出现奇怪且不可预测的失败。在 Java 5 中，`PriorityQueue.remove` 方法使用 `compareTo` 方法；而在 Java 6 中，则使用 `equals` 方法。

从 `Comparable` 接口的 `compareTo` 方法的 JavaDoc 中：建议但不是强制要求 `(x.compareTo(y) == 0) == (x.equals(y))`。通常情况下，任何实现了 `Comparable` 接口且违反这一条件的类都应该明确指出这一点。推荐的语言是“注意：此类的自然排序与其相等性不一致。”]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_HASHCODE_NO_EQUALS">
    <ShortDescription>类定义了hashCode()方法但未定义equals()方法  Class defines hashCode() but not equals()</ShortDescription>
    <LongDescription>{0} 定义了hashCode但没有定义equals</LongDescription>
    <Details>
<![CDATA[这个类定义了 `hashCode()` 方法但没有定义 `equals()` 方法。因此，该类可能会违反相等对象必须具有相同哈希码的不变量。]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_EQUALS_USE_HASHCODE">
    <ShortDescription>类定义了equals()方法，并使用Object.hashCode()方法  Class defines equals() and uses Object.hashCode()</ShortDescription>
    <LongDescription>{0}定义了equals方法并使用了Object.hashCode()</LongDescription>
    <Details>
<![CDATA[这个类重写了 `equals(Object)`，但没有重写 `hashCode()`，而是继承了 `java.lang.Object` 的 `hashCode()` 实现（该实现返回对象的身份哈希码，即 VM 分配给对象的一个任意值）。因此，这个类很可能违反相等对象必须具有相同哈希码的不变量。

如果你认为这个类的实例永远不会插入到 HashMap/HashTable 中，推荐使用的 `hashCode` 实现是：

```java
public int hashCode() {     
    assert false : "hashCode not designed";     
    return 42; // 任何任意常量都可以
}
```]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_INHERITS_EQUALS_USE_HASHCODE">
    <ShortDescription>类继承了equals()方法，并使用Object的hashCode()方法。  Class inherits equals() and uses Object.hashCode()</ShortDescription>
    <LongDescription>{0} 继承了 equals 方法，并使用了 Object 的 hashCode 方法。</LongDescription>
    <Details>
<![CDATA[这个类从抽象超类继承了 `<code>equals(Object)</code>`，并且从 `java.lang.Object` 继承了 `<code>hashCode()</code>`（返回的是身份哈希码，由虚拟机分配的任意值）。因此，该类很可能违反了相等对象必须具有相同哈希码的不变量。

如果你不想定义 `hashCode` 方法，并且/或者相信这个对象永远不会被放入 `HashMap/Hashtable` 中，则可以将 `<code>hashCode()</code>` 方法定义为抛出 `UnsupportedOperationException`。]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_EQUALS_NO_HASHCODE">
    <ShortDescription>类定义了equals()方法但未定义hashCode()方法  Class defines equals() but not hashCode()</ShortDescription>
    <LongDescription>{0} 定义了 equals 但没有定义 hashCode</LongDescription>
    <Details>
<![CDATA[这个类重写了 `equals(Object)`，但没有重写 `hashCode()`。因此，该类可能会违反相等对象必须具有相同哈希码的不变量。]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_ABSTRACT_SELF">
    <ShortDescription>抽象类定义了协变的equals()方法  Abstract class defines covariant equals() method</ShortDescription>
    <LongDescription>摘要：{0}定义了equals({0.givenClass})方法</LongDescription>
    <Details>
<![CDATA[这个类定义了一个协变版本的 `equals()` 方法。为了正确重写 `java.lang.Object` 中的 `equals()` 方法，`equals()` 的参数必须是 `java.lang.Object` 类型。]]>
    </Details>
  </BugPattern>
  <BugPattern type="ES_COMPARING_STRINGS_WITH_EQ">
    <ShortDescription>使用 `==` 或 `!=` 比较 String 对象  Comparison of String objects using == or !=</ShortDescription>
    <LongDescription>在{1}中，使用==或!=比较String对象</LongDescription>
    <Details>
<![CDATA[这段代码使用 `==` 或 `!=` 操作符比较 `java.lang.String` 对象的引用相等性。除非两个字符串都是源文件中的常量，或者通过 `String.intern()` 方法进行了intern化，否则相同的字符串值可能由两个不同的 String 对象表示。建议改为使用 `equals(Object)` 方法。]]>
    </Details>
  </BugPattern>
  <BugPattern type="ES_COMPARING_PARAMETER_STRING_WITH_EQ">
    <ShortDescription>使用 `==` 或 `!=` 比较字符串参数的比较  Comparison of String parameter using == or !=</ShortDescription>
    <LongDescription>比较String参数使用==或!=在{1}中的区别</LongDescription>
    <Details>
<![CDATA[这段代码使用 `==` 或 `!=` 操作符比较 `java.lang.String` 参数的引用等价性。要求调用者仅传递字符串常量或intern化的字符串给方法是不必要的脆弱，而且很少能带来可测量的性能提升。考虑改为使用 `equals(Object)` 方法。]]>
    </Details>
  </BugPattern>
  <BugPattern type="CO_ABSTRACT_SELF">
    <ShortDescription>抽象类定义了协变的compareTo()方法  Abstract class defines covariant compareTo() method</ShortDescription>
    <LongDescription>摘要《0》定义了compareTo({0.givenClass})方法</LongDescription>
    <Details>
<![CDATA[这个类定义了一个协变版本的 `compareTo()`。为了正确重写 `Comparable` 接口中的 `compareTo()` 方法，`compareTo()` 的参数必须是 `java.lang.Object` 类型。]]>
    </Details>
  </BugPattern>
  <BugPattern type="IS_FIELD_NOT_GUARDED">
    <ShortDescription>未防护并发访问的字段  Field not guarded against concurrent access</ShortDescription>
    <LongDescription>{1.givenClass} 没有防护同时访问；锁住 {2}% 的时间</LongDescription>
    <Details>
<![CDATA[这个字段被标注为`net.jcip.annotations.GuardedBy`或`javax.annotation.concurrent.GuardedBy`，但似乎以违反这些注释的方式被访问。]]>
</Details>
  </BugPattern>
  <BugPattern type="MSF_MUTABLE_SERVLET_FIELD">
    <ShortDescription>可变的Servlet字段  Mutable servlet field</ShortDescription>
    <LongDescription>{1} 是一个可变的Servlet字段</LongDescription>
    <Details>
<![CDATA[一个Web服务器通常只会创建一个Servlet或JSP类的实例（即，将其视为单例），并让多个线程调用该实例的方法以处理多个同时请求。因此，拥有可变的实例字段通常会创建竞态条件。]]>
    </Details>
  </BugPattern>
  <BugPattern type="IS2_INCONSISTENT_SYNC">
    <ShortDescription>不一致的同步  Inconsistent synchronization</ShortDescription>
    <LongDescription>不一致的同步:{1}; 上锁了{2}%的时间</LongDescription>
    <Details>
<![CDATA[该类中的字段似乎以不一致的方式进行同步访问。此错误报告表明，错误模式检测器判断该模式如下：
- 该类包含锁定和未锁定的访问混合；
- 该类并未标注为 `javax.annotation.concurrent.NotThreadSafe`；
- 至少有一个锁定访问是由该类自己的方法执行的；
- 无同步字段访问（读取和写入）的数量不超过总访问次数的三分之一，且写入的操作权重是读取操作的两倍。

一个典型的与此错误模式匹配的bug是在本应线程安全的类中忘记对某个方法进行同步。

你可以选择标记为“未同步访问”的节点，以显示检测器认为字段在无同步情况下被访问的代码位置。

请注意，此检测器存在各种不准确的因素；例如，检测器无法静态检测所有持有锁的情况。即使检测器能够准确地区分锁定和未锁定的访问，相关代码仍然可能是正确的。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NN_NAKED_NOTIFY">
    <ShortDescription>裸体通知  Naked notify</ShortDescription>
    <LongDescription> Naked通知在{1}</LongDescription>
    <Details>
<![CDATA[调用了`notify()` 或 `notifyAll()`，但没有（明显地）伴随有对可变对象状态的修改。通常，在一个监视器上调用通知方法是因为某些条件已经满足，而其他线程正在等待这个条件变为真。然而，为了使这种条件有意义，它必须涉及到两个线程都能看到的堆对象。

这 bugs 并不一定表示错误，因为可变对象状态的变化可能是在调用通知的方法之前的一个方法中完成的。]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_EXPOSE_REP">
    <ShortDescription>公共静态方法可能会通过返回数组暴露内部表示。  Public static method may expose internal representation by returning array</ShortDescription>
    <LongDescription>公共静态块可能通过返回 `{2.givenClass}` � Expose 内部表示。</LongDescription>
    <Details>
<![CDATA[<p>一个公共静态方法返回一个数组的引用，该数组是类的静态状态的一部分。任何调用此方法的代码都可以自由修改底层数组。一种修复方法是返回数组的副本。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_REP">
    <ShortDescription>可能会通过返回可变对象的引用暴露内部表示形式  May expose internal representation by returning reference to mutable object</ShortDescription>
    <LongDescription>{1} 可能通过返回 {2.givenClass} 来暴露内部表示。</LongDescription>
    <Details>
<![CDATA[返回一个指向对象字段中存储的可变对象值的引用会暴露该对象的内部表示形式。如果实例通过不可信代码访问，并且对可变对象的未经检查更改会危及安全或其他重要属性，您就需要采取不同的方法。在许多情况下，返回对象的新副本是更好的做法。]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_REP2">
    <ShortDescription>可能通过引用可变对象来暴露内部表示形式  May expose internal representation by incorporating reference to mutable object</ShortDescription>
    <LongDescription>{1} 可能会通过将一个外部可变对象存储到 {2.givenClass} 中来暴露内部表示。</LongDescription>
    <Details>
<![CDATA[这段代码将对外可变的对象引用存储到了对象的内部表示中。如果实例被不可信的代码访问，并且对可变对象的未检查更改会危及安全或其他重要属性，你需要采取不同的方法。在许多情况下，复制对象是一个更好的做法。]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_STATIC_REP2">
    <ShortDescription>可能会通过将可变对象存储在静态字段中来暴露内部静态状态。  May expose internal static state by storing a mutable object into a static field</ShortDescription>
    <LongDescription>{1} 可能会暴露内部的静态状态，通过将可变对象存储到静态字段中 {2}</LongDescription>
    <Details>
<![CDATA[这段代码将对外可变的对象引用存储到了一个静态字段中。如果对该可变对象的未受检查的修改会危及安全或其他重要属性，你需要采取不同的方法。在许多情况下，复制对象存储是更好的做法。]]>
    </Details>
  </BugPattern>
  <BugPattern type="RU_INVOKE_RUN">
    <ShortDescription>在线程上调用run（您是想启动它而不是调用它吗？）  Invokes run on a thread (did you mean to start it instead?)</ShortDescription>
    <LongDescription>{1} 显式地在某个线程上调用了 run 方法（您本意是要启动它而不是直接调用吗？）</LongDescription>
    <Details>
<![CDATA[这种方法显式地在对象上调用了 `run()` 方法。通常情况下，类会实现 `Runnable` 接口，因为它们的 `run()` 方法将在新线程中被调用，在这种情况下应该使用 `Thread.start()` 来调用。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SP_SPIN_ON_FIELD">
    <ShortDescription>方法在场地上旋转  Method spins on field</ShortDescription>
    <LongDescription>在{2.givenClass}上旋转在{1}</LongDescription>
    <Details>
<![CDATA[这个方法在一个循环中读取一个字段。编译器可以合法地将读操作移出循环，使代码变成无限循环。应该修改类，使其使用正确的同步（包括wait和notify调用）。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NS_DANGEROUS_NON_SHORT_CIRCUIT">
    <ShortDescription>潜在危险的非短路逻辑使用  Potentially dangerous use of non-short-circuit logic</ShortDescription>
    <LongDescription>在{1}中使用了潜在危险的非短路逻辑</LongDescription>
    <Details>
<![CDATA[这段代码似乎使用了非短路逻辑（例如，& 或 |），而不是短路逻辑（&& 或 ||）。此外，根据左侧的值，你可能不想评估右侧的内容（因为这可能会产生副作用、导致异常或非常昂贵）。

非短路逻辑会导致表达式的两边都被评估，即使结果可以根据左边的值来推断。这可能会降低效率，并且如果左边的值保护了在评估右边时会生成错误的情况，则可能导致错误。 

有关详细信息，请参阅 <a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.22.2">Java 语言规范</a>。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NS_NON_SHORT_CIRCUIT">
    <ShortDescription>可疑的非短路逻辑使用  Questionable use of non-short-circuit logic</ShortDescription>
    <LongDescription>在{1}中使用了可疑的非短路逻辑</LongDescription>
    <Details>
<![CDATA[这段代码似乎使用了非短路逻辑（例如，& 或 |），而不是短路逻辑（&& 或 ||）。非短路逻辑会导致表达式的两边都在结果可以从前者推断出来的情况下也被评估。这可能会降低效率，并且如果左半部分用于保护某些情况，在评估右半部分时会产生错误。  
参见 <a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.22.2">Java 语言规范</a> 以获取详细信息。]]>
    </Details>
  </BugPattern>
  <BugPattern type="TLW_TWO_LOCK_WAIT">
    <ShortDescription>带着两个锁等待  Wait with two locks held</ShortDescription>
    <LongDescription>在{1}中持有两个锁的wait()方法</LongDescription>
    <Details>
<![CDATA[在持有两个锁的情况下等待一个监视器可能会导致死锁。仅执行等待操作会释放被等待的对象上的锁，但不会释放其他任何锁。这不一定是一个错误，但值得仔细检查。]]>
    </Details>
  </BugPattern>
  <BugPattern type="TLW_TWO_LOCK_NOTIFY" deprecated="true"> <!-- never generated -->
    <ShortDescription>持有两个锁进行通知  Notify with two locks held</ShortDescription>
    <LongDescription>持有两个锁在{1}情况下使用notify()或notifyAll*()</LongDescription>
    <Details>
<![CDATA[代码在持有两个锁的情况下调用了`notify()`或`notifyAll()`。如果这种通知是为了唤醒一个同样持有这两个锁的`wait()`，可能会导致死锁，因为`wait()`只会释放一个锁，而`notify()`将无法获得两个锁，因此通知不会成功。如果有关于双重锁等待的警告，出现bug的概率相当高。]]>
    </Details>
  </BugPattern>
  <BugPattern type="UW_UNCOND_WAIT">
    <ShortDescription>无条件等待  Unconditional wait</ShortDescription>
    <LongDescription>无条件等待在{1}</LongDescription>
    <Details>
<![CDATA[这种方法包含对 `java.lang.Object.wait()` 的调用，但没有通过条件控制流进行防护。代码在调用 `wait` 之前应该验证它打算等待的条件是否已经满足；任何先前的通知都将被忽略。]]>
    </Details>
  </BugPattern>
  <BugPattern type="UR_UNINIT_READ">
    <ShortDescription>在构造函数中读取未初始化的字段  Uninitialized read of field in constructor</ShortDescription>
    <LongDescription>在{1}中读取未初始化的{2.name}</LongDescription>
    <Details>
<![CDATA[这个构造函数读取了一个尚未被赋值的字段。这通常是因为程序员错误地使用了该字段而不是构造函数的一个参数所导致的。]]>
    </Details>
  </BugPattern>
  <BugPattern type="UR_UNINIT_READ_CALLED_FROM_SUPER_CONSTRUCTOR">
    <ShortDescription>从超类构造函数中调用的未初始化读取字段方法  Uninitialized read of field method called from constructor of superclass</ShortDescription>
    <LongDescription>在从超类构造函数调用时，{1.name} 中没有初始化 {2.name}</LongDescription>
    <Details>
<![CDATA[这个方法在超类的构造函数中被调用。在这个时候，类的字段还没有初始化。

为了使这一点更具体，考虑以下类：

```java
abstract class A {
    int hashCode;
    abstract Object getValue();

    A() {
        hashCode = getValue().hashCode();
    }
}

class B extends A {
    Object value;

    B(Object v) {
        this.value = v;
    }

    Object getValue() {
        return value;
    }
}
```

当创建一个`B`对象时，会在设置`value`之前调用`A`类的构造函数。因此，当`A`类的构造函数调用`getValue`方法时，会读取一个未初始化的`value`值。]]>
    </Details>
  </BugPattern>
  <BugPattern type="UG_SYNC_SET_UNSYNC_GET">
    <ShortDescription>未同步的get方法，同步的set方法  Unsynchronized get method, synchronized set method</ShortDescription>
    <LongDescription>{1} 是未同步的，{2} 是已同步的</LongDescription>
    <Details>
<![CDATA[这个类包含同名的方法，其中set方法是同步的，而get方法不是。这可能导致运行时出现错误行为，因为调用get方法的方程不一定能看到对象的一致状态。应该使get方法同步。]]>
    </Details>
  </BugPattern>
  <BugPattern type="IC_INIT_CIRCULARITY">
    <ShortDescription>初始化循环  Initialization circularity</ShortDescription>
    <LongDescription>在{0}和{1}之间的初始化循环性</LongDescription>
    <Details>
<![CDATA[在一个bug实例中引用的两个类的静态初始化器检测到了循环依赖。这种循环依赖可能会导致许多意想不到的行为。]]>
    </Details>
  </BugPattern>
  <BugPattern type="IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION">
    <ShortDescription>超类在初始化时使用子类  Superclass uses subclass during initialization</ShortDescription>
    <LongDescription>初始化{0}访问了类{2}，但该类尚未初始化完毕</LongDescription>
    <Details>
<![CDATA[在类的初始化过程中，该类会主动使用一个子类。此时子类还未被初始化。例如，在以下代码中，`foo` 将为 `null`。

```java
public class CircularClassInitialization {     
    static class InnerClassSingleton extends CircularClassInitialization {       
        static InnerClassSingleton singleton = new InnerClassSingleton();     
    }     
    
    static CircularClassInitialization foo = InnerClassSingleton.singleton; 
}
```]]>
    </Details>
  </BugPattern>
  <BugPattern type="IT_NO_SUCH_ELEMENT">
    <ShortDescription>iterator的next()方法不能抛出NoSuchElementException异常  Iterator next() method can't throw NoSuchElementException</ShortDescription>
    <LongDescription>{1} 无法抛出 NoSuchElementException</LongDescription>
    <Details>
<![CDATA[这个类实现了 `java.util.Iterator` 接口。然而，其 `next()` 方法不能抛出 `java.util.NoSuchElementException`。应该将 `next()` 方法修改为在没有更多元素可返回时调用该方法时抛出 `NoSuchElementException`。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DL_SYNCHRONIZATION_ON_SHARED_CONSTANT">
    <ShortDescription>interned字符串的同步  Synchronization on interned String</ShortDescription>
    <LongDescription>在{1}中interned String的同步</LongDescription>
    <Details>
<![CDATA[<p>该代码使用 interned String 进行同步。</p>
<pre><code>private static String LOCK = "LOCK"; ... synchronized(LOCK) {     ... } ... </code></pre>
<p>常量字符串会在 JVM 加载的所有其他类中共享。因此，这段代码在其他代码也可能进行锁定的对象上进行了锁定。这可能会导致非常奇怪且难以诊断的阻塞和死锁行为。请参阅 <a href="http://www.javalobby.org/java/forums/t96352.html">http://www.javalobby.org/java/forums/t96352.html</a> 和 <a href="http://jira.codehaus.org/browse/JETTY-352">http://jira.codehaus.org/browse/JETTY-352</a>。</p>
<p>请参阅 CERT <a href="https://www.securecoding.cert.org/confluence/display/java/CON08-J.+Do+not+synchronize+on+objects+that+may+be+reused">CON08-J. 不要在可能被重复使用的对象上进行同步</a> 获取更多信息。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DL_SYNCHRONIZATION_ON_BOOLEAN">
    <ShortDescription>Boolean同步  Synchronization on Boolean</ShortDescription>
    <LongDescription>在{1}中Boolean的同步</LongDescription>
    <Details>
      <![CDATA[代码使用了一个装箱的基本常量（例如Boolean）进行同步，如下所示：
```java
private static Boolean inited = Boolean.FALSE; ...
synchronized(inited) {
    if (!inited) {   
        init();    
        inited = Boolean.TRUE;   
    } 
} ...
```
由于通常只存在两个Boolean对象，这段代码可能会和其他不相关的代码同步在同一个对象上，从而导致响应性下降甚至出现死锁问题。

更多信息，请参阅CERT的[CON08-J. 不要在可能被重复使用的对象上进行同步](https://www.securecoding.cert.org/confluence/display/java/CON08-J.+Do+not+synchronize+on+objects+that+may+be+reused)。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DL_SYNCHRONIZATION_ON_UNSHARED_BOXED_PRIMITIVE">
    <ShortDescription>同步boxed原始值  Synchronization on boxed primitive values</ShortDescription>
    <LongDescription>在{1}中对齐{2}</LongDescription>
    <Details>
      <![CDATA[代码同步在一个表面上未共享的装箱原始类型上，例如一个`Integer`。

```html
<code>private static final Integer fileLock = new Integer(1); ... synchronized(fileLock) {     .. do something .. } ...</code>
```

在这种情况下，最好将`fileLock`重新声明为

```html
<code>private static final Object fileLock = new Object();</code>
```

现有的代码可能没有问题，但这样做会让人困惑。未来可能会进行“移除装箱”重构（在IntelliJ中），这可能会用一个在整个 JVM 中共享的interned `Integer`对象替换它，从而导致非常混乱的行为和潜在的死锁。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DL_SYNCHRONIZATION_ON_BOXED_PRIMITIVE">
    <ShortDescription>同步化对装箱原始类型  Synchronization on boxed primitive</ShortDescription>
    <LongDescription>在{1}中对齐{2}</LongDescription>
    <Details>
      <![CDATA[代码使用了一个装箱的原始常量（例如，Integer）进行同步。

```java
private static Integer count = 0;
...
synchronized(count) {
    count++;
}
...
```

由于Integer对象可以被缓存和共享，这段代码可能会与其他无关的代码同步在同一个对象上，导致响应性降低甚至可能出现死锁。

更多详情参见CERT [CON08-J. 不要在可能被重用的对象上进行同步](https://www.securecoding.cert.org/confluence/display/java/CON08-J.%20Do+not+synchronize+on+objects+that+may+be+reused)。]]>
    </Details>
  </BugPattern>
  <BugPattern type="ESync_EMPTY_SYNC">
    <ShortDescription>空的同步块  Empty synchronized block</ShortDescription>
    <LongDescription>在{1}中存在空的同步块</LongDescription>
    <Details>
<![CDATA[代码包含一个空的同步块：
```java
synchronized() { }
```
空的同步块远比大多数人认识到的要更加微妙和难以正确使用，并且几乎从来没有比更简单的解决方案更好的情况。]]>
    </Details>
  </BugPattern>
  <BugPattern type="IS_INCONSISTENT_SYNC">
    <ShortDescription>不一致的同步  Inconsistent synchronization</ShortDescription>
    <LongDescription>不一致的同步{1}；锁定{2}%的时间</LongDescription>
    <Details>
<![CDATA[这个类的字段似乎在同步方面不一致地被访问。这个问题报告指出， bug模式检测器判断该模式符合以下条件：
- 该类包含加锁和未加锁的访问混合；
- 至少有一个加锁访问是由该类自己的方法执行的；
- 无同步字段访问（读取和写入）的数量不超过所有访问的三分之一，其中写入的权重是读取的两倍。

一个典型的符合这种bug模式的错误是在打算线程安全的类中忘记同步其中一个方法。

请注意，此检测器存在各种不准确来源；例如，检测器无法静态检测所有持有锁的情况。即使检测器在区分加锁和未加锁访问方面是准确的，所讨论的代码仍然可能是正确的。]]>
    </Details>
  </BugPattern>
  <BugPattern type="ML_SYNC_ON_FIELD_TO_GUARD_CHANGING_THAT_FIELD">
    <ShortDescription>在场上的同步，在徒劳地试图保护那个场地的情况下  Synchronization on field in futile attempt to guard that field</ShortDescription>
    <LongDescription>在{2.givenClass}上进行同步，以无谓地保护它</LongDescription>
    <Details>
<![CDATA[这种方法似乎是在尝试防止同时更新某个字段。但它保护的是字段时，实际上是对引用对象加锁，而不是对字段本身加锁。这可能不能提供你需要的互斥性，并且其他线程可能会以其他目的获取引用对象上的锁。例如：

```java
private Long myNtfSeqNbrCounter = new Long(0);
private Long getNotificationSequenceNumber() {
    Long result = null;
    synchronized (myNtfSeqNbrCounter) {
        result = new Long(myNtfSeqNbrCounter.longValue() + 1);
        myNtfSeqNbrCounter = new Long(result.longValue());
    }
    return result;
}
```]]>
    </Details>
  </BugPattern>
  <BugPattern type="ML_SYNC_ON_UPDATED_FIELD">
    <ShortDescription>方法会同步更新的字段  Method synchronizes on an updated field</ShortDescription>
    <LongDescription>{s1} 同步了更新的字段 {2.givenClass}</LongDescription>
    <Details>
<![CDATA[这种方法会同步一个从可变字段引用的对象。由于不同的线程可能在不同对象上进行同步，这很可能没有有用的语义。]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_OOI_PKGPROTECT">
    <ShortDescription>字段应该从接口中移出，并改为包私有访问修饰符  Field should be moved out of an interface and made package protected</ShortDescription>
    <LongDescription>{1} 应该从接口中移出，并改为包私有访问级别</LongDescription>
    <Details>
<![CDATA[在一个接口中定义的一个最终静态字段引用了一个可变对象，例如数组或哈希表。这个可变对象可能会被恶意代码或从另一个包中的意外操作修改。为了解决这个问题，需要将该字段移到一个类中，并将其改为包私有，以避免这种漏洞。]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_FINAL_PKGPROTECT">
    <ShortDescription>字段应该既是final的，又是包私有访问修饰符  Field should be both final and package protected</ShortDescription>
    <LongDescription>{1} 应该既是最终的又是包私有（包保护）的</LongDescription>
    <Details>
<![CDATA[<p>可变的静态字段可能会被恶意代码或另一包中的意外操作更改。可以将该字段改为包保护级和/或将之设为final以避免此漏洞。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_SHOULD_BE_REFACTORED_TO_BE_FINAL">
    <ShortDescription>字段不是最终的，但应该重构为最终的。  Field isn't final but should be refactored to be so</ShortDescription>
    <LongDescription>{1} 不是最终版本，应该被重构为最终版本。</LongDescription>
    <Details>
<![CDATA[这个静态字段是public但不是final的，因此可能会被恶意代码或意外地从另一个包中更改。可以将该字段设为final以避免这种漏洞。然而，静态初始化器对字段进行了多次写操作，所以这样做需要进行一些重构。]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_SHOULD_BE_FINAL">
    <ShortDescription>字段不是最终的，但应该 是最终的  Field isn't final but should be</ShortDescription>
    <LongDescription>{1} 不是最终的，应当被</LongDescription>
    <Details>
<![CDATA[这个静态字段是public但不是final的，因此可能被恶意代码或意外地从另一个包中更改。可以将该字段设为final以避免这种漏洞。]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_PKGPROTECT">
    <ShortDescription>字段应为包私有保护  Field should be package protected</ShortDescription>
    <LongDescription>{1} 应该是包私有保护</LongDescription>
    <Details>
<![CDATA[一个可变的静态字段可能会被恶意代码或意外更改。可以将该字段改为包私有以避免这个漏洞。]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_MUTABLE_HASHTABLE">
    <ShortDescription>Field 是一个可变的哈希表（Hashtable）。  Field is a mutable Hashtable</ShortDescription>
    <LongDescription>{1} 是一个可变的哈希表（Hashtable）</LongDescription>
    <Details>
<![CDATA[一个最终静态字段引用了一个Hashtable，并且可以被恶意代码或不小心从另一个包中访问。这段代码可以自由修改Hashtable的内容。]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_MUTABLE_COLLECTION">
    <ShortDescription>Field 是一个可变集合  Field is a mutable collection</ShortDescription>
    <LongDescription>{1} 是一个可变集合</LongDescription>
    <Details>
<![CDATA[一个可变集合实例被赋值给一个最终静态字段，因此可能会被恶意代码或不小心从另一个包中更改。考虑使用 `Collections.unmodifiableSet`/`List`/`Map` 等方法将此字段封装起来，以避免这种漏洞。]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_MUTABLE_COLLECTION_PKGPROTECT">
    <ShortDescription>`Field` 是一个可变集合，应该设置为包私有访问级别。  Field is a mutable collection which should be package protected</ShortDescription>
    <LongDescription>{1} 是一个可变集合，应该声明为包私有。</LongDescription>
    <Details>
<![CDATA[<p>一个可变集合实例被分配给了一个最终静态字段，因此可能会被恶意代码或意外地从另一个包中更改。可以将该字段改为包保护级以避免这种漏洞。或者你可以使用 <code>Collections.unmodifiableSet/List/Map/etc.</code> 将这个字段包装起来，从而避免这种漏洞。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_MUTABLE_ARRAY">
    <ShortDescription>Field 是一个可变数组  Field is a mutable array</ShortDescription>
    <LongDescription>{1} 是一个可变数组</LongDescription>
    <Details>
<![CDATA[一个最终静态字段引用了一个数组，并且可以被恶意代码或无意间从另一个包中访问。这段代码可以自由修改数组的内容。]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_CANNOT_BE_FINAL">
    <ShortDescription>字段不是最终的，无法防止恶意代码访问  Field isn't final and can't be protected from malicious code</ShortDescription>
    <LongDescription>{1} 并不最终，并且无法保护恶意代码。</LongDescription>
    <Details>
<![CDATA[一个可变的静态字段可能被恶意代码或另一个包中的意外操作更改。不幸的是，该字段的使用方式并不允许对此问题进行简单的修复。]]>
    </Details>
  </BugPattern>
  <BugPattern type="ME_MUTABLE_ENUM_FIELD">
    <ShortDescription>枚举字段是公共可变的  Enum field is public and mutable</ShortDescription>
    <LongDescription>{1} 字段是公共的且可变的</LongDescription>
    <Details>
<![CDATA[在一个公共枚举内部定义了一个可变的公共字段，因此恶意代码或不小心从另一个包中就可以改变它。虽然可以在枚举字段上使用懒初始化，但将其暴露给外部世界是一个不良实践。考虑将该字段声明为 final 和/或将访问级别改为包私有。]]>
    </Details>
  </BugPattern>
  <BugPattern type="ME_ENUM_FIELD_SETTER">
    <ShortDescription>公共枚举方法无条件地设置其字段  Public enum method unconditionally sets its field</ShortDescription>
    <LongDescription>{1} 无条件地设置字段 {2.name}</LongDescription>
    <Details>
<![CDATA[这个在公共枚举中无条件声明的公共方法会设置枚举字段，因此该字段可能会被恶意代码或意外地从另一个包修改。尽管可变枚举字段可以用于懒加载初始化，但将其暴露给外部世界是一个不良实践。考虑移除此方法或将其实现为包私有方法。]]>
    </Details>
  </BugPattern>
  <BugPattern type="IA_AMBIGUOUS_INVOCATION_OF_INHERITED_OR_OUTER_METHOD">
    <ShortDescription>可能模糊的调用，可能是继承来的或外部的方法  Potentially ambiguous invocation of either an inherited or outer method</ShortDescription>
    <LongDescription>在{1}中可能模棱两可地调用了外部或继承的方法{2}</LongDescription>
    <Details>
<![CDATA[内部类调用的方法既可以解析为从超类继承的方法，也可以解析为外部类中定义的方法。例如，你调用了 `foo(17)`，这个方法在超类和外部方法中都定义了。根据Java语义，它将被解析为调用继承下来的方法，但这可能并不是你的意图。

如果你确实想调用继承下来的方法，请通过super来调用该方法（例如，`super.foo(17)`），这样其他阅读你代码的人以及SpotBugs都能清楚地知道你想调用的是继承下来的方法，而不是外部类中的方法。

如果你调用了 `this.foo(17)`，则会调用继承下来的方法。然而，由于SpotBugs只能分析.class文件，它无法区分`this.foo(17)`和`foo(17)`的调用，因此仍然会抱怨可能存在模棱两可的调用。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_SAME_SIMPLE_NAME_AS_SUPERCLASS">
    <ShortDescription>类名不应屏蔽上级类的简单名称  Class names shouldn't shadow simple name of superclass</ShortDescription>
    <LongDescription>类名 `{0}` � contrasted 名字与超类 `{1}` 的简单名字相同</LongDescription>
    <Details>
<![CDATA[这个类有一个简单的名称，与它的超类的名称相同，只是其超类在不同的包中（例如，`alpha.Foo` 扩展自 `beta.Foo`）。这可能会造成极大的混淆，在很多情况下你需要查看导入语句来解决引用问题，并且会有很多机会不小心定义未覆盖超类方法的方法。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_SAME_SIMPLE_NAME_AS_INTERFACE">
    <ShortDescription>类名不应该遮蔽实现的接口的简单名称  Class names shouldn't shadow simple name of implemented interface</ShortDescription>
    <LongDescription>类名 `{0}` � contrasted 掩盖 了 实现 的 接口 名称 `{1}`</LongDescription>
    <Details>
<![CDATA[这个类/接口具有与实现或继承的接口相同的基本名称，只是接口在不同的包中（例如，`alpha.Foo` 继承自 `beta.Foo`）。这可能会非常令人困惑，在很多情况下你需要查看导入语句来解析引用，并且很容易不小心定义不覆盖超类方法的方法。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_CLASS_NAMING_CONVENTION">
    <ShortDescription>类名应以大写字母开头  Class names should start with an upper case letter</ShortDescription>
    <LongDescription>类名{0}没有以大写字母开头</LongDescription>
    <Details>
<![CDATA[类名应为名词，采用混合大小写的方式，每个内部单词的首字母大写。尽量让类名简单且具有描述性。使用完整的单词，避免使用 acronym 和缩写（除非该缩写比长形式更广泛使用，例如 URL 或 HTML）。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_METHOD_NAMING_CONVENTION">
    <ShortDescription>方法名应该以小写字母开头  Method names should start with a lower case letter</ShortDescription>
    <LongDescription>方法名{1}没有以小写字母开头</LongDescription>
    <Details>
<![CDATA[方法应为动词，采用混合小写和大写的格式，首字母小写，内部单词首字母大写。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_FIELD_NAMING_CONVENTION">
    <ShortDescription>字段名应该以小写字母开头  Field names should start with a lower case letter</ShortDescription>
    <LongDescription>字段名{1}没有以小写字母开头</LongDescription>
    <Details>
<![CDATA[字段名中的非最终字段应采用混合大小写格式，首字母小写，后续单词的首字母大写。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_VERY_CONFUSING">
    <ShortDescription>非常混乱的方法名  Very confusing method names</ShortDescription>
    <LongDescription>方法{1}和方法{3}非常令人困惑。</LongDescription>
    <Details>
<![CDATA[引用的方法名称仅在大小写上有所不同。这非常令人困惑，因为如果大小写也相同，则一个方法会覆盖另一个方法。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_VERY_CONFUSING_INTENTIONAL">
    <ShortDescription>非常混乱的方法名称（但也许是有意而为）  Very confusing method names (but perhaps intentional)</ShortDescription>
    <LongDescription>非常迷惑（可能是故意的）把方法{1}和方法{3}放在一起</LongDescription>
    <Details>
<![CDATA[引用的方法名称仅在大小写上有所不同。这非常令人困惑，因为如果大小写也相同，则其中一个方法会覆盖另一个方法。从其他方法的存在可以看出，这两个方法同时存在似乎是故意的，但确实令人困惑。你应该尽量消除其中的一个，除非由于冻结的API不得不保留两者。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_WRONG_PACKAGE">
    <ShortDescription>方法未在超类中被重写，因为参数的包不对  Method doesn't override method in superclass due to wrong package for parameter</ShortDescription>
    <LongDescription>{1} 没有覆盖超类中的方法，因为参数类型 {4} 不匹配超类的参数类型 {5}</LongDescription>
    <Details>
<![CDATA[子类中的方法并没有覆盖 superclass 中一个相似的方法，因为参数的类型与 superclass 中对应参数的类型并不完全匹配。例如，如果你有以下代码：

```java
import alpha.Foo;
public class A {
    public int f(Foo x) { return 17; }
}
----
import beta.Foo;
public class B extends A {
    public int f(Foo x) { return 42; }
}
```

类 B 中定义的 `f(Foo)` 方法并没有覆盖类 A 中定义的 `f(Foo)` 方法，因为参数类型来自不同的包 (`Foo` 来自 `alpha` 包和 `beta` 包)。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_WRONG_PACKAGE_INTENTIONAL">
    <ShortDescription>方法没有继承超类中的方法，因为参数的包名错误  Method doesn't override method in superclass due to wrong package for parameter</ShortDescription>
    <LongDescription>{1} 没有覆盖超类中的方法，因为参数类型 {4} 不匹配超类中的参数类型 {5}</LongDescription>
    <Details>
<![CDATA[子类中的方法并未覆盖超类中类似的某个方法，因为参数的类型与超类中对应参数的类型并不完全匹配。例如，如果有以下代码：

```java
import alpha.Foo;
public class A {
    public int f(Foo x) { return 17; }
}
---
import beta.Foo;
public class B extends A {
    public int f(Foo x) { return 42; }
    public int f(alpha.Foo x) { return 27; }
}
```

在类 `B` 中定义的 `f(Foo)` 方法并未覆盖类 `A` 中定义的 `f(Foo)` 方法，因为参数类型是来自不同包的 `Foo`。

在这种情况下，子类确实定义了一个与超类中方法签名完全相同的函数，这种情况是可以理解的。然而，这样的方法会非常令人困惑。你应该强烈考虑移除或弃用具有相似但不完全相同的签名的方法。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_CONFUSING">
    <ShortDescription>混淆的方法名称  Confusing method names</ShortDescription>
    <LongDescription>有方法{1}和{3}让人感到困惑</LongDescription>
    <Details>
<![CDATA[引用的方法名称仅在大小写上有所不同。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_METHOD_CONSTRUCTOR_CONFUSION">
    <ShortDescription>显式的方 法/构造器混淆  Apparent method/constructor confusion</ShortDescription>
    <LongDescription>{1}很可能被设计为一个构造函数</LongDescription>
    <Details>
<![CDATA[<p>这个常规方法与定义它的类同名。很可能这是打算作为构造函数的。如果确实打算将其作为构造函数，那么应移除返回值为void的声明。如果你不小心定义了这个方法，意识到错误后定义了一个正确的构造函数但因向后兼容的原因无法删除此方法，可以废弃该方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_LCASE_HASHCODE">
    <ShortDescription>class 中的 `hashcode()` 应该是 `hashCode()`？  Class defines hashcode(); should it be hashCode()?</ShortDescription>
    <LongDescription>类 `{0}` 定义了 `hashcode()`；应该写成 `hashCode()` 吗？</LongDescription>
    <Details>
<![CDATA[这个类定义了一个名为 `hashcode()` 的方法。这个方法并没有重写来自 `java.lang.Object` 的 `hashCode()` 方法，这可能是原本想要实现的功能。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_LCASE_TOSTRING">
    <ShortDescription>class中定义tostring(); 应该写成toString()？  Class defines tostring(); should it be toString()?</ShortDescription>
    <LongDescription>类 `{0}` 定义了 `tostring()`；它应该写成 `toString()` 吗？</LongDescription>
    <Details>
<![CDATA[这个类定义了一个名为 `<code>tostring()</code>` 的方法。该方法没有覆盖 `java.lang.Object` 中的 `toString()` 方法，这可能是开发者本意要做的。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_BAD_EQUAL">
    <ShortDescription>类定义equal(Object)；应该写成equals(Object)吗？  Class defines equal(Object); should it be equals(Object)?</ShortDescription>
    <LongDescription>类 `{0}` 定义了 `equal(Object)`；应该使用 `equals(Object)` 吗？</LongDescription>
    <Details>
<![CDATA[这个类定义了一个方法 `equal(Object)`。该方法并没有覆盖来自 `java.lang.Object` 的 `equals(Object)` 方法，这可能是开发者原本的意图。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_CLASS_NOT_EXCEPTION">
    <ShortDescription>类虽然名为异常类，但实际上并没有继承自Exception。  Class is not derived from an Exception, even though it is named as such</ShortDescription>
    <LongDescription>类 `{0}` 没有继承自异常，尽管它的名字听起来像是一个异常。</LongDescription>
    <Details>
<![CDATA[这个类没有继承其他异常，但却以'Exception'结尾。这会让使用这个类的用户感到困惑。]]>
    </Details>
  </BugPattern>
  <BugPattern type="RR_NOT_CHECKED">
    <ShortDescription>方法忽略了InputStream.read()的方法结果  Method ignores results of InputStream.read()</ShortDescription>
    <LongDescription>{1} 忽视了{2}的结果</LongDescription>
    <Details>
<![CDATA[这种方法忽略了 `java.io.InputStream.read()` 的返回值，而该方法可以返回多个字节。如果不检查返回值，调用者将无法正确处理读取的字节数少于请求字节数的情况。这是一种特别危险的 bug，因为在许多程序中，从输入流读取通常会读取完整的数据量，导致程序仅偶尔失败。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SR_NOT_CHECKED">
    <ShortDescription>方法忽略了InputStream.skip()的方法结果  Method ignores results of InputStream.skip()</ShortDescription>
    <LongDescription>{1} 忽视了{2}的结果</LongDescription>
    <Details>
<![CDATA[这种方法忽略了 `java.io.InputStream.skip()` 的返回值，该方法可以跳过多个字节。如果不检查返回值，调用者将无法正确处理实际跳过的字节数少于请求的字节数的情况。这是一种特别危险的bug，因为在许多程序中，从输入流进行跳过操作通常会跳过全部请求的数据，从而使程序仅在某些情况下失败。然而，在使用缓冲流的情况下，`skip()` 只会在缓存中跳过数据，并经常无法跳过请求的字节数。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_READ_RESOLVE_IS_STATIC">
    <ShortDescription>readResolve 方法不能声明为静态方法。  The readResolve method must not be declared as a static method.</ShortDescription>
    <LongDescription>{1} 应该声明为实例方法而不是静态方法</LongDescription>
    <Details>
<![CDATA[为了使readResolve方法被序列化机制识别，它不能声明为静态方法。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_PRIVATE_READ_RESOLVE_NOT_INHERITED">
    <ShortDescription>私有readResolve方法不会被子类继承  Private readResolve method not inherited by subclasses</ShortDescription>
    <LongDescription>在{0}中私有的readResolve方法未被子类继承。</LongDescription>
    <Details>
<![CDATA[这个类定义了一个私有的 `readResolve` 方法。由于它是私有的，不会被子类继承。这可能是有意为之并且是可以接受的，但应该进行审查以确保这是预期的行为。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_READ_RESOLVE_MUST_RETURN_OBJECT">
    <ShortDescription>readResolve方法必须声明为返回类型为Object。  The readResolve method must be declared with a return type of Object.</ShortDescription>
    <LongDescription>方法 {1} 必须声明为返回类型为 Object 而不是 {1.returnType}</LongDescription>
    <Details>
<![CDATA[为了使readResolve方法被序列化机制识别，它必须声明为返回类型为Object。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_TRANSIENT_FIELD_OF_NONSERIALIZABLE_CLASS">
    <ShortDescription> transient 类变量且该类不实现Serializable接口。  Transient field of class that isn't Serializable.</ShortDescription>
    <LongDescription>{1.givenClass} 是transient的，但{0} 不是Serializable的。</LongDescription>
    <Details>
<![CDATA[<p>该字段被标记为transient，但类并未实现Serializable接口，因此将字段标记为transient完全没有效果。这可能是之前版本的代码中类为transient遗留下来的标记，或者表明对序列化的工作原理存在误解。</p>
<p><em>只有当设置了特殊选项<tt>reportTransientFieldOfNonSerializableClass</tt>时才会报告此错误。</em></p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_TRANSIENT_FIELD_NOT_RESTORED">
    <ShortDescription> transient 字段且未由反序列化设置。  Transient field that isn't set by deserialization.</ShortDescription>
    <LongDescription>字段 {1} 是瞬态的，但在反序列化时并未设置。</LongDescription>
    <Details>
<![CDATA[这个类包含一个在多个地方被更新的字段，因此似乎它是类状态的一部分。然而，由于该字段被标记为transient，并且不在readObject或readResolve中设置，任何从序列化实例反序列化的对象都会包含该字段的默认值。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_METHOD_MUST_BE_PRIVATE">
    <ShortDescription>方法必须是私有的，以便序列化能够正常工作。  Method must be private in order for serialization to work</ShortDescription>
    <LongDescription>方法 `{1.givenClass}` 必须是私有方法，才能在反序列化/{0}的序列化/反序列化过程中被调用</LongDescription>
    <Details>
<![CDATA[这个类实现了 `Serializable` 接口，并定义了一个自定义序列化/反序列化的方法。但由于该方法没有声明为私有，因此在序列化/反序列化API中将会被默默地忽略。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION">
    <ShortDescription>类实现了Externalizable接口，但没有定义无参构造方法。  Class is Externalizable but doesn't define a void constructor</ShortDescription>
    <LongDescription>{0} 实现了 Externalizable 接口，但没有定义无参构造函数</LongDescription>
    <Details>
<![CDATA[这个类实现了 `Externalizable` 接口，但没有定义一个公共空参数构造函数。当反序列化 `Externalizable` 对象时，它们首先需要通过调用公共空参数构造函数来构建。由于这个类没有任何这样的构造函数，因此在运行时进行序列化和反序列化将会失败。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NO_SUITABLE_CONSTRUCTOR">
    <ShortDescription>类是可序列化的，但其超类没有定义无参构造函数。  Class is Serializable but its superclass doesn't define a void constructor</ShortDescription>
    <LongDescription> `{0}` 实现了可序列化，但其超类没有定义可访问的无参构造函数。</LongDescription>
    <Details>
<![CDATA[这个类实现了 `Serializable` 接口，而其超类却没有实现。当这样的对象被反序列化时，需要通过调用超类的无参构造函数来初始化超类的字段。由于超类没有无参构造函数，因此在运行时序列化和反序列化将会失败。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NO_SERIALVERSIONID">
    <ShortDescription>类是可序列化的，但没有定义serialVersionUID  Class is Serializable, but doesn't define serialVersionUID</ShortDescription>
    <LongDescription>`{0}` 是可序列化的；考虑声明一个 `serialVersionUID`。</LongDescription>
    <Details>
<![CDATA[这个类实现了 `Serializable` 接口，但没有定义 `serialVersionUID` 字段。简单的更改如添加一个 `.class` 对象的引用将会向类中添加合成字段，不幸的是这会改变隐式的 `serialVersionUID`（例如，添加对 `String.class` 的引用将生成一个静态字段 `class$java$lang$String`）。此外，不同的源代码到字节码编译器可能会使用不同的命名约定为对象引用或内部类生成的合成变量命名。为了确保不同版本间的可互操作性，请考虑显式地添加一个 `serialVersionUID`。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_COMPARATOR_SHOULD_BE_SERIALIZABLE">
    <ShortDescription>Comparator 不实现Serializable接口  Comparator doesn't implement Serializable</ShortDescription>
    <LongDescription>{0} 实现了 Comparator 但没有实现 Serializable</LongDescription>
    <Details>
<![CDATA[这个类实现了 `Comparator` 接口。你应该考虑一下它是否也应该实现 `Serializable` 接口。如果使用比较器来构建有序集合（例如 `TreeMap`），那么只有当比较器也是可序列化的时候，`TreeMap` 才是可序列化的。因为大多数比较器几乎没有或根本没有状态，使其可序列化通常是比较容易的，并且也是一种良好的防御性编程实践。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SF_SWITCH_FALLTHROUGH">
    <ShortDescription>在switch语句中发现一个case掉到了下一个case里  Switch statement found where one case falls through to the next case</ShortDescription>
    <LongDescription>在 `{1}` 中找到了一个switch语句，其中某个case没有显式返回直接跳到了下一个case。</LongDescription>
    <Details>
<![CDATA[这个方法包含一个 switch 语句，其中一种情况的分支会fall through 到下一个 case。通常你需要在这个 case 的末尾加上 break 或者 return。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SF_SWITCH_NO_DEFAULT">
    <ShortDescription>在缺少默认（default）情况的switch语句中找到了switch语句。  Switch statement found where default case is missing</ShortDescription>
    <LongDescription>在{1}中找到了switch语句，但缺少default情况。</LongDescription>
    <Details>
<![CDATA[这个方法包含一个缺少默认情况（default case）的switch语句。通常你需要提供一个默认情况。
由于分析只检查生成的字节码，因此如果默认情况位于switch语句末尾且该switch语句没有其他情况的break语句，则此警告可能会被错误触发。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH">
    <ShortDescription>由于switch语句的穿透导致的死存储  Dead store due to switch statement fall through</ShortDescription>
    <LongDescription>值 `{2.givenClass}` 从上一个案例中被在这里由于开关语句的延续而覆盖了。</LongDescription>
    <Details>
<![CDATA[在一个switch语句中，由于发生了switch fall through，这里存储的值会覆盖掉之前switch case中的值。你可能忘记在之前的case后面加上break或return了。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH_TO_THROW">
    <ShortDescription>由于switch语句跳过导致的死.store  Dead store due to switch statement fall through to throw</ShortDescription>
    <LongDescription>从之前的案例中，{2.givenClass} 的值在这里由于switch语句的fall through到throw丢失了。</LongDescription>
    <Details>
<![CDATA[在一个switch语句中，由于发生了switch fall through，并且在某个地方抛出了异常，因此之前case中的值在这里被忽略。很可能你在之前的case结尾忘记添加break或return了。]]>
    </Details>
  </BugPattern>
  <BugPattern type="WS_WRITEOBJECT_SYNC">
    <ShortDescription>class的writeObject()方法是同步的，但除此之外nothing else是同步的。  Class's writeObject() method is synchronized but nothing else is</ShortDescription>
    <LongDescription>{0}的writeObject方法是同步的，但其他方法都不是。</LongDescription>
    <Details>
<![CDATA[这个类有一个`synchronized`的`writeObject()`方法；然而，该类的其他方法都没有同步。]]>
    </Details>
  </BugPattern>
  <BugPattern type="RS_READOBJECT_SYNC">
    <ShortDescription>类的readObject()方法是同步的  Class's readObject() method is synchronized</ShortDescription>
    <LongDescription>{0}的readObject方法是同步的</LongDescription>
    <Details>
<![CDATA[这个可序列化的类定义了一个`synchronized`的`readObject()`方法。根据定义，通过反序列化创建的对象只可达一个线程，因此不需要将`readObject()`同步化。如果`readObject()`方法本身导致对象变得可见于另一个线程，那是一种非常可疑的编程风格。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NONSTATIC_SERIALVERSIONID">
    <ShortDescription>serialVersionUID 不是静态的  serialVersionUID isn't static</ShortDescription>
    <LongDescription>{1} 不是静态的</LongDescription>
    <Details>
<![CDATA[这个类定义了一个非静态的 `serialVersionUID` 字段。如果打算将该字段指定为序列化时的版本UID，那么应该将其声明为静态的。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NONFINAL_SERIALVERSIONID">
    <ShortDescription>serialVersionUID 不是 final  serialVersionUID isn't final</ShortDescription>
    <LongDescription>{1} 不是最终的</LongDescription>
    <Details>
<![CDATA[这个类定义了一个非final的`serialVersionUID`字段。如果打算为此序列化指定版本UID，应该将该字段设为final。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NONLONG_SERIALVERSIONID">
    <ShortDescription>serialVersionUID 不是 long 类型  serialVersionUID isn't long</ShortDescription>
    <LongDescription>{1} 不长</LongDescription>
    <Details>
<![CDATA[这个类定义了一个不是long类型的`serialVersionUID`字段。如果打算将该字段用于序列化版本UID的指定，应该将其改为long类型。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_BAD_FIELD">
    <ShortDescription>可序列化类中的非瞬时非序列化实例字段  Non-transient non-serializable instance field in serializable class</ShortDescription>
    <LongDescription>类 {0} 定义了非暂存且不可序列化的实例字段 {1.name}</LongDescription>
    <Details>
<![CDATA[这个可序列化类定义了一个非原始实例字段，该字段既不是transient、Serializable或`java.lang.Object`，也没有实现`Externalizable`接口或`readObject()`和`writeObject()`方法。如果在这个字段中存储了非序列化对象，那么此类的对象在反序列化时将无法正确解析。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_BAD_FIELD_INNER_CLASS">
    <ShortDescription>非序列化类包含一个可序列化的内部类  Non-serializable class has a serializable inner class</ShortDescription>
    <LongDescription>{\0}是可以序列化的，但同时也是非序列化类的内部类。</LongDescription>
    <Details>
<![CDATA[这个可序列化的类是某个非可序列化类的内部类。因此，尝试序列化它时也会试图将与之关联的外部类实例一起序列化，从而导致运行时错误。  
如果可能的话，将内部类改为静态内部类可以解决问题。使外部类可序列化也可能解决这个问题，但那样做意味着每次序列化内部类实例时都会同时序列化外部类实例，这通常不是你真正想要的结果。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_INNER_CLASS">
    <ShortDescription>可序列化的内部类  Serializable inner class</ShortDescription>
    <LongDescription>{0}是可以序列化并且是一个内部类</LongDescription>
    <Details>
<![CDATA[这个可序列化类是一个内部类。任何尝试序列化它的行为也将序列化相关的外部实例。外部实例是可序列化的，所以这不会失败，但可能会序列化比预期更多的数据。如果可能的话，将内部类改为静态内部类（也称为嵌套类）应该可以解决问题。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_BAD_FIELD_STORE">
    <ShortDescription>可序列化的类中实例字段存储了不可序列化的值  Non-serializable value stored into instance field of a serializable class</ShortDescription>
    <LongDescription>{2} 存入了非易失性字段 {1.givenClass}</LongDescription>
    <Details>
<![CDATA[一个非序列化值被存储到了可序列化类的一个非瞬态字段中。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SC_START_IN_CTOR">
    <ShortDescription>构造函数调用了Thread.start()  Constructor invokes Thread.start()</ShortDescription>
    <LongDescription>{1} 启动了 {2}</LongDescription>
    <Details>
<![CDATA[构造函数启动了一个线程。如果类被扩展或子类化，这可能是错误的，因为线程将在子类构造函数启动之前启动。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SS_SHOULD_BE_STATIC">
    <ShortDescription>未读字段：这个字段应该设置为静态吗？  Unread field: should this field be static?</ShortDescription>
    <LongDescription>未读字段：{1}；这个字段应该设置为静态吗？</LongDescription>
    <Details>
<![CDATA[这个类包含一个实例最终字段，该字段初始化为编译时静态值。考虑将该字段声明为静态。]]>
    </Details>
  </BugPattern>
  <BugPattern type="UUF_UNUSED_FIELD">
    <ShortDescription>未使用的字段  Unused field</ShortDescription>
    <LongDescription>未使用字段：{1}</LongDescription>
    <Details>
<![CDATA[这个字段从未使用过。考虑从类中移除它。]]>
    </Details>
  </BugPattern>
  <BugPattern type="URF_UNREAD_FIELD">
    <ShortDescription>未读字段  Unread field</ShortDescription>
    <LongDescription>未读字段：{1}</LongDescription>
    <Details>
<![CDATA[这个字段从未被读取。考虑从类中移除它。]]>
    </Details>
  </BugPattern>
  <BugPattern type="UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD">
    <ShortDescription>未使用的公共或保护字段  Unused public or protected field</ShortDescription>
    <LongDescription>未使用的公共或保护字段：{1}</LongDescription>
    <Details>
<![CDATA[这个字段从未使用过。该字段是公共的或保护的，或许它是打算与其他在分析范围之外的类一起使用的。如果不是这种情况，可以考虑从类中移除它。]]>
    </Details>
  </BugPattern>
  <BugPattern type="URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD">
    <ShortDescription>未读公共/受保护字段  Unread public/protected field</ShortDescription>
    <LongDescription>未读公共/受保护字段：{1}</LongDescription>
    <Details>
<![CDATA[这个字段从未被读取。该字段是公有的或受保护的，也许它是打算与其他分析中未见到的类一起使用。如果不是这样，可以考虑从类中移除它。]]>
    </Details>
  </BugPattern>
  <BugPattern type="QF_QUESTIONABLE_FOR_LOOP">
    <ShortDescription>复杂的、微妙的或错误的for循环增量  Complicated, subtle or wrong increment in for-loop</ShortDescription>
    <LongDescription>复杂的、微妙的或错误的for-loop增量{1}</LongDescription>
    <Details>
<![CDATA[你确定这个for循环是正确递增了变量吗？看来另一个变量可能被for循环初始化和检查了。]]>
    </Details>
  </BugPattern>
  <BugPattern type="UWF_NULL_FIELD">
    <ShortDescription>字段仅被设置为null  Field only ever set to null</ShortDescription>
    <LongDescription>字段仅被设置为null：{1}</LongDescription>
    <Details>
<![CDATA[所有对该字段的写操作都是常量值null，因此对该字段的所有读取都将返回null。检查是否有错误，或者如果这个字段没有用处就移除它。]]>
    </Details>
  </BugPattern>
  <BugPattern type="UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD">
    <ShortDescription>未定义的公共或受保护字段  Unwritten public or protected field</ShortDescription>
    <LongDescription>未定义的公共或受保护字段：{1}</LongDescription>
    <Details>
<![CDATA[没有对该公共/保护字段进行写操作。所有对其的读取都将返回默认值。请检查是否存在错误（它应该已经被初始化了吗？），或者如果它是无用的，可以将其删除。]]>
    </Details>
  </BugPattern>
  <BugPattern type="UWF_UNWRITTEN_FIELD">
    <ShortDescription>未写明字段  Unwritten field</ShortDescription>
    <LongDescription>未填写字段：{1}</LongDescription>
    <Details>
<![CDATA[这个字段从未被写入。所有对该字段的读取都会返回默认值。检查是否有错误（它是否已被初始化？），如果没有用处，可以将其删除。]]>
    </Details>
  </BugPattern>
  <BugPattern type="ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD">
    <ShortDescription>从实例方法写入静态字段  Write to static field from instance method</ShortDescription>
    <LongDescription>从实例方法{1}写入静态字段{2}</LongDescription>
    <Details>
<![CDATA[这个实例方法写入了一个静态字段。如果多个实例被同时操作，这会很难正确实现，并且通常不是一个好的实践。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_LOAD_OF_KNOWN_NULL_VALUE">
    <ShortDescription>已知的空值负载  Load of known null value</ShortDescription>
    <LongDescription>在{1}中有已知的空值负载</LongDescription>
    <Details>
<![CDATA[在这个点引用的变量已知为null，因为之前对其进行过一次null检查。虽然这是有效的，但这可能是一个错误（也许你应该引用的是另一个变量，或者之前的检查应该是检查该变量是否不为null）。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_DEREFERENCE_OF_READLINE_VALUE">
    <ShortDescription>读取行的结果未进行空检查解引用  Dereference of the result of readLine() without nullcheck</ShortDescription>
    <LongDescription>在{1}中，readLine()结果的解引用没有进行空检查</LongDescription>
    <Details>
<![CDATA[调用readLine()的方法返回值在未检查是否为null的情况下被解引用。如果不再有可读取的文本行，readLine()将返回null，并且解引这个null将会生成空指针异常。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_IMMEDIATE_DEREFERENCE_OF_READLINE">
    <ShortDescription>readLine()的结果的立即间接引用  Immediate dereference of the result of readLine()</ShortDescription>
    <LongDescription>在{1}中立即解引用readLine()的结果</LongDescription>
    <Details>
<![CDATA[调用readLine()的方法立即解除引用。如果没有任何更多的文本行可读，readLine()将返回null，并且对该null值进行解除引用会产生空指针异常。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_UNWRITTEN_FIELD">
    <ShortDescription>读取未定义字段  Read of unwritten field</ShortDescription>
    <LongDescription>在{1}中读取未写入的字段 {2.name}</LongDescription>
    <Details>
<![CDATA[该程序正在解引用一个似乎从未被写入非空值的字段。除非该字段是通过分析未看到的一些机制初始化的，否则解引用这个值将会生成空指针异常。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD">
    <ShortDescription>读取未定义的公共或受保护字段  Read of unwritten public or protected field</ShortDescription>
    <LongDescription>在{1}中读取未定义的公共或受保护字段{2.name}</LongDescription>
    <Details>
<![CDATA[该程序正在反初始化一个公共或受保护的字段，而这个字段似乎从未被写入过非空值。除非该字段是通过分析未见的机制初始化的，否则反初始化这个值会导致空指针异常。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIC_THREADLOCAL_DEADLY_EMBRACE">
    <ShortDescription>非静态内部类和线程局部变量的致命拥抱  Deadly embrace of non-static inner class and thread local</ShortDescription>
    <LongDescription>{0} 需要被声明为 _static_ 以避免与 {1} 之间的致命拥抱</LongDescription>
    <Details>
<![CDATA[这个类是一个内部类，但很可能应该被定义为静态内部类。由于它不是静态的，内部类保留了对外部类的引用。如果外部类中的线程局部变量包含对内部类实例的引用，那么内外两个对象都会变得可达，并且无法进行垃圾回收。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIC_INNER_SHOULD_BE_STATIC">
    <ShortDescription>应该是一个静态内部类  Should be a static inner class</ShortDescription>
    <LongDescription>{0}应该是一个静态内部类吗？</LongDescription>
    <Details>
<![CDATA[这个类是一个内部类，但并不使用嵌入的对象引用。这个引用使得该类的实例更大，并且可能使对该创建者对象的引用保持存活时间比必要的时间更长。如果可能的话，应该将该类声明为静态类。]]>
    </Details>
  </BugPattern>
  <BugPattern type="UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR">
    <ShortDescription>字段在构造函数中未初始化但未经null检查就被解引用了。  Field not initialized in constructor but dereferenced without null check</ShortDescription>
    <LongDescription>在构造函数中未初始化的{1.givenClass}在{2}中被间接使用</LongDescription>
    <Details>
<![CDATA[这个字段在任何构造函数中都没有被初始化，因此在对象构建后可能会是空的（null）。而在其他地方，它会被加载并去引用而没有进行空检查。这可能是错误或者是有争议的设计，因为这意味着如果在该字段被初始化之前对其进行引用，则会产生空指针异常。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIC_INNER_SHOULD_BE_STATIC_ANON">
    <ShortDescription>可以重构为一个命名的静态内部类  Could be refactored into a named static inner class</ShortDescription>
    <LongDescription>该类 `{0}` 可以重构为一个命名的 `_static_ 内部类`。</LongDescription>
    <Details>
<![CDATA[这个类是一个内部类，但并不使用其嵌入的对象引用。这个引用会使该类的实例变大，并可能使对该创建者对象的引用保持存活时间比必要的时间更长。如果可能的话，应该将这个类改为静态内部类。由于匿名内部类不能标记为静态，因此这需要重构内部类，使其成为命名的内部类。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS">
    <ShortDescription>可以重构为静态内部类  Could be refactored into a static inner class</ShortDescription>
    <LongDescription>该类 `{0}` 可以重构为一个 `_static_` 内部类</LongDescription>
    <Details>
<![CDATA[这个类是一个内部类，但在构造内部对象时除了在构造期间外，并未使用来自创建它的对象的引用。该引用使得此类的实例变大，并可能使对外部对象的引用保持活性的时间比必要的时间更长。如果可能的话，应该将此类改造成静态内部类。由于在构造内部实例时需要对外部对象的引用，因此内部类需要进行重构，以通过构造函数传递对外部实例的引用。]]>
    </Details>
  </BugPattern>
  <BugPattern type="WA_NOT_IN_LOOP">
    <ShortDescription>等待，不要在循环中  Wait not in loop</ShortDescription>
    <LongDescription>等待，不要在循环中{1}</LongDescription>
    <Details>
<![CDATA[这段方法包含对 `<code>java.lang.Object.wait()</code>` 的调用，但该调用不在循环中。如果监控器用于多个条件，则实际发生的条件可能并不是调用者期望等待的条件。]]>
    </Details>
  </BugPattern>
  <BugPattern type="WA_AWAIT_NOT_IN_LOOP">
    <ShortDescription>Condition.await() 不在循环中  Condition.await() not in loop</ShortDescription>
    <LongDescription>Condition.await() 不在 {1} 循环中</LongDescription>
    <Details>
<![CDATA[这个方法包含对 `<code>java.util.concurrent.await()</code>`（或其变体）的调用，但该调用不在循环中。如果对象用于多个条件，则实际发生的可能是呼叫者并未期望的那个条件。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NO_NOTIFY_NOT_NOTIFYALL">
    <ShortDescription>使用notify()而不是notifyAll()  Using notify() rather than notifyAll()</ShortDescription>
    <LongDescription>在{1}中使用notify而非notifyAll</LongDescription>
    <Details>
<![CDATA[这种方法调用了`notify()`而不是`notifyAll()`。Java监视器通常用于处理多个条件。调用`notify()`只会唤醒一个线程，这意味着被唤醒的线程可能并不是刚刚被满足条件所等待的那个线程。]]>
    </Details>
  </BugPattern>
  <BugPattern type="UC_USELESS_VOID_METHOD">
    <ShortDescription>无用的非空虚空方法  Useless non-empty void method</ShortDescription>
    <LongDescription>方法{1}似乎没用</LongDescription>
    <Details>
<![CDATA[我们的分析显示，这个非空的空方法实际上并没有执行任何有用的工作。请检查一下：很可能代码中有错误，或者其内容可以完全删除。

我们尽量减少误报的数量，但在某些情况下这种警告可能是错误的。常见的误报情况包括：

- 该方法旨在触发加载某个类，而这个类可能会有一些副作用。
- 该方法旨在隐式抛出一些不明显的异常。]]>
    </Details>
  </BugPattern>
  <BugPattern type="UC_USELESS_CONDITION">
    <ShortDescription>条件没有效果  Condition has no effect</ShortDescription>
    <LongDescription>无用的条件：已知{2}此时</LongDescription>
    <Details>
<![CDATA[这个条件总是会产生与之前被缩小的变量值相同的结果。可能是另有其他意思，或者这个条件可以被移除。]]>
    </Details>
  </BugPattern>
  <BugPattern type="UC_USELESS_CONDITION_TYPE">
    <ShortDescription>条件由于变量类型的原因没有生效  Condition has no effect due to the variable type</ShortDescription>
    <LongDescription>无用的条件：它总是{2}，因为变量类型是{3}</LongDescription>
    <Details>
<![CDATA[这个条件总是产生相同的结果，因为涉及的变量类型范围所致。可能是另有其他含义，或者这个条件可以被移除。]]>
    </Details>
  </BugPattern>
  <BugPattern type="UC_USELESS_OBJECT">
    <ShortDescription>无用的对象创建  Useless object created</ShortDescription>
    <LongDescription>变量{2}中存储的无用对象在方法{1}中</LongDescription>
    <Details>
<![CDATA[我们的分析显示这个对象是无用的。它被创建并修改，但其值从未超出方法范围或产生任何副作用。要么是出现了错误，该对象本应被使用，要么它可以被移除。
这种分析很少产生误报。常见的误报情况包括：
- 这个对象曾隐式抛出过某些不显眼的异常。
- 这个对象用作占位符以泛化代码。
- 这个对象用于持有对弱引用或软引用对象的强引用。]]>
    </Details>
  </BugPattern>
  <BugPattern type="UC_USELESS_OBJECT_STACK">
    <ShortDescription>在栈上创建的无用对象  Useless object created on stack</ShortDescription>
    <LongDescription>在方法{1}中创建的无用对象</LongDescription>
    <Details>
<![CDATA[这个对象只是为了执行一些没有副作用的修改。可能是原本有其他意图，或者这个对象可以被移除。]]>
    </Details>
  </BugPattern>
  <BugPattern type="RANGE_ARRAY_INDEX">
    <ShortDescription>数组索引越界  Array index is out of bounds</ShortDescription>
    <LongDescription>数组索引越界：{3}</LongDescription>
    <Details>
<![CDATA[数组操作已完成，但数组索引越界，这将在运行时导致ArrayIndexOutOfBoundsException。]]>
    </Details>
  </BugPattern>
  <BugPattern type="RANGE_ARRAY_OFFSET">
    <ShortDescription>数组下标越界  Array offset is out of bounds</ShortDescription>
    <LongDescription>数组偏移量越界：{3}</LongDescription>
    <Details>
<![CDATA[方法带数组参数和偏移量参数被调用，但偏移量超出了范围。这将在运行时导致IndexOutOfBoundsException异常。]]>
    </Details>
  </BugPattern>
  <BugPattern type="RANGE_ARRAY_LENGTH">
    <ShortDescription>数组长度越界  Array length is out of bounds</ShortDescription>
    <LongDescription>数组长度越界：{3}</LongDescription>
    <Details>
<![CDATA[方法带数组参数和长度参数被调用，但长度超出范围。这将在运行时导致索引越界异常（IndexOutOfBoundsException）。]]>
    </Details>
  </BugPattern>
  <BugPattern type="RANGE_STRING_INDEX">
    <ShortDescription>字符串索引超出范围  String index is out of bounds</ShortDescription>
    <LongDescription>在调用{5}:{3}时，字符串索引越界。</LongDescription>
    <Details>
<![CDATA[字符串方法被调用，但指定的字符串索引超出范围。这将在运行时导致StringIndexOutOfBoundsException异常。]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_CHECK_FOR_POSITIVE_INDEXOF">
    <ShortDescription>方法检查String.indexOf的结果是否为正数  Method checks to see if result of String.indexOf is positive</ShortDescription>
    <LongDescription>{1} 检查 `String.indexOf` 的结果是否为正数</LongDescription>
    <Details>
<![CDATA[该方法调用了String.indexOf，并检查其结果是否为正数或非正数。通常的做法是检查结果是否为负数或非负数。只有当要查找的子字符串出现在字符串中除开头之外的位置时，结果才是正数。]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_DONT_JUST_NULL_CHECK_READLINE">
    <ShortDescription>方法在检查readLine返回的值是否非空后，丢弃了其返回值。  Method discards result of readLine after checking if it is non-null</ShortDescription>
    <LongDescription>{1} 在检查readLine是否非空后丢弃其结果</LongDescription>
    <Details>
<![CDATA[读取返回的值在检查其是否非空后会被丢弃。几乎在所有情况下，如果结果是非空的，你将希望使用这个非空值。再次调用readLine会给你不同的行。]]>
    </Details>
  </BugPattern>

  <BugPattern type="RV_RETURN_VALUE_IGNORED_INFERRED">
    <ShortDescription>这种方法忽略了返回值，这可以接受吗？  Method ignores return value, is this OK?</ShortDescription>
    <LongDescription>在{1}中，{2.givenClass}的返回值被忽略，这样可以吗？</LongDescription>
    <Details>
<![CDATA[这段代码调用了一个方法并忽略了返回值。返回值与调用该方法的对象类型相同，从我们的分析来看，返回值可能是重要的（例如，类似于忽略 `String.toLowerCase()` 的返回值）。

我们只是简单地从方法体的分析中猜测忽略返回值可能不是一个好主意。你可以使用 `@CheckReturnValue` 注解来指示 SpotBugs 你是否认为忽略此方法的返回值是重要或可接受的。

请仔细调查，决定是否可以忽略该返回值。]]>
    </Details>
  </BugPattern>

  <BugPattern type="RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT">
    <ShortDescription>方法带有副作用的返回值被忽略了  Return value of method without side effect is ignored</ShortDescription>
    <LongDescription>{2.givenClass} 方法的返回值被忽略，但该方法没有副作用</LongDescription>
    <Details>
<![CDATA[这段代码调用了一个方法并忽略了返回值。然而，我们的分析显示该方法（包括其在任何子类中的实现）除了返回值外没有任何其他效果。因此可以移除这个调用。

我们尽量减少误报的数量，但在某些情况下这种警告可能是错误的。常见的误报情况包括：

- 该方法设计为被重写并在其他项目中产生副作用，而这些项目超出了分析的范围。
- 调用该方法是为了触发类加载，这可能会产生一些副作用。
- 调用该方法只是为了引发某些异常。

如果你认为我们的假设是错误的，你可以使用@CheckReturnValue注解来指示SpotBugs忽略对该方法返回值的忽视是可接受的。]]>
    </Details>
  </BugPattern>

  <BugPattern type="RV_RETURN_VALUE_IGNORED">
    <ShortDescription>方法忽略了返回值  Method ignores return value</ShortDescription>
    <LongDescription>在{1}中，{2.givenClass}的方法返回值被忽略掉了</LongDescription>
    <Details>
<![CDATA[该方法的返回值应当被检查。这种警告的一个常见原因是，在认为某个方法会更新对象的情况下对不可变对象调用方法。例如，在下面的代码片段中：

```java
String dateString = getHeaderField(name);
dateString.trim();
```

程序员似乎以为 `trim()` 方法会更新由 `dateString` 引用的字符串。但由于字符串是不可变的，`trim()` 函数返回一个新的字符串值，并在这里被忽略了。代码应当修正为：

```java
String dateString = getHeaderField(name);
dateString = dateString.trim();
```]]>
    </Details>
  </BugPattern>


  <BugPattern type="RV_RETURN_VALUE_IGNORED_BAD_PRACTICE">
    <ShortDescription>方法忽略了异常的返回值  Method ignores exceptional return value</ShortDescription>
    <LongDescription>在{1}中忽略了{2}的异常返回值</LongDescription>
    <Details>
<![CDATA[这种方法返回一个未经检查的值。应该检查返回值，因为它们可以指示异常或意外的功能执行。例如，`File.delete()` 方法如果文件未能成功删除会返回 `false`（而不是抛出异常）。如果不检查结果，你将无法注意到方法调用通过返回非典型返回值信号了异常行为。]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_CHECK_COMPARETO_FOR_SPECIFIC_RETURN_VALUE">
    <ShortDescription>代码检查由compareTo方法返回的特定值  Code checks for specific values returned by compareTo</ShortDescription>
    <LongDescription>检查{2.givenClass}的返回值是否等于{3}</LongDescription>
    <Details>
<![CDATA[这段代码调用了compareTo或compare方法，并检查返回值是否为特定值，例如1或-1。在调用这些方法时，你应该只检查结果的符号，而不是特定的非零值。虽然许多或大多数compareTo和compare方法只会返回-1、0或1，但其中一些会返回其他值。]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_EXCEPTION_NOT_THROWN">
    <ShortDescription>异常创建后被销毁而不是抛出  Exception created and dropped rather than thrown</ShortDescription>
    <LongDescription>在{1}中没有抛出{2.givenClass}</LongDescription>
    <Details>
<![CDATA[这段代码创建了一个异常（或错误）对象，但并没有做任何处理。例如：

```java
if (x < 0) {
    new IllegalArgumentException("x must be nonnegative");
}
```

程序员很可能意图是抛出这个创建的异常：

```java
if (x < 0) {
    throw new IllegalArgumentException("x must be nonnegative");
}
```]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_ALWAYS_NULL">
    <ShortDescription>空指针解引用  Null pointer dereference</ShortDescription>
    <LongDescription>在{1}中对{2.givenClass}进行了空指针解引用</LongDescription>
    <Details>
<![CDATA[一个空指针在这里被解引用了。当代码执行时，这将会导致一个 `<code>NullPointerException</code>`。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_CLOSING_NULL">
    <ShortDescription>在调用一个始终为null的值上的close()方法  close() invoked on a value that is always null</ShortDescription>
    <LongDescription>由于在{1}中{2.givenClass}始终为null，因此无法关闭它。</LongDescription>
    <Details>
<![CDATA[`close()` 被应用于始终为 null 的值。如果执行此语句，将会发生空指针异常。但更大的风险是你从未关闭本应关闭的东西。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_STORE_INTO_NONNULL_FIELD">
    <ShortDescription>将空值存储到标注了@Nonnull的字段中  Store of null value into field annotated @Nonnull</ShortDescription>
    <LongDescription>在{1}中将空值存储到了标记了@Nonnull注解的字段{2.givenClass}中</LongDescription>
    <Details>
      <![CDATA[一个可能为null的值被存储到了一个已经被注解为@Nonnull的字段中。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_ALWAYS_NULL_EXCEPTION">
    <ShortDescription>在异常处理路径中的空指针解引用  Null pointer dereference in method on exception path</ShortDescription>
    <LongDescription>在异常路径上，{1} 中的 {2.givenClass} 发生了空指针解引用错误</LongDescription>
    <Details>
<![CDATA[一个在异常路径上为null的指针在这里被去引用了。当代码执行时，这将导致`NullPointerException`。请注意，因为SpotBugs当前不修剪不可能的异常路径，所以这可能是一个假警报。

此外，请注意，SpotBugs认为switch语句的默认情况是异常路径，因为默认情况通常是不可能发生的。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE">
    <ShortDescription>参数必须是非空的，但被标记为可为空。  Parameter must be non-null but is marked as nullable</ShortDescription>
    <LongDescription>{2} 必须为非空，但被标记为可为空。</LongDescription>
    <Details>
<![CDATA[这个参数总是以非空的方式使用，但该参数明确标注为可为空。要么参数的使用方式有误，要么注解有误。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_ON_SOME_PATH">
    <ShortDescription>可能的空指针解引用  Possible null pointer dereference</ShortDescription>
    <LongDescription>可能在{1}中对{2.givenClass}进行了空指针解引用</LongDescription>
    <Details>
<![CDATA[有一支语句分支，如果被执行，会保证出现空值解引用的情况，在代码执行时会产生一个`NullPointerException`。当然，问题可能是该分支或语句是不可行的，空指针异常实际上永远不会发生；SpotBugs 无法确定这种情况是否会发生。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_ON_SOME_PATH_MIGHT_BE_INFEASIBLE">
    <ShortDescription>可能在可能存在不可行性的分支上发生空指针解引用  Possible null pointer dereference on branch that might be infeasible</ShortDescription>
    <LongDescription>在{1}中，可能在不可行分支上对{2.givenClass}进行了空指针解引用。</LongDescription>
    <Details>
<![CDATA[有一个分支的语句，如果执行的话，会保证出现空值dereference的情况，在代码执行时会产生`NullPointerException`。当然，问题可能是该分支或语句是不可行的，因此空指针异常实际上永远不会发生；SpotBugs 无法判断这种情况。由于这个值之前已经被测试过是否为空，这种情况确实存在可能性。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_ON_SOME_PATH_EXCEPTION">
    <ShortDescription>在异常路径上可能存在空指针解引用问题  Possible null pointer dereference in method on exception path</ShortDescription>
    <LongDescription>在异常路径上，{1} 中可能对 {2.givenClass} 进行了空指针解引用。</LongDescription>
    <Details>
<![CDATA[在一个某些异常控制路径为null的引用值在此处被解引用。当代码执行时，这可能会导致`NullPointerException`。请注意，由于SpotBugs当前不剪枝不可能的异常路径，这可能是一个假警告。

另外，请注意，SpotBugs认为switch语句的默认情况也是一种异常路径，因为默认情况通常是不可能发生的。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE">
    <ShortDescription>可能由于调用方法的返回值导致空指针解引用  Possible null pointer dereference due to return value of called method</ShortDescription>
    <LongDescription>在{1}中可能存在空指针解引用，因为调用方法的返回值。</LongDescription>
    <Details>
      <![CDATA[方法返回值在未进行空检查的情况下被去引号引用，而该方法的返回值通常应该进行空检查。这可能会导致在代码执行时出现 `<code>NullPointerException</code>`。]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_PARAM_DEREF_NONVIRTUAL">
    <ShortDescription>非虚方法调用传递了非空参数的空值  Non-virtual method call passes null for non-null parameter</ShortDescription>
    <LongDescription>在{1}中的非虚方法调用为{2.givenClass}的非空参数传递了null值</LongDescription>
    <Details>
      <![CDATA[一个可能为null的值被传递给了一个非null的方法参数。要么该参数被注解为总是非null的，要么分析显示它总是会被去引用。]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS">
    <ShortDescription>方法调用传递了空值给非空参数  Method call passes null for non-null parameter</ShortDescription>
    <LongDescription>在{1}中，传递了空值给非空参数{2.givenClass}</LongDescription>
    <Details>
      <![CDATA[在一个调用点传递了一个可能为null的值，而所有已知的目标方法都要求该参数不能为null。要么这个参数被注解为始终不能为null的参数，要么分析已经表明它总是会被反引用来使用。]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_PARAM_DEREF">
    <ShortDescription>方法调用传递了空值给非空参数  Method call passes null for non-null parameter</ShortDescription>
    <LongDescription>在{1}中，为{2.givenClass}的非空参数传入了null</LongDescription>
    <Details>
      <![CDATA[这个方法调用传递了一个空值给一个必需非空的方法参数。要么该参数被标注为总是非空的参数，要么分析显示它始终会被去引用来使用。]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_NONNULL_PARAM_VIOLATION">
    <ShortDescription>方法调用向非空参数传递了空值  Method call passes null to a non-null parameter</ShortDescription>
    <LongDescription>在{1}中，为{2.givenClass}的非空参数传入了null</LongDescription>
    <Details>
      <![CDATA[这个方法将一个空值作为参数传递给必须为非空的方法。要么该参数被显式标记为@Nonnull，要么分析已确定此参数总是会被解引用。]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_NONNULL_RETURN_VIOLATION">
    <ShortDescription>方法可能会返回null，但声明为@Nonnull  Method may return null, but is declared @Nonnull</ShortDescription>
    <LongDescription>{1} 可能返回null，但声明为@Nonnull</LongDescription>
    <Details>
      <![CDATA[这个方法可能会返回一个空值，但该方法（或它所重写的超类方法）被声明为返回@Nonnull。]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_CLONE_COULD_RETURN_NULL">
    <ShortDescription>克隆方法可能会返回null  Clone method may return null</ShortDescription>
    <LongDescription>{1} 可能返回null</LongDescription>
    <Details>
      <![CDATA[这个克隆方法在某些情况下似乎会返回null，但clone永远不允许返回null值。如果你确信这条路径是不可达的，那么应该抛出一个AssertionError而不是null。]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_TOSTRING_COULD_RETURN_NULL">
    <ShortDescription>toString方法可能会返回null  toString method may return null</ShortDescription>
    <LongDescription>{1} 可能返回null</LongDescription>
    <Details>
      <![CDATA[这个 `toString` 方法在某些情况下似乎会返回 `null`。规范的宽松解读可能会允许这种情况，但这很可能不是一个好主意，并可能导致其他代码出错。最好返回空字符串或其他合适的字符串，而不是 `null`。]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_GUARANTEED_DEREF">
    <ShortDescription>空值保证会被反引用  Null value is guaranteed to be dereferenced</ShortDescription>
    <LongDescription>{2.givenClass} 可能为null，并且在{1}中保证会被解引用。</LongDescription>
    <Details>
          <![CDATA[存在一个语句或分支，如果执行该语句或分支可以保证在此点某个值为null，并且除了涉及运行时异常的前向路径外，这个被保证为null的值会被解引用。  

注意，类似`if (x == null) throw new NullPointerException();`这样的检查也被视为对`x`的解引操作。]]>
      </Details>
  </BugPattern>
  <BugPattern type="NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH">
    <ShortDescription>值为null，并且在异常路径上会被解引用。  Value is null and guaranteed to be dereferenced on exception path</ShortDescription>
    <LongDescription>在{1}的异常路径中，"{2.name} is null" 保证会被解引用。</LongDescription>
    <Details>
          <![CDATA[存在一条语句或分支在异常路径上，如果执行该语句在此点会保证某个值为null，并且这个被保证为null的值将在除涉及运行时异常的前向路径之外的所有路径上被解引用。]]>
      </Details>
  </BugPattern>
  <BugPattern type="SI_INSTANCE_BEFORE_FINALS_ASSIGNED">
    <ShortDescription>静态初始化器会在所有static final字段赋值之前创建实例  Static initializer creates instance before all static final fields assigned</ShortDescription>
    <LongDescription>对于{0}的静态初始化器在所有static final字段被赋值之前创建了实例</LongDescription>
    <Details>
<![CDATA[类的静态初始化器会在所有静态最终字段被赋值之前创建该类的一个实例。]]>
    </Details>
  </BugPattern>
  <BugPattern type="OS_OPEN_STREAM">
    <ShortDescription>方法可能无法关闭流  Method may fail to close stream</ShortDescription>
    <LongDescription>{1} 可能无法关闭流</LongDescription>
    <Details>
<![CDATA[该方法创建了一个IO流对象，但没有将其赋值给任何字段、传给其他可能会关闭它的方法或返回它，并且从方法中出来的所有路径都没有看到流被关闭。这可能导致文件描述符泄漏。通常来说，在finally块中确保流被关闭是一个好主意。]]>
    </Details>
  </BugPattern>
  <BugPattern type="OS_OPEN_STREAM_EXCEPTION_PATH">
    <ShortDescription>方法可能在发生异常时无法关闭流  Method may fail to close stream on exception</ShortDescription>
    <LongDescription>{1} 可能在异常情况下未能关闭流</LongDescription>
    <Details>
<![CDATA[该方法创建了一个IO流对象，但没有将其赋值给任何字段、传给其他方法或返回它，并且在所有可能的异常路径中都没有出现关闭它的代码。这可能会导致文件描述符泄漏。通常来说，在finally块中确保流被关闭是个好主意。]]>
    </Details>
  </BugPattern>
  <BugPattern type="PZLA_PREFER_ZERO_LENGTH_ARRAYS">
    <ShortDescription>考虑返回一个空数组而不是null  Consider returning a zero length array rather than null</ShortDescription>
    <LongDescription>{1} 应该返回一个空数组而不是 null？</LongDescription>
    <Details>
<![CDATA[通常，在表示没有结果时（即，一个空的结果列表），返回长度为零的数组而不是空引用会是一个更好的设计选择。这样客户端方法就不需要显式地检查是否为空引用了。

另一方面，使用空引用表示“对这个问题没有答案”可能是适当的。例如，`File.listFiles()` 如果给定的是一个不包含任何文件的目录，则会返回一个空列表；如果给定的文件不是一个目录，则会返回 `null`。]]>
    </Details>
  </BugPattern>
  <BugPattern type="UCF_USELESS_CONTROL_FLOW">
    <ShortDescription>无用的控制流  Useless control flow</ShortDescription>
    <LongDescription>在{1}中的无用控制流</LongDescription>
    <Details>
<![CDATA[这种方法包含了一个无用的控制流语句，无论分支是否被取，控制流都会继续到相同的地方。例如，这是由于在一个 `if` 语句中有一个空语句块引起的：

```javascript
if (argv.length == 0) {     // TODO: 处理这种情况
}
```]]>
    </Details>
  </BugPattern>
  <BugPattern type="UCF_USELESS_CONTROL_FLOW_NEXT_LINE">
    <ShortDescription>无用的控制流移到下一行  Useless control flow to next line</ShortDescription>
    <LongDescription>在{1}中使用无用的控制流跳到下一行</LongDescription>
    <Details>
<![CDATA[这种方法包含了一个无用的控制流语句，在这个语句中，无论分支是否被选择，控制流都会遵循到同一行或后续的某一行。通常这是由于不小心将空语句作为`if`语句体使用造成的，例如：

```java
if (argv.length == 1);     System.out.println("Hello, " + argv[0]);
```]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE">
    <ShortDescription>之前解引用过的值的空检查  Nullcheck of value previously dereferenced</ShortDescription>
    <LongDescription>在第{4#lineNumber}行的{2#givenClass}进行了空值检查，此前在{1}中对该值进行了解引用。</LongDescription>
    <Details>
<![CDATA[这里检查一个值是否为空，但这个值不可能为空，因为之前已经对该值进行了去引操作，如果它为空，则在早期的去引操作中会抛出空指针异常。本质上，这段代码和之前的去引操作对这个值是否允许为空的看法是矛盾的。要么这个检查是多余的，要么之前的去引操作有误。]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE">
    <ShortDescription>已知为null的值的冗余空指针检查  Redundant nullcheck of value known to be null</ShortDescription>
    <LongDescription>在{1}中已知{2}为null的情况下对{2}进行冗余的空检查</LongDescription>
    <Details>
<![CDATA[这种方法包含了一个已知空值与常量空值的冗余检查。]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE">
    <ShortDescription>已知非空值的多余空检测  Redundant nullcheck of value known to be non-null</ShortDescription>
    <LongDescription>在{1}中已知{2}为非空的情况下对{2}进行多余的空值检查</LongDescription>
    <Details>
<![CDATA[这个方法包含了一个对已知非空值与常量null的冗余检查。]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES">
    <ShortDescription>两个空值的冗余比较  Redundant comparison of two null values</ShortDescription>
    <LongDescription>在{1}中对两个空值进行了多余的比较</LongDescription>
    <Details>
<![CDATA[这个方法包含了一个已知肯定为null的两个引用之间的冗余比较。]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE">
    <ShortDescription>非空值与空值的冗余比较  Redundant comparison of non-null value to null</ShortDescription>
    <LongDescription>在{1}中对非空值进行了与空值的冗余比较</LongDescription>
    <Details>
<![CDATA[这个方法包含一个已知非空的引用和另一个已知为空的引用。]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_CHECKED_NULL_COMPARISON" deprecated="true"> <!-- deprecated in favor of two separate RCN_ patterns -->
    <ShortDescription>之前已检查过的值与null的冗余比较  Redundant comparison to null of previously checked value</ShortDescription>
    <LongDescription>在{1}中，对之前已检查过的{2}与null的冗余比较</LongDescription>
    <Details>
<![CDATA[这种方法包含对引用值与null的冗余比较。报告了两种类型的冗余比较：

1. 比较的两个值肯定都是null。
2. 其中一个值肯定为null，而另一个值肯定不为null。

这种警告通常表明一个已知不会为null的值被检查是否为null。虽然这个检查不是必要的，但它可能是出于防御性编程的考虑。]]>
    </Details>
  </BugPattern>
  <BugPattern type="UL_UNRELEASED_LOCK">
    <ShortDescription>方法不在所有路径上释放锁  Method does not release lock on all paths</ShortDescription>
    <LongDescription>{1} 不在所有路径上释放锁</LongDescription>
    <Details>
<![CDATA[这种方法获取了一个JSR-166（`java.util.concurrent`）锁，但在方法的所有退出路径上并未释放该锁。通常正确使用JSR-166锁的模式是：

```java
Lock l = ...;
l.lock();
try {
    // 执行某些操作
} finally {
    l.unlock();
}
```]]>
    </Details>
  </BugPattern>
  <BugPattern type="UL_UNRELEASED_LOCK_EXCEPTION_PATH">
    <ShortDescription>方法在所有异常路径中都没有释放锁  Method does not release lock on all exception paths</ShortDescription>
    <LongDescription>{1} 在所有异常路径上都没有释放锁</LongDescription>
    <Details>
<![CDATA[这种方法获取了一个JSR-166（`java.util.concurrent`）锁，但在方法的所有异常退出路径中并未释放该锁。通常使用JSR-166锁的正确用法是：

```java
Lock l = ...;
l.lock();
try {
    // 做一些事情
} finally {
    l.unlock();
}
```]]>
    </Details>
  </BugPattern>
  <BugPattern type="RC_REF_COMPARISON">
    <ShortDescription>可疑的引文比较  Suspicious reference comparison</ShortDescription>
    <LongDescription>在{1}中出现了{2}个可疑的引用比较</LongDescription>
    <Details>
<![CDATA[这个方法使用 `==` 或 `!=` 运算符来比较两个引用值，而通常情况下应该使用 `equals()` 方法来比较此类实例。可能存在这样的情况：虽然两个实例相等，但由于它们是不同的对象，因此不会通过 `==` 来比较。一般而言，不应该按引用比较的类包括 `java.lang.Integer`、`java.lang.Float` 等。]]>
    </Details>
  </BugPattern>
  <BugPattern type="RC_REF_COMPARISON_BAD_PRACTICE">
    <ShortDescription>可疑的对照常量比较  Suspicious reference comparison to constant</ShortDescription>
    <LongDescription>可疑地将{1}中的{2}引用与常量进行比较</LongDescription>
    <Details>
<![CDATA[这种方法使用 `==` 或 `!=` 操作符将一个参考值与常量进行比较，而通常情况下，比较此类类型的实例应该使用 `equals()` 方法。可能存在不同的对象但值相等的情况，因此它们不会通过 `==` 进行比较。一般不应按引用比较的类示例包括 `java.lang.Integer`, `java.lang.Float` 等。]]>
    </Details>
  </BugPattern>
  <BugPattern type="RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN">
    <ShortDescription>可疑的布尔值比较参考  Suspicious reference comparison of Boolean values</ShortDescription>
    <LongDescription>在{1}中对布尔引用进行了可疑的比较。</LongDescription>
    <Details>
<![CDATA[这种方法使用 `==` 或 `!=` 运算符比较两个布尔值。通常，只有两种布尔值（Boolean.TRUE 和 Boolean.FALSE），但可以使用 `new Boolean(b)` 构造函数创建其他布尔对象。最好避免使用这样的对象，但如果它们存在，则使用 `==` 或 `!=` 检查布尔对象的相等性将得到与使用 `.equals(...)` 不同的结果。]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_UNRELATED_TYPES_USING_POINTER_EQUALITY">
    <ShortDescription>使用指针相等性来比较不同类型  Using pointer equality to compare different types</ShortDescription>
    <LongDescription>使用指针相等性比较{1}中的一个{2.givenClass}与一个{3.givenClass}</LongDescription>
    <Details>
<![CDATA[这种方法使用指针相等性来比较两个看起来是不同类型的引用。这种比较在运行时的结果总是为假。]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_UNRELATED_TYPES">
    <ShortDescription>调用equals()比较不同类型  Call to equals() comparing different types</ShortDescription>
    <LongDescription>在{1}中调用了{3.simpleClass}.equals({2.simpleClass})方法</LongDescription>
    <Details>
<![CDATA[这种方法会对不同类类型的两个引用调用equals(Object)方法，并且分析表明在运行时它们将是不同类的对象。此外，对将要被调用的equals方法的检查表明，要么这次调用总是返回false，要么equals方法不是对称的（这是类Object中equals方法合同所要求的一个属性）。]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_UNRELATED_INTERFACES">
    <ShortDescription>比较不同接口类型时调用equals()方法  Call to equals() comparing different interface types</ShortDescription>
    <LongDescription>在{1}中调用了{3.simpleClass}.equals({2.simpleClass})</LongDescription>
    <Details>
<![CDATA[这个方法会在两个不相关接口类型的引用上调用equals(Object)，而这两个接口既不是彼此的子类型，也没有已知的具体类同时实现了这两个接口。因此，在运行时比较的对象很可能不属于同一个类（除非有些应用类没有被分析，或者可以在运行时动态加载类）。根据equals()的方法合同，不同类的对象应该总是比较为不相等；因此，根据java.lang.Object.equals(Object)定义的合同，这种比较在运行时的结果总是false。]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_UNRELATED_CLASS_AND_INTERFACE">
    <ShortDescription>调用equals()方法比较不相关的类和接口  Call to equals() comparing unrelated class and interface</ShortDescription>
    <LongDescription>在{1}中调用了{3.simpleClass}.equals({2.simpleClass})方法</LongDescription>
    <Details>
      <![CDATA[这个方法会对一个类引用和一个接口引用调用equals(Object)。但是，该类及其非抽象子类均未实现该接口。因此，在运行时比较的对象很可能不属于同一个类（除非某些应用程序类未被分析，或者可以在运行时动态加载类）。根据equals()的方法合同，不同类的对象应该总是比较不相等；因此，根据java.lang.Object.equals(Object)定义的合同，在运行时这种比较的结果将始终为false。]]>
   </Details>
  </BugPattern>
  <BugPattern type="EC_NULL_ARG">
    <ShortDescription>调用equals(null)  Call to equals(null)</ShortDescription>
    <LongDescription>在{1}中调用了equals(null)方法</LongDescription>
    <Details>
<![CDATA[这个方法调用了equals(Object)，并将null值作为参数传递。根据equals()方法的合约，这次调用应该始终返回false。]]>
    </Details>
  </BugPattern>
  <BugPattern type="MWN_MISMATCHED_WAIT">
    <ShortDescription>等待匹配失败  Mismatched wait()</ShortDescription>
    <LongDescription>{1}中的wait()不匹配</LongDescription>
    <Details>
<![CDATA[这个方法在明显没有持有对象锁的情况下调用了Object.wait()。在没有持有锁的情况下调用wait()将会抛出一个<code>IllegalMonitorStateException</code>。]]>
    </Details>
  </BugPattern>
  <BugPattern type="MWN_MISMATCHED_NOTIFY">
    <ShortDescription>不匹配的notify()  Mismatched notify()</ShortDescription>
    <LongDescription>在{1}中发现了不匹配的notify()</LongDescription>
    <Details>
<![CDATA[这个方法在没有明显持有对象锁的情况下调用了Object.notify()或Object.notifyAll()。在没有持有锁的情况下调用notify()或notifyAll()将会抛出一个<code>IllegalMonitorStateException</code>。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_LOCAL_SELF_ASSIGNMENT_INSTEAD_OF_FIELD">
    <ShortDescription>局部自我赋值而不是字段赋值  Self assignment of local rather than assignment to field</ShortDescription>
    <LongDescription>将{2}自我分配而不是分配给{1}中的字段</LongDescription>
    <Details>
<![CDATA[这个方法包含对局部变量的自赋值操作，并且存在一个同名字段。赋值似乎被错误地写成了：

```java
int foo;
public void setFoo(int foo) {
    foo = foo;
}
```

这条赋值是无用的。你本意是要给字段赋值而不是局部变量吗？]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_LOCAL_SELF_ASSIGNMENT">
    <ShortDescription>局部变量的自赋值  Self assignment of local variable</ShortDescription>
    <LongDescription>在{1}中将{2}自我赋值</LongDescription>
    <Details>
<![CDATA[这个方法包含对本地变量的自赋值；例如：

```java
public void foo() { 
    int x = 3; 
    x = x; 
}
```

这样的赋值是多余的，可能会指示逻辑错误或打字错误。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_FIELD_SELF_ASSIGNMENT">
    <ShortDescription>自赋值字段  Self assignment of field</ShortDescription>
    <LongDescription>在{1}中自定义字段{2.givenClass}的赋值</LongDescription>
    <Details>
<![CDATA[这个方法包含对一个字段的自赋值；例如：
```java
int x;
public void foo() {
    x = x;
}
```
这样的赋值是无用的，可能会指示逻辑错误或打字错误。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_FIELD_DOUBLE_ASSIGNMENT">
    <ShortDescription>字段的双重赋值  Double assignment of field</ShortDescription>
    <LongDescription>在{1}中，字段{2.givenClass}发生了双重赋值</LongDescription>
    <Details>
<![CDATA[这种方法包含对一个字段的双重赋值；例如：

```java
int x, y;
public void foo() {
    x = x = 17;
}
```

对字段进行两次赋值是多余的，可能会表明逻辑错误或打字错误。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_LOCAL_DOUBLE_ASSIGNMENT">
    <ShortDescription>局部变量的双重赋值  Double assignment of local variable</ShortDescription>
    <LongDescription>在{1}中为{2}进行了双重赋值</LongDescription>
    <Details>
<![CDATA[这个方法中包含了一个局部变量的双重赋值；例如：

```java
public void foo() { 
    int x,y; 
    x = x = 17; 
}
```

将同一个变量两次赋予相同的值是多余的，可能会表示逻辑错误或打字错误。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_FIELD_SELF_COMPUTATION">
    <ShortDescription> nonsensical 自我计算涉及一个域（例如，x &amp; x）  Nonsensical self computation involving a field (e.g., x &amp; x)</ShortDescription>
    <LongDescription>{2.给定类}自身在{1}中的 nonsensical 自我计算</LongDescription>
    <Details>
<![CDATA[这个方法对一个字段进行了与自身引用的无意义计算（例如，x&x 或 x-x）。由于计算的本质，这种操作似乎没有意义，可能表示存在打字错误或逻辑错误。请重新检查该计算。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_LOCAL_SELF_COMPUTATION">
    <ShortDescription> nonsensical 自我计算涉及一个变量（例如，x &amp; x）  Nonsensical self computation involving a variable (e.g., x &amp; x)</ShortDescription>
    <LongDescription>{2}自身在{1}中的 nonsensical 自计算</LongDescription>
    <Details>
<![CDATA[这个方法对一个局部变量进行了一种毫无意义的计算（例如，x&x 或 x-x）。由于这种计算的本质看起来没有任何意义，这可能表明存在打字错误或逻辑错误。请检查该计算是否正确。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_FIELD_SELF_COMPARISON">
    <ShortDescription>自我比较与自身  Self comparison of field with itself</ShortDescription>
    <LongDescription>在{1}中，{2.givenClass}自身与自身的比较</LongDescription>
    <Details>
<![CDATA[这个方法会将一个字段与其自身进行比较，可能会指示存在拼写错误或逻辑错误。请确保你正在正确地进行比较。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_LOCAL_SELF_COMPARISON">
    <ShortDescription>自我价值比较  Self comparison of value with itself</ShortDescription>
    <LongDescription>自己与自身{1}进行比较{2}</LongDescription>
    <Details>
<![CDATA[这种方法会将一个局部变量与其自身进行比较，这可能表明存在打字错误或逻辑错误。请确保你正在比较的是正确的内容。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT">
    <ShortDescription>将int类型的值通过Double.longBitsToDouble方法转换为double类型  Double.longBitsToDouble invoked on an int</ShortDescription>
    <LongDescription>在{1}中，调用了Double.longBitsToDouble方法处理int值。</LongDescription>
    <Details>
<![CDATA[`Double.longBitsToDouble` 方法被调用，但传递的参数是一个32位int值。这几乎肯定不是预期的操作，并且不太可能得到预期的结果。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_ARGUMENTS_WRONG_ORDER">
    <ShortDescription>反向传递参数  Reversed method arguments</ShortDescription>
    <LongDescription>在{1}中调用{2.name}时参数顺序错误</LongDescription>
    <Details>
<![CDATA[该方法调用的参数顺序似乎不对。例如，`Preconditions.checkNotNull("message", message)` 这个调用使用了预留参数：需要检查的值应该是第一个参数。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_RANDOM_USED_ONLY_ONCE">
    <ShortDescription>随机创建并在仅使用一次的对象  Random object created and used only once</ShortDescription>
    <LongDescription>在{1}中创建并仅使用一次的随机对象</LongDescription>
    <Details>
<![CDATA[这段代码创建了一个 `java.util.Random` 对象，使用它生成一个随机数，然后丢弃该对象。这会产生质量一般的随机数，并且效率低下。如果可能，可以重写代码，使其只创建一次 `Random` 对象并保存起来，每次需要新的随机数时调用现有 `Random` 对象上的方法来获取。

如果生成的随机数不能被猜测到很重要，那么 **必须** 不为每个随机数创建一个新的 `Random`；因为这些值太容易被猜到了。你应该强烈考虑使用 `java.security.SecureRandom`（并且避免为每次需要的随机数分配一个新的 `SecureRandom`）。]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_ABSOLUTE_VALUE_OF_RANDOM_INT">
    <ShortDescription>计算有符号随机整数的绝对值尝试失败  Bad attempt to compute absolute value of signed random integer</ShortDescription>
    <LongDescription>试图计算有符号随机整数的绝对值是错误的在{1}中</LongDescription>
    <Details>
<![CDATA[这段代码生成一个随机的带符号整数，然后计算该随机整数的绝对值。如果随机数生成器返回的是 `Integer.MIN_VALUE`，那么结果也会是负数（因为 `Math.abs(Integer.MIN_VALUE) == Integer.MIN_VALUE`）。同样的问题也适用于长整型值。]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_ABSOLUTE_VALUE_OF_HASHCODE">
    <ShortDescription>试图计算有符号32位哈希码的绝对值是不正确的做法  Bad attempt to compute absolute value of signed 32-bit hashcode</ShortDescription>
    <LongDescription>在{1}中尝试计算有符号32位哈希码的绝对值是一个不良尝试。</LongDescription>
    <Details>
<![CDATA[这段代码生成一个哈希码，然后计算该哈希码的绝对值。如果哈希码是 `Integer.MIN_VALUE`，那么结果也将是负数（因为 `Math.abs(Integer.MIN_VALUE) == Integer.MIN_VALUE`）。大约每 2^32 个字符串的哈希码为 `Integer.MIN_VALUE`，包括 "polygenelubricants"、"GydZG_" 和 "DESIGNING WORKHOUSES"。]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_REM_OF_RANDOM_INT">
    <ShortDescription>32位-signed随机整数的余数  Remainder of 32-bit signed random integer</ShortDescription>
    <LongDescription>32位有符号随机整数在{1}中的余数</LongDescription>
    <Details>
<![CDATA[这段代码生成一个随机带符号整数，然后计算该值除以另一个值的余数。由于随机数可以是负数，因此余数操作的结果也可能为负数。请确保这是你所期望的，并强烈考虑使用 `Random.nextInt(int)` 方法代替。]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_REM_OF_HASHCODE">
    <ShortDescription>hashCode的余数可能是负数  Remainder of hashCode could be negative</ShortDescription>
    <LongDescription>在{1}中，hashCode的余数可能是负数。</LongDescription>
    <Details>
<![CDATA[这段代码计算哈希码，然后计算该值除以另一个值的余数。由于哈希码可以是负数，因此取余运算的结果也可能为负数。

假设你需要确保你的计算结果是非负数，你可能需要修改代码。如果你知道除数是2的幂次，可以使用位与操作符（即，而不是使用 `x.hashCode() % n`，使用 `x.hashCode() & (n-1)`）。这可能比计算余数更快。如果不知道除数是否是2的幂次，可以在取余运算的结果上取绝对值（即使用 `Math.abs(x.hashCode() % n)`）。]]>
    </Details>
  </BugPattern>
  <BugPattern type="INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE">
    <ShortDescription>将非负值与负常数或零进行不良比较  Bad comparison of nonnegative value with negative constant or zero</ShortDescription>
    <LongDescription>在{1}中将非负值与{2}进行了不良比较</LongDescription>
    <Details>
<![CDATA[这段代码将一个保证非负的值与一个负常量或零进行比较。]]>
    </Details>
  </BugPattern>

  <BugPattern type="INT_BAD_COMPARISON_WITH_SIGNED_BYTE">
    <ShortDescription>有符号字节的不良比较  Bad comparison of signed byte</ShortDescription>
    <LongDescription>在{1}中，将已签名的字节与{2}进行了不良比较。</LongDescription>
    <Details>
<![CDATA[signed字节只能在-128到127的范围内取值。将一个signed字节与范围之外的值进行比较是空洞的，并且很可能不正确。要将signed字节`b`转换为0..255范围内的无符号值，可以使用`0xff & b`。]]>
    </Details>
  </BugPattern>
  <BugPattern type="INT_BAD_COMPARISON_WITH_INT_VALUE">
    <ShortDescription>将int值与长常量进行不良比较  Bad comparison of int value with long constant</ShortDescription>
    <LongDescription>在{1}中将int与{2}进行不良比较</LongDescription>
    <Details>
<![CDATA[这段代码将一个int值与一个long常量进行比较，而这个long常量超出了int可以表示的值范围。这种比较是空洞的，并且可能是错误的。]]>
    </Details>
  </BugPattern>


  <BugPattern type="INT_VACUOUS_BIT_OPERATION">
    <ShortDescription>空洞位掩码操作在整数值上  Vacuous bit mask operation on integer value</ShortDescription>
    <LongDescription>在{1}中对{3}进行虚操作{2}</LongDescription>
    <Details>
<![CDATA[这是一个无用的工作整数位操作（与、或、异或等），例如 `<code>v & 0xffffffff</code>`。]]>
    </Details>
  </BugPattern>
  <BugPattern type="INT_VACUOUS_COMPARISON">
    <ShortDescription>整数值的空洞比较  Vacuous comparison of integer value</ShortDescription>
    <LongDescription>整数值{1}的空洞比较</LongDescription>
    <Details>
<![CDATA[存在一个整数比较始终返回相同值（例如，x <= Integer.MAX_VALUE）。]]>
    </Details>
  </BugPattern>
  <BugPattern type="INT_BAD_REM_BY_1">
    <ShortDescription>整数除以1的余数  Integer remainder modulo 1</ShortDescription>
    <LongDescription>在{1}中计算整数余数模1的结果</LongDescription>
    <Details>
<![CDATA[任意表达式 (exp % 1) 总是返回零。你是想用 (exp & 1) 或 (exp % 2) 吗？]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_IOR_OF_SIGNED_BYTE">
    <ShortDescription>有符号字节值的位或运算  Bitwise OR of signed byte value</ShortDescription>
    <LongDescription>在{1}中计算的带符号字节值的位或运算</LongDescription>
    <Details>
<![CDATA[加载一个字节值（例如，从字节数组中加载的值或由返回类型为 byte 的方法返回的值），并对该值执行位或操作。在对值进行任何位运算之前，字节值会扩展到 32 位。因此，如果 `b[0]` 包含值 `0xff`，并且 `x` 初始值为 0，则代码 `((x << 8) | b[0])` 将将 `0xff` 签扩展为 `0xffffffff`，从而给出结果 `0xffffffff`。

特别是以下用于将字节数组打包到 int 中的代码是错误的：
```java
int result = 0;
for(int i = 0; i < 4; i++) {
    result = ((result << 8) | b[i]);
}
```

以下idiom 将会起作用：
```java
int result = 0;
for(int i = 0; i < 4; i++) {
    result = ((result << 8) | (b[i] & 0xff));
}
```]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_ADD_OF_SIGNED_BYTE">
    <ShortDescription>带符号字节值的位级相加  Bitwise add of signed byte value</ShortDescription>
    <LongDescription>在{1}中计算的带符号字节值的位级求和</LongDescription>
    <Details>
<![CDATA[<p>将一个字节值与一个已知低8位为清零的值相加。从字节数组加载的值在进行任何位操作之前会被扩展为32位。因此，如果`b[0]`包含值`0xff`，且`x`初始为0，则代码`((x << 8) + b[0])`会将`0xff`扩展为`0xffffffff`，从而给出结果`0xffffffff`。</p>
<p>特别是以下用于将字节数组打包成一个int的代码是错误的：</p>
```java
int result = 0;
for(int i = 0; i < 4; i++)
     result = ((result << 8) + b[i]);
```
<p>相反，可以使用以下模式来正确实现：</p>
```java
int result = 0;
for(int i = 0; i < 4; i++)
     result = ((result << 8) + (b[i] & 0xff));
```]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_AND">
    <ShortDescription>不兼容的位掩码  Incompatible bit masks</ShortDescription>
    <LongDescription>在(e &amp; {2} == {3})中不兼容的位掩码导致在{1}处得到一个常量结果</LongDescription>
    <Details>
<![CDATA[这种方法将表达式(e & C)与D进行比较，由于常量C和D的具体值，这种比较总是不相等的。这可能表明存在逻辑错误或打字误操作。]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_SIGNED_CHECK">
    <ShortDescription>检查是否有位运算的迹象  Check for sign of bitwise operation</ShortDescription>
    <LongDescription>检查{1}中是否存在位运算的迹象</LongDescription>
    <Details>
<![CDATA[这种方法会比较表达式，例如 `((event.detail & SWT.SELECTED) > 0)`。使用位算术运算符与大于操作符进行比较可能会导致意外结果（当然这取决于SWT.SELECTED的值）。如果SWT.SELECTED是一个负数，这可能是存在bug的一个候选点。即使SWT.SELECTED不是负数，使用`!= 0`代替`> 0`似乎也是良好的实践。]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_SIGNED_CHECK_HIGH_BIT">
    <ShortDescription>检查涉及负数的位运算的符号  Check for sign of bitwise operation involving negative number</ShortDescription>
    <LongDescription>在{1}中检查是否包含涉及{2}的位运算符号</LongDescription>
    <Details>
<![CDATA[这种方法会比较位运算表达式，例如 <code>((val &amp; CONSTANT) > 0)</code>，其中CONSTANT是一个负数。使用位算术运算符然后与大于运算符进行比较可能会导致意外的结果。这种比较很可能不会如预期那样工作。良好的实践是使用'!= 0'而不是'> 0'。]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_AND_ZZ">
    <ShortDescription>检查是否 (((...) &amp; 0) == 0)  Check to see if ((...) &amp; 0) == 0</ShortDescription>
    <LongDescription>检查 ((...) &amp; 0) 是否等于 0 在 {1} 中</LongDescription>
    <Details>
<![CDATA[这种方法将表达式 `<code>(e & 0)</code>` 与 0 进行比较，这始终会比较相等。这可能表明存在逻辑错误或打字错误。]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_IOR">
    <ShortDescription>不兼容的位掩码  Incompatible bit masks</ShortDescription>
    <LongDescription>在(e | 2 == 3)中，不兼容的位掩码导致{1}始终为常量结果。</LongDescription>
    <Details>
<![CDATA[<p>这种方法将表达式的形式 <code>(e | C)</code> 与 D 进行比较，由于常量 C 和 D 的特定值，这总是会比较不相等。这可能表明存在逻辑错误或拼写错误。</p>
<p>通常，这个 bug 是因为代码希望在一个位集合中执行成员测试，但却使用了按位 OR 操作符 (“|”) 而不是按位 AND 操作符 (“&amp;”)。</p>
<p>此外，在表达式 <code>(e &amp; A | B) == C</code> 中也可能出现这样的 bug，这个表达式会被解析为 <code>((e &amp; A) | B) == C</code>，而本意是 <code>(e &amp; (A | B)) == C</code>。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="LI_LAZY_INIT_INSTANCE" deprecated="true"> <!-- never generated? -->
    <ShortDescription>错误地懒初始化实例字段  Incorrect lazy initialization of instance field</ShortDescription>
    <LongDescription>在{1}中，实例字段{2}的懒初始化不正确</LongDescription>
    <Details>
<![CDATA[这个方法包含了一个未同步的懒初始化非易失性字段。由于编译器或处理器可能会重新排列指令，当该方法可以被多个线程调用时，线程不能保证看到一个完全初始化的对象。你可以将字段设为易失性的以纠正这个问题。更多信息，请参见 <a href="http://www.cs.umd.edu/~pugh/java/memoryModel/">Java 内存模型网页</a>。]]>
    </Details>
  </BugPattern>
  <BugPattern type="LI_LAZY_INIT_STATIC">
    <ShortDescription>静态字段的懒初始化错误  Incorrect lazy initialization of static field</ShortDescription>
    <LongDescription>在{1}中静态字段{2}的懒初始化不正确</LongDescription>
    <Details>
<![CDATA[这个方法包含了一个未同步的懒初始化非易失静态字段。由于编译器或处理器可能会重排序指令，线程不能保证看到一个完全初始化的对象，如果该方法可以被多个线程调用的话。你可以将字段设为易失（volatile）以修正这个问题。更多信息，请参见<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/">Java内存模型网站</a>。]]>
    </Details>
  </BugPattern>
  <BugPattern type="LI_LAZY_INIT_UPDATE_STATIC">
    <ShortDescription>不正确的懒初始化和静态字段更新  Incorrect lazy initialization and update of static field</ShortDescription>
    <LongDescription>在{1}中，静态字段{2}的懒初始化和更新不正确</LongDescription>
    <Details>
<![CDATA[这个方法包含了一个未同步的懒初始化静态字段。一旦字段被设置，存储在该位置的对象将被进一步更新或访问。当字段被设置时，其设置对其他线程是可见的。如果设置字段的方法中的后续访问用于初始化对象，则除非有其他东西防止任何其他线程在此对象完全初始化之前对其进行访问，否则您有一个非常严重的多线程 bug。

即使你觉得这个方法从不会由多个线程同时调用，最好还是不要在值完全填充/初始化之前就设置静态字段。]]>
    </Details>
  </BugPattern>
  <BugPattern type="JLM_JSR166_LOCK_MONITORENTER">
    <ShortDescription>同步操作在Lock上执行  Synchronization performed on Lock</ShortDescription>
    <LongDescription>在{1}中对{2}进行了同步</LongDescription>
    <Details>
<![CDATA[这种方法在实现了java.util.concurrent.locks.Lock接口的对象上进行同步。这样的对象是通过`acquire()`和`release()`来加锁/解锁的，而不是使用`synchronized (...)`构造。]]>
</Details>
  </BugPattern>
  <BugPattern type="JML_JSR166_CALLING_WAIT_RATHER_THAN_AWAIT">
    <ShortDescription>使用util.concurrent抽象化的监视器风格等待方法  Using monitor style wait methods on util.concurrent abstraction</ShortDescription>
    <LongDescription>在{1}中调用{2.name}而不是{3.name}</LongDescription>
    <Details>
<![CDATA[这种方法会在一个也提供了 `await()`、`signal()` 或 `signalAll()` 方法的对象上调用 `wait()`、`notify()` 或 `notifyAll()`（如 util.concurrent 条件对象）。这可能不是你想要的，即使你需要这样做，也应该考虑改变你的设计，因为其他开发人员可能会发现这一点非常令人困惑。]]>
</Details>
  </BugPattern>
  <BugPattern type="JLM_JSR166_UTILCONCURRENT_MONITORENTER">
    <ShortDescription>在util.concurrent实例上执行了同步操作  Synchronization performed on util.concurrent instance</ShortDescription>
    <LongDescription>在{1}中对{2}进行了同步</LongDescription>
    <Details>
<![CDATA[这种方法会在一个实例来自 java.util.concurrent 包（或其子类）的类的对象上执行同步。这些类的实例具有自己的并发控制机制，这种机制与 Java 关键字 `synchronized` 提供的同步是独立的。例如，在一个 `AtomicBoolean` 上进行同步并不会防止其他线程修改该 `AtomicBoolean`。

这样的代码可能是正确的，但应该仔细审查和记录，并且可能会让以后维护代码的人感到困惑。]]>
</Details>
  </BugPattern>
  <BugPattern type="UPM_UNCALLED_PRIVATE_METHOD">
    <ShortDescription>私有方法从未被调用  Private method is never called</ShortDescription>
    <LongDescription>私有方法{1}从未被调用</LongDescription>
    <Details>
<![CDATA[这个私有方法从未被调用。尽管有可能通过反射来调用此方法，但更可能的是该方法从不使用，应该移除。]]>
</Details>
  </BugPattern>
  <BugPattern type="UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS">
    <ShortDescription>在匿名类中定义了无法调用的方法  Uncallable method defined in anonymous class</ShortDescription>
    <LongDescription>无法调用匿名类中定义的方法 {1}</LongDescription>
    <Details>
<![CDATA[这个匿名类定义了一个方法，并且该方法未直接调用，也没有在超类中覆盖任何方法。由于其他类无法直接调用匿名类中声明的方法，看起来这个方法可能是不可调用的。该方法可能只是一个死代码，但也有可能是意图覆盖超类中声明的方法，但由于 typo 或其他错误，实际上并未覆盖预期的方法。]]>
</Details>
  </BugPattern>
  <BugPattern type="ODR_OPEN_DATABASE_RESOURCE">
    <ShortDescription>方法可能无法关闭数据库资源  Method may fail to close database resource</ShortDescription>
    <LongDescription>{1} 可能无法关闭 {2.排除包}</LongDescription>
    <Details>
<![CDATA[该方法创建了一个数据库资源（例如，数据库连接或行集），但未将其分配给任何字段，也没有传递给其他方法或返回它，并且在方法的所有路径结束时都没有关闭对象。如果不在方法的所有路径中关闭数据库资源，可能会导致性能不佳，并可能导致应用程序与数据库通信出现问题。]]>
    </Details>
  </BugPattern>
  <BugPattern type="ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH">
    <ShortDescription>方法在发生异常时可能无法关闭数据库资源  Method may fail to close database resource on exception</ShortDescription>
    <LongDescription>{1} 在异常情况下可能无法关闭数据库资源</LongDescription>
    <Details>
<![CDATA[该方法创建了一个数据库资源（例如，数据库连接或行集），但未将其分配给任何字段、传递给其他方法或返回它，并且在方法的所有异常路径中均未出现关闭对象的情况。如果不在方法的所有路径中关闭数据库资源，可能会导致性能不佳，并可能导致应用程序与数据库通信出现问题。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SBSC_USE_STRINGBUFFER_CONCATENATION">
    <ShortDescription>方法在循环中使用+连接字符串  Method concatenates strings using + in a loop</ShortDescription>
    <LongDescription>{1} 使用循环和 + 连接字符串</LongDescription>
    <Details>
<![CDATA[<p>这种方法似乎是在循环中使用连接操作构建一个String。在每次迭代中，字符串会被转换为StringBuffer或StringBuilder，然后追加内容，并再次转换回String。这会导致成本与迭代次数的平方成正比，在每次迭代中，随着字符串的增长都会进行重新复制。</p>
<p>通过显式使用StringBuffer（或Java 1.5中的StringBuilder）可以获得更好的性能。</p>
<p>例如：</p>
<pre><code>// 这是不好的做法
String s = "";
for (int i = 0; i < field.length; ++i) {
    s = s + field[i];
}

// 这是更好的做法
StringBuffer buf = new StringBuffer();
for (int i = 0; i < field.length; ++i) {
    buf.append(field[i]);
}
String s = buf.toString();
</code></pre>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIL_PREPARE_STATEMENT_IN_LOOP">
    <ShortDescription>在循环中调用prepareStatement方法  Method calls prepareStatement in a loop</ShortDescription>
    <LongDescription>{1} 在循环中使用常量参数调用prepareStatement方法</LongDescription>
    <Details>
<![CDATA[方法在循环中调用了Connection.prepareStatement，并传递了常量参数。如果PreparedStatement需要多次执行，就没有必要在每次循环迭代中重新创建它。将此调用移出循环即可。]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIL_ELEMENTS_GET_LENGTH_IN_LOOP">
    <ShortDescription>在循环中调用了NodeList.getLength()方法  NodeList.getLength() called in a loop</ShortDescription>
    <LongDescription>{1} 循环调用 NodeList.GetLength() 来获取 getElementsByTagName 的返回值</LongDescription>
    <Details>
<![CDATA[该方法在循环中调用了NodeList.getLength()，而NodeList是由getElementsByTagName调用产生的。这个NodeList没有存储其长度，而是以一种不太理想的方式每次计算一次。考虑在循环之前将长度存储到变量中。]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIL_PATTERN_COMPILE_IN_LOOP">
    <ShortDescription>在循环中调用`Pattern.compile`方法  Method calls Pattern.compile in a loop</ShortDescription>
    <LongDescription>{1} 在循环中使用常量参数调用Pattern.compile</LongDescription>
    <Details>
<![CDATA[该方法在循环中调用了Pattern.compile，传入了常量参数。如果应该多次使用Pattern，那么没有理由为每次循环迭代都进行编译。可以将此调用移出循环，甚至放入静态final字段中。]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIL_PATTERN_COMPILE_IN_LOOP_INDIRECT">
    <ShortDescription>方法会在循环中编译正则表达式  Method compiles the regular expression in a loop</ShortDescription>
    <LongDescription>{1} 在循环中编译正则表达式</LongDescription>
    <Details>
<![CDATA[该方法在循环中创建相同的正则表达式，因此会在每次迭代时进行编译。在这种情况下，在循环外部使用`Pattern.compile`预编译这个正则表达式会更高效。]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIO_INEFFICIENT_INDEX_OF">
    <ShortDescription>无效使用String.indexOf(String)  Inefficient use of String.indexOf(String)</ShortDescription>
    <LongDescription>{1} 使用了 `String.indexOf(String)` 而不是 `String.indexOf(int)`</LongDescription>
    <Details>
<![CDATA[这段代码将一个长度为1的常量字符串传递给`String.indexOf()`。直接使用整数实现的`String.indexOf()`更为高效，例如调用`myString.indexOf('.')`而不是`myString.indexOf(".")`。]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIO_INEFFICIENT_LAST_INDEX_OF">
    <ShortDescription>无效使用String.lastIndexOf(String)  Inefficient use of String.lastIndexOf(String)</ShortDescription>
    <LongDescription>{1} 使用了 `String.lastIndexOf(String)` 而不是 `String.lastIndexOf(int)`</LongDescription>
    <Details>
<![CDATA[这段代码将一个长度为1的常量字符串传递给`String.lastIndexOf()`。直接使用整数版本的`String.lastIndexOf()`更为高效，例如调用`myString.lastIndexOf('.')`而不是`myString.lastIndexOf(".")`。]]>
    </Details>
  </BugPattern>
  <BugPattern type="ITA_INEFFICIENT_TO_ARRAY">
    <ShortDescription>方法使用了toArray()方法，并传入了一个空数组作为参数。  Method uses toArray() with zero-length array argument</ShortDescription>
    <LongDescription>{1} 使用了 Collection.toArray() 并带有一个空数组作为参数</LongDescription>
    <Details>
<![CDATA[这种方法使用了集合派生类的toArray()方法，并传入了一个零长度的原型数组参数。如果传入的数组足够大以存储集合中的所有元素，那么该数组会被填充并直接返回。这避免了通过反射创建第二个数组来作为结果返回的需求。]]>
    </Details>
  </BugPattern>
  <BugPattern type="IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD">
    <ShortDescription>在 `run` 方法中的 JUnit 断言不会被 JUnit 检测到  JUnit assertion in run method will not be noticed by JUnit</ShortDescription>
    <LongDescription>在{1}中的JUnit断言将不会被JUnit注意到</LongDescription>
    <Details>
<![CDATA[在一个run方法中执行了一个JUnit断言。失败的JUnit断言只会抛出异常。因此，如果这个异常发生在调用测试方法之外的线程中，将会终止该线程但不会导致测试失败。]]>
    </Details>
  </BugPattern>
  <BugPattern type="IJU_SETUP_NO_SUPER">
    <ShortDescription>测试用例定义了setUp方法，但没有调用super.setUp()。  TestCase defines setUp that doesn't call super.setUp()</ShortDescription>
    <LongDescription>测试用例 {0} 定义了 `setUp` 但没有调用 `super.setUp()` 方法。</LongDescription>
    <Details>
<![CDATA[<p>这个类是一个JUnit TestCase，并实现了setUp方法。虽然应该调用super.setUp()，但实际上没有调用。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IJU_TEARDOWN_NO_SUPER">
    <ShortDescription>测试用例定义了tearDown方法，但没有调用super.tearDown()。  TestCase defines tearDown that doesn't call super.tearDown()</ShortDescription>
    <LongDescription>测试用例 {0} 定义了 `tearDown` 但没有调用 `super.tearDown()`</LongDescription>
    <Details>
<![CDATA[<p>Class 是一个 JUnit 测试用例，并实现了 tearDown 方法。tearDown 方法应该调用 super.tearDown()，但并没有这样做。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IJU_SUITE_NOT_STATIC">
    <ShortDescription>testCase 实现了一个非静态套件方法  TestCase implements a non-static suite method</ShortDescription>
    <LongDescription>测试用例 {0} 实现了一个非静态套件方法</LongDescription>
    <Details>
<![CDATA[<p>类是一个JUnit测试用例，并实现了suite()方法。但是，suite方法应该声明为静态的，但并没有这样。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="IJU_BAD_SUITE_METHOD">
    <ShortDescription>.TestCase声明了一个坏的suite方法  TestCase declares a bad suite method</ShortDescription>
    <LongDescription>在{0}中，套件方法的声明有误。</LongDescription>
    <Details>
<![CDATA[类是一个JUnit测试案例，并定义了一个suite()方法。然而，suite方法需要声明为以下之一：
```java
public static junit.framework.Test suite()
```
或者
```java
public static junit.framework.TestSuite suite()
```]]>
    </Details>
  </BugPattern>
  <BugPattern type="IJU_NO_TESTS">
    <ShortDescription>测试用例中没有任何测试。  TestCase has no tests</ShortDescription>
    <LongDescription>测试用例 {0} 没有包含任何测试项</LongDescription>
    <Details>
<![CDATA[<p>这是一个JUnit TestCase，但没有实现任何测试方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="BOA_BADLY_OVERRIDDEN_ADAPTER">
    <ShortDescription>类在重写超类适配器中实现的方法时出错了  Class overrides a method implemented in super class Adapter wrongly</ShortDescription>
    <LongDescription>类 `{0}` 错误地覆写了超类 `Adapter` 中实现的方法 `{1}`</LongDescription>
    <Details>
<![CDATA[这个方法覆盖了父类中找到的一个方法，而该父类是一个适配器，实现了由java.awt.event或javax.swing.event包定义的监听器。因此，当事件发生时，这个方法将不会被调用。]]>
    </Details>
  </BugPattern>
  <BugPattern type="BRSA_BAD_RESULTSET_ACCESS" deprecated="true"> <!-- deprecated in favor of SQL_BAD_RESULTSET_ACCESS -->
    <ShortDescription>方法尝试使用索引0访问结果集字段  Method attempts to access a result set field with index 0</ShortDescription>
    <LongDescription>{1} 尝试使用索引 0 访问结果集字段</LongDescription>
    <Details>
<![CDATA[<p>对结果集的getXXX或updateXXX方法进行了调用，其中字段索引为0。由于结果集的字段从索引1开始，这始终是一个错误。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="SQL_BAD_RESULTSET_ACCESS">
    <ShortDescription>方法尝试使用索引0访问结果集字段  Method attempts to access a result set field with index 0</ShortDescription>
    <LongDescription>尝试使用索引0访问结果集字段</LongDescription>
    <Details>
<![CDATA[在一个结果集调用了getXXX或updateXXX方法，但字段索引使用了0。由于结果集的字段从索引1开始，这总是错误的。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SQL_BAD_PREPARED_STATEMENT_ACCESS">
    <ShortDescription>方法尝试使用索引0访问预处理语句参数  Method attempts to access a prepared statement parameter with index 0</ShortDescription>
    <LongDescription>{1} 尝试使用索引 0 访问预编译语句参数</LongDescription>
    <Details>
<![CDATA[在一个准备语句的setXXX方法调用中，参数索引使用了0。由于参数索引从1开始，这始终是一个错误。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIO_SUPERFLUOUS_INSTANCEOF">
    <ShortDescription>使用instanceof操作符进行不必要的类型检查  Unnecessary type check done using instanceof operator</ShortDescription>
    <LongDescription>{1} 在可以进行静态确定的情况下，使用instanceof操作符进行了不必要的类型检查。</LongDescription>
    <Details>
<![CDATA[使用 `instanceof` 运算符进行类型检查，在可以静态确定对象是否为所需类型的场合。]]>
    </Details>
  </BugPattern>
  <BugPattern type="BAC_BAD_APPLET_CONSTRUCTOR">
    <ShortDescription>Bad Applet Constructor 依赖于未初始化的 AppletStub  Bad Applet Constructor relies on uninitialized AppletStub</ShortDescription>
    <LongDescription>坏的Applet构造函数依赖于未初始化的AppletStub</LongDescription>
    <Details>
<![CDATA[这个构造函数调用了依赖于AppletStub的方法，而AppletStub直到这个applet的init()方法被调用才初始化。因此这些方法将不能正确执行。]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_ARRAY_AND_NONARRAY">
    <ShortDescription>`equals()` 用于比较数组和非数组  equals() used to compare array and nonarray</ShortDescription>
    <LongDescription>在{1}中调用{3.simpleClass}.equals({2.simpleClass})</LongDescription>
    <Details>
<![CDATA[这种方法会调用 .equals(Object o) 来比较一个数组和一个看起来不是数组的引用。如果被比较的对象类型不同，它们肯定不相等，并且这种比较几乎肯定是错误的。即使两者都是数组，数组的 equals 方法只能确定这两个数组是否是同一个对象。要比较数组的内容，请使用 java.util.Arrays.equals(Object[], Object[])。]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_BAD_ARRAY_COMPARE">
    <ShortDescription>在数组上调用equals()，这等同于==比较  Invocation of equals() on an array, which is equivalent to ==</ShortDescription>
    <LongDescription>使用 `.equals` 来比较两个 `{2.simpleClass}` 的对象（相当于 `==`）在 `{1}` 中。</LongDescription>
    <Details>
<![CDATA[这个方法会调用数组的 `.equals(Object o)` 方法。由于数组没有重写 `Object` 的 `equals` 方法，因此调用数组的 `equals` 是在比较它们的地址。要比较数组的内容，应该使用 `java.util.Arrays.equals(Object[], Object[])`。如果只是想比较数组的地址，明确地使用 `==` 进行指针比较会更清晰。]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_INCOMPATIBLE_ARRAY_COMPARE">
    <ShortDescription>用于比较不兼容数组的 equals(...) 方法  equals(...) used to compare incompatible arrays</ShortDescription>
    <LongDescription>在{1}中使用equals比较一个{2.simpleClass}和一个{3.simpleClass}</LongDescription>
    <Details>
<![CDATA[这个方法调用了`.equals(Object o)`来比较两个数组，但这些数组是不兼容的类型（例如，String[] 和 StringBuffer[], 或 String[] 和 int[]）。它们永远不会相等。此外，当使用`equals(...)`来比较数组时，它只检查这两个数组是否是同一个数组，并忽略数组的内容。]]>
    </Details>
  </BugPattern>
  <BugPattern type="STI_INTERRUPTED_ON_CURRENTTHREAD">
    <ShortDescription>不必要的currentThread()调用，用于调用interrupted()方法  Unneeded use of currentThread() call, to call interrupted()</ShortDescription>
    <LongDescription>{1} 不必要地调用了currentThread()只是为了调用interrupted()方法</LongDescription>
    <Details>
<![CDATA[这个方法调用了Thread.currentThread()，只是为了调用interrupted()方法。由于interrupted()是一个静态方法，使用Thread.interrupted()更为简单和清晰。]]>
    </Details>
  </BugPattern>
  <BugPattern type="STI_INTERRUPTED_ON_UNKNOWNTHREAD">
    <ShortDescription>在线程实例上调用静态方法Thread.interrupted()  Static Thread.interrupted() method invoked on thread instance</ShortDescription>
    <LongDescription>{1} 在线程实例上调用静态的 `Thread.interrupted()` 方法</LongDescription>
    <Details>
<![CDATA[这种方法会调用一个看似是Thread对象但不是当前线程的Thread对象上的Thread.interrupted()方法。由于interrupted()方法是静态方法，所以实际调用的是其他对象上的该方法，而不是作者意图调用的对象。]]>
    </Details>
  </BugPattern>
  <BugPattern type="IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN">
    <ShortDescription>一个参数在进入方法时已经失效，但被覆盖了  A parameter is dead upon entry to a method but overwritten</ShortDescription>
    <LongDescription>参数{2}在进入{1}时已经失效，但被覆盖了</LongDescription>
    <Details>
<![CDATA[这个参数的初始值将被忽略，并在此处被覆盖。这通常表明有一个错误的认识，即对该参数的写操作会返回给调用者。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DLS_DEAD_LOCAL_STORE_SHADOWS_FIELD">
    <ShortDescription>死存储到遮蔽字段的局部变量  Dead store to local variable that shadows field</ShortDescription>
    <LongDescription>将死存储赋值给{2}，而不是在同一名称的字段{1}中</LongDescription>
    <Details>
<![CDATA[这个指令给局部变量赋了一个值，但该值没有在后续的任何指令中被读取或使用。通常这表示存在一个错误，因为计算出的值从未被使用过。存在一个同名的字段。你是不是应该把值赋予那个变量呢？]]>
    </Details>
  </BugPattern>
  <BugPattern type="DLS_DEAD_LOCAL_STORE">
    <ShortDescription>死存储到本地变量  Dead store to local variable</ShortDescription>
    <LongDescription>在{1}中对{2}进行了死存储</LongDescription>
    <Details>
<![CDATA[这个指令为一个局部变量赋值，但该值在后续的任何指令中都没有被读取或使用。通常这表明存在错误，因为计算出的值从未被利用过。
需要注意的是，Sun的javac编译器经常会对最终的局部变量生成无效存储。由于SpotBugs是一个基于字节码的工具，因此很难消除这些误报。]]>
    </Details>
  </BugPattern>

  <BugPattern type="DLS_DEAD_LOCAL_STORE_IN_RETURN">
    <ShortDescription>在返回语句中使用的无用赋值  Useless assignment in return statement</ShortDescription>
    <LongDescription>来自{1}的无用作业</LongDescription>
    <Details>
      <![CDATA[这个语句在一个返回语句中给一个局部变量进行了赋值。这个赋值是有效果的，请验证该语句是否正确执行。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DLS_DEAD_LOCAL_INCREMENT_IN_RETURN">
    <ShortDescription>在返回语句中的无用增量操作  Useless increment in return statement</ShortDescription>
    <LongDescription>来自{1}的无用回报增量</LongDescription>
    <Details>
      <![CDATA[这个语句返回的是 `return x++;`。后缀增量/ decrement 不会影响表达式的值，所以这个增量/ decrement 没有效果。请确认这条语句是否正确。]]>
    </Details>
  </BugPattern>



  <BugPattern type="DLS_DEAD_STORE_OF_CLASS_LITERAL">
    <ShortDescription>类字面量的死存储  Dead store of class literal</ShortDescription>
    <LongDescription>在{1}中存在对{3}.class的死存储</LongDescription>
    <Details>
<![CDATA[这个指令将一个类字面量赋值给一个变量，但从未使用它。在Java 1.4和Java 5中表现出不同的行为。<a href="http://www.oracle.com/technetwork/java/javase/compatibility-137462.html#literal">在Java 1.4及更早版本中，对`Foo.class`的引用会强制执行`Foo`的静态初始化器（如果尚未执行的话）。而在Java 5及更高版本中，并不会执行。</a> 查看Sun关于<a href="http://www.oracle.com/technetwork/java/javase/compatibility-137462.html#literal">Java SE兼容性文章</a>以获取更多细节和示例，以及如何在Java 5中强制初始化类的建议。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DLS_DEAD_LOCAL_STORE_OF_NULL">
    <ShortDescription>null赋值给局部变量的死存储  Dead store of null to local variable</ShortDescription>
    <LongDescription>向{1}中存储了null到{2}位置</LongDescription>
    <Details>
<![CDATA[代码将空值存储到一个局部变量中，而该存储的值并未被读取。这种存储可能是为了帮助垃圾回收器使用，但在Java SE 6.0及之后版本中，这已经不再需要或有用。]]>
    </Details>
  </BugPattern>
  <BugPattern type="MF_METHOD_MASKS_FIELD">
    <ShortDescription>方法定义了一个变量来遮蔽一个字段  Method defines a variable that obscures a field</ShortDescription>
    <LongDescription>定义了一个变量，遮蔽了字段 {2.givenClass}</LongDescription>
    <Details>
<![CDATA[这个方法定义了一个局部变量，其名称与该类或超类中的一个字段同名。这可能会导致方法从字段中读取未初始化的值、使字段保持未初始化状态，或者两者兼有。]]>
    </Details>
  </BugPattern>
  <BugPattern type="MF_CLASS_MASKS_FIELD">
    <ShortDescription>类定义的字段遮盖了超类的字段  Class defines field that masks a superclass field</ShortDescription>
    <LongDescription>字段 `{1.givenClass}` 覆盖了超类 `{2.class}` 中的字段</LongDescription>
    <Details>
<![CDATA[这个类定义了一个与超类中一个可见实例字段同名的字段。这可能会导致混淆，并且如果方法更新或访问其中一个字段时本应访问另一个字段，则可能表示存在错误。]]>
    </Details>
  </BugPattern>
  <BugPattern type="WMI_WRONG_MAP_ITERATOR">
    <ShortDescription>键集迭代器的无效使用而不是入口集迭代器  Inefficient use of keySet iterator instead of entrySet iterator</ShortDescription>
    <LongDescription>{1} 不是使用 entrySet 迭代器，而是不-efficient 地使用了 keySet 迭代器</LongDescription>
    <Details>
<![CDATA[这种方法通过键集迭代器获取Map条目的值。直接在映射的entrySet上使用迭代器会更高效，可以避免进行Map.get(key)查找。]]>
        </Details>
  </BugPattern>
  <BugPattern type="ISC_INSTANTIATE_STATIC_CLASS">
    <ShortDescription>仅仅提供静态方法的类的不必要的实例化  Needless instantiation of class that only supplies static methods</ShortDescription>
    <LongDescription>{1} 不必要地实例化了一个只提供静态方法的类</LongDescription>
    <Details>
<![CDATA[这个类分配了一个基于只提供静态方法的类的对象。该对象不需要被创建，可以直接通过类名作为限定符来访问静态方法。]]>
        </Details>
  </BugPattern>
  <BugPattern type="REC_CATCH_EXCEPTION">
    <ShortDescription>当没有抛出异常时捕获了异常  Exception is caught when Exception is not thrown</ShortDescription>
    <LongDescription>当在{1}中没有抛出异常时捕获到了异常</LongDescription>
    <Details>
  <![CDATA[这种方法使用了一个 try-catch 块来捕获 Exception 对象，但在 try 块中并没有抛出 Exception，也没有显式地捕获 RuntimeException。将 `try { ... } catch (Exception e) { something }` 作为一种简写方式用于捕获多个类型的异常，每个 catch 块的处理逻辑相同，但这种构造也会意外地捕获 RuntimeException，从而掩盖潜在的错误。

更好的做法是显式地捕获具体的抛出异常，或者显式地捕获 RuntimeException 异常并重新抛出，然后捕获所有非-Runtime Exceptions，如下所示：

```java
try {     ... } catch (RuntimeException e) {     throw e; } catch (Exception e) {     ... 处理所有非运行时异常 ... }
```]]>
     </Details>
  </BugPattern>
  <BugPattern type="FE_TEST_IF_EQUAL_TO_NOT_A_NUMBER">
    <ShortDescription> doomed 测试对于 NaN 的相等性  Doomed test for equality to NaN</ShortDescription>
    <LongDescription>在{1}中，命运攸关的等于NaN的测试</LongDescription>
    <Details>
   <![CDATA[这段代码检查一个浮点值是否等于特殊值“非数字”（例如，`if (x == Double.NaN)`）。但由于“NaN”的特殊语义，没有任何值等于“NaN”，包括“NaN”本身。因此，`x == Double.NaN` 总是评估为假。  
要检查变量 `x` 中的值是否为特殊的“非数字”值，应使用 `Double.isNaN(x)`（如果 `x` 是单精度浮点数，则使用 `Float.isNaN(x)`）。]]>
     </Details>
  </BugPattern>
  <BugPattern type="FE_FLOATING_POINT_EQUALITY">
    <ShortDescription>测试浮点数相等性  Test for floating point equality</ShortDescription>
    <LongDescription>在{1}中进行浮点数相等测试</LongDescription>
    <Details>
   <![CDATA[这个操作用于比较两个浮点值是否相等。由于浮点计算可能会涉及舍入，因此计算得到的float和double值可能不够准确。对于必须精确的值（例如货币值），考虑使用固定精度类型，如BigDecimal。对于不需要非常精确的值，可以考虑在某个范围内进行相等性比较，例如：`if ( Math.abs(x - y) < 0.0000001 )`。参见Java语言规范第4.2.4节。]]>
     </Details>
  </BugPattern>
  <BugPattern type="UM_UNNECESSARY_MATH">
    <ShortDescription>方法调用静态Math类的方法对一个常量值进行操作  Method calls static Math class method on a constant value</ShortDescription>
    <LongDescription>方法调用静态Math类的方法对一个常量值进行操作</LongDescription>
    <Details>
<![CDATA[<p>该方法使用了来自 java.lang.Math 的静态方法对一个常量值进行操作。在这种情况下，此方法的结果可以静态确定，并且直接使用常量会更快有时也更准确。检测到的方法如下：</p>
<table>
    <tr>
        <th>方法</th>
        <th>参数</th>
    </tr>
    <tr>
        <td>abs</td>
        <td>-任何-</td>
    </tr>
    <tr>
        <td>acos</td>
        <td>0.0 或 1.0</td>
    </tr>
    <tr>
        <td>asin</td>
        <td>0.0 或 1.0</td>
    </tr>
    <tr>
        <td>atan</td>
        <td>0.0 或 1.0</td>
    </tr>
    <tr>
        <td>atan2</td>
        <td>0.0</td>
    </tr>
    <tr>
        <td>cbrt</td>
        <td>0.0 或 1.0</td>
    </tr>
    <tr>
        <td>ceil</td>
        <td>-任何-</td>
    </tr>
    <tr>
        <td>cos</td>
        <td>0.0</td>
    </tr>
    <tr>
        <td>cosh</td>
        <td>0.0</td>
    </tr>
    <tr>
        <td>exp</td>
        <td>0.0 或 1.0</td>
    </tr>
    <tr>
        <td>expm1</td>
        <td>0.0</td>
    </tr>
    <tr>
        <td>floor</td>
        <td>-任何-</td>
    </tr>
    <tr>
        <td>log</td>
        <td>0.0 或 1.0</td>
    </tr>
    <tr>
        <td>log10</td>
        <td>0.0 或 1.0</td>
    </tr>
    <tr>
        <td>rint</td>
        <td>-任何-</td>
    </tr>
    <tr>
        <td>round</td>
        <td>-任何-</td>
    </tr>
    <tr>
        <td>sin</td>
        <td>0.0</td>
    </tr>
    <tr>
        <td>sinh</td>
        <td>0.0</td>
    </tr>
    <tr>
        <td>sqrt</td>
        <td>0.0 或 1.0</td>
    </tr>
    <tr>
        <td>tan</td>
        <td>0.0</td>
    </tr>
    <tr>
        <td>tanh</td>
        <td>0.0</td>
    </tr>
    <tr>
        <td>toDegrees</td>
        <td>0.0 或 1.0</td>
    </tr>
    <tr>
        <td>toRadians</td>
        <td>0.0</td>
    </tr>
</table>]]>
    </Details>
  </BugPattern>
  <BugPattern type="CD_CIRCULAR_DEPENDENCY">
    <ShortDescription>测试类之间的循环依赖关系  Test for circular dependencies among classes</ShortDescription>
    <LongDescription>类 {0} 与其他类存在循环依赖关系</LongDescription>
    <Details>
   <![CDATA[这个类与其他类存在循环依赖。这使得构建这些类变得困难，因为每个类都依赖于另一个类来正确构建。考虑使用接口来打破这种硬性依赖。]]>
     </Details>
  </BugPattern>
  <BugPattern type="RI_REDUNDANT_INTERFACES">
    <ShortDescription>类实现与超类相同的接口  Class implements same interface as superclass</ShortDescription>
    <LongDescription>类 {0} 实现了与超类相同的接口</LongDescription>
    <Details>
   <![CDATA[这个类声明实现了某个接口，而该接口也被其超类所实现。这种实现是冗余的，因为一旦超类实现了某个接口，所有子类默认也会继承并实现这个接口。可能自这个类创建以来，继承层次结构已经发生了变化，因此需要考虑接口实现的所有权问题。]]>
     </Details>
  </BugPattern>
  <BugPattern type="MTIA_SUSPECT_STRUTS_INSTANCE_FIELD">
    <ShortDescription>该类扩展了Struts Action类，并使用了实例变量。  Class extends Struts Action class and uses instance variables</ShortDescription>
    <LongDescription>类 {0} 扩展了 Struts 行动类，并使用了实例变量</LongDescription>
    <Details>
   <![CDATA[这个类从一个Struts Action类继承，并使用了一个实例成员变量。由于Struts框架只会创建一个Struts Action类的实例并在多线程环境中使用，因此这种模式被高度 discouraged 并且很可能存在问题。考虑只使用方法局部变量。只有在监控之外被写入的实例字段才会被报告。]]>
      </Details>
  </BugPattern>
  <BugPattern type="MTIA_SUSPECT_SERVLET_INSTANCE_FIELD">
    <ShortDescription>该类扩展了Servlet类，并使用了实例变量。  Class extends Servlet class and uses instance variables</ShortDescription>
    <LongDescription>类 {0} 扩展了 Servlet 类，并使用了实例变量</LongDescription>
    <Details>
   <![CDATA[这个类从Servlet类派生，并使用了一个实例成员变量。由于J2EE框架只会创建一个Servlet类的实例，并以多线程方式使用，因此这种模式被强烈 discourages 并且很可能存在问题。考虑仅使用方法局部变量。]]>
      </Details>
  </BugPattern>
  <BugPattern type="PS_PUBLIC_SEMAPHORES">
    <ShortDescription>该类在其公共接口中暴露了同步和信号量功能  Class exposes synchronization and semaphores in its public interface</ShortDescription>
    <LongDescription>类 {0} 在其公共接口中暴露了同步和信号量功能</LongDescription>
    <Details>
   <![CDATA[这个类使用了同步，并且在它自身（this引用）上使用了wait()、notify()或notifyAll()方法。使用此类的客户端类还可以将该类的一个实例用作同步对象。因为两个类共用了同一个对象进行同步，因此多线程正确性存在问题。你不应该对公共引用进行同步或调用信号量方法。考虑使用一个内部私有成员变量来控制同步。]]>
      </Details>
  </BugPattern>
  <BugPattern type="ICAST_INTEGER_MULTIPLY_CAST_TO_LONG">
    <ShortDescription>整数相乘后的结果转换为long类型  Result of integer multiplication cast to long</ShortDescription>
    <LongDescription>在{1}中，整数乘法的结果被强制转换为long类型。</LongDescription>
    <Details>
<![CDATA[这段代码执行整数乘法，然后将结果转换为long类型，如下所示：
```java
long convertDaysToMilliseconds(int days) {
    return 1000*3600*24*days;
}
```
如果使用长整型算术进行乘法运算，可以避免结果溢出的可能性。例如，你可以将上述代码修复为：
```java
long convertDaysToMilliseconds(int days) {
    return 1000L*3600*24*days;
}
```
或者
```java
static final long MILLISECONDS_PER_DAY = 24L*3600*1000;
long convertDaysToMilliseconds(int days) {
    return days * MILLISECONDS_PER_DAY;
}
```]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_INT_2_LONG_AS_INSTANT">
    <ShortDescription>将整数值转换为长整型并用作绝对时间  int value converted to long and used as absolute time</ShortDescription>
    <LongDescription>将int类型的值转换为long类型，并作为绝对时间传递给{1}中的{2}</LongDescription>
    <Details>
<![CDATA[这段代码将一个32位的int值转换为64位的long值，然后将其作为需要绝对时间值的方法参数传递。绝对时间值是从被称为“纪元”的标准基准时间（即1970年1月1日00:00:00 GMT）以来的毫秒数。例如，以下旨在将自纪元以来的秒转换为Date的方法是严重错误的：

```java
Date getDate(int seconds) {
    return new Date(seconds * 1000);
}
```

这里的乘法使用的是32位算术运算，并随后转换为64位值。当一个32位值被转换成64位并用于表示绝对时间时，只能表示1969年12月和1970年1月的日期。

正确实现上述方法如下：

```java
// 仅在2038年之前有效
Date getDate(int seconds) {
    return new Date(seconds * 1000L);
}

// 更好的实现，适用于所有日期
Date getDate(long seconds) {
    return new Date(seconds * 1000);
}
```]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND">
    <ShortDescription>将整数值转换为浮点数，然后传递给Math.round方法  int value cast to float and then passed to Math.round</ShortDescription>
    <LongDescription>将整数类型值转换为浮点型，然后传递给`Math.round`在{}中</LongDescription>
    <Details>
<![CDATA[这段代码将一个int值转换为具有浮点精度的float类型，然后将其结果传递给Math.round()函数，该函数返回最接近参数的int/long值。由于将整数转换为浮点数应该得到没有小数部分的数字，因此这项操作本应总是无操作的。很可能生成要传递给Math.round()的操作原本应该使用浮点算术来执行。]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL">
    <ShortDescription>将整数值转换为双精度类型，然后传递给Math.ceil函数  Integral value cast to double and then passed to Math.ceil</ShortDescription>
    <LongDescription>将整数值转换为双精度浮点数，然后传递给Math.ceil({1})</LongDescription>
    <Details>
<![CDATA[这段代码将一个整数值（例如，int或long）转换为双精度浮点数，然后将结果传递给Math.ceil()函数，该函数会将双精度浮点数向上取整到下一个更高的整数值。由于将整数转换为双精度浮点数应该得到没有小数部分的数字，因此此操作本应始终无意义。很可能生成要传递给Math.ceil()的值的操作本应使用双精度浮点数算术完成。]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_IDIV_CAST_TO_DOUBLE">
    <ShortDescription>整数除法结果转换为双精度浮点数或单精度浮点数  Integral division result cast to double or float</ShortDescription>
    <LongDescription>在{1}中，整数除法的结果被转换为double或float类型。</LongDescription>
    <Details>
<![CDATA[这段代码将整数除法（例如，int 或 long 除法）的结果转换为 double 或 float。进行整数除法时，结果会被截断为最接近零的整数值。将结果强制转换为 double 建议应该保留这种精度。很可能的意思是在执行除法之前将一个或两个操作数强制转换为 double。这里有一个示例：

```java
int x = 2;
int y = 5;

// 错误：返回结果 0.0
double value1 = x / y;

// 正确：返回结果 0.4
double value2 = x / (double) y;
```]]>
    </Details>
  </BugPattern>
  <BugPattern type="J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION">
    <ShortDescription>将非序列化的对象存储到HttpSession中  Store of non serializable object into HttpSession</ShortDescription>
    <LongDescription>将非序列化的 `{2}` 存入 HttpSession 在 `{1}` 中</LongDescription>
    <Details>
<![CDATA[这段代码似乎将一个非序列化对象存储到了HttpSession中。如果该会话被静止或迁移，将会导致错误。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_NONSERIALIZABLE_OBJECT_WRITTEN">
    <ShortDescription>非序列化的对象写入了ObjectOutput  Non serializable object written to ObjectOutput</ShortDescription>
    <LongDescription>非序列化 `{2}` 写入了 `{1}` 中的 `ObjectOutput`</LongDescription>
    <Details>
<![CDATA[这段代码似乎将一个不可序列化的对象传递给了ObjectOutput.writeObject方法。如果该对象确实不可序列化，将会导致错误。]]>
    </Details>
  </BugPattern>
  <BugPattern type="VA_FORMAT_STRING_USES_NEWLINE">
    <ShortDescription>格式字符串应该使用%n 而不是\n  Format string should use %n rather than \n</ShortDescription>
    <LongDescription>格式字符串应该使用%n 而不是\n 在{1}处</LongDescription>
    <Details>
<![CDATA[这个格式字符串包含了一个换行字符（\n）。在格式字符串中，通常最好使用%n，它将会生成平台特定的行分隔符。]]>
     </Details>
  </BugPattern>
  <BugPattern type="VA_PRIMITIVE_ARRAY_PASSED_TO_OBJECT_VARARG">
    <ShortDescription>原始数组传递给期望接收可变数量对象参数的函数  Primitive array passed to function expecting a variable number of object arguments</ShortDescription>
    <LongDescription>{2} 被传递给 {3} 的可变参数方法 {1}</LongDescription>
    <Details>
<![CDATA[这段代码将一个原始数组传递给一个接受可变数量对象参数的函数。这创建了一个长度为一的数组来持有原始数组，并将其传递给该函数。]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS">
    <ShortDescription>equals方法不应该假设其参数的类型  Equals method should not assume anything about the type of its argument</ShortDescription>
    <LongDescription>对于{0}的Equals方法假设参数是{0.givenClass}类型</LongDescription>
    <Details>
<![CDATA[`equals(Object o)` 方法不应该对 `o` 的类型做出任何假设。如果 `o` 不是与 `this` 相同的类型，它应该简单地返回 false。]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_BAD_CAST_TO_ABSTRACT_COLLECTION">
    <ShortDescription>将可疑的演员集合抽象化  Questionable cast to abstract collection</ShortDescription>
    <LongDescription>在{1}中，从Collection转换为抽象类{3}的 casts 是有问题的。</LongDescription>
    <Details>
<![CDATA[这段代码将一个集合转换为抽象集合（例如 `List`、`Set` 或 `Map`）。请确保你转换的目标对象确实是你要转换的类型。如果你只需要遍历集合中的元素，那么不需要将其转换为 `Set` 或 `List`。]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_IMPOSSIBLE_CAST_PRIMITIVE_ARRAY">
    <ShortDescription>涉及原始数组的不可能转换  Impossible cast involving primitive array</ShortDescription>
    <LongDescription>在{1}中涉及原始数组的不可能转换</LongDescription>
    <Details>
<![CDATA[这个铸型操作总是会抛出一个ClassCastException。]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_IMPOSSIBLE_CAST">
    <ShortDescription>不可能的转换  Impossible cast</ShortDescription>
    <LongDescription>在{1}中无法将{2}强制转换为{3}</LongDescription>
    <Details>
<![CDATA[这个铸型将会始终抛出一个ClassCastException。SpotBugs会追踪from instanceof检查中类型的信息，并且还会使用从方法返回值和字段加载的更精确类型的详细信息。因此，它可能拥有比变量声明类型更加精确的信息，并可以利用这些信息来确定在运行时会发生异常。]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_IMPOSSIBLE_DOWNCAST">
    <ShortDescription>不可能的向下转型  Impossible downcast</ShortDescription>
    <LongDescription>在{1}中，无法从{2}向下转换为{3}</LongDescription>
    <Details>
<![CDATA[这个铸型转换总是会抛出一个ClassCastException。分析认为它知道被铸型转换的值的确切类型，尝试将其向下转换为子类型总会因为抛出ClassCastException而失败。]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_IMPOSSIBLE_DOWNCAST_OF_TOARRAY">
    <ShortDescription>将toArray()结果进行向下转换是不可能的  Impossible downcast of toArray() result</ShortDescription>
    <LongDescription>将`toArray()`结果向下转换为{3}在{1}中是不可能的</LongDescription>
    <Details>
<![CDATA[这段代码将调用`toArray()`方法后的结果强制转换为比`Object[]`更具体的类型，如下所示：

```java
String[] getAsArray(Collection<String> c) {
    return (String[]) c.toArray();
}
```

这通常会因抛出`ClassCastException`而失败。几乎所有的集合的`toArray()`返回一个`Object[]`。这是因为Collection对象没有引用其集合声明的泛型类型。

正确的做法是从集合中获取特定类型的数组，应使用`c.toArray(new String[])`或`c.toArray(new String[c.size()])`（后者稍微更高效）。

有一种常见且已知的例外情况：由`Arrays.asList(...)`返回的列表的`toArray()`方法会返回协变类型数组。例如，`Arrays.asList(new String[] { "a" }).toArray()`将返回一个`String []`。SpotBugs 尝试检测并抑制这类情况，但可能会遗漏一些。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_INSTANCEOF">
    <ShortDescription>一个已知的空值被检查是否是某个类型的实例  A known null value is checked to see if it is an instance of a type</ShortDescription>
    <LongDescription>一个已知的空值被检查是否是{1}中的{2}类型的实例</LongDescription>
    <Details>
<![CDATA[这个 `instanceof` 测试总是会返回 false，因为被检查的值必定为 null。虽然这是安全的，但确保这不是某种误解或其它逻辑错误的迹象。]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_NULL_INSTANCEOF" deprecated="true"> <!-- deprecated in favor of NP_NULL_INSTANCEOF -->
    <ShortDescription>一个已知的空值被检查是否是一个类型的实例  A known null value is checked to see if it is an instance of a type</ShortDescription>
    <LongDescription>一个已知的空值被检查是否是{1}中的{2}实例</LongDescription>
    <Details>
<![CDATA[这个 `instanceof` 测试总是会返回 false，因为被检查的值肯定为 null。虽然这是安全的，但请确保这并不是某种误解或逻辑错误的指示。]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_IMPOSSIBLE_INSTANCEOF">
    <ShortDescription>instanceof 总是会返回 false  instanceof will always return false</ShortDescription>
    <LongDescription>instanceof 总是会返回false，因为1是一个数字，不能是一个对象。</LongDescription>
    <Details>
<![CDATA[这个 `instanceof` 测试总是会返回 false。虽然这是安全的，但请确保这不是某种误解或其它逻辑错误的指示。]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_VACUOUS_INSTANCEOF">
    <ShortDescription>instanceof 总是会返回 true  instanceof will always return true</ShortDescription>
    <LongDescription>instanceof 对于 {1} 中的所有非空值将始终返回 true，因为所有 {2} 都是 {3} 的实例。</LongDescription>
    <Details>
<![CDATA[这个 `instanceof` 测试总是会返回 true（除非被测试的值是 null）。虽然这是安全的，但一定要确保这不是某种误解或逻辑错误的迹象。如果你确实要测试该值是否为 null，也许进行一个 null 检测比 `instanceof` 检测更为清晰。]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_UNCONFIRMED_CAST">
    <ShortDescription>未检查/未验证的铸型  Unchecked/unconfirmed cast</ShortDescription>
    <LongDescription>在{1}中，未检查/未确认将{2}转换为{3}</LongDescription>
    <Details>
<![CDATA[这个类型转换未进行检查，且并非所有转换来源的实例都能成功转换为目标类型。请确保你的程序逻辑能够保证该类型转换不会失败。]]>
    </Details>
  </BugPattern>
   <BugPattern type="BC_UNCONFIRMED_CAST_OF_RETURN_VALUE">
    <ShortDescription>未检查/未确认的方法返回值类型  Unchecked/unconfirmed cast of return value from method</ShortDescription>
    <LongDescription>未检查/未确认将{2}转换为{3}的返回值来自{1}</LongDescription>
    <Details>
<![CDATA[这段代码执行了对方法返回值的未检查强制转换。代码可能以某种方式调用该方法，使得强制转换是安全的，但SpotBugs无法验证该强制转换是否安全。请检查你的程序逻辑以确保这种强制转换不会失败。]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_BAD_CAST_TO_CONCRETE_COLLECTION">
    <ShortDescription>对混凝土集合的疑问  Questionable cast to concrete collection</ShortDescription>
    <LongDescription>在{1}中，从{2}到{3}的cast是可疑的</LongDescription>
    <Details>
<![CDATA[这段代码将一个抽象集合（如Collection、List或Set）转换为具体的实现类（如ArrayList或HashSet）。这可能不正确，并且会使你的代码变得脆弱，因为将来切换到其他具体实现类会更加困难。除非你有特别的理由这样做，否则直接使用抽象集合类即可。]]>
    </Details>
  </BugPattern>
  <BugPattern type="RE_POSSIBLE_UNINTENDED_PATTERN">
    <ShortDescription>“.” 或 “|” 用于正则表达式中  "." or "|" used for regular expression</ShortDescription>
    <LongDescription>在正则表达式中，“.”或“|”用于匹配任意单个字符或表示逻辑或的关系。</LongDescription>
    <Details>
<![CDATA[<p>一个字符串函数被调用，并向接受正则表达式作为参数的参数传递了 "." 或 "|"。这是否是你想要的？例如：</p>
<ul>
<li>`s.replaceAll(".", "/")` 将返回一个每个字符都被 "/" 替换的字符串</li>
<li>`s.split(".")` 总是返回一个空数组</li>
<li>`"ab|cd".replaceAll("|", "/")` 将返回 `"/a/b/|/c/d/"`</li>
<li>`"ab|cd".split("|")` 将返回包含六个元素 (!) 的数组：[ , a, b, |, c, d]</li>
</ul>]]>
    </Details>
  </BugPattern>
  <BugPattern type="RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION">
    <ShortDescription>无效的正则表达式语法  Invalid syntax for regular expression</ShortDescription>
    <LongDescription>在{1}中的正则表达式语法无效</LongDescription>
    <Details>
<![CDATA[这里使用的代码包含一个无效的正则表达式，根据正则表达式的语法规范这是不合法的。当执行该语句时，将会抛出PatternSyntaxException异常。]]>
    </Details>
  </BugPattern>
  <BugPattern type="RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION">
    <ShortDescription>`File.separator` 用于正则表达式  File.separator used for regular expression</ShortDescription>
    <LongDescription>在正则表达式中使用`File.separator`表示文件分隔符。</LongDescription>
    <Details>
<![CDATA[这里的代码使用了 `File.separator`，但在正则表达式中需要的是一个普通字符。在Windows平台上，`File.separator` 是反斜杠（`\`），而在正则表达式中反斜杠是一个转义字符。你可以选择使用 `File.separatorChar=='\\' ? "\\\\" : File.separator` 替代 `File.separator` 来解决这个问题。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DLS_OVERWRITTEN_INCREMENT">
    <ShortDescription>覆盖增量  Overwritten increment</ShortDescription>
    <LongDescription>在{1}处进行了覆盖增量</LongDescription>
    <Details>
<![CDATA[代码执行增量操作（例如，`i++`），然后立即覆盖它。例如，`i = i++` 会立即用原始值覆盖增量后的值。]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT">
    <ShortDescription>无符号右移转换为short/byte  Unsigned right shift cast to short/byte</ShortDescription>
    <LongDescription>在{1}中，无符号右移并转换为short/byte</LongDescription>
    <Details>
<![CDATA[代码执行无符号右移操作，然后将结果转换为short或byte类型，这会丢弃结果的高位。由于高位被丢弃，无符号右移和有符号右移的结果可能在某些情况下没有区别（这取决于移位的大小）。]]>
    </Details>
  </BugPattern>
  <BugPattern type="BSHIFT_WRONG_ADD_PRIORITY">
    <ShortDescription>可能的位移操作解析错误  Possible bad parsing of shift operation</ShortDescription>
    <LongDescription>可能在{1}中出现了移位操作的解析错误</LongDescription>
    <Details>
<![CDATA[代码执行的操作像是 `(x << 8 + y)`。虽然这可能是正确的，但可能本意是要执行 `(x << 8) + y`，但由于位移操作符的优先级较低，实际上会被解析为 `x << (8 + y)`。]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_BAD_SHIFT_AMOUNT">
    <ShortDescription>32位整数左移或右移的位数不在-31到31的范围内  32 bit int shifted by an amount not in the range -31..31</ShortDescription>
    <LongDescription>32位整数右移2位在1中</LongDescription>
    <Details>
<![CDATA[代码对一个32位整数进行恒定数量的移位操作，但该数量超出了-31到31的范围。这表示使用整数值的较低5位来决定移位量（例如，向右移40位与向右移8位相同，向右移32位与不移位相同）。这可能不是预期的效果，并且至少会让人感到困惑。]]>
    </Details>
  </BugPattern>
  <BugPattern type="IM_MULTIPLYING_RESULT_OF_IREM">
    <ShortDescription>整数乘以其整数余数  Integer multiply of result of integer remainder</ShortDescription>
    <LongDescription>整数的倍数运算结果在{1}中的余数整数倍</LongDescription>
    <Details>
<![CDATA[代码将一个整数余数与一个整数常量相乘。一定要注意你的运算优先级不要出错。例如 `i % 60 * 1000` 是 `(i % 60) * 1000`，而不是 `i % (60 * 1000)`。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_INVOKING_HASHCODE_ON_ARRAY">
    <ShortDescription>对数组调用hashCode方法  Invocation of hashCode on an array</ShortDescription>
    <LongDescription>在{1}中对数组调用hashCode方法</LongDescription>
    <Details>
<![CDATA[代码调用了数组的 `hashCode`。调用数组的 `hashCode` 返回与 `System.identityHashCode` 相同的值，并忽略数组的内容和长度。如果你需要一个依赖于数组 `a` 内容的 `hashCode`，可以使用 `java.util.Arrays.hashCode(a)`。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_INVOKING_TOSTRING_ON_ARRAY">
    <ShortDescription>对数组调用toString方法  Invocation of toString on an array</ShortDescription>
    <LongDescription>在{1}中对{2.givenClass}调用toString方法</LongDescription>
    <Details>
<![CDATA[代码调用了数组的 `toString` 方法，这将生成一个相当无用的结果，比如 `[C@16f0472`。建议使用 `Arrays.toString` 将数组转换为可读的字符串，这样可以显示数组的内容。详见《编程谜题》，第3章，谜题12。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_INVOKING_TOSTRING_ON_ANONYMOUS_ARRAY">
    <ShortDescription>对未命名数组调用toString方法  Invocation of toString on an unnamed array</ShortDescription>
    <LongDescription>在{1}中对未命名数组调用toString方法</LongDescription>
    <Details>
<![CDATA[代码对一个（匿名）数组调用了toString方法。调用数组的toString方法会产生一个相当无用的结果，比如[C@16f0472。建议使用Arrays.toString将数组转换为可读的字符串，以便显示数组的内容。参见《编程谜题》，第3章，第12个谜题。]]>
    </Details>
  </BugPattern>
  <BugPattern type="IM_AVERAGE_COMPUTATION_COULD_OVERFLOW">
    <ShortDescription>平均值的计算可能会溢出  Computation of average could overflow</ShortDescription>
    <LongDescription>在{1}中计算平均值可能会溢出</LongDescription>
    <Details>
<![CDATA[代码计算两个整数的平均值，使用的是除法或带符号右移操作，然后将结果作为数组的索引。如果被平均的数值非常大，这可能会导致溢出（从而计算出一个负平均值）。假设结果应该是非负的，可以使用无符号右移代替。换句话说，而不是使用 `(low+high)/2`，应使用 `(low+high) >> 1`。

这个漏洞存在于许多早期实现的二分查找和合并排序中。Martin Buchholz 在 JDK 库中发现了并修复了这个问题（参见 <a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6412541">这里</a>）。Joshua Bloch 广泛宣传了这种错误模式（参见 <a href="http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html">这里</a>)。]]>
    </Details>
  </BugPattern>
  <BugPattern type="IM_BAD_CHECK_FOR_ODD">
    <ShortDescription>检查奇偶性的方法不适用于负数  Check for oddness that won't work for negative numbers</ShortDescription>
    <LongDescription>检查奇偶性的方法对于负数无效在{1}中不会生效。</LongDescription>
    <Details>
<![CDATA[代码使用 `x % 2 == 1` 来检查一个值是否为奇数，但这种方法对负数无效（例如，`(-5) % 2 == -1`）。如果代码意图检查奇偶性，可以考虑使用 `x & 1 == 1` 或 `x % 2 != 0`。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_HARDCODED_ABSOLUTE_FILENAME">
    <ShortDescription>代码中包含对绝对路径的硬编码引用  Code contains a hard coded reference to an absolute pathname</ShortDescription>
    <LongDescription>在{1}中硬编码了绝对路径引用</LongDescription>
    <Details>
<![CDATA[这段代码使用硬编码的绝对路径构造了一个File对象（例如，`new File("/home/dannyc/workspace/j2ee/src/share/com/sun/enterprise/deployment");`）]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_BAD_MONTH">
    <ShortDescription>坏的月份常量值  Bad constant value for month</ShortDescription>
    <LongDescription>在{1}中传入{3}的{2}号月份值无效</LongDescription>
    <Details>
<![CDATA[这段代码将一个常量月份值传递给方法，但该值超出了预期的范围（0..11）。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_USELESS_SUBSTRING">
    <ShortDescription>对 `substring(0)` 的调用，返回原始值  Invocation of substring(0), which returns the original value</ShortDescription>
    <LongDescription>{1} 调用了 substring(0)，这返回了原始值。</LongDescription>
    <Details>
<![CDATA[这段代码对一个字符串调用了substring(0)，这会返回原来的值。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_CALLING_NEXT_FROM_HASNEXT">
    <ShortDescription>hasNext方法会调用next方法  hasNext method invokes next</ShortDescription>
    <LongDescription>\{1\} 调用了 \{2.givenClass\}</LongDescription>
    <Details>
<![CDATA[`hasNext()`方法调用了`next()`方法。这几乎肯定不对，因为`hasNext()`方法不应该改变迭代器的状态，而`next`方法应该改变迭代器的状态。]]>
    </Details>
  </BugPattern>
  <BugPattern type="SWL_SLEEP_WITH_LOCK_HELD">
    <ShortDescription>方法在持有锁的情况下调用了Thread.sleep()  Method calls Thread.sleep() with a lock held</ShortDescription>
    <LongDescription>持有锁的情况下，{1} 调用了 Thread.sleep() 方法。</LongDescription>
    <Details>
      <![CDATA[这种方法在持锁的情况下调用了Thread.sleep()。这可能会导致非常糟糕的性能和扩展性问题，甚至可能导致死锁，因为其他线程可能正在等待获取该锁。更好的做法是调用wait()来释放锁并允许其他线程运行。]]>
   </Details>
  </BugPattern>
  <BugPattern type="DB_DUPLICATE_BRANCHES">
    <ShortDescription>方法使用相同的代码为两个分支服务  Method uses the same code for two branches</ShortDescription>
    <LongDescription>{1} 使用相同的代码 для两个分支</LongDescription>
    <Details>
      <![CDATA[这个方法使用相同的代码实现条件分支中的两个分支。请确保这不是一个编码错误。]]>
   </Details>
  </BugPattern>
  <BugPattern type="DB_DUPLICATE_SWITCH_CLAUSES">
    <ShortDescription>方法使用相同的代码为两个switch语句Clause  Method uses the same code for two switch clauses</ShortDescription>
    <LongDescription>{1} 使用了两个switch语句相同的代码</LongDescription>
    <Details>
      <![CDATA[这个方法使用相同的代码实现switch语句中的两个分支。这可能是重复代码，但也可能表明存在编码错误。]]>
   </Details>
  </BugPattern>
  <BugPattern type="IMA_INEFFICIENT_MEMBER_ACCESS">
    <ShortDescription>方法访问了所属类的私有成员变量  Method accesses a private member variable of owning class</ShortDescription>
    <LongDescription>{1} 次访问拥有类的私有成员变量</LongDescription>
    <Details>
      <![CDATA[这个内类的方法会读取或写入拥有类的私有成员变量，或者调用拥有类的私有方法。编译器必须生成一个特殊的方法来访问这个私有成员，这会导致效率降低。放松对成员变量或方法的保护级别可以让编译器将其视为正常的访问。]]>
    </Details>
  </BugPattern>
  <BugPattern type="XFB_XML_FACTORY_BYPASS">
    <ShortDescription>方法直接分配特定的XML接口实现  Method directly allocates a specific implementation of xml interfaces</ShortDescription>
    <LongDescription>{1} 直接分配特定的XML接口实现</LongDescription>
    <Details>
      <![CDATA[这个方法分配了特定的XML接口实现。建议使用提供的工厂类来创建这些对象，以便在运行时可以更改实现。参见

- `javax.xml.parsers.DocumentBuilderFactory`
- `javax.xml.parsers.SAXParserFactory`
- `javax.xml.transform.TransformerFactory`
- `org.w3c.dom.Document.createXXXX`

以获得详细信息。]]>
    </Details>
  </BugPattern>
  <BugPattern type="USM_USELESS_SUBCLASS_METHOD">
    <ShortDescription>方法无必要地委托给父类的方法  Method superfluously delegates to parent class method</ShortDescription>
    <LongDescription>{1} 不必要地将方法委托给父类</LongDescription>
    <Details>
      <![CDATA[这个派生方法仅仅是在接收到的相同参数下调用了超类的方法。这个方法可以移除，因为它没有提供额外的价值。]]>
    </Details>
  </BugPattern>
  <BugPattern type="USM_USELESS_ABSTRACT_METHOD">
    <ShortDescription>抽象方法已经在实现的接口中定义了  Abstract Method is already defined in implemented interface</ShortDescription>
    <LongDescription>抽象方法 {1} 已经在实现的接口中定义。</LongDescription>
    <Details>
      <![CDATA[这个抽象方法已经在被此抽象类实现的接口中定义。该方法可以移除，因为它没有提供额外的价值。]]>
    </Details>
  </BugPattern>
  <BugPattern type="CI_CONFUSED_INHERITANCE">
    <ShortDescription>类是最终类但声明了受保护的字段  Class is final but declares protected field</ShortDescription>
    <LongDescription>类 `{0}` 是最终类但声明了受保护的字段 `{1}`</LongDescription>
    <Details>
      <![CDATA[这个类被声明为final，但声明了字段为protected。由于该类是final的，无法派生，使用protected修饰符会使情况变得模糊。应该将字段的访问修饰符改为private或public以正确表示字段的真实用途。]]>
    </Details>
  </BugPattern>
  <BugPattern type="QBA_QUESTIONABLE_BOOLEAN_ASSIGNMENT">
    <ShortDescription>方法将布尔字面量赋值给布尔表达式  Method assigns boolean literal in boolean expression</ShortDescription>
    <LongDescription>{1} 将布尔常量赋值给布尔表达式</LongDescription>
    <Details>
      <![CDATA[这个方法在 if 或 while 表达式中将一个字面量布尔值（true 或 false）赋给一个布尔变量。很可能这里应该进行的是使用 == 的布尔比较，而不是使用 = 的赋值。]]>
    </Details>
  </BugPattern>
  <BugPattern type="VR_UNRESOLVABLE_REFERENCE">
    <ShortDescription>类引用了无法解析的类或方法  Class makes reference to unresolvable class or method</ShortDescription>
    <LongDescription>{0} 引用了无法解决的 {1} 参考</LongDescription>
    <Details>
      <![CDATA[这个类引用了一个在分析其所使用库时无法解决的类或方法。]]>
    </Details>
  </BugPattern>
  <BugPattern type="GC_UNCHECKED_TYPE_IN_GENERIC_CALL">
    <ShortDescription>未检查的类型在泛型调用中  Unchecked type in generic call</ShortDescription>
    <LongDescription>在{1}中提供了类型为Object的未检查参数，但预期类型应为{3.givenClass}</LongDescription>
    <Details>
     <![CDATA[这个对泛型集合方法的调用传递了一个参数，而编译类型为 `Object`，但预期的是特定类型的泛型类型参数。因此，既不能通过标准Java类型系统也不能通过静态分析提供有用的信息来判断传递的对象是否是适当类型的。]]>
    </Details>
  </BugPattern>
  <BugPattern type="GC_UNRELATED_TYPES">
    <ShortDescription>通用参数与方法实参之间不存在关系  No relationship between generic parameter and method argument</ShortDescription>
    <LongDescription>{2.givenClass} 与预期的参数类型 {3.givenClass} 在 {1} 中不兼容</LongDescription>
    <Details>
     <![CDATA[<p>这个对泛型集合方法的调用包含了一个与集合参数不兼容的参数（即，参数的类型既不是对应泛型类型参数的超类型也不是子类型）。因此，很可能集合中没有任何对象与这里使用的参数相等。最有可能的是，传递给方法的值是错误的。</p>
<p>一般来说，两个无关类的实例并不相等。例如，如果 <code>Foo</code> 和 <code>Bar</code> 类之间不存在子类型关系，则 <code>Foo</code> 的一个实例不应该等于 <code>Bar</code> 的一个实例。这样做可能会导致相等方法不具有对称性。例如，如果你定义 <code>Foo</code> 类使得 <code>Foo</code> 可以与 <code>String</code> 相等，那么你的相等方法就不是对称的，因为一个 <code>String</code> 只能与其他 <code>String</code> 相等。</p>
<p>在极少数情况下，人们确实定义了不对称的相等方法，并且仍然能够使代码正常工作。尽管没有 API 文档或保证这一点，但通常情况下，如果你检查一个 <code>Collection&lt;String&gt;</code> 是否包含一个 <code>Foo</code>，所使用的相等方法（例如，<code>Foo</code> 类的 equals 方法）会用于执行相等性检查。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_COLLECTIONS_SHOULD_NOT_CONTAIN_THEMSELVES">
    <ShortDescription>集合不应该包含自己  Collections should not contain themselves</ShortDescription>
    <LongDescription>集合不应在其对{2.givenClass}的调用中包含自身。</LongDescription>
    <Details>
     <![CDATA[这个对泛型集合方法的调用只有在集合包含它自己时（例如，如果 `s.contains(s)` 为真）才有意义。这种情况不太可能发生，即使发生了也会引起问题（比如计算哈希码会导致无限递归）。很可能传递给参数的是错误的值。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_VACUOUS_SELF_COLLECTION_CALL">
    <ShortDescription>空洞的集合调用  Vacuous call to collections</ShortDescription>
    <LongDescription>对于任何集合c，调用c.{2.name}(c)没有意义。</LongDescription>
    <Details>
     <![CDATA[这个调用没有意义。对于任何集合 `c`，调用 `c.containsAll(c)` 应该总是为真，并且 `c.retainAll(c)` 应该没有效果。]]>
    </Details>
  </BugPattern>
  <BugPattern type="PZ_DONT_REUSE_ENTRY_OBJECTS_IN_ITERATORS">
    <ShortDescription>不要在迭代器中重复使用entry对象  Don't reuse entry objects in iterators</ShortDescription>
    <LongDescription>{0}既是迭代器又是Map.Entry</LongDescription>
    <Details>
     <![CDATA[`entrySet()` 方法允许返回一个视图，该视图基于基础的 `Map` 并包含 `Iterator` 和 `Map.Entry`。这个聪明的想法被几种 `Map` 实现所采用，但引入了潜在的编码错误的可能性。如果映射 `m` 通过 `entrySet` 返回这样的迭代器，那么 `c.addAll(m.entrySet())` 将会出现严重的问题。OpenJDK 1.7 中的所有 `Map` 实现都已重新编写以避免这种情况，你也应该这样做。]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_ENTRY_SETS_MAY_REUSE_ENTRY_OBJECTS">
    <ShortDescription>添加条目集中的元素可能会因为重用Entry对象而失败。  Adding elements of an entry set may fail due to reuse of Entry objects</ShortDescription>
    <LongDescription>添加条目集中的元素可能会因为{1}中reuse了{2.simpleClass}.Entry对象而失败。</LongDescription>
    <Details>
     <![CDATA[`entrySet()` 方法允许返回一个视图，其中在迭代过程中会重复使用同一个 Entry 对象。从 Java 1.6 版本开始，`IdentityHashMap` 和 `EnumMap` 都是这样做的。当你遍历这样的 Map 时，在迭代到下一个元素之前，Entry 的值都是有效的。例如，如果你尝试将 such an entrySet 传递给一个 `addAll` 方法，将会出错。]]>
    </Details>
  </BugPattern>

  <BugPattern type="DMI_USING_REMOVEALL_TO_CLEAR_COLLECTION">
    <ShortDescription>不要使用removeAll来清空一个集合  Don't use removeAll to clear a collection</ShortDescription>
    <LongDescription>removeAll 用于清除 {1} 中的集合。</LongDescription>
    <Details>
     <![CDATA[如果你想从集合 `<c>` 中移除所有元素，应使用 `c.clear`，而不是 `c.removeAll(c)`。调用 `c.removeAll(c)` 来清空集合不够清晰，容易因打字错误而出错，并且效率较低，在某些情况下可能会抛出 `ConcurrentModificationException`。    ]]>
    </Details>
  </BugPattern>
  <BugPattern type="STCAL_STATIC_CALENDAR_INSTANCE">
    <ShortDescription>静态日历字段  Static Calendar field</ShortDescription>
    <LongDescription>{1} 是一种静态字段，类型为 `java.util.Calendar`，这不是线程安全的。</LongDescription>
    <Details>
<![CDATA[尽管JavaDoc中没有提及这一点，但Calendar类本身在多线程环境中是不安全的。如果不加适当同步地跨线程边界共享单个实例，会导致应用程序行为不稳定。在Java 1.4中，这些问题似乎不如在Java 5中频繁出现，在Java 5中你可能会看到随机的ArrayIndexOutOfBoundsException或IndexOutOfBoundsException异常，这些异常发生在sun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate()方法中。

你也可能会遇到序列化问题。

建议使用实例字段。

有关更多信息，请参见[JDK Bug #6231579](http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6231579)和[JDK Bug #6178997](http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6178997)。]]>
</Details>
  </BugPattern>
  <BugPattern type="STCAL_INVOKE_ON_STATIC_CALENDAR_INSTANCE">
    <ShortDescription>调用静态Calendar方法  Call to static Calendar</ShortDescription>
    <LongDescription>在{1}中调用了静态java.util.Calendar的方法</LongDescription>
    <Details>
<![CDATA[尽管JavaDoc中没有提到这一点，但Calendar对象本质上不适合多线程使用。检测器发现有通过静态字段获取的Calendar实例被调用的情况，这看起来很可疑。

更多相关信息请参见[JDK Bug #6231579](http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6231579) 和 [JDK Bug #6178997](http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6178997)。]]>
</Details>
  </BugPattern>
  <BugPattern type="STCAL_STATIC_SIMPLE_DATE_FORMAT_INSTANCE">
    <ShortDescription>静态日期格式化  Static DateFormat</ShortDescription>
    <LongDescription>{1} 是一种静态字段，类型为 java.text.DateFormat，并且不是线程安全的。</LongDescription>
    <Details>
<![CDATA[根据JavaDoc的说明，DateFormats本质上不适合多线程使用。如果不加适当同步地在线程边界共享单个实例，会导致应用程序的行为变得不一致。

你可能会遇到序列化问题。

推荐使用实例字段。

更多详细信息，请参阅 [JDK Bug #6231579](http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6231579) 和 [JDK Bug #6178997](http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6178997)。]]>
</Details>
  </BugPattern>
  <BugPattern type="STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE">
    <ShortDescription>调用静态的DateFormat方法  Call to static DateFormat</ShortDescription>
    <LongDescription>在{1}中调用了静态java.text.DateFormat的方法</LongDescription>
    <Details>
<![CDATA[根据JavaDoc的说明，DateFormats本质上不适合多线程使用。检测器发现有一个对通过静态字段获得的DateFormat实例的调用，这看起来可疑。

更多关于这个问题的信息，请参见[jdk Bug #6231579](http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6231579)和[jdk Bug #6178997](http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6178997)。]]>
</Details>
  </BugPattern>
  <BugPattern type="TQ_COMPARING_VALUES_WITH_INCOMPATIBLE_TYPE_QUALIFIERS">
    <ShortDescription>将不兼容的类型限定符进行比较  Comparing values with incompatible type qualifiers</ShortDescription>
    <LongDescription>标记为具有类型限定符{2.simpleName}的值与从未具备该限定符的值进行了相等性比较。</LongDescription>
    <Details>
      <![CDATA[<p>一个带有类型限定符注解的值与从不带该限定符的值进行比较。</p>
<p>更精确地说，一个带有指定 `when=ALWAYS` 的类型限定符注解的值与一个相同类型限定符但指定为 `when=NEVER` 的值进行比较。</p>
<p>例如，假设 `@NonNegative` 是 `@Negative(when=When.NEVER)` 的别名。以下代码会生成警告，因为返回语句需要一个带有 `@NonNegative` 限定符的值，但接收的是标记为 `@Negative` 的值。</p>
<pre><code>public boolean example(@Negative Integer value1, @NonNegative Integer value2) {     return value1.equals(value2); }
</code></pre>]]>
    </Details>
  </BugPattern>


  <BugPattern type="TQ_ALWAYS_VALUE_USED_WHERE_NEVER_REQUIRED">
    <ShortDescription>标注了类型限定符的值用于需要不带该限定符的值的地方  Value annotated as carrying a type qualifier used where a value that must not carry that qualifier is required</ShortDescription>
    <LongDescription>标记为携带类型限定符 `{2.simpleName}` 的值用于需要不携带该限定符的场合</LongDescription>
    <Details>
      <![CDATA[<p>
一个指定带有类型限定注解的值会在需要该值不带此注解的位置被消费。
</p>

<p>
更准确地说，带有 when=ALWAYS 限定类型的注解的值可以保证到达当其限定类型为 when=NEVER 的使用位置或多个使用位置。
</p>

<p>
例如，假设 @NonNegative 是 @Negative(when=When.NEVER) 的别名。以下代码会生成警告，因为返回语句需要一个 @NonNegative 值，但接收的是标记了 @Negative 的值。
</p>

<pre><code>public @NonNegative Integer example(@Negative Integer value) {     return value; } </code></pre>]]>
    </Details>
  </BugPattern>


  <BugPattern type="TQ_UNKNOWN_VALUE_USED_WHERE_ALWAYS_STRICTLY_REQUIRED">
    <ShortDescription>在需要该限定符的情况下使用未带类型限定的值  Value without a type qualifier used where a value is required to have that qualifier</ShortDescription>
    <LongDescription>值在需要一个 `{2.simpleName}` 注解的地方被使用了，但没有类型限定符。</LongDescription>
    <Details>
      <![CDATA[<p>一个值正在被使用的方式需要该值带有类型限定符。由于类型的限定符是严格的，因此工具会拒绝任何没有适当注解的值。</p>
<p>要将一个值强制转换为具有严格限定符注解的值，可以定义一个返回值带有严格限定符注解的恒等函数。这是唯一将未注解的值转化为具有严格类型限定符注解的值的方法。</p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="TQ_NEVER_VALUE_USED_WHERE_ALWAYS_REQUIRED">
    <ShortDescription>值被标注为不带类型限定符，但在需要携带该限定符的值的地方使用了它。  Value annotated as never carrying a type qualifier used where value carrying that qualifier is required</ShortDescription>
    <LongDescription>标注为永不携带类型限定符的值 `{2.simpleName}` 在需要携带该限定符的值的位置使用了它。</LongDescription>
    <Details>
      <![CDATA[<p>一个未指定类型限定符注解的值保证会在需要该类型限定符注解的位置或多个位置被消费。</p>
<p>更精确地说，一个带有type qualifier且when=NEVER限定的值会保证到达那些使用相同type qualifier且when=ALWAYS指定位的地方。</p>
<p>TODO：示例</p>]]>
    </Details>
  </BugPattern>




  <BugPattern type="TQ_MAYBE_SOURCE_VALUE_REACHES_ALWAYS_SINK">
    <ShortDescription>可能不带类型限定符的值总是以需要该类型限定符的方式使用  Value that might not carry a type qualifier is always used in a way requires that type qualifier</ShortDescription>
    <LongDescription>可能不带有{2.simpleName}注解的值总是以需要该类型限定符的方式使用</LongDescription>
    <Details>
      <![CDATA[一个被标注为可能不是由类型限定符表示的值，但该值保证将以需要使用由该类型限定符表示的值的方式被使用。]]>
    </Details>
  </BugPattern>
  <BugPattern type="TQ_MAYBE_SOURCE_VALUE_REACHES_NEVER_SINK">
    <ShortDescription>带有类型限定符可能的值总是以禁止其具有该类型限定符的方式使用  Value that might carry a type qualifier is always used in a way prohibits it from having that type qualifier</ShortDescription>
    <LongDescription>带有 `{2.simpleName}` 注解的值总是被用于禁止其具有该类型限定词的方式。</LongDescription>
    <Details>
      <![CDATA[一个被标注为可能是某种类型限定符所表示的值的实例，且该值保证将以禁止使用那种类型限定符所表示的值的方式被使用。]]>
    </Details>
  </BugPattern>
  <BugPattern type="TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_NEVER_SINK">
    <ShortDescription>值要求没有类型修饰符，但标记为未知  Value required to not have type qualifier, but marked as unknown</ShortDescription>
    <LongDescription>值不能为 {2.simpleName}，但被显式标注为未知的 {2.simpleName} 类型。</LongDescription>
    <Details>
      <![CDATA[一个值被用在一种方式上，这种用法要求该值永远不能带类型限定符，但存在明确标注表明并不知道该值在哪种情况下不能带那种类型的限定符。要么是使用方法不正确，要么是注解不准确。]]>
    </Details>
  </BugPattern>
  <BugPattern type="TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_ALWAYS_SINK">
    <ShortDescription>需要类型限定符的值但被标记为未知  Value required to have type qualifier, but marked as unknown</ShortDescription>
    <LongDescription>值始终需要是 `{2.simpleName}`，但在关于 `{2.simpleName}` 的显式注解中被标记为未知。</LongDescription>
    <Details>
      <![CDATA[一个值被使用的方式要求它始终带有一个类型限定符，但存在一个显式的注解表示不清楚该值在何处需要带有这种类型限定符。要么使用的方式不正确，要么注解不正确。]]>
    </Details>
  </BugPattern>
  <BugPattern type="IO_APPENDING_TO_OBJECT_OUTPUT_STREAM">
    <ShortDescription>注定失败的尝试向对象输出流追加内容  Doomed attempt to append to an object output stream</ShortDescription>
    <LongDescription>在{1}中注定失败的尝试向对象输出流追加内容</LongDescription>
    <Details>
      <![CDATA[这段代码以追加模式打开文件，然后将其包装在对象输出流中。这不会让你能够追加到已存储在文件中的对象输出流。如果你希望能够追加到对象输出流，你需要保持对象输出流的打开状态。

唯一可能使以追加模式打开文件并写入对象输出流有效的情况是在读取文件时，计划以随机访问模式打开文件，并跳转到追加操作开始的字节偏移量处。 

TODO: 示例。]]>
    </Details>
  </BugPattern>
  <BugPattern type="WL_USING_GETCLASS_RATHER_THAN_CLASS_LITERAL">
    <ShortDescription>在getClass而非类字面量上进行同步  Synchronization on getClass rather than class literal</ShortDescription>
    <LongDescription>在{1}中，同步操作是基于getClass而不是类字面量。</LongDescription>
    <Details>
      <![CDATA[这个实例方法在 `this.getClass()` 上进行同步。如果该类被子类化，子类将在此类对象上进行同步，这很可能不是预期的行为。例如，考虑以下来自 `java.awt.Label` 的代码：

```java
private static final String base = "label";
private static int nameCounter = 0;

String constructComponentName() {
    synchronized (getClass()) {
        return base + nameCounter++;
    }
}
```

子类的 `Label` 不会在相同的类对象上进行同步，从而导致数据竞争。相反，这段代码应该在 `Label.class` 上进行同步：

```java
private static final String base = "label";
private static int nameCounter = 0;

String constructComponentName() {
    synchronized (Label.class) {
        return base + nameCounter++;
    }
}
```

该错误模式由 Jason Mehrens 提供。]]>
    </Details>
  </BugPattern>
  <BugPattern type="OBL_UNSATISFIED_OBLIGATION">
    <ShortDescription>方法可能无法清理流或资源  Method may fail to clean up stream or resource</ShortDescription>
    <LongDescription>{1} 可能无法清理 {2}</LongDescription>
    <Details>
          <![CDATA[这个方法可能无法清理（关闭、处置）流、数据库对象或其他需要显式清理操作的资源。

通常，如果一个方法打开了一个流或其他资源，该方法应该使用 try/finally 块来确保在方法返回之前已经对流或资源进行了清理。

这个错误模式实际上与 OS_OPEN_STREAM 和 ODR_OPEN_DATABASE_RESOURCE 错误模式基本相同，但基于不同的（并且希望是更好的）静态分析技术。我们对此错误模式的有用性感兴趣，并且希望获得反馈。
要发送反馈，请参阅：
- [贡献指南](https://github.com/spotbugs/spotbugs/blob/master/CONTRIBUTING.md)
- [讨论列表](https://github.com/spotbugs/discuss/issues?q=)

特别是，此错误模式的假阳性抑制启发式规则尚未广泛调整，因此关于假阳性的报告对我们很有帮助。

有关分析技术的描述，请参见 Weimer 和 Necula 的《寻找和防止运行时错误处理错误》。]]>
      </Details>
  </BugPattern>




  <BugPattern type="OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE">
    <ShortDescription>方法可能在处理已检查异常时未能清理流或资源  Method may fail to clean up stream or resource on checked exception</ShortDescription>
    <LongDescription>{1} 可能无法清理 {2} 检查异常</LongDescription>
    <Details>
          <![CDATA[这段方法可能无法正确清理（关闭、释放）流、数据库对象或其他需要显式清理操作的资源。

通常，如果一个方法打开了一个流或其他资源，该方法应该使用 try/finally 块来确保在方法返回之前正确清理流或资源。

这个错误模式本质上与 OS_OPEN_STREAM 和 ODR_OPEN_DATABASE_RESOURCE 错误模式相同，但基于不同的（希望更好）静态分析技术。我们对此错误模式的有用性感兴趣，并且欢迎反馈意见。
你可以通过以下链接发送反馈：
- [贡献指南](https://github.com/spotbugs/spotbugs/blob/master/CONTRIBUTING.md)
- [邮件列表](https://github.com/spotbugs/discuss/issues?q=[])

特别是，针对这个错误模式的假阳性抑制启发式规则还没有进行广泛调整，因此关于假阳性的报告对我们很有帮助。

更多详情请参见 Weimer 和 Necula 的《寻找和预防运行时错误处理错误》一文，了解分析技术的描述。]]>
      </Details>
  </BugPattern>















  <BugPattern type="FB_UNEXPECTED_WARNING">
    <ShortDescription>来自SpotBugs的意外/不必要的警告  Unexpected/undesired warning from SpotBugs</ShortDescription>
    <LongDescription>在{1}中出现了意想不到的/{2} SpotBugs 警告</LongDescription>
    <Details>
          <![CDATA[<p>SpotBugs生成了一个警告，根据@NoWarning注解，这个警告是意外的或不需要的。</p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="FB_MISSING_EXPECTED_WARNING">
    <ShortDescription>缺少预期或desired的SpotBugs警告  Missing expected or desired warning from SpotBugs</ShortDescription>
    <LongDescription>在{1}中缺少预期或期望的{2} SpotBugs 警告</LongDescription>
    <Details>
          <![CDATA[<p>SpotBugs 没有生成根据 @ExpectedWarning 注解预期或希望的警告。</p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="RV_RETURN_VALUE_OF_PUTIFABSENT_IGNORED">
    <ShortDescription>putIfAbsent的返回值被忽略，传给putIfAbsent的值被重复使用  Return value of putIfAbsent ignored, value passed to putIfAbsent reused</ShortDescription>
    <LongDescription>putIfAbsent的返回值被忽略，但{4}在{1}中被重复使用</LongDescription>
    <Details>
          <![CDATA[`putIfAbsent` 方法通常用于确保给定键关联单一值（即，如果 `putIfAbsent` 成功，则为该键设置第一个值）。如果你忽略了返回值并保留了传入的值引用，你可能会保留一个与映射中键不对应的值。如果使用时需要特定的值并且使用了未存储在映射中的值，你的程序将表现错误。]]>
      </Details>
  </BugPattern>
  <BugPattern type="LG_LOST_LOGGER_DUE_TO_WEAK_REFERENCE">
    <ShortDescription>由于OpenJDK中的弱引用导致的潜在丢失日志记录变化  Potential lost logger changes due to weak reference in OpenJDK</ShortDescription>
    <LongDescription>变化在{1}中可能会丢失</LongDescription>
    <Details>
          <![CDATA[OpenJDK 引入了潜在的不兼容性。特别是，java.util.logging.Logger 的行为已发生变化。它现在内部使用弱引用而不是强引用。这是一个合理的改变，但不幸的是，有些代码依赖于旧的行为 - 在更改日志器配置时，它简单地丢弃了日志器引用。这意味着垃圾回收器可以自由回收该内存，从而导致日志器配置丢失。例如，考虑以下代码：

```java
public static void initLogging() throws Exception {
    Logger logger = Logger.getLogger("edu.umd.cs");
    logger.addHandler(new FileHandler()); // 调用更改日志器配置
    logger.setUseParentHandlers(false); // 另一个更改日志器配置的调用
}
```

该方法结束时丢失了日志器引用（它没有逃出方法），因此在 initLogging 调用之后如果有垃圾回收周期，日志器配置将丢失（因为 Logger 仅保留弱引用）。

```java
public static void main(String[] args) throws Exception {
    initLogging(); // 向日志器添加文件处理程序
    System.gc(); // 日志器配置丢失
    Logger.getLogger("edu.umd.cs").info("Some message"); // 这将不会像预期那样记录到文件中
}
```

— Ulf Ochsenfahrt 和 Eric Fellheimer]]>
      </Details>
  </BugPattern>
  <BugPattern type="AT_OPERATION_SEQUENCE_ON_CONCURRENT_ABSTRACTION">
    <ShortDescription>并发抽象的调用序列可能不是原子性的  Sequence of calls to concurrent abstraction may not be atomic</ShortDescription>
    <LongDescription>在{1}中，对{2}的一系列调用可能不是原子操作。</LongDescription>
    <Details>
          <![CDATA[这段代码包含对并发抽象（如并发哈希映射）的一系列调用。这些调用不会被原子地执行。]]>
      </Details>
  </BugPattern>
  <BugPattern type="DM_DEFAULT_ENCODING">
    <ShortDescription>依赖默认编码  Reliance on default encoding</ShortDescription>
    <LongDescription>在{1}中发现依赖默认编码：{2}</LongDescription>
    <Details>
<![CDATA[<p>发现了一个将字节转换为字符串（或字符串转换为字节）的方法调用，并且该方法假设默认平台编码是合适的。这会导致应用程序在不同平台上表现出不同的行为。请使用替代API，并显式指定字符集名称或Charset对象。</p>]]>
      </Details>
  </BugPattern>
  <BugPattern type="NP_METHOD_PARAMETER_RELAXING_ANNOTATION">
    <ShortDescription>方法收紧了参数的空值注解  Method tightens nullness annotation on parameter</ShortDescription>
    <LongDescription>方法{1}覆盖了空值注解，从而放宽了对参数的祖先方法的要求。</LongDescription>
    <Details>
        <![CDATA[一个方法应该始终实现它覆盖的方法的合同。因此，如果一个方法接受一个标记为@Nullable的参数，你不应在子类中用一个该参数标记为@Nonnull的方法来覆盖这个方法。这样做违反了该方法应处理空参数的合同。]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_METHOD_PARAMETER_TIGHTENS_ANNOTATION">
    <ShortDescription>方法收紧了参数的空值注解  Method tightens nullness annotation on parameter</ShortDescription>
    <LongDescription>方法 {1} 以不兼容的方式 overriding 参数 {2} 的非空性注解</LongDescription>
    <Details>
        <![CDATA[一个方法应该始终实现它所覆盖的方法的合同。因此，如果一个方法接受一个标记为@Nullable的参数，你不应该在子类中用一个该参数标记为@Nonnull的方法来覆盖这个方法。这样做会违反该方法应处理空参数的合同。]]>
      </Details>
  </BugPattern>

  <BugPattern type="NP_METHOD_RETURN_RELAXING_ANNOTATION">
    <ShortDescription>方法放松了返回值的空值注解  Method relaxes nullness annotation on return value</ShortDescription>
    <LongDescription>方法 {1} 以不兼容的方式 overriding 了返回值的空值注解。</LongDescription>
    <Details>
        <![CDATA[方法在重写时应该实现该方法的契约。因此，如果一个方法被注解为返回一个非空值(@Nonnull)，你不应在子类中用一个被注解为可以返回空值(@Nullable 或 @CheckForNull)的方法来重写它。这样做违反了该方法不应返回 null 的契约。]]>
      </Details>
  </BugPattern>
  <!--
  **********************************************************************
   BugCodes
  **********************************************************************
   -->
  <BugCode abbrev="FS">格式化字符串问题  Format string problem</BugCode>
  <BugCode abbrev="SKIPPED">分析跳过  Analysis skipped</BugCode>
  <BugCode abbrev="IL">无限循环  Infinite Loop</BugCode>
  <BugCode abbrev="VO">volatile 的使用  Use of volatile</BugCode>
  <BugCode abbrev="UI">不安全的继承  Unsafe inheritance</BugCode>
  <BugCode abbrev="FL">浮点精度的使用  Use of floating point precision</BugCode>
  <BugCode abbrev="TEST">测试原型和未完成的bug模式  Testing prototype and incomplete bug pattern</BugCode>
  <BugCode abbrev="IMSE">可疑的捕获IllegalMonitorStateException  Dubious catching of IllegalMonitorStateException</BugCode>
  <BugCode abbrev="CN">克隆模式的实现不佳  Bad implementation of cloneable idiom</BugCode>
  <BugCode abbrev="CAA">共变数组赋值  Covariant array assignment</BugCode>
  <BugCode abbrev="AT">可能的原子性违规  Possible atomicity violation</BugCode>
  <BugCode abbrev="FI">不正确的使用finally块  Incorrect use of finalizers</BugCode>
  <BugCode abbrev="ES">使用 `==` 或 `!=` 检查字符串相等性  Checking String equality using == or !=</BugCode>
  <BugCode abbrev="ML">同步更新字段（可变锁）  Synchronization on updated field (Mutable Lock)</BugCode>
  <BugCode abbrev="UG">未同步的get方法，同步的set方法  Unsynchronized get method, synchronized set method</BugCode>
  <BugCode abbrev="IO">输入/输出问题  Input/Output problem</BugCode>
  <BugCode abbrev="IC">初始化循环  Initialization circularity</BugCode>
  <BugCode abbrev="SI">可疑的静态初始化器  Suspicious static initializer</BugCode>
  <BugCode abbrev="MSF">可变的Servlet字段  Mutable servlet field</BugCode>
  <BugCode abbrev="IS">不一致的同步  Inconsistent synchronization</BugCode>
  <BugCode abbrev="Eq">equals()方法的实现问题  Problems with implementation of equals()</BugCode>
  <BugCode abbrev="Co">Comparable接口中compareTo()方法的实现问题  Problems with implementation of compareTo()</BugCode>
  <BugCode abbrev="HE">相等的对象必须具有相同的哈希码  Equal objects must have equal hashcodes</BugCode>
  <BugCode abbrev="AM">API滥用  API misuse</BugCode>
  <BugCode abbrev="Dm">可疑的方法使用了  Dubious method used</BugCode>
  <BugCode abbrev="Bx"> questionable 原始值的包装boxing  Questionable Boxing of primitive value</BugCode>
  <BugCode abbrev="UR">在构造函数中读取未初始化的字段  Uninitialized read of field in constructor</BugCode>
  <BugCode abbrev="RR">方法忽略了InputStream.read()的方法结果  Method ignores results of InputStream.read()</BugCode>
  <BugCode abbrev="NN">裸通知  Naked notify</BugCode>
  <BugCode abbrev="UW">无条件等待  Unconditional wait</BugCode>
  <BugCode abbrev="SP">方法在场地上旋转  Method spins on field</BugCode>
  <BugCode abbrev="DC">双核对图案  Double check pattern</BugCode>
  <BugCode abbrev="Wa">等待，不要在循环中  Wait not in loop</BugCode>
  <BugCode abbrev="No">使用notify()而不是notifyAll()  Using notify() rather than notifyAll()</BugCode>
  <BugCode abbrev="DE">抛出或忽略的异常  Dropped or ignored exception</BugCode>
  <BugCode abbrev="Ru">方法调用了run()方法  Method invokes run()</BugCode>
  <BugCode abbrev="It">错误定义的Iterator  Incorrect definition of Iterator</BugCode>
  <BugCode abbrev="SnVI">没有版本号的可序列化类  Serializable class with no Version ID</BugCode>
  <BugCode abbrev="Se">Serializable接口的错误实现  Incorrect definition of Serializable class</BugCode>
  <BugCode abbrev="WS">class的writeObject()方法是同步的，但其他nothing else都未同步。  Class's writeObject() method is synchronized but nothing else is</BugCode>
  <BugCode abbrev="RS">类的readObject()方法是同步的  Class's readObject() method is synchronized</BugCode>
  <BugCode abbrev="SC">构造函数调用了Thread.start()方法  Constructor invokes Thread.start()</BugCode>
  <BugCode abbrev="MS">可变静态字段  Mutable static field</BugCode>
  <BugCode abbrev="ME">可变枚举字段  Mutable enum field</BugCode>
  <BugCode abbrev="EI">返回数组的方法可能暴露内部表示形式  Method returning array may expose internal representation</BugCode>
  <BugCode abbrev="Nm">混淆的方法名称  Confusing method name</BugCode>
  <BugCode abbrev="SS">未读字段应该静态  Unread field should be static</BugCode>
  <BugCode abbrev="UuF">未使用的字段  Unused field</BugCode>
  <BugCode abbrev="UrF">未读字段  Unread field</BugCode>
  <BugCode abbrev="UwF">未写明的字段  Unwritten field</BugCode>
  <BugCode abbrev="SIC">内类可以被声明为静态的  Inner class could be made static</BugCode>
  <BugCode abbrev="TLW">带着两个锁等着  Wait with two locks held</BugCode>
  <BugCode abbrev="RANGE">范围检查  Range checks</BugCode>
  <BugCode abbrev="RV">方法返回值的错误使用  Bad use of return value from method</BugCode>
  <BugCode abbrev="LG">日志器问题  Logger problem</BugCode>
  <BugCode abbrev="IA">模糊调用  Ambiguous invocation</BugCode>
  <BugCode abbrev="HSC">巨大的字符串常量  Huge String constants</BugCode>
  <BugCode abbrev="HRS">HTTP响应拆分漏洞  HTTP Response splitting vulnerability</BugCode>
  <BugCode abbrev="PT">路径遍历  Path traversal</BugCode>
  <BugCode abbrev="XSS">跨站脚本漏洞  Cross site scripting vulnerability</BugCode>
  <BugCode abbrev="NP">空指针解引用  Null pointer dereference</BugCode>
  <BugCode abbrev="NOISE">虚假随机警告  Bogus random warning</BugCode>
  <BugCode abbrev="RpC">重复的条件测试  Repeated conditional test</BugCode>
  <BugCode abbrev="OS">没有在所有路径上关闭流  Stream not closed on all paths</BugCode>
  <BugCode abbrev="PZLA"> Prefer 零长度数组 以表示没有结果，而不是使用 null  Prefer zero length arrays to null to indicate no results</BugCode>
  <BugCode abbrev="UCF">无用的控制流  Useless control flow</BugCode>
  <BugCode abbrev="RCN">与空值的冗余比较  Redundant comparison to null</BugCode>
  <BugCode abbrev="UL">锁在所有路径上都没有释放  Lock not released on all paths</BugCode>
  <BugCode abbrev="RC">使用引用相等性而非调用equals方法是值得怀疑的  Questionable use of reference equality rather than calling equals</BugCode>
  <BugCode abbrev="EC">比较不兼容的类型是否相等  Comparing incompatible types for equality</BugCode>
  <BugCode abbrev="MWN">不匹配的wait()或notify()  Mismatched wait() or notify()</BugCode>
  <BugCode abbrev="SA">徒劳的自我操作  Useless self-operation</BugCode>
  <BugCode abbrev="INT">可疑的整数表达式  Suspicious integer expression</BugCode>
  <BugCode abbrev="BIT">可疑的位运算逻辑表达式  Suspicious bitwise logical expression</BugCode>
  <BugCode abbrev="LI">未同步的懒初始化  Unsynchronized Lazy Initialization</BugCode>
  <BugCode abbrev="JLM">java.util.concurrent对象的同步  Synchronization on java.util.concurrent objects</BugCode>
  <BugCode abbrev="UPM">私有方法从不被调用  Private method is never called</BugCode>
  <BugCode abbrev="UMAC">匿名类的未调用方法  Uncallable method of anonymous class</BugCode>
  <BugCode abbrev="EI2">存储对可变对象的引用  Storing reference to mutable object</BugCode>
  <BugCode abbrev="NS">可疑使用非短路布尔运算符  Suspicious use of non-short-circuit boolean operator</BugCode>
  <BugCode abbrev="ODR">数据库资源在所有路径中未关闭  Database resource not closed on all paths</BugCode>
  <BugCode abbrev="SBSC">在循环中使用+运算符进行字符串连接  String concatenation in loop using + operator</BugCode>
  <BugCode abbrev="IIL">可以在循环外部移动的低效代码  Inefficient code which can be moved outside of the loop</BugCode>
  <BugCode abbrev="IIO">无效使用 `String.indexOf(String)` 或 `String.lastIndexOf(String)` 方法  Inefficient use of String.indexOf(String) or String.lastIndexOf(String)</BugCode>
  <BugCode abbrev="ITA">无效使用`collection.toArray(new Foo[0])`  Inefficient use of collection.toArray(new Foo[0])</BugCode>
  <BugCode abbrev="SW">摆动编程规则  Swing coding rules</BugCode>
  <BugCode abbrev="IJU">不当实现的JUnit测试案例  Improperly implemented JUnit TestCase</BugCode>
  <BugCode abbrev="BOA">严重篡改的适配器  Badly Overridden Adapter</BugCode>
  <BugCode abbrev="SF">switch-case 会发生跳转  Switch case falls through</BugCode>
  <BugCode abbrev="SIO">多余的 instanceof  Superfluous instanceof</BugCode>
  <BugCode abbrev="BAC">坏的Applet构造函数  Bad Applet Constructor</BugCode>
  <BugCode abbrev="UOE">使用对象equals方法  Use Object Equals</BugCode>
  <BugCode abbrev="STI">可疑线程已中断  Suspicious Thread Interrupted</BugCode>
  <BugCode abbrev="DLS">死掉的当地商店  Dead local store</BugCode>
  <BugCode abbrev="IP">忽略的参数  Ignored parameter</BugCode>
  <BugCode abbrev="MF">遮罩字段  Masked Field</BugCode>
  <BugCode abbrev="WMI">无效的地图迭代器  Inefficient Map Iterator</BugCode>
  <BugCode abbrev="ISC">实例化静态类  Instantiated Static Class</BugCode>
  <BugCode abbrev="REC"> RuntimeException捕获  RuntimeException capture</BugCode>
  <BugCode abbrev="FE">浮点数相等性测试  Test for floating point equality</BugCode>
  <BugCode abbrev="UM">关于常量的不必要的数学运算  Unnecessary Math on constants</BugCode>
  <BugCode abbrev="UC">无用的代码  Useless code</BugCode>
  <BugCode abbrev="CNT">已知常数的粗略值  Rough value of known constant</BugCode>
  <BugCode abbrev="CD">循环依赖  Circular Dependencies</BugCode>
  <BugCode abbrev="RI">冗余接口  Redundant Interfaces</BugCode>
  <BugCode abbrev="MTIA">多线程实例访问  Multithreaded Instance Access</BugCode>
  <BugCode abbrev="PS">公共信号量  Public Semaphores</BugCode>
  <BugCode abbrev="BSHIFT">糟糕的班次  Bad shift</BugCode>
  <BugCode abbrev="ICAST">从整数值进行类型转换  Casting from integer values</BugCode>
  <BugCode abbrev="RE">正则表达式  Regular expressions</BugCode>
  <BugCode abbrev="SQL">潜在的SQL问题  Potential SQL Problem</BugCode>
  <BugCode abbrev="WL">可能锁错了对象  Possible locking on wrong object</BugCode>
  <BugCode abbrev="ESync">空的同步块  Empty Synchronized blocks</BugCode>
  <BugCode abbrev="QF">可疑的for循环  Questionable for loops</BugCode>
  <BugCode abbrev="VA">变参问题  Vararg problems</BugCode>
  <BugCode abbrev="BC">对象引用的不良铸型  Bad casts of object references</BugCode>
  <BugCode abbrev="IM">可疑的整数运算  Questionable integer math</BugCode>
  <BugCode abbrev="ST">静态字段的误用  Misuse of static fields</BugCode>
  <BugCode abbrev="JCIP">违反net.jcip注解  Violation of net.jcip annotations</BugCode>
  <BugCode abbrev="USELESS_STRING">无用/非信息性字符串生成  Useless/non-informative string generated</BugCode>
  <BugCode abbrev="DMI">可疑的方法调用  Dubious method invocation</BugCode>
  <BugCode abbrev="PZ">警告，受Joshua Bloch和Neal Gafter的Programming Puzzlers启发  Warning inspired by Joshua Bloch's and Neal Gafter's Programming Puzzlers</BugCode>
  <BugCode abbrev="SWL">握着锁入睡  Sleep with lock held</BugCode>
  <BugCode abbrev="J2EE">J2EE错误  J2EE error</BugCode>
  <BugCode abbrev="DB">复制分支  Duplicate Branches</BugCode>
  <BugCode abbrev="IMA">无效的成员访问  Inefficient Member Access</BugCode>
  <BugCode abbrev="XFB">XML工厂绕过  XML Factory Bypass</BugCode>
  <BugCode abbrev="USM">无用的子类方法  Useless Subclass Method</BugCode>
  <BugCode abbrev="CI">困惑的继承  Confused Inheritance</BugCode>
  <BugCode abbrev="QBA">可疑的布尔赋值  Questionable Boolean Assignment</BugCode>
  <BugCode abbrev="VR">版本兼容性问题  Version compatibility issue</BugCode>
  <BugCode abbrev="DP">使用doPrivileged  Use doPrivileged</BugCode>
  <BugCode abbrev="GC">可疑的对泛型集合方法的调用  Suspicious calls to generic collection methods</BugCode>
  <BugCode abbrev="STCAL">静态使用Calendar或DateFormat类型  Static use of type Calendar or DateFormat</BugCode>
  <BugCode abbrev="TQ">类型注解的一致性使用不当  Inconsistent use of type qualifier annotations</BugCode>
  <BugCode abbrev="OBL">未履行清理河流或资源的义务  Unsatisfied obligation to clean up stream or resource</BugCode>
  <BugCode abbrev="FB">SpotBugs在对一个方法进行检查时没有产生预期的警告  SpotBugs did not produce the expected warnings on a method</BugCode>
  <BugCode abbrev="DL">由于对共享对象加锁可能导致意外的竞争或可能的死锁  Unintended contention or possible deadlock due to locking on shared objects</BugCode>
</MessageCollection>
